var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var mathis;
(function (mathis) {
    (function (Direction) {
        Direction[Direction["vertical"] = 0] = "vertical";
        Direction[Direction["horizontal"] = 1] = "horizontal";
        Direction[Direction["slash"] = 2] = "slash";
        Direction[Direction["antislash"] = 3] = "antislash";
    })(mathis.Direction || (mathis.Direction = {}));
    var Direction = mathis.Direction;
    mathis.myFavoriteColors = {
        green: new BABYLON.Color3(124 / 255, 252 / 255, 0)
    };
    var UV = (function () {
        function UV(u, v) {
            this.u = u;
            this.v = v;
        }
        return UV;
    }());
    mathis.UV = UV;
    var M22 = (function () {
        function M22() {
            this.m11 = 0;
            this.m12 = 0;
            this.m21 = 0;
            this.m22 = 0;
        }
        M22.prototype.determinant = function () {
            return this.m11 * this.m22 - this.m21 * this.m12;
        };
        M22.prototype.inverse = function () {
            var res = new M22();
            var det = this.determinant();
            res.m11 = this.m22 / det;
            res.m22 = this.m11 / det;
            res.m12 = -this.m12 / det;
            res.m21 = -this.m21 / det;
            return res;
        };
        M22.prototype.multiplyUV = function (uv) {
            return new UV(this.m11 * uv.u + this.m12 * uv.v, this.m21 * uv.u + this.m22 * uv.v);
        };
        return M22;
    }());
    mathis.M22 = M22;
    var XYZ = (function (_super) {
        __extends(XYZ, _super);
        function XYZ(x, y, z) {
            _super.call(this, x, y, z);
        }
        XYZ.resetDefaultNbDecimalForHash = function () { XYZ.nbDecimalForHash = 5; };
        Object.defineProperty(XYZ.prototype, "hashString", {
            get: function () { return mathis.roundWithGivenPrecision(this.x, XYZ.nbDecimalForHash) + ',' + mathis.roundWithGivenPrecision(this.y, XYZ.nbDecimalForHash) + ',' + mathis.roundWithGivenPrecision(this.z, XYZ.nbDecimalForHash); },
            enumerable: true,
            configurable: true
        });
        XYZ.newZero = function () {
            return new XYZ(0, 0, 0);
        };
        XYZ.newFrom = function (vect) {
            if (vect == null)
                return null;
            return new XYZ(vect.x, vect.y, vect.z);
        };
        XYZ.newOnes = function () {
            return new XYZ(1, 1, 1);
        };
        XYZ.newRandom = function () {
            return new XYZ(Math.random(), Math.random(), Math.random());
        };
        XYZ.temp0 = function (x, y, z) {
            tempXYZ0.copyFromFloats(x, y, z);
            return tempXYZ0;
        };
        XYZ.temp1 = function (x, y, z) {
            tempXYZ1.copyFromFloats(x, y, z);
            return tempXYZ1;
        };
        // static temp2(x,y,z):XYZ{
        //     tempXYZ2.copyFromFloats(x,y,z)
        //     return tempXYZ2
        // }
        // static temp3(x,y,z):XYZ{
        //     tempXYZ3.copyFromFloats(x,y,z)
        //     return tempXYZ3
        // }
        // static temp4(x,y,z):XYZ{
        //     tempXYZ4.copyFromFloats(x,y,z)
        //     return tempXYZ4
        // }
        // static temp5(x,y,z):XYZ{
        //     tempXYZ5.copyFromFloats(x,y,z)
        //     return tempXYZ5
        // }
        // newCopy():XYZ{
        //    return new XYZ(this.x,this.y,this.z)
        //}
        XYZ.prototype.add = function (vec) {
            mathis.geo.add(this, vec, this);
            return this;
        };
        XYZ.prototype.resizes = function (vec) {
            this.x *= vec.x;
            this.y *= vec.y;
            this.z *= vec.z;
            return this;
        };
        XYZ.prototype.multiply = function (vec) {
            this.x *= vec.x;
            this.y *= vec.y;
            this.z *= vec.z;
            return this;
        };
        XYZ.prototype.substract = function (vec) {
            mathis.geo.substract(this, vec, this);
            return this;
        };
        XYZ.prototype.scale = function (factor) {
            mathis.geo.scale(this, factor, this);
            return this;
        };
        XYZ.prototype.copyFrom = function (vect) {
            this.x = vect.x;
            this.y = vect.y;
            this.z = vect.z;
            return this;
        };
        XYZ.prototype.copyFromFloats = function (x, y, z) {
            this.x = x;
            this.y = y;
            this.z = z;
            return this;
        };
        XYZ.prototype.changeBy = function (x, y, z) {
            this.x = x;
            this.y = y;
            this.z = z;
            return this;
        };
        XYZ.prototype.normalize = function () {
            var norm = mathis.geo.norme(this);
            if (norm < mathis.geo.epsilon)
                throw 'be careful, you have normalized a very small vector';
            return this.scale(1 / norm);
        };
        XYZ.prototype.almostEqual = function (vect) {
            return mathis.geo.xyzAlmostEquality(this, vect);
        };
        XYZ.prototype.toString = function (deci) {
            if (deci === void 0) { deci = 2; }
            return '(' + this.x.toFixed(deci) + ',' + this.y.toFixed(deci) + ',' + this.z.toFixed(deci) + ')';
        };
        //private xyz:XYZ
        //get x(){return this.xyz.x}
        //get y(){return this.xyz.y}
        //get z(){return this.xyz.z}
        //set x(x:number){this.xyz.x=x}
        //set y(y:number){this.xyz.y=y}
        //set z(z:number){this.xyz.z=z}
        XYZ.lexicalOrder = function (a, b) {
            if (a.x != b.x)
                return a.x - b.x;
            else if (a.y != b.y)
                return a.y - b.y;
            else if (a.z != b.z)
                return a.z - b.z;
            else
                return 0;
        };
        XYZ.lexicalOrderInverse = function (a, b) {
            return -XYZ.lexicalOrder(a, b);
        };
        /**it is important to rount the number for hash. Because we want that two almost equal vectors have the same hash*/
        XYZ.nbDecimalForHash = 5;
        return XYZ;
    }(BABYLON.Vector3));
    mathis.XYZ = XYZ;
    var tempXYZ0 = new XYZ(0, 0, 0);
    var tempXYZ1 = new XYZ(0, 0, 0);
    //TODO rewrite the not-in-place methods
    var XYZW = (function (_super) {
        __extends(XYZW, _super);
        function XYZW(x, y, z, w) {
            _super.call(this, x, y, z, w);
        }
        XYZW.prototype.multiply = function (quat) {
            mathis.geo.quaternionMultiplication(quat, this, this);
            return this;
        };
        return XYZW;
    }(BABYLON.Quaternion));
    mathis.XYZW = XYZW;
    var Positioning = (function () {
        function Positioning() {
            this.position = new XYZ(0, 0, 0);
            this.frontDir = new XYZ(1, 0, 0);
            this.upVector = new XYZ(0, 1, 0);
            this.scaling = new XYZ(1, 1, 1);
            this.defaultUpDirIfTooSmall = new XYZ(1, 1, 0);
            this.defaultFrontDirIfTooSmall = new XYZ(0, 0, 1);
        }
        Positioning.prototype.copyFrom = function (positionning) {
            this.position = XYZ.newFrom(positionning.position);
            this.upVector = XYZ.newFrom(positionning.upVector);
            this.frontDir = XYZ.newFrom(positionning.frontDir);
            this.scaling = XYZ.newFrom(positionning.scaling);
        };
        Positioning.prototype.changeFrontDir = function (vector) {
            mathis.geo.orthonormalizeKeepingFirstDirection(vector, this.upVector, this.frontDir, this.upVector);
        };
        Positioning.prototype.changeUpVector = function (vector) {
            mathis.geo.orthonormalizeKeepingFirstDirection(this.upVector, vector, this.upVector, this.frontDir);
        };
        Positioning.prototype.setOrientation = function (frontDir, upVector) {
            this.upVector = new XYZ(0, 0, 0);
            this.frontDir = new XYZ(0, 0, 0);
            mathis.geo.orthonormalizeKeepingFirstDirection(frontDir, upVector, this.frontDir, this.upVector);
        };
        Positioning.prototype.quaternion = function (preserveUpVectorInPriority) {
            if (preserveUpVectorInPriority === void 0) { preserveUpVectorInPriority = true; }
            if (this.frontDir == null && this.upVector == null)
                throw 'you must precise a frontDir or a upVector or both of them';
            else if (this.frontDir == null) {
                this.frontDir = new XYZ(0, 0, 0);
                mathis.geo.getOneOrthonormal(this.upVector, this.frontDir);
            }
            else if (this.upVector == null) {
                this.upVector = new XYZ(0, 0, 0);
                mathis.geo.getOneOrthonormal(this.frontDir, this.upVector);
            }
            if (this.frontDir.length() < mathis.geo.epsilon) {
                this.frontDir = this.defaultFrontDirIfTooSmall;
                mathis.logger.c('a tangent was too small, and so replaced by a default one');
            }
            if (this.upVector.length() < mathis.geo.epsilon) {
                this.upVector = this.defaultUpDirIfTooSmall;
                mathis.logger.c('a normal was too small, and so replaced by a default one');
            }
            var quaternion = new XYZW(0, 0, 0, 1);
            mathis.geo.twoVectorsToQuaternion(this.frontDir, this.upVector, !preserveUpVectorInPriority, quaternion);
            return quaternion;
        };
        Positioning.prototype.applyToMeshes = function (meshes) {
            var quaternion = null;
            if (this.frontDir != null || this.upVector != null)
                quaternion = this.quaternion();
            for (var _i = 0, meshes_1 = meshes; _i < meshes_1.length; _i++) {
                var mesh = meshes_1[_i];
                if (this.scaling != null)
                    mesh.scaling = this.scaling;
                if (quaternion != null)
                    mesh.rotationQuaternion = quaternion;
                if (this.position != null)
                    mesh.position = this.position;
            }
        };
        Positioning.prototype.applyToVertices = function (vertices) {
            var quaternion = this.quaternion();
            var matrix = new MM();
            mathis.geo.quaternionToMatrix(quaternion, matrix);
            for (var _i = 0, vertices_1 = vertices; _i < vertices_1.length; _i++) {
                var vertex = vertices_1[_i];
                vertex.position.multiply(this.scaling);
                mathis.geo.multiplicationMatrixVector(matrix, vertex.position, vertex.position);
                vertex.position.add(this.position);
            }
        };
        return Positioning;
    }());
    mathis.Positioning = Positioning;
    var MM = (function (_super) {
        __extends(MM, _super);
        //private mm:MM
        //get m(){return this.mm.m}
        //public m=new Float32Array(16)
        function MM() {
            _super.call(this);
        }
        MM.newIdentity = function () {
            var res = new MM();
            res.m[0] = 1;
            res.m[5] = 1;
            res.m[10] = 1;
            res.m[15] = 1;
            return res;
        };
        MM.newFrom = function (matr) {
            var res = new MM();
            for (var i = 0; i < 16; i++)
                res.m[i] = matr.m[i];
            return res;
        };
        MM.newRandomMat = function () {
            var res = new MM();
            for (var i = 0; i < 16; i++)
                res.m[i] = Math.random();
            return res;
        };
        MM.newZero = function () {
            return new MM();
        };
        MM.prototype.equal = function (matr) {
            return mathis.geo.matEquality(this, matr);
        };
        MM.prototype.almostEqual = function (matr) {
            return mathis.geo.matAlmostEquality(this, matr);
        };
        MM.prototype.leftMultiply = function (matr) {
            mathis.geo.multiplyMatMat(matr, this, this);
            return this;
        };
        MM.prototype.rightMultiply = function (matr) {
            mathis.geo.multiplyMatMat(this, matr, this);
            return this;
        };
        MM.prototype.inverse = function () {
            mathis.geo.inverse(this, this);
            return this;
        };
        MM.prototype.copyFrom = function (matr) {
            mathis.geo.copyMat(matr, this);
            return this;
        };
        MM.prototype.transpose = function () {
            mathis.geo.transpose(this, this);
            return this;
        };
        MM.prototype.toString = function () {
            return "\n" +
                this.m[0] + this.m[1] + this.m[2] + this.m[3] + "\n" +
                this.m[4] + this.m[5] + this.m[6] + this.m[7] + "\n" +
                this.m[8] + this.m[9] + this.m[10] + this.m[11] + "\n" +
                this.m[12] + this.m[13] + this.m[14] + this.m[15] + "\n";
        };
        return MM;
    }(BABYLON.Matrix));
    mathis.MM = MM;
    var Link = (function () {
        function Link(to) {
            if (to == null)
                throw 'a links is construct with a null vertex';
            this.to = to;
        }
        return Link;
    }());
    mathis.Link = Link;
    /** An element of a graph */
    var Vertex = (function () {
        function Vertex() {
            /**link lead to an other vertex*/
            this.links = [];
            this.isInvisible = false;
            this.dichoLevel = 0;
            this.markers = [];
            this.customerObject = {};
            this._hashCode = Vertex.hashCount++;
        }
        Object.defineProperty(Vertex.prototype, "hashNumber", {
            get: function () { return this._hashCode; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vertex.prototype, "hashString", {
            get: function () { return this._hashCode + ''; },
            enumerable: true,
            configurable: true
        });
        Vertex.prototype.setPosition = function (x, y, z, useAlsoTheseValuesForParam) {
            if (useAlsoTheseValuesForParam === void 0) { useAlsoTheseValuesForParam = false; }
            this.position = new XYZ(x, y, z);
            this.param = new XYZ(x, y, z);
            return this;
        };
        Vertex.prototype.hasMark = function (mark) {
            return (this.markers.indexOf(mark) != -1);
        };
        Vertex.prototype.getOpposites = function (vert1) {
            var fle = this.findLink(vert1);
            if (fle == null)
                throw "the vertex is not a neighbor. Probably your neighborhood relation is not symetric. " +
                    "Please, perform the graph analysis, with the help of the function linkModule.checkTheRegularityOfAGRaph";
            if (fle.opposites == null)
                return null;
            var res = [];
            for (var _i = 0, _a = fle.opposites; _i < _a.length; _i++) {
                var li = _a[_i];
                res.push(li.to);
            }
            return res;
        };
        Vertex.prototype.hasBifurcations = function () {
            for (var _i = 0, _a = this.links; _i < _a.length; _i++) {
                var link = _a[_i];
                if (link.opposites != null && link.opposites.length > 1)
                    return true;
            }
            return false;
        };
        Vertex.prototype.hasVoisin = function (vertex) {
            for (var _i = 0, _a = this.links; _i < _a.length; _i++) {
                var link = _a[_i];
                if (link.to == vertex)
                    return true;
            }
            return false;
        };
        Vertex.prototype.isBorder = function () { return this.hasMark(Vertex.Markers.border); };
        Vertex.prototype.findLink = function (vertex) {
            for (var _i = 0, _a = this.links; _i < _a.length; _i++) {
                var fle = _a[_i];
                if (fle.to == vertex)
                    return fle;
            }
            return null;
        };
        /** set two links in opposition.
         * If one of them exists (eg as a link with no opposition) the opposition is created */
        Vertex.prototype.setTwoOppositeLinks = function (cell1, cell2) {
            var link1 = this.findLink(cell1);
            var link2 = this.findLink(cell2);
            if (link1 == null) {
                link1 = new Link(cell1);
                this.links.push(link1);
            }
            if (link2 == null) {
                link2 = new Link(cell2);
                this.links.push(link2);
            }
            if (link1.opposites == null)
                link1.opposites = [];
            if (link2.opposites == null)
                link2.opposites = [];
            link1.opposites.push(link2);
            link2.opposites.push(link1);
            return this;
        };
        /**set a simple link between this and vertex.
         *  if such a link already existe (even with somme oppositions, it is suppressed)*/
        Vertex.prototype.setOneLink = function (vertex) {
            if (vertex == this)
                throw "it is forbidden to link to itself";
            this.suppressOneLink(vertex);
            // let link1=this.findLink(vertex)
            // if (link1==null) link1=new Link(vertex)
            // else {
            //     link1.opposites=[]
            // }
            this.links.push(new Link(vertex));
            return this;
        };
        Vertex.separateTwoVoisins = function (v1, v2) {
            v1.suppressOneLink(v2);
            v2.suppressOneLink(v1);
        };
        Vertex.addWeightToLink = function (v1, v2, weight) {
            v1.findLink(v2).weight = weight;
            v2.findLink(v1).weight = weight;
        };
        /**to completely separate to vertex, you have to apply this procedure on both the two vertices*/
        Vertex.prototype.suppressOneLink = function (voisin) {
            var link = this.findLink(voisin);
            if (link == null)
                return;
            mathis.tab.removeFromArray(this.links, link);
            if (link.opposites != null) {
                for (var _i = 0, _a = link.opposites; _i < _a.length; _i++) {
                    var li = _a[_i];
                    if (li.opposites.length >= 2)
                        mathis.tab.removeFromArray(li.opposites, link);
                    else
                        li.opposites = null;
                }
            }
        };
        Vertex.prototype.changeToLinkWithoutOpposite = function (voisin) {
            var link = this.findLink(voisin);
            if (link == null)
                return;
            if (link.opposites != null) {
                for (var _i = 0, _a = link.opposites; _i < _a.length; _i++) {
                    var li = _a[_i];
                    if (li.opposites.length >= 2)
                        mathis.tab.removeFromArray(li.opposites, link);
                    else
                        li.opposites = null;
                }
            }
            link.opposites = null;
        };
        Vertex.prototype.toString = function (toSubstract) {
            var res = (this.hashNumber - toSubstract) + "";
            return res;
        };
        Vertex.prototype.toStringComplete = function (toSubstract) {
            var res = this.hashNumber - toSubstract + "|links:";
            for (var _i = 0, _a = this.links; _i < _a.length; _i++) {
                var fle = _a[_i];
                var bif = "";
                if (fle.opposites != null) {
                    bif += ",";
                    for (var _b = 0, _c = fle.opposites; _b < _c.length; _b++) {
                        var li = _c[_b];
                        bif += (li.to.hashNumber - toSubstract) + ",";
                    }
                }
                res += "(" + (fle.to.hashNumber - toSubstract) + bif + ")";
            }
            if (this.position != null)
                res += "|pos:" + this.position.toString(1) + ',';
            res += "|mark:";
            for (var _d = 0, _e = this.markers; _d < _e.length; _d++) {
                var mark = _e[_d];
                res += Vertex.Markers[mark] + ',';
            }
            return res;
        };
        Vertex.hashCount = 0;
        return Vertex;
    }());
    mathis.Vertex = Vertex;
    var Vertex;
    (function (Vertex) {
        (function (Markers) {
            Markers[Markers["honeyComb"] = 0] = "honeyComb";
            Markers[Markers["corner"] = 1] = "corner";
            Markers[Markers["center"] = 2] = "center";
            Markers[Markers["border"] = 3] = "border";
            Markers[Markers["polygonCenter"] = 4] = "pintagoneCenter";
            Markers[Markers["selectedForLineDrawing"] = 5] = "selectedForLineDrawing";
        })(Vertex.Markers || (Vertex.Markers = {}));
        var Markers = Vertex.Markers;
    })(Vertex = mathis.Vertex || (mathis.Vertex = {}));
    /**A graph but not only : it contains vertices but also lines passing through vertices.
     * Most of time a Mamesh is a graph on a surface, so it contains square/triangle between vertices.
     * It can contain also many other informations e.g. {@link vertexToPositioning} or {@link lineToColor} which are useful
     * to represent a Mamesh */
    var Mamesh = (function () {
        function Mamesh() {
            /**'points' of a graph*/
            this.vertices = [];
            /**surface element between vertices*/
            this.smallestTriangles = [];
            this.smallestSquares = [];
            /**to perform dichotomy*/
            this.cutSegmentsDico = {};
        }
        Object.defineProperty(Mamesh.prototype, "polygons", {
            get: function () {
                var res = [];
                for (var i = 0; i < this.smallestSquares.length; i += 4)
                    res.push([this.smallestSquares[i], this.smallestSquares[i + 1], this.smallestSquares[i + 2], this.smallestSquares[i + 3]]);
                for (var i = 0; i < this.smallestTriangles.length; i += 3)
                    res.push([this.smallestTriangles[i], this.smallestTriangles[i + 1], this.smallestTriangles[i + 2]]);
                return res;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Mamesh.prototype, "linesWasMade", {
            //linksOK=false
            get: function () {
                return this.lines != null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Mamesh.prototype, "segments", {
            get: function () {
                var res = [];
                for (var _i = 0, _a = this.vertices; _i < _a.length; _i++) {
                    var vertex = _a[_i];
                    for (var _b = 0, _c = vertex.links; _b < _c.length; _b++) {
                        var link = _c[_b];
                        if (vertex.hashNumber < link.to.hashNumber)
                            res.push([vertex, link.to]);
                    }
                }
                return res;
            },
            enumerable: true,
            configurable: true
        });
        Mamesh.prototype.addATriangle = function (a, b, c) {
            this.smallestTriangles.push(a, b, c);
            return this;
        };
        Mamesh.prototype.addASquare = function (a, b, c, d) {
            this.smallestSquares.push(a, b, c, d);
            return this;
        };
        Mamesh.prototype.newVertex = function (position, dichoLevel, param) {
            if (dichoLevel === void 0) { dichoLevel = 0; }
            var vertex = new Vertex();
            vertex.position = position;
            vertex.param = (param) ? param : position;
            vertex.dichoLevel = dichoLevel;
            this.addVertex(vertex);
            return vertex;
        };
        Mamesh.prototype.findVertexFromParam = function (param) {
            for (var _i = 0, _a = this.vertices; _i < _a.length; _i++) {
                var v = _a[_i];
                if (v.param.hashString == param.hashString)
                    return v;
            }
            return null;
        };
        Mamesh.prototype.addVertex = function (vertex) {
            this.vertices.push(vertex);
        };
        // suppressVertex(vertex:Vertex,exceptionIfNotInside=true):void{
        //     if (!this.hasVertex(vertex)) {
        //         if (exceptionIfNotInside) throw 'this vertex is not in this IN_mamesh'
        //     }
        //     else{
        //         removeFromArray(this.vertices,vertex)
        //         this.paramToVertex.removeKey(vertex.param)
        //     }
        // }
        //
        Mamesh.prototype.hasVertex = function (vertex) {
            for (var _i = 0, _a = this.vertices; _i < _a.length; _i++) {
                var ver = _a[_i];
                if (ver.hashNumber == vertex.hashNumber)
                    return true;
            }
            return false;
        };
        Mamesh.prototype.getStraightLines = function () {
            var res = [];
            for (var _i = 0, _a = this.lines; _i < _a.length; _i++) {
                var line = _a[_i];
                if (!line.isLoop)
                    res.push(line);
            }
            return res;
        };
        Mamesh.prototype.getLoopLines = function () {
            var res = [];
            for (var _i = 0, _a = this.lines; _i < _a.length; _i++) {
                var line = _a[_i];
                if (line.isLoop)
                    res.push(line);
            }
            return res;
        };
        Mamesh.prototype.getStraightLinesAsVertices = function () {
            var res = [];
            for (var _i = 0, _a = this.lines; _i < _a.length; _i++) {
                var line = _a[_i];
                if (!line.isLoop)
                    res.push(line.vertices);
            }
            return res;
        };
        Mamesh.prototype.getLoopLinesAsVertices = function () {
            var res = [];
            for (var _i = 0, _a = this.lines; _i < _a.length; _i++) {
                var line = _a[_i];
                if (line.isLoop)
                    res.push(line.vertices);
            }
            return res;
        };
        Mamesh.prototype.toString = function (substractHashCode) {
            if (substractHashCode === void 0) { substractHashCode = true; }
            var toSubstract = 0;
            if (substractHashCode) {
                toSubstract = Number.MAX_VALUE;
                for (var _i = 0, _a = this.vertices; _i < _a.length; _i++) {
                    var vert = _a[_i];
                    if (vert.hashNumber < toSubstract)
                        toSubstract = vert.hashNumber;
                }
            }
            var res = "\n";
            if (this.name != null)
                res += this.name + "\n";
            for (var _b = 0, _c = this.vertices; _b < _c.length; _b++) {
                var vert = _c[_b];
                res += vert.toStringComplete(toSubstract) + "\n";
            }
            res += "tri:";
            for (var j = 0; j < this.smallestTriangles.length; j += 3) {
                res += "[" + (this.smallestTriangles[j].hashNumber - toSubstract) + "," + (this.smallestTriangles[j + 1].hashNumber - toSubstract) + "," + (this.smallestTriangles[j + 2].hashNumber - toSubstract) + "]";
            }
            res += "\nsqua:";
            for (var j = 0; j < this.smallestSquares.length; j += 4) {
                res += "[" + (this.smallestSquares[j].hashNumber - toSubstract) + "," + (this.smallestSquares[j + 1].hashNumber - toSubstract) + "," + (this.smallestSquares[j + 2].hashNumber - toSubstract) + "," + (this.smallestSquares[j + 3].hashNumber - toSubstract) + "]";
            }
            if (this.linesWasMade) {
                res += "\nstrai:";
                for (var _d = 0, _e = this.getStraightLines(); _d < _e.length; _d++) {
                    var line = _e[_d];
                    res += "[";
                    for (var _f = 0, _g = line.vertices; _f < _g.length; _f++) {
                        var ver = _g[_f];
                        res += (ver.hashNumber - toSubstract) + ",";
                    }
                    res += "]";
                }
                res += "\nloop:";
                for (var _h = 0, _j = this.getLoopLines(); _h < _j.length; _h++) {
                    var line = _j[_h];
                    res += "[";
                    for (var _k = 0, _l = line.vertices; _k < _l.length; _k++) {
                        var ver = _l[_k];
                        res += (ver.hashNumber - toSubstract) + ",";
                    }
                    res += "]";
                }
            }
            res += "\ncutSegments";
            for (var key in this.cutSegmentsDico) {
                var segment = this.cutSegmentsDico[key];
                res += '{' + (segment.a.hashNumber - toSubstract) + ',' + (segment.middle.hashNumber - toSubstract) + ',' + (segment.b.hashNumber - toSubstract) + '}';
            }
            // res+="\nparamToVertex"
            // //let key:XYZ
            // for (let key of this.paramToVertex.allKeys()){
            //     res+=key.hashString+':'+(this.paramToVertex.getValue(key).hashNumber-toSubstract)+'|'
            // }
            return res;
        };
        Mamesh.prototype.fillLineCatalogue = function (startingVertices) {
            if (startingVertices === void 0) { startingVertices = this.vertices; }
            this.lines = mathis.lineModule.makeLineCatalogue2(startingVertices, true);
        };
        Mamesh.prototype.addSimpleLinksAroundPolygons = function () {
            new mathis.linkModule.SimpleLinkFromPolygonCreator(this).goChanging();
        };
        Mamesh.prototype.addOppositeLinksAroundPolygons = function () {
            new mathis.linkModule.SimpleLinkFromPolygonCreator(this).goChanging();
            new mathis.linkModule.OppositeLinkAssocierByAngles(this.vertices).goChanging();
            //new linkModule.LinkCreaterSorterAndBorderDetecterByPolygons(this).goChanging()
        };
        /** A IN_mamesh can be include in a larger graph. This method cut all the link going outside.
         * This method is often use after a submamesh extraction */
        Mamesh.prototype.isolateMameshVerticesFromExteriorVertices = function () {
            var verticesAndLinkToSepare = [];
            for (var _i = 0, _a = this.vertices; _i < _a.length; _i++) {
                var vertex = _a[_i];
                for (var _b = 0, _c = vertex.links; _b < _c.length; _b++) {
                    var link = _c[_b];
                    if (!this.hasVertex(link.to))
                        verticesAndLinkToSepare.push({ vertex: vertex, link: link });
                }
            }
            for (var _d = 0, verticesAndLinkToSepare_1 = verticesAndLinkToSepare; _d < verticesAndLinkToSepare_1.length; _d++) {
                var vl = verticesAndLinkToSepare_1[_d];
                Vertex.separateTwoVoisins(vl.link.to, vl.vertex);
            }
        };
        Mamesh.prototype.getOrCreateSegment = function (v1, v2, segments) {
            var res = this.cutSegmentsDico[Segment.segmentId(v1.hashNumber, v2.hashNumber)];
            if (res == null) {
                res = new Segment(v1, v2);
                this.cutSegmentsDico[Segment.segmentId(v1.hashNumber, v2.hashNumber)] = res;
            }
            segments[Segment.segmentId(v1.hashNumber, v2.hashNumber)] = res;
        };
        Mamesh.prototype.maxLinkLength = function () {
            var res = -1;
            this.vertices.forEach(function (vert) {
                vert.links.forEach(function (li) {
                    var dist = mathis.geo.distance(vert.position, li.to.position);
                    if (dist > res)
                        res = dist;
                });
            });
            if (res == -1)
                throw 'your IN_mamesh seems empty';
            return res;
        };
        // standartDeviationOfLinks():number{
        //     let res=0
        //     let nb=0
        //
        //     this.vertices.forEach(v=>{
        //         v.links.forEach(l=>{
        //             nb++
        //             res+=geo.squaredDistance(v.position,l.to.position)
        //         })
        //
        //     })
        //    
        //     return Math.sqrt(res)/nb
        //
        // }
        Mamesh.prototype.clearLinksAndLines = function () {
            this.vertices.forEach(function (v) {
                mathis.tab.clearArray(v.links);
            });
            this.lines = null;
        };
        Mamesh.prototype.clearOppositeInLinks = function () {
            this.vertices.forEach(function (v) {
                v.links.forEach(function (li) {
                    li.opposites = null;
                });
            });
            //this.loopLines=null
            //this.straightLines=null
        };
        Mamesh.prototype.allLinesAsASortedString = function (substractHashCode) {
            if (substractHashCode === void 0) { substractHashCode = true; }
            var res = "";
            var stringTab;
            var toSubstract;
            if (substractHashCode) {
                toSubstract = Number.MAX_VALUE;
                for (var _i = 0, _a = this.vertices; _i < _a.length; _i++) {
                    var vert = _a[_i];
                    if (vert.hashNumber < toSubstract)
                        toSubstract = vert.hashNumber;
                }
            }
            if (this.linesWasMade) {
                var straigth = this.getStraightLines();
                var loop = this.getLoopLines();
                if (this.linesWasMade && straigth.length > 0) {
                    stringTab = [];
                    straigth.forEach(function (li) {
                        var line = li.vertices;
                        var hashTab = [];
                        line.forEach(function (v) {
                            hashTab.push(v.hashNumber - toSubstract);
                        });
                        stringTab.push(JSON.stringify(hashTab));
                    });
                    stringTab.sort();
                    res = "straightLines:" + JSON.stringify(stringTab);
                }
                if (loop.length > 0) {
                    stringTab = [];
                    loop.forEach(function (li) {
                        var line = li.vertices;
                        var hashTab = [];
                        line.forEach(function (v) {
                            hashTab.push(v.hashNumber - toSubstract);
                        });
                        var minIndex = mathis.tab.minIndexOfNumericList(hashTab);
                        var permutedHashTab = [];
                        for (var i = 0; i < hashTab.length; i++) {
                            permutedHashTab[i] = hashTab[(i + minIndex) % hashTab.length];
                        }
                        stringTab.push(JSON.stringify(permutedHashTab));
                    });
                    stringTab.sort();
                    res += "|loopLines:" + JSON.stringify(stringTab);
                }
            }
            return res;
        };
        Mamesh.prototype.allSquareAndTrianglesAsSortedString = function (subtractHashCode) {
            if (subtractHashCode === void 0) { subtractHashCode = true; }
            var toSubtract = 0;
            if (subtractHashCode) {
                toSubtract = Number.MAX_VALUE;
                for (var _i = 0, _a = this.vertices; _i < _a.length; _i++) {
                    var vert = _a[_i];
                    if (vert.hashNumber < toSubtract)
                        toSubtract = vert.hashNumber;
                }
            }
            var resSquare = "square:" + this.allSquaresOrTrianglesAsASortedString(this.smallestSquares, 4, toSubtract);
            var resTri = "triangle:" + this.allSquaresOrTrianglesAsASortedString(this.smallestTriangles, 3, toSubtract);
            return resSquare + resTri;
        };
        Mamesh.prototype.allSquaresOrTrianglesAsASortedString = function (squareOrTriangles, blockSize, toSubtract) {
            var res = "";
            var stringTab;
            var listOfPoly = [];
            for (var i = 0; i < squareOrTriangles.length; i += blockSize) {
                var block = [];
                for (var j = 0; j < blockSize; j++)
                    block.push(squareOrTriangles[i + j]);
                listOfPoly.push(block);
            }
            stringTab = [];
            listOfPoly.forEach(function (line) {
                var hashTab = [];
                line.forEach(function (v) {
                    hashTab.push(v.hashNumber - toSubtract);
                });
                var minIndex = mathis.tab.minIndexOfNumericList(hashTab);
                var permutedHashTab = [];
                for (var i = 0; i < hashTab.length; i++) {
                    permutedHashTab[i] = hashTab[(i + minIndex) % hashTab.length];
                }
                stringTab.push(JSON.stringify(permutedHashTab));
            });
            stringTab.sort();
            res += JSON.stringify(stringTab);
            return res;
        };
        return Mamesh;
    }());
    mathis.Mamesh = Mamesh;
    var Line = (function () {
        function Line(vertices, isLoop) {
            this.vertices = vertices;
            this.isLoop = isLoop;
        }
        Line.prototype.getVertex = function (index, loopIfLoop) {
            if (loopIfLoop === void 0) { loopIfLoop = true; }
            if (this.isLoop && loopIfLoop)
                return this.vertices[index % this.vertices.length];
            else
                return this.vertices[index];
        };
        Line.prototype.hashForDirected = function () {
            var decayList = [];
            if (!this.isLoop) {
                for (var _i = 0, _a = this.vertices; _i < _a.length; _i++) {
                    var v = _a[_i];
                    decayList.push(v.hashNumber);
                }
            }
            else {
                var minIndex = mathis.tab.minIndexOb(this.vertices, function (v1, v2) { return v1.hashNumber - v2.hashNumber; });
                for (var i = 0; i < this.vertices.length; i++)
                    decayList.push(this.vertices[(i + minIndex) % this.vertices.length].hashNumber);
            }
            return JSON.stringify(decayList);
        };
        Line.prototype.inverted = function () {
            var invertedVert = [];
            for (var i = 0; i < this.vertices.length; i++)
                invertedVert.push(this.vertices[this.vertices.length - 1 - i]);
            return new Line(invertedVert, this.isLoop);
        };
        Line.prototype.positionList = function () {
            var res = [];
            for (var _i = 0, _a = this.vertices; _i < _a.length; _i++) {
                var v = _a[_i];
                res.push(v.position);
            }
            return res;
        };
        Object.defineProperty(Line.prototype, "hashString", {
            get: function () {
                var hash1 = this.hashForDirected();
                var hash2 = this.inverted().hashForDirected();
                return (hash1 < hash2) ? hash1 : hash2;
            },
            enumerable: true,
            configurable: true
        });
        Line.prototype.positionnalHashForDirected = function (precision) {
            if (precision === void 0) { precision = 1; }
            var listOfHash = [];
            XYZ.nbDecimalForHash = precision;
            if (!this.isLoop) {
                for (var _i = 0, _a = this.vertices; _i < _a.length; _i++) {
                    var v = _a[_i];
                    listOfHash.push(v.position.hashString);
                }
            }
            else {
                var positionList = this.positionList();
                var minIndex = mathis.tab.minIndexOb(positionList, XYZ.lexicalOrder);
                for (var i = 0; i < positionList.length; i++)
                    listOfHash.push(positionList[(i + minIndex) % positionList.length].hashString);
            }
            XYZ.resetDefaultNbDecimalForHash();
            return JSON.stringify(listOfHash);
        };
        Line.prototype.positionnalHash = function (precision) {
            if (precision === void 0) { precision = 1; }
            var hash1 = this.positionnalHashForDirected(precision);
            var hash2 = this.inverted().positionnalHashForDirected(precision);
            return (hash1 < hash2) ? hash1 : hash2;
        };
        //
        // hashStringUpToSymmetries(symmetries:((xyz:XYZ)=>XYZ)[],precision=1):string{
        //    
        //     let symmetriesAndIdentity=symmetries.concat((xyz:XYZ)=>xyz)
        //    
        //     let firstPosSymmetrised:XYZ[]=[]
        //     for (let sym of symmetriesAndIdentity) firstPosSymmetrised.push(sym(this.vertices[0].position))
        //     let lesserFirst=tab.minValueOb<XYZ>(firstPosSymmetrised,XYZ.lexicalOrder)
        //
        //     let lastPosSymmetrized:XYZ[]=[]
        //     for (let sym of symmetriesAndIdentity) lastPosSymmetrized.push(sym(this.vertices[this.vertices.length-1].position))
        //     let lesserLast=tab.minValueOb<XYZ>(lastPosSymmetrized,XYZ.lexicalOrder)
        //    
        //     let chosenSym:(xyz:XYZ)=>XYZ
        //     let chosenOrder:Vertex[]
        //
        //     if (XYZ.lexicalOrder(lesserFirst,lesserLast)  <0){
        //         let chosenSymInd=firstPosSymmetrised.indexOf(lesserFirst)
        //         chosenSym=symmetriesAndIdentity[chosenSymInd]
        //         chosenOrder=this.vertices
        //     }
        //     else{
        //         let chosenSymInd=lastPosSymmetrized.indexOf(lesserLast)
        //         chosenSym=symmetriesAndIdentity[chosenSymInd]
        //         chosenOrder=[]
        //         for (let i=0;i<this.vertices.length;i++) chosenOrder.push(this.vertices[this.vertices.length-1-i])
        //     }
        //
        //     let res:string[]=[]
        //     XYZ.nbDecimalForHash=precision
        //     for (let a of chosenOrder) res.push(chosenSym(a.position).hashString)
        //     XYZ.resetDefaultNbDecimalForHash()
        //    
        //    
        //     return JSON.stringify(res)
        //    
        // }
        //
        Line.prototype.hashStringUpToSymmetries = function (symmetries, positionVersusParam) {
            var linesHash = [this.positionnalHash()];
            for (var _i = 0, symmetries_1 = symmetries; _i < symmetries_1.length; _i++) {
                var sym = symmetries_1[_i];
                var symV = [];
                for (var _a = 0, _b = this.vertices; _a < _b.length; _a++) {
                    var v = _b[_a];
                    var vert = new Vertex();
                    if (positionVersusParam)
                        vert.position = sym(v.position);
                    else
                        vert.position = sym(v.param);
                    symV.push(vert);
                }
                var line = new Line(symV, this.isLoop);
                linesHash.push(line.positionnalHash());
            }
            return mathis.tab.minValueString(linesHash);
        };
        Line.prototype.allSegments = function () {
            var res = [];
            var oneMore = (this.isLoop) ? 1 : 0;
            for (var i = 0; i < this.vertices.length - 1 + oneMore; i++) {
                res.push(new Segment(this.vertices[i], this.vertices[(i + 1) % this.vertices.length]));
            }
            return res;
        };
        return Line;
    }());
    mathis.Line = Line;
    var Segment = (function () {
        function Segment(c, d) {
            this.a = (c.hashNumber < d.hashNumber) ? c : d;
            this.b = (c.hashNumber < d.hashNumber) ? d : c;
        }
        Segment.segmentId = function (a, b) {
            if (a < b)
                return a + ',' + b;
            else
                return b + ',' + a;
        };
        Object.defineProperty(Segment.prototype, "hashString", {
            get: function () { return Segment.segmentId(this.a.hashNumber, this.b.hashNumber); },
            enumerable: true,
            configurable: true
        });
        Segment.prototype.equals = function (ab) {
            return this.a == ab.a && this.b == ab.b;
        };
        Segment.prototype.getOther = function (c) {
            if (c == this.a)
                return this.b;
            else
                return this.a;
        };
        Segment.prototype.getFirst = function () {
            return this.a;
        };
        Segment.prototype.getSecond = function () {
            return this.b;
        };
        Segment.prototype.has = function (c) {
            return c == this.a || c == this.b;
        };
        return Segment;
    }());
    mathis.Segment = Segment;
})(mathis || (mathis = {}));
/**
 * Created by vigon on 05/12/2016.
 */
/**https://scripter.click/typescript-example-generate-transform-manipulate-colors/*/
var mathis;
(function (mathis) {
    var Color = (function () {
        function Color(color) {
            if (typeof color === "number") {
                var res = this.hex2rgb(this.intToColorName(color));
                this.rgb = new RGB_range255(res[0], res[1], res[2]);
            }
            else if (typeof color === "string") {
                var res = this.hex2rgb(color);
                this.rgb = new RGB_range255(res[0], res[1], res[2]);
            }
            else if (color instanceof RGB_range255) {
                this.rgb = color;
            }
            else if (color instanceof HSV_01) {
                this.rgb = color.toRGB();
            }
        }
        Color.prototype.hex2rgb = function (hex) {
            var h = hex.replace('#', '');
            h = h.match(new RegExp('(.{' + h.length / 3 + '})', 'g'));
            for (var i = 0; i < h.length; i++)
                h[i] = parseInt(h[i].length == 1 ? h[i] + h[i] : h[i], 16);
            return h; //'rgba('+h.join(',')+')';
        };
        Color.prototype.lighten = function (by) {
            this.rgb = this.rgb.lighten(by);
            //this.hex = this.rgb.toHex();
            return this;
        };
        Color.prototype.darken = function (by) {
            this.rgb = this.rgb.darken(by);
            //this.hex = this.rgb.toHex();
            return this;
        };
        // public toString(rgb:boolean = true):string {
        //     return (rgb) ? this.rgb.toString() : this.hex.toString();
        // }
        //
        // public setAlpha(a:number):Color {
        //     this.rgb.setAlpha(a);
        //     this.hex = this.rgb.toHex();
        //     return this;
        // }
        Color.prototype.toBABYLON_Color4 = function () {
            return new BABYLON.Color4(this.rgb.r / 255, this.rgb.g / 255, this.rgb.b / 255, this.rgb.alpha);
        };
        Color.prototype.toBABYLON_Color3 = function () {
            return new BABYLON.Color3(this.rgb.r / 255, this.rgb.g / 255, this.rgb.b / 255);
        };
        Color.prototype.toString = function () { return this.rgb.toString(); };
        Color.prototype.intToColorName = function (int) {
            var nbColors = 226 - 78;
            var count = 0;
            for (var key in Color.names) {
                if (Color.names.hasOwnProperty(key)) {
                    if (count == ((int * 763) % nbColors)) {
                        return Color.names[key];
                    }
                    count++;
                }
            }
        };
        Color.names = {
            aliceblue: "f0f8ff",
            antiquewhite: "faebd7",
            aqua: "0ff",
            aquamarine: "7fffd4",
            azure: "f0ffff",
            beige: "f5f5dc",
            bisque: "ffe4c4",
            black: "000",
            blanchedalmond: "ffebcd",
            blue: "00f",
            blueviolet: "8a2be2",
            brown: "a52a2a",
            burlywood: "deb887",
            burntsienna: "ea7e5d",
            cadetblue: "5f9ea0",
            chartreuse: "7fff00",
            chocolate: "d2691e",
            coral: "ff7f50",
            cornflowerblue: "6495ed",
            cornsilk: "fff8dc",
            crimson: "dc143c",
            cyan: "0ff",
            darkblue: "00008b",
            darkcyan: "008b8b",
            darkgoldenrod: "b8860b",
            darkgray: "a9a9a9",
            darkgreen: "006400",
            darkgrey: "a9a9a9",
            darkkhaki: "bdb76b",
            darkmagenta: "8b008b",
            darkolivegreen: "556b2f",
            darkorange: "ff8c00",
            darkorchid: "9932cc",
            darkred: "8b0000",
            darksalmon: "e9967a",
            darkseagreen: "8fbc8f",
            darkslateblue: "483d8b",
            darkslategray: "2f4f4f",
            darkslategrey: "2f4f4f",
            darkturquoise: "00ced1",
            darkviolet: "9400d3",
            deeppink: "ff1493",
            deepskyblue: "00bfff",
            dimgray: "696969",
            dimgrey: "696969",
            dodgerblue: "1e90ff",
            firebrick: "b22222",
            floralwhite: "fffaf0",
            forestgreen: "228b22",
            fuchsia: "f0f",
            gainsboro: "dcdcdc",
            ghostwhite: "f8f8ff",
            gold: "ffd700",
            goldenrod: "daa520",
            gray: "808080",
            green: "008000",
            greenyellow: "adff2f",
            grey: "808080",
            honeydew: "f0fff0",
            hotpink: "ff69b4",
            indianred: "cd5c5c",
            indigo: "4b0082",
            ivory: "fffff0",
            khaki: "f0e68c",
            lavender: "e6e6fa",
            lavenderblush: "fff0f5",
            lawngreen: "7cfc00",
            lemonchiffon: "fffacd",
            lightblue: "add8e6",
            lightcoral: "f08080",
            lightcyan: "e0ffff",
            lightgoldenrodyellow: "fafad2",
            lightgray: "d3d3d3",
            lightgreen: "90ee90",
            lightgrey: "d3d3d3",
            lightpink: "ffb6c1",
            lightsalmon: "ffa07a",
            lightseagreen: "20b2aa",
            lightskyblue: "87cefa",
            lightslategray: "789",
            lightslategrey: "789",
            lightsteelblue: "b0c4de",
            lightyellow: "ffffe0",
            lime: "0f0",
            limegreen: "32cd32",
            linen: "faf0e6",
            magenta: "f0f",
            maroon: "800000",
            mediumaquamarine: "66cdaa",
            mediumblue: "0000cd",
            mediumorchid: "ba55d3",
            mediumpurple: "9370db",
            mediumseagreen: "3cb371",
            mediumslateblue: "7b68ee",
            mediumspringgreen: "00fa9a",
            mediumturquoise: "48d1cc",
            mediumvioletred: "c71585",
            midnightblue: "191970",
            mintcream: "f5fffa",
            mistyrose: "ffe4e1",
            moccasin: "ffe4b5",
            navajowhite: "ffdead",
            navy: "000080",
            oldlace: "fdf5e6",
            olive: "808000",
            olivedrab: "6b8e23",
            orange: "ffa500",
            orangered: "ff4500",
            orchid: "da70d6",
            palegoldenrod: "eee8aa",
            palegreen: "98fb98",
            paleturquoise: "afeeee",
            palevioletred: "db7093",
            papayawhip: "ffefd5",
            peachpuff: "ffdab9",
            peru: "cd853f",
            pink: "ffc0cb",
            plum: "dda0dd",
            powderblue: "b0e0e6",
            purple: "800080",
            rebeccapurple: "663399",
            red: "f00",
            rosybrown: "bc8f8f",
            royalblue: "4169e1",
            saddlebrown: "8b4513",
            salmon: "fa8072",
            sandybrown: "f4a460",
            seagreen: "2e8b57",
            seashell: "fff5ee",
            sienna: "a0522d",
            silver: "c0c0c0",
            skyblue: "87ceeb",
            slateblue: "6a5acd",
            slategray: "708090",
            slategrey: "708090",
            snow: "fffafa",
            springgreen: "00ff7f",
            steelblue: "4682b4",
            tan: "d2b48c",
            teal: "008080",
            thistle: "d8bfd8",
            tomato: "ff6347",
            turquoise: "40e0d0",
            violet: "ee82ee",
            wheat: "f5deb3",
            white: "fff",
            whitesmoke: "f5f5f5",
            yellow: "ff0",
            yellowgreen: "9acd32"
        };
        return Color;
    }());
    mathis.Color = Color;
    var HSV_01 = (function () {
        function HSV_01(h, s, v, alpha) {
            if (alpha === void 0) { alpha = 1; }
            this.h = h;
            this.s = s;
            this.v = v;
            this.alpha = alpha;
        }
        HSV_01.HSV_01_toRGB_01 = function (h, s, v) {
            var r, g, b, i, f, p, q, t;
            //if (h && s === undefined && v === undefined) {
            //    s = h.s, v = h.v, h = h.h;
            //}
            i = Math.floor(h * 6);
            f = h * 6 - i;
            p = v * (1 - s);
            q = v * (1 - f * s);
            t = v * (1 - (1 - f) * s);
            switch (i % 6) {
                case 0:
                    r = v;
                    g = t;
                    b = p;
                    break;
                case 1:
                    r = q;
                    g = v;
                    b = p;
                    break;
                case 2:
                    r = p;
                    g = v;
                    b = t;
                    break;
                case 3:
                    r = p;
                    g = q;
                    b = v;
                    break;
                case 4:
                    r = t;
                    g = p;
                    b = v;
                    break;
                case 5:
                    r = v;
                    g = p;
                    b = q;
                    break;
            }
            // if (hasCSSstring) {
            //     r= Math.floor(r * 255);
            //     g= Math.floor(g * 255);
            //     b= Math.floor(b * 255);
            //     return 'rgb('+r+','+g+','+b+')'
            // }
            return { r: r, g: g, b: b };
        };
        HSV_01.prototype.toRGB = function () {
            var pre = HSV_01.HSV_01_toRGB_01(this.h, this.s, this.v);
            return new RGB_range255(pre.r * 255, pre.g * 255, pre.b * 255, 1);
        };
        return HSV_01;
    }());
    mathis.HSV_01 = HSV_01;
    // export class HEX {
    //
    //     static format(hex):string {
    //         let hex:string
    //          /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex) //(hex.toString().length == 6) ? "#" + hex : (hex.toString().length == 7) ? hex : null;
    //     }
    //
    //     private hex:string = "#000000";
    //
    //     constructor(hex:string) {
    //         this.hex = HEX.format(hex)
    //     }
    //
    //     public toRGB():RGB {
    //         let hexString:string = this.hex.substr(1).toString();
    //         return new RGB(parseInt(hexString.substr(0, 2), 16), parseInt(hexString.substr(2, 2), 16), parseInt(hexString.substr(4, 2), 16));
    //     }
    //
    //     public toString():string {
    //         return this.hex;
    //     }
    // }
    var RGB_range255 = (function () {
        //private value:number = 0;
        function RGB_range255(r, g, b, alpha) {
            if (alpha === void 0) { alpha = 1; }
            this.r = 0;
            this.g = 0;
            this.b = 0;
            this.alpha = 1;
            this.setRed(r).setGreen(g).setBlue(b).setAlpha(alpha);
            //this.updateValue();
        }
        RGB_range255.prototype.getHexPart = function (v) {
            var h = v.toString(16);
            return (h.length > 1) ? h : "0" + h;
        };
        // public updateValue():RGB {
        //     this.value = (this.getRed() + this.getGreen() + this.getBlue());
        //     return this;
        // }
        //
        // public getValue():number {
        //     return this.value;
        // }
        // public toHex():string {
        //     return (this.alpha < 1) ? this.toHexAlpha().toString() : "#" + this.getHexPart(this.r) + this.getHexPart(this.g) + this.getHexPart(this.b);
        // }
        //
        // public toHexAlpha(light:boolean = true):string {
        //     let tmpRgb:RGB = new RGB(this.r, this.g, this.b);
        //     if (this.alpha < 1) {
        //         let tmp:number = (1 - this.alpha);
        //         tmpRgb.setRed(tmpRgb.r * tmp);
        //         tmpRgb.setGreen(tmpRgb.g * tmp);
        //         tmpRgb.setBlue(tmpRgb.b * tmp);
        //     }
        //     let adjustValue:number = (this.alpha < 1) ? Math.floor(255 * this.alpha) : 0;
        //     return (light) ? tmpRgb.lighten(adjustValue).toHex() : tmpRgb.darken(adjustValue).toHex();
        // }
        RGB_range255.prototype.setRed = function (value) {
            this.r = (value > 255) ? 255 : ((value < 0) ? 0 : Math.floor(value));
            return this;
        };
        RGB_range255.prototype.setGreen = function (value) {
            this.g = (value > 255) ? 255 : ((value < 0) ? 0 : Math.floor(value));
            return this;
        };
        RGB_range255.prototype.setBlue = function (value) {
            this.b = (value > 255) ? 255 : ((value < 0) ? 0 : Math.floor(value));
            return this;
        };
        RGB_range255.prototype.setAlpha = function (a) {
            this.alpha = (a <= 1 && a >= 0) ? a : 1;
            return this;
        };
        RGB_range255.prototype.lighten = function (by) {
            this.setRed(this.r + by)
                .setBlue(this.g + by)
                .setGreen(this.b + by);
            return this;
        };
        RGB_range255.prototype.darken = function (by) {
            this.setRed(this.r - by)
                .setBlue(this.g - by)
                .setGreen(this.b - by);
            return this;
        };
        RGB_range255.prototype.toString = function () {
            return (this.alpha < 1) ? 'rgba(' + this.r + ',' + this.g + ',' + this.b + ',' + this.alpha + ')' : 'rgb(' + this.r + ',' + this.g + ',' + this.b + ')';
        };
        return RGB_range255;
    }());
    mathis.RGB_range255 = RGB_range255;
    var color;
    (function (color) {
        var thema;
        (function (thema) {
            thema.defaultSurfaceColor = new Color(new RGB_range255(255, 50, 50));
            thema.defaultVertexColor = new Color(new RGB_range255(255, 50, 50));
            thema.defaultLinkColor = new Color(new RGB_range255(124, 252, 0));
        })(thema = color.thema || (color.thema = {}));
    })(color = mathis.color || (mathis.color = {}));
    /** OLD FUNCTIONS*/
    /* accepts parameters
     * h  Object = {h:x, s:y, v:z}
     * OR
     * h, s, v
     *
     * 0 <= h, s, v <= 1
     */
    function HSVtoRGB(h, s, v, hasCSSstring) {
        if (hasCSSstring === void 0) { hasCSSstring = true; }
        var r, g, b, i, f, p, q, t;
        //if (h && s === undefined && v === undefined) {
        //    s = h.s, v = h.v, h = h.h;
        //}
        i = Math.floor(h * 6);
        f = h * 6 - i;
        p = v * (1 - s);
        q = v * (1 - f * s);
        t = v * (1 - (1 - f) * s);
        switch (i % 6) {
            case 0:
                r = v;
                g = t;
                b = p;
                break;
            case 1:
                r = q;
                g = v;
                b = p;
                break;
            case 2:
                r = p;
                g = v;
                b = t;
                break;
            case 3:
                r = p;
                g = q;
                b = v;
                break;
            case 4:
                r = t;
                g = p;
                b = v;
                break;
            case 5:
                r = v;
                g = p;
                b = q;
                break;
        }
        if (hasCSSstring) {
            r = Math.floor(r * 255);
            g = Math.floor(g * 255);
            b = Math.floor(b * 255);
            return 'rgb(' + r + ',' + g + ',' + b + ')';
        }
        else
            return { r: r, g: g, b: b };
    }
    mathis.HSVtoRGB = HSVtoRGB;
    function hexToRgb(hex, maxIs255) {
        if (maxIs255 === void 0) { maxIs255 = false; }
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        var denominator = (maxIs255) ? 1 : 255;
        return result ? {
            r: parseInt(result[1], 16) / denominator,
            g: parseInt(result[2], 16) / denominator,
            b: parseInt(result[3], 16) / denominator
        } : null;
    }
    mathis.hexToRgb = hexToRgb;
    function componentToHex(c) {
        var hex = c.toString(16);
        return hex.length == 1 ? "0" + hex : hex;
    }
    function rgbToHex(r, g, b) {
        return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
    }
    mathis.rgbToHex = rgbToHex;
})(mathis || (mathis = {}));
/**
 * Created by vigon on 02/06/2016.
 */
var mathis;
(function (mathis) {
    var creation2D;
    (function (creation2D) {
        (function (PartShape) {
            PartShape[PartShape["triangulatedTriangle"] = 0] = "triangulatedTriangle";
            PartShape[PartShape["triangulatedRect"] = 1] = "triangulatedRect";
            PartShape[PartShape["square"] = 2] = "square";
            PartShape[PartShape["polygon3"] = 3] = "polygon3";
            PartShape[PartShape["polygon4"] = 4] = "polygon4";
            PartShape[PartShape["polygon5"] = 5] = "polygon5";
            PartShape[PartShape["polygon6"] = 6] = "polygon6";
            PartShape[PartShape["polygon7"] = 7] = "polygon7";
            PartShape[PartShape["polygon8"] = 8] = "polygon8";
            PartShape[PartShape["polygon9"] = 9] = "polygon9";
            PartShape[PartShape["polygon10"] = 10] = "polygon10";
            PartShape[PartShape["polygon11"] = 11] = "polygon11";
            PartShape[PartShape["polygon12"] = 12] = "polygon12";
        })(creation2D.PartShape || (creation2D.PartShape = {}));
        var PartShape = creation2D.PartShape;
        //
        // export class Patchwork{
        //
        //
        //
        //     private individualINumber:number
        //     private individualJNumber:number
        //
        //     nbPatchesI=2
        //     nbPatchesJ=2
        //     patchesInQuinconce=false
        //     /**if stays null, it take the value of previous field*/
        //     oneMorePatchAtOddRaw:boolean=null
        //
        //
        //     individualDilatation=new XYZ(2,2,0)
        //     origine=new XYZ(0,0,0)
        //     end=new XYZ(1,1,0)
        //
        //     shapes=[PartShape.square,PartShape.squareTurned]
        //
        //     constructor(nbIOfEach:number,nbJOfEach:number){
        //         this.individualINumber=nbIOfEach
        //         this.individualJNumber=nbJOfEach
        //     }
        //
        //
        //     goChanging():Mamesh{
        //
        //         if (this.oneMorePatchAtOddRaw==null) this.oneMorePatchAtOddRaw=this.patchesInQuinconce
        //
        //         let subMa:Mamesh[]=[]
        //
        //         for (let j=0; j<this.nbPatchesJ; j++){
        //             let oneMore=0
        //             if (this.patchesInQuinconce&&j%2==1) oneMore=1
        //             for (let i=0; i<this.nbPatchesI+oneMore; i++){
        //
        //                 /**other function are possible*/
        //                 let mailleIndex=(i+j)%this.shapes.length
        //
        //                 let dec=0
        //                 if (this.patchesInQuinconce&& j%2==1)dec=-0.5
        //
        //                 let gene=new reseau.BasisForRegularReseau()
        //                 gene.origin=new XYZ(i+dec,j,0)
        //                 gene.end=new XYZ(i+1+dec,j+1,0)
        //                 gene.nbI=this.individualINumber
        //                 gene.nbJ=this.individualJNumber
        //                 if (this.shapes[mailleIndex]==PartShape.triangulatedRect||this.shapes[mailleIndex]==PartShape.triangulatedRectInverted) gene.strateHaveSquareMailleVersusTriangleMaille=false
        //                 gene.goChanging()
        //
        //                 let regular=new reseau.Regular(gene)
        //                 let IN_mamesh=regular.goChanging()
        //                 subMa.push(IN_mamesh)
        //
        //                 let angle=0
        //                 if (this.shapes[mailleIndex]==PartShape.squareTurned)angle=Math.PI/4
        //                 else if (this.shapes[mailleIndex]==PartShape.triangulatedRectInverted) angle=Math.PI/2
        //                 let simi=new reseau.Similitude(IN_mamesh.vertices,angle,new XYZ(0,0,0),this.individualDilatation)
        //                 simi.goChanging()
        //
        //
        //
        //
        //
        //             }
        //         }
        //
        //         let gratAndStick=new mameshModification.ConcurrentMameshesGraterAndSticker(subMa)
        //         //gratAndStick.proximityCoefToStick=2.5
        //         let res=gratAndStick.goChanging()
        //
        //
        //
        //         /**a very small angle to avoid the bug of BABYLON*/
        //         new reseau.Similitude(res.vertices,0.01).goChanging()
        //
        //         let actualEnd=XYZ.newFrom(res.vertices[0].position)
        //         let actualOrigin=XYZ.newFrom(res.vertices[0].position)
        //         for (let vert of res.vertices){
        //             if (vert.position.x>actualEnd.x) actualEnd.x=vert.position.x
        //             if (vert.position.y>actualEnd.y) actualEnd.y=vert.position.y
        //             if (vert.position.x<actualOrigin.x) actualOrigin.x=vert.position.x
        //             if (vert.position.y<actualOrigin.y) actualOrigin.y=vert.position.y
        //         }
        //
        //         let actualAmplitude=XYZ.newFrom(actualEnd).substract(actualOrigin)
        //         let ampli=XYZ.newFrom(this.end).substract(this.origine)
        //         let factor=new XYZ(ampli.x/actualAmplitude.x,ampli.y/actualAmplitude.y,0)
        //
        //         for (let vert of res.vertices){
        //             vert.position.substract(actualOrigin).resizes(factor).add(this.origine)
        //         }
        //
        //
        //
        //
        //
        //         return res
        //
        //
        //     }
        //
        //
        //
        // }
        var Concentric = (function () {
            // /**the number of I and J of each component at the end*/
            // OUTComputedSize:number[][]=[]
            function Concentric(individualNbI, individualNbJ) {
                this.SUB_gratAndStick = new mathis.grateAndGlue.ConcurrentMameshesGraterAndSticker();
                this.SUB_oppositeLinkAssocierByAngles = new mathis.linkModule.OppositeLinkAssocierByAngles(null);
                this.SUB_mameshCleaner = new mathis.mameshModification.MameshCleaner(null);
                this.origine = new mathis.XYZ(0, 0, 0);
                this.end = new mathis.XYZ(1, 1, 0);
                /**a very small angle to avoid the bug of BABYLON*/
                this.rotation = 0.001;
                this.shapes = [PartShape.square];
                this.proportions = [new mathis.UV(1, 1), new mathis.UV(1, 1)];
                this.individualScales = [new mathis.UV(1, 1)];
                this.individualRotations = [0];
                this.individualTranslation = [new mathis.XYZ(0, 0, 0), new mathis.XYZ(0, 0, 0)];
                this.nbPatches = 2;
                /**if zero, sticking is made only for closest voisin*/
                this.toleranceToBeOneOfTheClosest = 0.05;
                this.stratesToSuppressFromCorners = [0];
                /**e.g. XYZ(1,0.5,0) will suppress all the vertical branching while
                 *      XYZ(0.5,1,0) will suppress all the horizontal branching */
                this.scalingBeforeOppositeLinkAssociations = null;
                this.exponentOfRoundingFunction = [1];
                this.percolationProba = [0];
                this.nbI = individualNbI;
                this.nbJ = individualNbJ;
            }
            Concentric.prototype.go = function () {
                var subMa = [];
                var _loop_1 = function(j) {
                    /**other function are possible*/
                    var indexModulo = (j) % this_1.shapes.length;
                    var partShape = this_1.shapes[indexModulo];
                    var name_1 = PartShape[partShape];
                    var nI = Math.round(this_1.nbI * this_1.proportions[j % this_1.proportions.length].u);
                    var nJ = Math.round(this_1.nbJ * this_1.proportions[j % this_1.proportions.length].v);
                    var radiusI = 0.5 * this_1.individualScales[j % this_1.individualScales.length].u * this_1.proportions[j % this_1.proportions.length].u;
                    var radiusJ = 0.5 * this_1.individualScales[j % this_1.individualScales.length].v * this_1.proportions[j % this_1.proportions.length].v;
                    var mamesh = void 0;
                    /**as usual, deformation of individual patches are  : scaling, then rotation, then translation */
                    if (name_1.indexOf('polygon') != -1) {
                        var nbSides = parseInt(name_1.slice(7, name_1.length));
                        var crea = new mathis.reseau.TriangulatedPolygone(nbSides);
                        crea.origin = new mathis.XYZ(-radiusI, -radiusJ, 0);
                        crea.end = new mathis.XYZ(radiusI, radiusJ, 0);
                        /** nbI and nbJ are sort of diameter, so the constantRadius is alf the mean of the diameter */
                        crea.nbSubdivisionInARadius = Math.floor((nI + nJ) / 4);
                        mamesh = crea.go();
                    }
                    else if (partShape == PartShape.square || partShape == PartShape.triangulatedRect) {
                        var gene = new mathis.reseau.BasisForRegularReseau();
                        /**here the scaling*/
                        gene.origin = new mathis.XYZ(-radiusI, -radiusJ, 0);
                        gene.end = new mathis.XYZ(radiusI, radiusJ, 0);
                        gene.nbI = nI;
                        gene.nbJ = nJ;
                        if (partShape == PartShape.triangulatedRect)
                            gene.squareMailleInsteadOfTriangle = false;
                        gene.go();
                        var regular = new mathis.reseau.Regular(gene);
                        if (partShape == PartShape.triangulatedRect)
                            regular.oneMoreVertexForOddLine = true;
                        mamesh = regular.go();
                    }
                    else if (partShape == PartShape.triangulatedTriangle) {
                        var creator = new mathis.reseau.TriangulatedTriangle();
                        creator.origin = new mathis.XYZ(-radiusI, -radiusJ, 0);
                        creator.end = new mathis.XYZ(radiusI, radiusJ, 0);
                        creator.nbSubdivisionInSide = (nI + nJ) / 2;
                        mamesh = creator.go();
                    }
                    if (this_1.propBeginToRound || this_1.propEndToRound || this_1.integerBeginToRound || this_1.integerEndToRound) {
                        var rounder = new mathis.spacialTransformations.RoundSomeStrates(mamesh);
                        if (this_1.propBeginToRound == null)
                            rounder.propBeginToRound = 0;
                        else
                            rounder.propBeginToRound = this_1.propBeginToRound[j % this_1.propBeginToRound.length];
                        if (this_1.propEndToRound == null)
                            rounder.propEndToRound = 1;
                        else
                            rounder.propEndToRound = this_1.propEndToRound[j % this_1.propEndToRound.length];
                        if (this_1.integerBeginToRound != null)
                            rounder.integerBeginToRound = this_1.integerBeginToRound[j % this_1.integerBeginToRound.length];
                        if (this_1.integerEndToRound != null)
                            rounder.integerEndToRound = this_1.integerEndToRound[j % this_1.integerEndToRound.length];
                        rounder.exponentOfRoundingFunction = this_1.exponentOfRoundingFunction[j % this_1.exponentOfRoundingFunction.length];
                        rounder.referenceRadiusIsMinVersusMaxVersusMean = 2;
                        rounder.preventStratesCrossings = true;
                        rounder.goChanging();
                    }
                    var percolation = this_1.percolationProba[j * this_1.percolationProba.length];
                    if (percolation > 0) {
                        var percolator = new mathis.mameshModification.PercolationOnLinks(mamesh);
                        percolator.percolationProba = percolation;
                        percolator.goChanging();
                    }
                    if (this_1.stratesToSuppressFromCorners[j % this_1.stratesToSuppressFromCorners.length] > 0) {
                        var supp = new mathis.grateAndGlue.ExtractCentralPart(mamesh, this_1.stratesToSuppressFromCorners[j % this_1.stratesToSuppressFromCorners.length]);
                        supp.suppressFromBorderVersusCorner = false;
                        mamesh = supp.go();
                        mamesh.isolateMameshVerticesFromExteriorVertices();
                    }
                    subMa.push(mamesh);
                    var decay = this_1.individualTranslation[j % this_1.individualTranslation.length];
                    var angle = this_1.individualRotations[j % this_1.individualRotations.length];
                    var mat = new mathis.MM();
                    mathis.geo.axisAngleToMatrix(new mathis.XYZ(0, 0, -1), angle, mat);
                    mamesh.vertices.forEach(function (v) {
                        mathis.geo.multiplicationMatrixVector(mat, v.position, v.position);
                        v.position.add(decay);
                    });
                };
                var this_1 = this;
                for (var j = 0; j < this.nbPatches; j++) {
                    _loop_1(j);
                }
                var res;
                /**just to win time : when there is only one IN_mamesh, no need of grating and stiking*/
                if (this.nbPatches > 1) {
                    this.SUB_gratAndStick.IN_mameshes = subMa;
                    this.SUB_gratAndStick.toleranceToBeOneOfTheClosest = this.toleranceToBeOneOfTheClosest;
                    res = this.SUB_gratAndStick.goChanging();
                }
                else {
                    res = subMa[0];
                    mathis.spacialTransformations.adjustInASquare(res, new mathis.XYZ(0, 0, 0), new mathis.XYZ(1, 1, 0));
                    res.clearOppositeInLinks();
                }
                if (this.scalingBeforeOppositeLinkAssociations != null)
                    mathis.spacialTransformations.adjustInASquare(res, new mathis.XYZ(0, 0, 0), new mathis.XYZ(this.scalingBeforeOppositeLinkAssociations.x, this.scalingBeforeOppositeLinkAssociations.y, 0));
                this.SUB_oppositeLinkAssocierByAngles.vertices = res.vertices;
                this.SUB_oppositeLinkAssocierByAngles.goChanging();
                this.SUB_mameshCleaner.IN_mamesh = res;
                this.SUB_mameshCleaner.goChanging();
                new mathis.spacialTransformations.Similitude(res.vertices, this.rotation).goChanging();
                mathis.spacialTransformations.adjustInASquare(res, this.origine, this.end);
                return res;
            };
            return Concentric;
        }());
        creation2D.Concentric = Concentric;
        var Patchwork = (function (_super) {
            __extends(Patchwork, _super);
            function Patchwork(nbI, nbJ, nbIPart, nbJPart) {
                _super.call(this, nbI, nbJ);
                this.nbPatchesI = 2;
                this.nbPatchesJ = 2;
                this.patchesInQuinconce = false;
                this.oddPatchLinesAreTheSameVersusLongerVersusShorter = 0;
                this.alternateShapeAccordingIPlusJVersusCounter = true;
                this.nbPatchesI = nbIPart;
                this.nbPatchesJ = nbJPart;
                /**field of the super class, which will be determine in goChanging-method*/
                this.nbPatches = 0;
                this.individualTranslation = [];
                //this.shapes=[]
            }
            Patchwork.prototype.go = function () {
                /**2 fields recomputed*/
                this.individualTranslation = [];
                this.nbPatches = 0;
                var shapes = [];
                var count = 0;
                for (var j = 0; j < this.nbPatchesJ; j++) {
                    var someMoreOrLessOfOdd = 0;
                    if (j % 2 == 1) {
                        if (this.oddPatchLinesAreTheSameVersusLongerVersusShorter == 0)
                            someMoreOrLessOfOdd = 0;
                        else if (this.oddPatchLinesAreTheSameVersusLongerVersusShorter == 1)
                            someMoreOrLessOfOdd = 1;
                        else if (this.oddPatchLinesAreTheSameVersusLongerVersusShorter == 2)
                            someMoreOrLessOfOdd = -1;
                        else
                            throw 'must be 0 or 1 or 2';
                    }
                    for (var i = 0; i < this.nbPatchesI + someMoreOrLessOfOdd; i++) {
                        this.nbPatches++;
                        var dec = 0;
                        if (this.patchesInQuinconce && j % 2 == 1) {
                            if (this.oddPatchLinesAreTheSameVersusLongerVersusShorter == 0)
                                dec = -0.5;
                            if (this.oddPatchLinesAreTheSameVersusLongerVersusShorter == 1)
                                dec = -0.5;
                            if (this.oddPatchLinesAreTheSameVersusLongerVersusShorter == 2)
                                dec = 0.5;
                        }
                        this.individualTranslation.push(new mathis.XYZ(i + dec, j, 0));
                        count++;
                        var ind = (this.alternateShapeAccordingIPlusJVersusCounter) ? (i + someMoreOrLessOfOdd + j) : count;
                        //this.proportions.push(this.patchSize[ind%this.patchSize.length])
                        shapes.push(this.shapes[ind % this.shapes.length]);
                    }
                }
                this.shapes = shapes;
                return _super.prototype.go.call(this);
            };
            return Patchwork;
        }(Concentric));
        creation2D.Patchwork = Patchwork;
    })(creation2D = mathis.creation2D || (mathis.creation2D = {}));
})(mathis || (mathis = {}));
/**
 * Created by vigon on 05/03/2016.
 */
var mathis;
(function (mathis) {
    var creation3D;
    (function (creation3D) {
        (function (PolyhedronType) {
            PolyhedronType[PolyhedronType["Tetrahedron"] = 0] = "Tetrahedron";
            PolyhedronType[PolyhedronType["Cube"] = 1] = "Cube";
            PolyhedronType[PolyhedronType["Octahedron"] = 2] = "Octahedron";
            PolyhedronType[PolyhedronType["Dodecahedron"] = 3] = "Dodecahedron";
            PolyhedronType[PolyhedronType["Icosahedron"] = 4] = "Icosahedron";
            PolyhedronType[PolyhedronType["Rhombicuboctahedron"] = 5] = "Rhombicuboctahedron";
            PolyhedronType[PolyhedronType["TriangulPrism"] = 6] = "TriangulPrism";
            PolyhedronType[PolyhedronType["PentagonalPrism"] = 7] = "PentagonalPrism";
            PolyhedronType[PolyhedronType["HexagonalPrism"] = 8] = "HexagonalPrism";
            PolyhedronType[PolyhedronType["SquarePyramid"] = 9] = "SquarePyramid";
            PolyhedronType[PolyhedronType["PentagonalPyramid"] = 10] = "PentagonalPyramid";
            PolyhedronType[PolyhedronType["TriangularDipyramid"] = 11] = "TriangularDipyramid";
            PolyhedronType[PolyhedronType["PentagonalDipyramid"] = 12] = "PentagonalDipyramid";
            PolyhedronType[PolyhedronType["ElongatedSquareDipyramid"] = 13] = "ElongatedSquareDipyramid";
            PolyhedronType[PolyhedronType["ElongatedPentagonalDipyramid"] = 14] = "ElongatedPentagonalDipyramid";
            PolyhedronType[PolyhedronType["ElongatedPentagonalCupola"] = 15] = "ElongatedPentagonalCupola";
        })(creation3D.PolyhedronType || (creation3D.PolyhedronType = {}));
        var PolyhedronType = creation3D.PolyhedronType;
        var Polyhedron = (function () {
            function Polyhedron(type) {
                this.makeLinks = true;
                this.mamesh = new mathis.Mamesh();
                this.type = type;
            }
            Polyhedron.prototype.go = function () {
                var polyhedra = [];
                polyhedra[PolyhedronType.Tetrahedron] = {
                    vertex: [[0, 0, 1.732051], [1.632993, 0, -0.5773503], [-0.8164966, 1.414214, -0.5773503], [-0.8164966, -1.414214, -0.5773503]],
                    face: [[0, 1, 2], [0, 2, 3], [0, 3, 1], [1, 3, 2]]
                };
                polyhedra[PolyhedronType.Cube] = {
                    vertex: [[0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0], [0, 0, 1], [1, 0, 1], [1, 1, 1], [0, 1, 1]],
                    face: [[0, 1, 2, 3], [4, 7, 6, 5], [1, 5, 6, 2], [0, 3, 7, 4], [2, 6, 7, 3], [0, 4, 5, 1]],
                    notYetCentered: true
                };
                polyhedra[PolyhedronType.Octahedron] = {
                    vertex: [[0, 0, 1.414214], [1.414214, 0, 0], [0, 1.414214, 0], [-1.414214, 0, 0], [0, -1.414214, 0], [0, 0, -1.414214]],
                    face: [[0, 1, 2], [0, 2, 3], [0, 3, 4], [0, 4, 1], [1, 4, 5], [1, 5, 2], [2, 5, 3], [3, 5, 4]]
                };
                polyhedra[PolyhedronType.Dodecahedron] = {
                    vertex: [[0, 0, 1.070466], [0.7136442, 0, 0.7978784], [-0.3568221, 0.618034, 0.7978784], [-0.3568221, -0.618034, 0.7978784], [0.7978784, 0.618034, 0.3568221], [0.7978784, -0.618034, 0.3568221], [-0.9341724, 0.381966, 0.3568221], [0.1362939, 1, 0.3568221], [0.1362939, -1, 0.3568221], [-0.9341724, -0.381966, 0.3568221], [0.9341724, 0.381966, -0.3568221], [0.9341724, -0.381966, -0.3568221], [-0.7978784, 0.618034, -0.3568221], [-0.1362939, 1, -0.3568221], [-0.1362939, -1, -0.3568221], [-0.7978784, -0.618034, -0.3568221], [0.3568221, 0.618034, -0.7978784], [0.3568221, -0.618034, -0.7978784], [-0.7136442, 0, -0.7978784], [0, 0, -1.070466]],
                    face: [[0, 1, 4, 7, 2], [0, 2, 6, 9, 3], [0, 3, 8, 5, 1], [1, 5, 11, 10, 4], [2, 7, 13, 12, 6], [3, 9, 15, 14, 8], [4, 10, 16, 13, 7], [5, 8, 14, 17, 11], [6, 12, 18, 15, 9], [10, 11, 17, 19, 16], [12, 13, 16, 19, 18], [14, 15, 18, 19, 17]]
                };
                polyhedra[PolyhedronType.Icosahedron] = {
                    vertex: [[0, 0, 1.175571], [1.051462, 0, 0.5257311], [0.3249197, 1, 0.5257311], [-0.8506508, 0.618034, 0.5257311], [-0.8506508, -0.618034, 0.5257311], [0.3249197, -1, 0.5257311], [0.8506508, 0.618034, -0.5257311], [0.8506508, -0.618034, -0.5257311], [-0.3249197, 1, -0.5257311], [-1.051462, 0, -0.5257311], [-0.3249197, -1, -0.5257311], [0, 0, -1.175571]],
                    face: [[0, 1, 2], [0, 2, 3], [0, 3, 4], [0, 4, 5], [0, 5, 1], [1, 5, 7], [1, 7, 6], [1, 6, 2], [2, 6, 8], [2, 8, 3], [3, 8, 9], [3, 9, 4], [4, 9, 10], [4, 10, 5], [5, 10, 7], [6, 7, 11], [6, 11, 8], [7, 10, 11], [8, 11, 9], [9, 11, 10]]
                };
                polyhedra[PolyhedronType.Rhombicuboctahedron] = {
                    vertex: [[0, 0, 1.070722], [0.7148135, 0, 0.7971752], [-0.104682, 0.7071068, 0.7971752], [-0.6841528, 0.2071068, 0.7971752], [-0.104682, -0.7071068, 0.7971752], [0.6101315, 0.7071068, 0.5236279], [1.04156, 0.2071068, 0.1367736], [0.6101315, -0.7071068, 0.5236279], [-0.3574067, 1, 0.1367736], [-0.7888348, -0.5, 0.5236279], [-0.9368776, 0.5, 0.1367736], [-0.3574067, -1, 0.1367736], [0.3574067, 1, -0.1367736], [0.9368776, -0.5, -0.1367736], [0.7888348, 0.5, -0.5236279], [0.3574067, -1, -0.1367736], [-0.6101315, 0.7071068, -0.5236279], [-1.04156, -0.2071068, -0.1367736], [-0.6101315, -0.7071068, -0.5236279], [0.104682, 0.7071068, -0.7971752], [0.6841528, -0.2071068, -0.7971752], [0.104682, -0.7071068, -0.7971752], [-0.7148135, 0, -0.7971752], [0, 0, -1.070722]],
                    face: [[0, 2, 3], [1, 6, 5], [4, 9, 11], [7, 15, 13], [8, 16, 10], [12, 14, 19], [17, 22, 18], [20, 21, 23], [0, 1, 5, 2], [0, 3, 9, 4], [0, 4, 7, 1], [1, 7, 13, 6], [2, 5, 12, 8], [2, 8, 10, 3], [3, 10, 17, 9], [4, 11, 15, 7], [5, 6, 14, 12], [6, 13, 20, 14], [8, 12, 19, 16], [9, 17, 18, 11], [10, 16, 22, 17], [11, 18, 21, 15], [13, 15, 21, 20], [14, 20, 23, 19], [16, 19, 23, 22], [18, 22, 23, 21]]
                };
                polyhedra[PolyhedronType.TriangulPrism] = {
                    vertex: [[0, 0, 1.322876], [1.309307, 0, 0.1889822], [-0.9819805, 0.8660254, 0.1889822], [0.1636634, -1.299038, 0.1889822], [0.3273268, 0.8660254, -0.9449112], [-0.8183171, -0.4330127, -0.9449112]],
                    face: [[0, 3, 1], [2, 4, 5], [0, 1, 4, 2], [0, 2, 5, 3], [1, 3, 5, 4]]
                };
                polyhedra[PolyhedronType.PentagonalPrism] = {
                    vertex: [[0, 0, 1.159953], [1.013464, 0, 0.5642542], [-0.3501431, 0.9510565, 0.5642542], [-0.7715208, -0.6571639, 0.5642542], [0.6633206, 0.9510565, -0.03144481], [0.8682979, -0.6571639, -0.3996071], [-1.121664, 0.2938926, -0.03144481], [-0.2348831, -1.063314, -0.3996071], [0.5181548, 0.2938926, -0.9953061], [-0.5850262, -0.112257, -0.9953061]],
                    face: [[0, 1, 4, 2], [0, 2, 6, 3], [1, 5, 8, 4], [3, 6, 9, 7], [5, 7, 9, 8], [0, 3, 7, 5, 1], [2, 4, 8, 9, 6]]
                };
                polyhedra[PolyhedronType.HexagonalPrism] = {
                    vertex: [[0, 0, 1.118034], [0.8944272, 0, 0.6708204], [-0.2236068, 0.8660254, 0.6708204], [-0.7826238, -0.4330127, 0.6708204], [0.6708204, 0.8660254, 0.2236068], [1.006231, -0.4330127, -0.2236068], [-1.006231, 0.4330127, 0.2236068], [-0.6708204, -0.8660254, -0.2236068], [0.7826238, 0.4330127, -0.6708204], [0.2236068, -0.8660254, -0.6708204], [-0.8944272, 0, -0.6708204], [0, 0, -1.118034]],
                    face: [[0, 1, 4, 2], [0, 2, 6, 3], [1, 5, 8, 4], [3, 6, 10, 7], [5, 9, 11, 8], [7, 10, 11, 9], [0, 3, 7, 9, 5, 1], [2, 4, 8, 11, 10, 6]]
                };
                polyhedra[PolyhedronType.SquarePyramid] = {
                    vertex: [[-0.729665, 0.670121, 0.319155], [-0.655235, -0.29213, -0.754096], [-0.093922, -0.607123, 0.537818], [0.702196, 0.595691, 0.485187], [0.776626, -0.36656, -0.588064]],
                    face: [[1, 4, 2], [0, 1, 2], [3, 0, 2], [4, 3, 2], [4, 1, 0, 3]]
                };
                polyhedra[PolyhedronType.PentagonalPyramid] = {
                    vertex: [[-0.868849, -0.100041, 0.61257], [-0.329458, 0.976099, 0.28078], [-0.26629, -0.013796, -0.477654], [-0.13392, -1.034115, 0.229829], [0.738834, 0.707117, -0.307018], [0.859683, -0.535264, -0.338508]],
                    face: [[3, 0, 2], [5, 3, 2], [4, 5, 2], [1, 4, 2], [0, 1, 2], [0, 3, 5, 4, 1]]
                };
                polyhedra[PolyhedronType.TriangularDipyramid] = {
                    vertex: [[-0.610389, 0.243975, 0.531213], [-0.187812, -0.48795, -0.664016], [-0.187812, 0.9759, -0.664016], [0.187812, -0.9759, 0.664016], [0.798201, 0.243975, 0.132803]],
                    face: [[1, 3, 0], [3, 4, 0], [3, 1, 4], [0, 2, 1], [0, 4, 2], [2, 4, 1]]
                };
                polyhedra[PolyhedronType.PentagonalDipyramid] = {
                    vertex: [[-1.028778, 0.392027, -0.048786], [-0.640503, -0.646161, 0.621837], [-0.125162, -0.395663, -0.540059], [0.004683, 0.888447, -0.651988], [0.125161, 0.395663, 0.540059], [0.632925, -0.791376, 0.433102], [1.031672, 0.157063, -0.354165]],
                    face: [[3, 2, 0], [2, 1, 0], [2, 5, 1], [0, 4, 3], [0, 1, 4], [4, 1, 5], [2, 3, 6], [3, 4, 6], [5, 2, 6], [4, 5, 6]]
                };
                polyhedra[PolyhedronType.ElongatedSquareDipyramid] = {
                    vertex: [[-0.669867, 0.334933, -0.529576], [-0.669867, 0.334933, 0.529577], [-0.4043, 1.212901, 0], [-0.334933, -0.669867, -0.529576], [-0.334933, -0.669867, 0.529577], [0.334933, 0.669867, -0.529576], [0.334933, 0.669867, 0.529577], [0.4043, -1.212901, 0], [0.669867, -0.334933, -0.529576], [0.669867, -0.334933, 0.529577]],
                    face: [[8, 9, 7], [6, 5, 2], [3, 8, 7], [5, 0, 2], [4, 3, 7], [0, 1, 2], [9, 4, 7], [1, 6, 2], [9, 8, 5, 6], [8, 3, 0, 5], [3, 4, 1, 0], [4, 9, 6, 1]]
                };
                polyhedra[PolyhedronType.ElongatedPentagonalDipyramid] = {
                    vertex: [[-0.931836, 0.219976, -0.264632], [-0.636706, 0.318353, 0.692816], [-0.613483, -0.735083, -0.264632], [-0.326545, 0.979634, 0], [-0.318353, -0.636706, 0.692816], [-0.159176, 0.477529, -0.856368], [0.159176, -0.477529, -0.856368], [0.318353, 0.636706, 0.692816], [0.326545, -0.979634, 0], [0.613482, 0.735082, -0.264632], [0.636706, -0.318353, 0.692816], [0.931835, -0.219977, -0.264632]],
                    face: [[11, 10, 8], [7, 9, 3], [6, 11, 8], [9, 5, 3], [2, 6, 8], [5, 0, 3], [4, 2, 8], [0, 1, 3], [10, 4, 8], [1, 7, 3], [10, 11, 9, 7], [11, 6, 5, 9], [6, 2, 0, 5], [2, 4, 1, 0], [4, 10, 7, 1]]
                };
                polyhedra[PolyhedronType.ElongatedPentagonalCupola] = {
                    vertex: [[-0.93465, 0.300459, -0.271185], [-0.838689, -0.260219, -0.516017], [-0.711319, 0.717591, 0.128359], [-0.710334, -0.156922, 0.080946], [-0.599799, 0.556003, -0.725148], [-0.503838, -0.004675, -0.969981], [-0.487004, 0.26021, 0.48049], [-0.460089, -0.750282, -0.512622], [-0.376468, 0.973135, -0.325605], [-0.331735, -0.646985, 0.084342], [-0.254001, 0.831847, 0.530001], [-0.125239, -0.494738, -0.966586], [0.029622, 0.027949, 0.730817], [0.056536, -0.982543, -0.262295], [0.08085, 1.087391, 0.076037], [0.125583, -0.532729, 0.485984], [0.262625, 0.599586, 0.780328], [0.391387, -0.726999, -0.716259], [0.513854, -0.868287, 0.139347], [0.597475, 0.85513, 0.326364], [0.641224, 0.109523, 0.783723], [0.737185, -0.451155, 0.538891], [0.848705, -0.612742, -0.314616], [0.976075, 0.365067, 0.32976], [1.072036, -0.19561, 0.084927]],
                    face: [[15, 18, 21], [12, 20, 16], [6, 10, 2], [3, 0, 1], [9, 7, 13], [2, 8, 4, 0], [0, 4, 5, 1], [1, 5, 11, 7], [7, 11, 17, 13], [13, 17, 22, 18], [18, 22, 24, 21], [21, 24, 23, 20], [20, 23, 19, 16], [16, 19, 14, 10], [10, 14, 8, 2], [15, 9, 13, 18], [12, 15, 21, 20], [6, 12, 16, 10], [3, 6, 2, 0], [9, 3, 1, 7], [9, 15, 12, 6, 3], [22, 17, 11, 5, 4, 8, 14, 19, 23, 24]]
                };
                var data = polyhedra[this.type];
                /**transform data has XYZ*/
                for (var _i = 0, _a = data.vertex; _i < _a.length; _i++) {
                    var ve = _a[_i];
                    this.mamesh.newVertex(new mathis.XYZ(ve[0], ve[1], ve[2]));
                }
                /**centering data if necessary*/
                if (data.notYetCentered) {
                    var bary = new mathis.XYZ(0, 0, 0);
                    var vertex = null;
                    for (var _b = 0, _c = this.mamesh.vertices; _b < _c.length; _b++) {
                        vertex = _c[_b];
                        bary.add(vertex.position);
                    }
                    bary.scale(1 / this.mamesh.vertices.length);
                    for (var _d = 0, _e = this.mamesh.vertices; _d < _e.length; _d++) {
                        vertex = _e[_d];
                        vertex.position.substract(bary);
                    }
                }
                /**scaling in oder that the max position norm is 1*/
                var maxNorm = Number.MIN_VALUE;
                for (var _f = 0, _g = this.mamesh.vertices; _f < _g.length; _f++) {
                    var vertex = _g[_f];
                    var norm = vertex.position.length();
                    if (norm > maxNorm)
                        maxNorm = norm;
                }
                for (var _h = 0, _j = this.mamesh.vertices; _h < _j.length; _h++) {
                    var vertex = _j[_h];
                    vertex.position.scale(1 / maxNorm);
                }
                var oneOverFive = 1 / 5;
                for (var _k = 0, _l = data.face; _k < _l.length; _k++) {
                    var face = _l[_k];
                    if (face.length == 3)
                        this.mamesh.addATriangle(this.mamesh.vertices[face[0]], this.mamesh.vertices[face[1]], this.mamesh.vertices[face[2]]);
                    else if (face.length == 4)
                        this.mamesh.addASquare(this.mamesh.vertices[face[0]], this.mamesh.vertices[face[1]], this.mamesh.vertices[face[2]], this.mamesh.vertices[face[3]]);
                    else if (face.length == 5) {
                        var centerVertex = this.mamesh.newVertex(new mathis.XYZ(0, 0, 0));
                        centerVertex.markers.push(mathis.Vertex.Markers.polygonCenter);
                        var v = [this.mamesh.vertices[face[0]], this.mamesh.vertices[face[1]], this.mamesh.vertices[face[2]], this.mamesh.vertices[face[3]], this.mamesh.vertices[face[4]]];
                        mathis.geo.baryCenter([v[0].position, v[1].position, v[2].position, v[3].position, v[4].position], [oneOverFive, oneOverFive, oneOverFive, oneOverFive, oneOverFive], centerVertex.position);
                        for (var i = 0; i < 5; i++)
                            this.mamesh.addATriangle(v[i], v[(i + 1) % 5], centerVertex);
                    }
                }
                if (this.makeLinks) {
                    new mathis.linkModule.LinkCreaterSorterAndBorderDetecterByPolygons(this.mamesh).goChanging();
                }
                return this.mamesh;
            };
            return Polyhedron;
        }());
        creation3D.Polyhedron = Polyhedron;
        var Snake = (function () {
            function Snake(mathisFrame) {
                //headPosition=new XYZ(0,0,0)
                this.maxLength = 500;
                this.curentLength = 0;
                this.serpentRadius = 0.03;
                this.path = [];
                this.sliceInsteadOfElongateWhenMaxLengthIsReached = true;
                this.initialPosition = new mathis.XYZ(0, 0, 0);
                this.mathisFrame = mathisFrame;
            }
            Snake.prototype.go = function () {
                for (var i = 0; i < this.maxLength; i++)
                    this.path.push(this.initialPosition);
                this.serpentMesh = BABYLON.Mesh.CreateTube('', this.path, this.serpentRadius, 10, null, BABYLON.Mesh.CAP_ALL, this.mathisFrame.scene, true);
                var green = new BABYLON.StandardMaterial('', this.mathisFrame.scene);
                green.diffuseColor = mathis.myFavoriteColors.green;
                this.serpentMesh.material = green;
                this.headSerpent = BABYLON.Mesh.CreateSphere('', 10, this.serpentRadius * 2.5, this.mathisFrame.scene);
                var red = new BABYLON.StandardMaterial('', this.mathisFrame.scene);
                red.diffuseColor = new BABYLON.Color3(1, 0, 0);
                this.headSerpent.material = red;
                this.headSerpent.position.copyFrom(this.initialPosition);
            };
            Snake.prototype.contractInOnePoint = function (point) {
                for (var i = 0; i < this.maxLength; i++)
                    this.path[i] = point;
                this.curentLength = 0;
                this.updateMeshes();
            };
            Snake.prototype.elongateTo = function (point) {
                if (this.curentLength < this.maxLength) {
                    for (var i = this.curentLength; i < this.maxLength; i++)
                        this.path[i] = point;
                    this.curentLength++;
                    this.updateMeshes();
                }
                else if (this.sliceInsteadOfElongateWhenMaxLengthIsReached)
                    this.bobySliceTo(point);
                else
                    throw "snake reaches his maximal length";
            };
            Snake.prototype.bobySliceTo = function (point) {
                this.path.splice(0, 1);
                this.path.push(point);
                this.updateMeshes();
            };
            Snake.prototype.updateMeshes = function () {
                /** modification des positions du serpent */
                this.serpentMesh = BABYLON.Mesh.CreateTube('', this.path, this.serpentRadius, null, null, null, null, true, null, this.serpentMesh);
                this.headSerpent.position = this.getHeadPosition();
            };
            // snakeMoveTo(point:XYZ){
            //     this.curentLength++
            //
            //     if (this.curentLength<this.maxLength) {
            //         for (let i = this.curentLength; i < this.maxLength; i++) this.path[i] = point
            //     }
            //     else{
            //         this.path.splice(0,1)
            //         this.path.push(point)
            //     }
            //     /** modification des positions du serpent */
            //     this.serpentMesh = BABYLON.Mesh.CreateTube('', this.path, this.serpentRadius, null, null, null, null, true, null, this.serpentMesh)
            //     this.headSerpent.position=point
            //    
            // }
            Snake.prototype.getHeadPosition = function () {
                return this.path[this.path.length - 1];
            };
            return Snake;
        }());
        creation3D.Snake = Snake;
        var ArrowCreator = (function () {
            function ArrowCreator(scene) {
                /**as all model, length are 1, and then can be scale to e.g. maug when we use this model*/
                this.totalHeight = 1;
                this.bodyProp = 3 / 4;
                this.headProp = 1 / 4;
                this.bodyDiameterProp = 0.1;
                this.headDiameterProp = 0.2;
                this.headUp = true;
                this.arrowFootAtOrigin = true;
                this.quaternion = null;
                this.subdivision = 6;
                this.scene = scene;
            }
            ArrowCreator.prototype.go = function () {
                var bodyHeight = this.bodyProp * this.totalHeight;
                var headHeight = this.headProp * this.totalHeight;
                var body = BABYLON.Mesh.CreateCylinder('', bodyHeight, this.bodyDiameterProp * this.totalHeight, this.bodyDiameterProp * this.totalHeight, this.subdivision, null, this.scene);
                body.position = new mathis.XYZ(0, bodyHeight / 2, 0);
                var head = BABYLON.Mesh.CreateCylinder('', headHeight, 0, this.headDiameterProp * this.totalHeight, this.subdivision, null, this.scene);
                head.position = new mathis.XYZ(0, bodyHeight + headHeight / 2, 0);
                var arrow = BABYLON.Mesh.MergeMeshes([body, head]);
                /**we decay before rotating*/
                if (!this.arrowFootAtOrigin) {
                    arrow.position.addInPlace(new mathis.XYZ(0, -this.totalHeight / 2, 0));
                    arrow.bakeCurrentTransformIntoVertices();
                }
                var quat = new mathis.XYZW(0, 0, 0, 1);
                if (!this.headUp)
                    mathis.geo.axisAngleToQuaternion(new mathis.XYZ(1, 0, 0), Math.PI, quat);
                if (this.quaternion != null)
                    quat.multiply(this.quaternion);
                arrow.rotationQuaternion = quat;
                arrow.bakeCurrentTransformIntoVertices();
                if (this.color != null) {
                    var material = new BABYLON.StandardMaterial('', this.scene);
                    material.diffuseColor = this.color.toBABYLON_Color3();
                    arrow.material = material;
                }
                return arrow;
            };
            return ArrowCreator;
        }());
        creation3D.ArrowCreator = ArrowCreator;
        var TwoOrThreeAxisMerged = (function () {
            function TwoOrThreeAxisMerged(scene) {
                this.scene = scene;
                this.twoOrThreeAxis = new TwoOrTreeAxis(this.scene);
            }
            TwoOrThreeAxisMerged.prototype.go = function () {
                this.twoOrThreeAxis.addColor = false;
                var xyzAxis = this.twoOrThreeAxis.go();
                var three = BABYLON.Mesh.MergeMeshes(xyzAxis);
                var x_nbIndices = xyzAxis[0].getTotalIndices();
                var y_nbIndices = xyzAxis[1].getTotalIndices();
                var z_nbIndices = xyzAxis[2].getTotalIndices();
                var mat0 = new BABYLON.StandardMaterial('', this.scene);
                mat0.diffuseColor = new BABYLON.Color3(1, 0, 0);
                var mat1 = new BABYLON.StandardMaterial('', this.scene);
                mat1.diffuseColor = new BABYLON.Color3(0, 1, 0);
                var mat2 = new BABYLON.StandardMaterial('', this.scene);
                mat2.diffuseColor = new BABYLON.Color3(0, 0, 1);
                var nbVertices = three.getTotalVertices();
                three.subMeshes = [];
                three.subMeshes.push(new BABYLON.SubMesh(0, 0, nbVertices, 0, x_nbIndices, three));
                three.subMeshes.push(new BABYLON.SubMesh(1, 0, nbVertices, x_nbIndices, y_nbIndices, three));
                three.subMeshes.push(new BABYLON.SubMesh(2, 0, nbVertices, x_nbIndices + y_nbIndices, z_nbIndices, three));
                var multimat = new BABYLON.MultiMaterial("multi", this.scene);
                multimat.subMaterials.push(mat0);
                multimat.subMaterials.push(mat1);
                multimat.subMaterials.push(mat2);
                three.material = multimat;
                return three;
            };
            return TwoOrThreeAxisMerged;
        }());
        creation3D.TwoOrThreeAxisMerged = TwoOrThreeAxisMerged;
        var TwoOrTreeAxis = (function () {
            function TwoOrTreeAxis(scene) {
                this.isLeftHandSided = true;
                this.addColor = true;
                this.threeVersusTwoAxis = true;
                this.addLabelsXYZ = false;
                this.scene = scene;
                this.SUB_x_axisCreator = new ArrowCreator(this.scene);
                this.SUB_y_axisCreator = new ArrowCreator(this.scene);
                this.SUB_z_axisCreator = new ArrowCreator(this.scene);
            }
            TwoOrTreeAxis.prototype.go = function () {
                if (this.addColor) {
                    this.SUB_x_axisCreator.color = new mathis.Color(mathis.Color.names.red);
                    this.SUB_y_axisCreator.color = new mathis.Color(mathis.Color.names.green);
                    this.SUB_z_axisCreator.color = new mathis.Color(mathis.Color.names.blue);
                }
                var flags = [];
                if (this.addLabelsXYZ) {
                    var x_flagCreator = new creation3D.FlagWithText(this.scene);
                    x_flagCreator.text = "x";
                    var x_flag = x_flagCreator.go();
                    x_flag.position = new mathis.XYZ(1.1, 0, 0);
                    flags.push(x_flag);
                    var y_flagCreator = new creation3D.FlagWithText(this.scene);
                    y_flagCreator.text = "y";
                    var y_flag = y_flagCreator.go();
                    y_flag.position = new mathis.XYZ(0, 1.15, 0);
                    flags.push(y_flag);
                    var z_flagCreator = new creation3D.FlagWithText(this.scene);
                    z_flagCreator.text = "z";
                    var z_flag = z_flagCreator.go();
                    z_flag.position = new mathis.XYZ(0, 0.1, 1);
                    flags.push(z_flag);
                }
                var yMesh = this.SUB_y_axisCreator.go();
                yMesh.bakeCurrentTransformIntoVertices();
                var xMesh = this.SUB_x_axisCreator.go();
                mathis.geo.axisAngleToQuaternion(new mathis.XYZ(0, 0, 1), -Math.PI / 2, xMesh.rotationQuaternion);
                xMesh.bakeCurrentTransformIntoVertices();
                if (this.threeVersusTwoAxis) {
                    var zMesh = this.SUB_z_axisCreator.go();
                    var angle = (this.isLeftHandSided) ? Math.PI / 2 : -Math.PI / 2;
                    mathis.geo.axisAngleToQuaternion(new mathis.XYZ(1, 0, 0), angle, zMesh.rotationQuaternion);
                    zMesh.bakeCurrentTransformIntoVertices();
                    return [xMesh, yMesh, zMesh].concat(flags);
                }
                else
                    return [xMesh, yMesh].concat(flags);
            };
            return TwoOrTreeAxis;
        }());
        creation3D.TwoOrTreeAxis = TwoOrTreeAxis;
        var FlagWithText = (function () {
            function FlagWithText(scene) {
                this.text = "TOTO";
                this.font = "bold 140px verdana";
                this.color = "black";
                this.backgroundColor = "transparent";
                this.scene = scene;
            }
            FlagWithText.prototype.go = function () {
                var textPlaneTexture = new BABYLON.DynamicTexture("dynamic texture", 512, this.scene, true);
                textPlaneTexture.drawText(this.text, null, 300, this.font, this.color, this.backgroundColor);
                textPlaneTexture.hasAlpha = true;
                var textPlane = BABYLON.Mesh.CreatePlane("textPlane", 1, this.scene, false);
                //textPlane.billboardMode = BABYLON.AbstractMesh.BILLBOARDMODE_ALL;
                //textPlane.position = new BABYLON.Vector3(0, 2, 0);
                var material = new BABYLON.StandardMaterial("textPlane", this.scene);
                material.diffuseTexture = textPlaneTexture;
                material.specularColor = new BABYLON.Color3(0, 0, 0);
                material.emissiveColor = new BABYLON.Color3(1, 1, 1);
                material.backFaceCulling = false;
                textPlane.material = material;
                return textPlane;
            };
            return FlagWithText;
        }());
        creation3D.FlagWithText = FlagWithText;
    })(creation3D = mathis.creation3D || (mathis.creation3D = {}));
})(mathis || (mathis = {}));
/**
 * Created by vigon on 05/12/2016.
 */
var mathis;
(function (mathis) {
    var debug;
    (function (debug) {
        function verticesToString(vertices) {
            var tab = [];
            for (var _i = 0, vertices_2 = vertices; _i < vertices_2.length; _i++) {
                var v = vertices_2[_i];
                tab.push(v.hashNumber);
            }
            return JSON.stringify(tab.sort());
        }
        debug.verticesToString = verticesToString;
        function verticesFamilyToString(verticesFamily) {
            var tableau = [];
            for (var _i = 0, verticesFamily_1 = verticesFamily; _i < verticesFamily_1.length; _i++) {
                var fam = verticesFamily_1[_i];
                var a = [];
                for (var _a = 0, fam_1 = fam; _a < fam_1.length; _a++) {
                    var v = fam_1[_a];
                    a.push(v.hashNumber);
                }
                tableau.push(mathis.tab.indicesUpPermutationToString(a));
            }
            return JSON.stringify(tableau.sort());
        }
        debug.verticesFamilyToString = verticesFamilyToString;
        function objToString(array) {
            var res = '';
            for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
                var xyz = array_1[_i];
                res += xyz.toString();
            }
            return res;
        }
        debug.objToString = objToString;
        /**pour des tests uniquement*/
        function checkTheRegularityOfAGraph(vertices) {
            for (var _i = 0, vertices_3 = vertices; _i < vertices_3.length; _i++) {
                var central = vertices_3[_i];
                var link = null;
                for (var _a = 0, _b = central.links; _a < _b.length; _a++) {
                    link = _b[_a];
                    if (!link.to.hasVoisin(central))
                        throw "neighborhood relation is not reflexive. The vertex:" + central.toString(0) + "\n has a link which gos to:" + link.to.toString(0) +
                            "\n but no link in the other direction. A possible cause: you vertices is only a part of a graph";
                    if (link.opposites != null) {
                        for (var _c = 0, _d = link.opposites; _c < _d.length; _c++) {
                            var op = _d[_c];
                            if (central.links.indexOf(op) == -1)
                                throw "a link attached to a vertex has an opposite link which is not attached of this vertex \n " +
                                    "problem takes place at vertex:" + central.toString(0)
                                    + "\n link going to:" + link.to.toString(0)
                                    + "\n opposite link going to:" + op.to.toString(0);
                            if (op.opposites.indexOf(link) == -1)
                                throw "opposite of  opposite do not give the same link";
                        }
                    }
                }
            }
        }
        debug.checkTheRegularityOfAGraph = checkTheRegularityOfAGraph;
    })(debug = mathis.debug || (mathis.debug = {}));
})(mathis || (mathis = {}));
var mathis;
(function (mathis) {
    /**
     * charte :
     * 1/ les argument d' entr ne doivent pas tre modifi, (sauf si ils sont mis aussi en sortie)
     * 2/ les sorties ne doivent tre affect qu' une fois termine la lecture des arguments d' entre
     * Ainsi une mthode doSomething(in1,in2,out1,out2) peut-tre appele comme ceci doSomething(in1,in2,in1,in2)
     *
     * */
    var Geo = (function () {
        function Geo() {
            /**eg: for testing that a vector is not too small to be normalised */
            this.epsilon = 0.00000001;
            this.epsilonSquare = this.epsilon * this.epsilon;
            /**bigger epsilon. When testing almost equality after operation such inversing twice a matrix*/
            this.epsitlonForAlmostEquality = 0.000001;
            this._resultTransp = new mathis.MM();
            this.baryResult = new mathis.XYZ(0, 0, 0);
            this._scaled = new mathis.XYZ(0, 0, 0);
            this._matUn = new mathis.MM();
            this._source = new mathis.XYZ(0, 0, 0);
            this._axis = new mathis.XYZ(0, 0, 0);
            this._ortBasisV1 = new mathis.XYZ(0, 0, 0);
            this._ortBasisV2 = new mathis.XYZ(0, 0, 0);
            this._ortBasisV3 = new mathis.XYZ(0, 0, 0);
            this._ortBasisAll = new mathis.MM();
            this._basisOrtho0 = new mathis.XYZ(0, 0, 0);
            this._basisOrtho1 = new mathis.XYZ(0, 0, 0);
            this._basisOrtho2 = new mathis.XYZ(0, 0, 0);
            this._basisMatrix = new mathis.MM();
            this._transposedBasisMatrix = new mathis.MM();
            this._diagoMatrix = new mathis.MM();
            /**a and b must be orthogonal
             * c and d must be orthogonal*/
            //private tempVa=new XYZ(0,0,0)
            //private tempVb=new XYZ(0,0,0)
            //private tempVc=new XYZ(0,0,0)
            //private tempVd=new XYZ(0,0,0)
            //private tempVbb=new XYZ(0,0,0)
            //private tempMatrix1=new MM()
            //private cross1=new XYZ(0,0,0)
            //private cross2=new XYZ(0,0,0)
            //
            //private quaternion1=new XYZW(0,0,0,0)
            //private quaternion2=new XYZW(0,0,0,0)
            //
            //aQuaternionMovingABtoCD(a:XYZ,b:XYZ,c:XYZ,d:XYZ,result:XYZW):void{
            //    /**saving, and normalising*/
            //    this.tempVa.copyFrom(a).normalize();
            //    this.tempVb.copyFrom(b).normalize();
            //    this.tempVc.copyFrom(c).normalize();
            //    this.tempVd.copyFrom(d).normalize();
            //
            //    /**first rotation*/
            //    this.cross(this.tempVa,this.tempVc,this.cross1)
            //    var angle1=this.angleBetweenTwoVectorsBetween0andPi(a,b) //Math.acos(this.dot(a, c))
            //    this.axisAngleToQuaternion(this.cross1,angle1,this.quaternion1)
            //    this.axisAngleToMatrix(this.cross1,angle1,this.tempMatrix1)
            //
            //    /**we have to transform tempVb */
            //    this.multiplicationMatrixVector(this.tempMatrix1,this.tempVb,this.tempVbb)
            //
            //    /**second rotation*/
            //    this.cross(this.tempVbb,this.tempVd,this.cross2)
            //    var angle2=Math.acos(this.dot(this.tempVbb,this.tempVd))
            //    this.axisAngleToQuaternion(this.cross2,angle2,this.quaternion2)
            //
            //    this.quaternionMultiplication(this.quaternion1,this.quaternion2,result)
            //
            //
            //}
            this.matt1 = new mathis.MM();
            this.matt2 = new mathis.MM();
            this.oor1 = new mathis.XYZ(0, 0, 0);
            this.oor2 = new mathis.XYZ(0, 0, 0);
            this.copA = new mathis.XYZ(0, 0, 0);
            this.copB = new mathis.XYZ(0, 0, 0);
            this.copC = new mathis.XYZ(0, 0, 0);
            this.copD = new mathis.XYZ(0, 0, 0);
            this.matBefore = new mathis.MM();
            this.v1nor = new mathis.XYZ(0, 0, 0);
            this.v2nor = new mathis.XYZ(0, 0, 0);
            this._aCros = new mathis.XYZ(0, 0, 0);
            this._quat0 = new mathis.XYZW(0, 0, 0, 0);
            this._quat1 = new mathis.XYZW(0, 0, 0, 0);
            this._quatAlpha = new mathis.XYZW(0, 0, 0, 0);
            this._mat0 = new mathis.MM();
            this._mat1 = new mathis.MM();
            this._matAlpha = new mathis.MM();
            this._c0 = new mathis.XYZ(0, 0, 0);
            this._c1 = new mathis.XYZ(0, 0, 0);
            this._crossResult = new mathis.XYZ(0, 0, 0);
            this.v1forSubstraction = new mathis.XYZ(0, 0, 0);
            this.randV2 = new mathis.XYZ(0, 0, 0);
            this._result1 = new mathis.XYZ(0, 0, 0);
            this._result2 = new mathis.XYZ(0, 0, 0);
            /**a tester : il doit y avoir une erreur quand sphereCenter!=(0,0,0)*/
            this.spheCentToRayOri = new mathis.XYZ(0, 0, 0);
            this._resultInters = new mathis.XYZ(0, 0, 0);
            this.difference = new mathis.XYZ(0, 0, 0);
            this._xAxis = mathis.XYZ.newZero();
            this._yAxis = mathis.XYZ.newZero();
            this._zAxis = mathis.XYZ.newZero();
        }
        Geo.prototype.copyXYZ = function (original, result) {
            result.x = original.x;
            result.y = original.y;
            result.z = original.z;
            return result;
        };
        Geo.prototype.copyXyzFromFloat = function (x, y, z, result) {
            result.x = x;
            result.y = y;
            result.z = z;
            return result;
        };
        Geo.prototype.copyMat = function (original, result) {
            for (var i = 0; i < 16; i++)
                result.m[i] = original.m[i];
            return result;
        };
        Geo.prototype.matEquality = function (mat1, mat2) {
            for (var i = 0; i < 16; i++) {
                if (mat1.m[i] != mat2.m[i])
                    return false;
            }
            return true;
        };
        Geo.prototype.matAlmostEquality = function (mat1, mat2) {
            for (var i = 0; i < 16; i++) {
                if (!this.almostEquality(mat1.m[i], mat2.m[i]))
                    return false;
            }
            return true;
        };
        Geo.prototype.xyzEquality = function (vec1, vec2) {
            return vec1.x == vec2.x && vec1.y == vec2.y && vec1.z == vec2.z;
        };
        Geo.prototype.xyzAlmostEquality = function (vec1, vec2) {
            return Math.abs(vec1.x - vec2.x) < this.epsitlonForAlmostEquality && Math.abs(vec1.y - vec2.y) < this.epsitlonForAlmostEquality && Math.abs(vec1.z - vec2.z) < this.epsitlonForAlmostEquality;
        };
        Geo.prototype.xyzwAlmostEquality = function (vec1, vec2) {
            return Math.abs(vec1.x - vec2.x) < this.epsitlonForAlmostEquality && Math.abs(vec1.y - vec2.y) < this.epsitlonForAlmostEquality && Math.abs(vec1.z - vec2.z) < this.epsitlonForAlmostEquality && Math.abs(vec1.w - vec2.w) < this.epsitlonForAlmostEquality;
        };
        Geo.prototype.almostLogicalEqual = function (quat1, quat2) {
            return mathis.geo.xyzwAlmostEquality(quat1, quat2) ||
                (mathis.geo.almostEquality(quat1.x, -quat2.x) && mathis.geo.almostEquality(quat1.y, -quat2.y) && mathis.geo.almostEquality(quat1.z, -quat2.z) && mathis.geo.almostEquality(quat1.w, -quat2.w));
        };
        Geo.prototype.xyzAlmostZero = function (vec) {
            return Math.abs(vec.x) < this.epsilon && Math.abs(vec.y) < this.epsilon && Math.abs(vec.z) < this.epsilon;
        };
        Geo.prototype.almostEquality = function (a, b) {
            return Math.abs(b - a) < this.epsitlonForAlmostEquality;
        };
        Geo.prototype.inverse = function (m1, result) {
            var l1 = m1.m[0];
            var l2 = m1.m[1];
            var l3 = m1.m[2];
            var l4 = m1.m[3];
            var l5 = m1.m[4];
            var l6 = m1.m[5];
            var l7 = m1.m[6];
            var l8 = m1.m[7];
            var l9 = m1.m[8];
            var l10 = m1.m[9];
            var l11 = m1.m[10];
            var l12 = m1.m[11];
            var l13 = m1.m[12];
            var l14 = m1.m[13];
            var l15 = m1.m[14];
            var l16 = m1.m[15];
            var l17 = (l11 * l16) - (l12 * l15);
            var l18 = (l10 * l16) - (l12 * l14);
            var l19 = (l10 * l15) - (l11 * l14);
            var l20 = (l9 * l16) - (l12 * l13);
            var l21 = (l9 * l15) - (l11 * l13);
            var l22 = (l9 * l14) - (l10 * l13);
            var l23 = ((l6 * l17) - (l7 * l18)) + (l8 * l19);
            var l24 = -(((l5 * l17) - (l7 * l20)) + (l8 * l21));
            var l25 = ((l5 * l18) - (l6 * l20)) + (l8 * l22);
            var l26 = -(((l5 * l19) - (l6 * l21)) + (l7 * l22));
            var l27 = 1.0 / ((((l1 * l23) + (l2 * l24)) + (l3 * l25)) + (l4 * l26));
            var l28 = (l7 * l16) - (l8 * l15);
            var l29 = (l6 * l16) - (l8 * l14);
            var l30 = (l6 * l15) - (l7 * l14);
            var l31 = (l5 * l16) - (l8 * l13);
            var l32 = (l5 * l15) - (l7 * l13);
            var l33 = (l5 * l14) - (l6 * l13);
            var l34 = (l7 * l12) - (l8 * l11);
            var l35 = (l6 * l12) - (l8 * l10);
            var l36 = (l6 * l11) - (l7 * l10);
            var l37 = (l5 * l12) - (l8 * l9);
            var l38 = (l5 * l11) - (l7 * l9);
            var l39 = (l5 * l10) - (l6 * l9);
            result.m[0] = l23 * l27;
            result.m[4] = l24 * l27;
            result.m[8] = l25 * l27;
            result.m[12] = l26 * l27;
            result.m[1] = -(((l2 * l17) - (l3 * l18)) + (l4 * l19)) * l27;
            result.m[5] = (((l1 * l17) - (l3 * l20)) + (l4 * l21)) * l27;
            result.m[9] = -(((l1 * l18) - (l2 * l20)) + (l4 * l22)) * l27;
            result.m[13] = (((l1 * l19) - (l2 * l21)) + (l3 * l22)) * l27;
            result.m[2] = (((l2 * l28) - (l3 * l29)) + (l4 * l30)) * l27;
            result.m[6] = -(((l1 * l28) - (l3 * l31)) + (l4 * l32)) * l27;
            result.m[10] = (((l1 * l29) - (l2 * l31)) + (l4 * l33)) * l27;
            result.m[14] = -(((l1 * l30) - (l2 * l32)) + (l3 * l33)) * l27;
            result.m[3] = -(((l2 * l34) - (l3 * l35)) + (l4 * l36)) * l27;
            result.m[7] = (((l1 * l34) - (l3 * l37)) + (l4 * l38)) * l27;
            result.m[11] = -(((l1 * l35) - (l2 * l37)) + (l4 * l39)) * l27;
            result.m[15] = (((l1 * l36) - (l2 * l38)) + (l3 * l39)) * l27;
        };
        Geo.prototype.transpose = function (matrix, result) {
            this._resultTransp.m[0] = matrix.m[0];
            this._resultTransp.m[1] = matrix.m[4];
            this._resultTransp.m[2] = matrix.m[8];
            this._resultTransp.m[3] = matrix.m[12];
            this._resultTransp.m[4] = matrix.m[1];
            this._resultTransp.m[5] = matrix.m[5];
            this._resultTransp.m[6] = matrix.m[9];
            this._resultTransp.m[7] = matrix.m[13];
            this._resultTransp.m[8] = matrix.m[2];
            this._resultTransp.m[9] = matrix.m[6];
            this._resultTransp.m[10] = matrix.m[10];
            this._resultTransp.m[11] = matrix.m[14];
            this._resultTransp.m[12] = matrix.m[3];
            this._resultTransp.m[13] = matrix.m[7];
            this._resultTransp.m[14] = matrix.m[11];
            this._resultTransp.m[15] = matrix.m[15];
            mathis.geo.copyMat(this._resultTransp, result);
        };
        Geo.prototype.multiplyMatMat = function (m1, other, result) {
            var tm0 = m1.m[0];
            var tm1 = m1.m[1];
            var tm2 = m1.m[2];
            var tm3 = m1.m[3];
            var tm4 = m1.m[4];
            var tm5 = m1.m[5];
            var tm6 = m1.m[6];
            var tm7 = m1.m[7];
            var tm8 = m1.m[8];
            var tm9 = m1.m[9];
            var tm10 = m1.m[10];
            var tm11 = m1.m[11];
            var tm12 = m1.m[12];
            var tm13 = m1.m[13];
            var tm14 = m1.m[14];
            var tm15 = m1.m[15];
            var om0 = other.m[0];
            var om1 = other.m[1];
            var om2 = other.m[2];
            var om3 = other.m[3];
            var om4 = other.m[4];
            var om5 = other.m[5];
            var om6 = other.m[6];
            var om7 = other.m[7];
            var om8 = other.m[8];
            var om9 = other.m[9];
            var om10 = other.m[10];
            var om11 = other.m[11];
            var om12 = other.m[12];
            var om13 = other.m[13];
            var om14 = other.m[14];
            var om15 = other.m[15];
            result.m[0] = tm0 * om0 + tm1 * om4 + tm2 * om8 + tm3 * om12;
            result.m[1] = tm0 * om1 + tm1 * om5 + tm2 * om9 + tm3 * om13;
            result.m[2] = tm0 * om2 + tm1 * om6 + tm2 * om10 + tm3 * om14;
            result.m[3] = tm0 * om3 + tm1 * om7 + tm2 * om11 + tm3 * om15;
            result.m[4] = tm4 * om0 + tm5 * om4 + tm6 * om8 + tm7 * om12;
            result.m[5] = tm4 * om1 + tm5 * om5 + tm6 * om9 + tm7 * om13;
            result.m[6] = tm4 * om2 + tm5 * om6 + tm6 * om10 + tm7 * om14;
            result.m[7] = tm4 * om3 + tm5 * om7 + tm6 * om11 + tm7 * om15;
            result.m[8] = tm8 * om0 + tm9 * om4 + tm10 * om8 + tm11 * om12;
            result.m[9] = tm8 * om1 + tm9 * om5 + tm10 * om9 + tm11 * om13;
            result.m[10] = tm8 * om2 + tm9 * om6 + tm10 * om10 + tm11 * om14;
            result.m[11] = tm8 * om3 + tm9 * om7 + tm10 * om11 + tm11 * om15;
            result.m[12] = tm12 * om0 + tm13 * om4 + tm14 * om8 + tm15 * om12;
            result.m[13] = tm12 * om1 + tm13 * om5 + tm14 * om9 + tm15 * om13;
            result.m[14] = tm12 * om2 + tm13 * om6 + tm14 * om10 + tm15 * om14;
            result.m[15] = tm12 * om3 + tm13 * om7 + tm14 * om11 + tm15 * om15;
        };
        Geo.prototype.baryCenter = function (xyzs, weights, result) {
            this.baryResult.x = 0;
            this.baryResult.y = 0;
            this.baryResult.z = 0;
            for (var i = 0; i < xyzs.length; i++) {
                mathis.geo.copyXYZ(xyzs[i], this._scaled);
                this.scale(this._scaled, weights[i], this._scaled);
                this.add(this.baryResult, this._scaled, this.baryResult);
            }
            mathis.geo.copyXYZ(this.baryResult, result);
        };
        //private betweenRes=new XYZ(0,0,0)
        Geo.prototype.between = function (v1, v2, alpha, res) {
            res.x = v1.x * (1 - alpha) + v2.x * alpha;
            res.y = v1.y * (1 - alpha) + v2.y * alpha;
            res.z = v1.z * (1 - alpha) + v2.z * alpha;
        };
        Geo.prototype.betweenUV = function (v1, v2, alpha, res) {
            res.u = v1.u * (1 - alpha) + v2.u * alpha;
            res.v = v1.v * (1 - alpha) + v2.v * alpha;
        };
        Geo.prototype.unproject = function (source, viewportWidth, viewportHeight, world, view, projection, result) {
            mathis.geo.copyXYZ(source, this._source);
            if (world != null) {
                this.multiplyMatMat(world, view, this._matUn);
                this.multiplyMatMat(this._matUn, projection, this._matUn);
            }
            else {
                this.multiplyMatMat(view, projection, this._matUn);
            }
            this.inverse(this._matUn, this._matUn);
            this._source.x = this._source.x / viewportWidth * 2 - 1;
            this._source.y = -(this._source.y / viewportHeight * 2 - 1);
            this.multiplicationMatrixVector(this._matUn, this._source, result);
            var num = source.x * this._matUn.m[3] + source.y * this._matUn.m[7] + source.z * this._matUn.m[11] + this._matUn.m[15];
            if (this.withinEpsilon(num, 1.0)) {
                this.scale(result, 1.0 / num, result);
            }
        };
        //public static Unproject(source: BABYLON.Vector3, viewportWidth: number, viewportHeight: number, world: BABYLON.Matrix, view: BABYLON.Matrix, projection: BABYLON.Matrix): BABYLON.Vector3 {
        //    var matrix = world.multiply(view).multiply(projection);
        //
        //
        //    matrix.invert();
        //
        //    source.x = source.x / viewportWidth * 2 - 1;
        //    source.y = -(source.y / viewportHeight * 2 - 1);
        //    var vector = BABYLON.Vector3.TransformCoordinates(source, matrix);
        //    var num = source.x * matrix.m[3] + source.y * matrix.m[7] + source.z * matrix.m[11] + matrix.m[15];
        //
        //
        //    console.log("vec",vector)
        //    if (BABYLON.Tools.WithinEpsilon(num, 1.0)) {
        //        vector = vector.scale(1.0 / num);
        //    }
        //    return vector;
        //}
        /**??? */
        Geo.prototype.withinEpsilon = function (a, b) {
            var num = a - b;
            return -1.401298E-45 <= num && num <= 1.401298E-45;
        };
        Geo.prototype.axisAngleToMatrix = function (axis, angle, result) {
            var s = Math.sin(-angle);
            var c = Math.cos(-angle);
            var c1 = 1 - c;
            mathis.geo.copyXYZ(axis, this._axis);
            this.normalize(this._axis, this._axis);
            result.m[0] = (this._axis.x * this._axis.x) * c1 + c;
            result.m[1] = (this._axis.x * this._axis.y) * c1 - (this._axis.z * s);
            result.m[2] = (this._axis.x * this._axis.z) * c1 + (this._axis.y * s);
            result.m[3] = 0.0;
            result.m[4] = (this._axis.y * this._axis.x) * c1 + (this._axis.z * s);
            result.m[5] = (this._axis.y * this._axis.y) * c1 + c;
            result.m[6] = (this._axis.y * this._axis.z) * c1 - (this._axis.x * s);
            result.m[7] = 0.0;
            result.m[8] = (this._axis.z * this._axis.x) * c1 - (this._axis.y * s);
            result.m[9] = (this._axis.z * this._axis.y) * c1 + (this._axis.x * s);
            result.m[10] = (this._axis.z * this._axis.z) * c1 + c;
            result.m[11] = 0.0;
            result.m[12] = 0.0;
            result.m[13] = 0.0;
            result.m[14] = 0.0;
            result.m[15] = 1.0;
        };
        Geo.prototype.multiplicationMatrixVector = function (transformation, vector, result) {
            var x = (vector.x * transformation.m[0]) + (vector.y * transformation.m[4]) + (vector.z * transformation.m[8]) + transformation.m[12];
            var y = (vector.x * transformation.m[1]) + (vector.y * transformation.m[5]) + (vector.z * transformation.m[9]) + transformation.m[13];
            var z = (vector.x * transformation.m[2]) + (vector.y * transformation.m[6]) + (vector.z * transformation.m[10]) + transformation.m[14];
            var w = (vector.x * transformation.m[3]) + (vector.y * transformation.m[7]) + (vector.z * transformation.m[11]) + transformation.m[15];
            result.x = x / w;
            result.y = y / w;
            result.z = z / w;
        };
        Geo.prototype.axisAngleToQuaternion = function (axis, angle, result) {
            var sin = Math.sin(angle / 2);
            result.w = Math.cos(angle / 2);
            result.x = axis.x * sin;
            result.y = axis.y * sin;
            result.z = axis.z * sin;
        };
        Geo.prototype.matrixToQuaternion = function (m, result) {
            //m=Matrix.Transpose(m);
            //attention, il y a une transposition cache
            var m00, m01, m02, m10, m11, m12, m20, m21, m22;
            m00 = m.m[0];
            m10 = m.m[1];
            m20 = m.m[2];
            m01 = m.m[4];
            m11 = m.m[5];
            m21 = m.m[6];
            m02 = m.m[8];
            m12 = m.m[9];
            m22 = m.m[10];
            var qx, qy, qz, qw;
            var tr = m00 + m11 + m22;
            if (tr > 0) {
                var S = Math.sqrt(tr + 1.0) * 2; // S=4*qw
                qw = 0.25 * S;
                qx = (m21 - m12) / S;
                qy = (m02 - m20) / S;
                qz = (m10 - m01) / S;
            }
            else if ((m00 > m11) && (m00 > m22)) {
                var S = Math.sqrt(1.0 + m00 - m11 - m22) * 2; // S=4*qx
                qw = (m21 - m12) / S;
                qx = 0.25 * S;
                qy = (m01 + m10) / S;
                qz = (m02 + m20) / S;
            }
            else if (m11 > m22) {
                var S = Math.sqrt(1.0 + m11 - m00 - m22) * 2; // S=4*qy
                qw = (m02 - m20) / S;
                qx = (m01 + m10) / S;
                qy = 0.25 * S;
                qz = (m12 + m21) / S;
            }
            else {
                var S = Math.sqrt(1.0 + m22 - m00 - m11) * 2; // S=4*qz
                qw = (m10 - m01) / S;
                qx = (m02 + m20) / S;
                qy = (m12 + m21) / S;
                qz = 0.25 * S;
            }
            result.x = qx;
            result.y = qy;
            result.z = qz;
            result.w = qw;
        };
        Geo.prototype.twoVectorsToQuaternion = function (v1, v2, firstIsPreserved, result) {
            if (firstIsPreserved) {
                mathis.geo.orthonormalizeKeepingFirstDirection(v1, v2, this._ortBasisV1, this._ortBasisV2);
            }
            else {
                mathis.geo.orthonormalizeKeepingFirstDirection(v2, v1, this._ortBasisV2, this._ortBasisV1);
            }
            mathis.geo.cross(this._ortBasisV1, this._ortBasisV2, this._ortBasisV3);
            mathis.geo.matrixFromLines(this._ortBasisV1, this._ortBasisV2, this._ortBasisV3, this._ortBasisAll);
            mathis.geo.matrixToQuaternion(this._ortBasisAll, result);
        };
        Geo.prototype.orthogonalProjectionOnLine = function (direction, result) {
            this.normalize(direction, this._basisOrtho0);
            this.getOneOrthonormal(direction, this._basisOrtho1);
            this.cross(this._basisOrtho0, this._basisOrtho1, this._basisOrtho2);
            this.matrixFromLines(this._basisOrtho0, this._basisOrtho1, this._basisOrtho2, this._basisMatrix);
            this.transpose(this._basisMatrix, this._transposedBasisMatrix);
            this._diagoMatrix.m[0] = 1;
            this._diagoMatrix.m[15] = 1;
            this.multiplyMatMat(this._transposedBasisMatrix, this._diagoMatrix, result);
            this.multiplyMatMat(result, this._basisMatrix, result);
        };
        Geo.prototype.orthogonalProjectionOnPlane = function (direction, otherDirection, result) {
            this.orthonormalizeKeepingFirstDirection(direction, otherDirection, this._basisOrtho0, this._basisOrtho1);
            //this.normalize(direction,this._basisOrtho0)
            //this.getOneOrthonormal(direction,this._basisOrtho1)
            this.cross(this._basisOrtho0, this._basisOrtho1, this._basisOrtho2);
            this.matrixFromLines(this._basisOrtho0, this._basisOrtho1, this._basisOrtho2, this._basisMatrix);
            this.transpose(this._basisMatrix, this._transposedBasisMatrix);
            this._diagoMatrix.m[0] = 1;
            this._diagoMatrix.m[5] = 1;
            this._diagoMatrix.m[15] = 1;
            this.multiplyMatMat(this._transposedBasisMatrix, this._diagoMatrix, result);
            this.multiplyMatMat(result, this._basisMatrix, result);
        };
        Geo.prototype.translationOnMatrix = function (vector3, result) {
            result.m[12] = vector3.x;
            result.m[13] = vector3.y;
            result.m[14] = vector3.z;
        };
        Geo.prototype.quaternionToMatrix = function (quaternion, result) {
            var xx = quaternion.x * quaternion.x;
            var yy = quaternion.y * quaternion.y;
            var zz = quaternion.z * quaternion.z;
            var xy = quaternion.x * quaternion.y;
            var zw = quaternion.z * quaternion.w;
            var zx = quaternion.z * quaternion.x;
            var yw = quaternion.y * quaternion.w;
            var yz = quaternion.y * quaternion.z;
            var xw = quaternion.x * quaternion.w;
            result.m[0] = 1.0 - (2.0 * (yy + zz));
            result.m[1] = 2.0 * (xy + zw);
            result.m[2] = 2.0 * (zx - yw);
            result.m[3] = 0;
            result.m[4] = 2.0 * (xy - zw);
            result.m[5] = 1.0 - (2.0 * (zz + xx));
            result.m[6] = 2.0 * (yz + xw);
            result.m[7] = 0;
            result.m[8] = 2.0 * (zx + yw);
            result.m[9] = 2.0 * (yz - xw);
            result.m[10] = 1.0 - (2.0 * (yy + xx));
            result.m[11] = 0;
            result.m[12] = 0;
            result.m[13] = 0;
            result.m[14] = 0;
            result.m[15] = 1.0;
        };
        Geo.prototype.quaternionMultiplication = function (q0, q1, result) {
            var x = q0.x * q1.w + q0.y * q1.z - q0.z * q1.y + q0.w * q1.x;
            var y = -q0.x * q1.z + q0.y * q1.w + q0.z * q1.x + q0.w * q1.y;
            var z = q0.x * q1.y - q0.y * q1.x + q0.z * q1.w + q0.w * q1.z;
            var w = -q0.x * q1.x - q0.y * q1.y - q0.z * q1.z + q0.w * q1.w;
            result.x = x;
            result.y = y;
            result.z = z;
            result.w = w;
        };
        Geo.prototype.anOrthogonalMatrixMovingABtoCD = function (a, b, c, d, result, argsAreOrthonormal) {
            if (argsAreOrthonormal === void 0) { argsAreOrthonormal = false; }
            if (argsAreOrthonormal) {
                this.copA.copyFrom(a);
                this.copB.copyFrom(b);
                this.copC.copyFrom(c);
                this.copD.copyFrom(d);
            }
            else {
                this.orthonormalizeKeepingFirstDirection(a, b, this.copA, this.copB);
                this.orthonormalizeKeepingFirstDirection(c, d, this.copC, this.copD);
            }
            this.cross(this.copA, this.copB, this.oor1);
            this.matrixFromLines(this.copA, this.copB, this.oor1, this.matt1);
            this.cross(this.copC, this.copD, this.oor2);
            this.matrixFromLines(this.copC, this.copD, this.oor2, this.matt2);
            this.transpose(this.matt1, this.matt1);
            this.multiplyMatMat(this.matt1, this.matt2, result);
        };
        Geo.prototype.aQuaternionMovingABtoCD = function (a, b, c, d, result, argsAreOrthonormal) {
            if (argsAreOrthonormal === void 0) { argsAreOrthonormal = false; }
            this.anOrthogonalMatrixMovingABtoCD(a, b, c, d, this.matBefore, argsAreOrthonormal);
            this.matrixToQuaternion(this.matBefore, result);
        };
        Geo.prototype.slerp = function (left, right, amount, result) {
            var num2;
            var num3;
            var num = amount;
            var num4 = (((left.x * right.x) + (left.y * right.y)) + (left.z * right.z)) + (left.w * right.w);
            var flag = false;
            if (num4 < 0) {
                flag = true;
                num4 = -num4;
            }
            if (num4 > 0.999999) {
                num3 = 1 - num;
                num2 = flag ? -num : num;
            }
            else {
                var num5 = Math.acos(num4);
                var num6 = (1.0 / Math.sin(num5));
                num3 = (Math.sin((1.0 - num) * num5)) * num6;
                num2 = flag ? ((-Math.sin(num * num5)) * num6) : ((Math.sin(num * num5)) * num6);
            }
            result.x = (num3 * left.x) + (num2 * right.x);
            result.y = (num3 * left.y) + (num2 * right.y);
            result.z = (num3 * left.z) + (num2 * right.z);
            result.w = (num3 * left.w) + (num2 * right.w);
        };
        Geo.prototype.matrixFromLines = function (line1, line2, line3, result) {
            result.m[0] = line1.x;
            result.m[1] = line1.y;
            result.m[2] = line1.z;
            result.m[3] = 0;
            result.m[4] = line2.x;
            result.m[5] = line2.y;
            result.m[6] = line2.z;
            result.m[7] = 0;
            result.m[8] = line3.x;
            result.m[9] = line3.y;
            result.m[10] = line3.z;
            result.m[11] = 0;
            result.m[12] = 0;
            result.m[13] = 0;
            result.m[14] = 0;
            result.m[15] = 1.0;
        };
        Geo.prototype.angleBetweenTwoVectorsBetween0andPi = function (v1, v2) {
            if (mathis.geo.xyzAlmostZero(v1) || mathis.geo.xyzAlmostZero(v2)) {
                throw 'be aware: you compute angle between two vectors, one of them being almost zero';
            }
            this.normalize(v1, this.v1nor);
            this.normalize(v2, this.v2nor);
            var dotProduct = this.dot(this.v1nor, this.v2nor);
            /**because normalisations can be imperfect*/
            if (dotProduct > 1)
                return 0;
            if (dotProduct < -1)
                return Math.PI; //we see here that this is not realy an angle modulo PI
            else
                return Math.acos(dotProduct);
        };
        Geo.prototype.almostParallel = function (v1, v2, oppositeAreParallel, toleranceAngle) {
            if (oppositeAreParallel === void 0) { oppositeAreParallel = true; }
            if (toleranceAngle === void 0) { toleranceAngle = 0.001; }
            var angle = this.angleBetweenTwoVectorsBetween0andPi(v1, v2);
            if (angle < toleranceAngle)
                return true;
            if (oppositeAreParallel && Math.PI - angle < toleranceAngle)
                return true;
            return false;
        };
        Geo.prototype.angleBetweenTwoVectorsBetweenMinusPiAndPi = function (v1, v2, upDirection) {
            var angle = this.angleBetweenTwoVectorsBetween0andPi(v1, v2);
            mathis.geo.cross(v1, v2, this._aCros);
            var sign = (mathis.geo.dot(upDirection, this._aCros) < 0) ? -1 : 1;
            return sign * angle;
        };
        Geo.prototype.slerpTwoOrthogonalVectors = function (a0, b0, a1, b1, alpha, aAlpha, bAlpha) {
            this.cross(a0, b0, this._c0);
            this.cross(a1, b1, this._c1);
            this.matrixFromLines(a0, b0, this._c0, this._mat0);
            this.matrixFromLines(a1, b1, this._c1, this._mat1);
            this.matrixToQuaternion(this._mat0, this._quat0);
            this.matrixToQuaternion(this._mat1, this._quat1);
            this.slerp(this._quat0, this._quat1, alpha, this._quatAlpha);
            this.quaternionToMatrix(this._quatAlpha, this._matAlpha);
            mathis.geo.copyXyzFromFloat(this._matAlpha.m[0], this._matAlpha.m[1], this._matAlpha.m[2], aAlpha);
            mathis.geo.copyXyzFromFloat(this._matAlpha.m[4], this._matAlpha.m[5], this._matAlpha.m[7], bAlpha);
        };
        Geo.prototype.interpolateTwoVectors = function (a0, a1, alpha, aAlpha) {
            aAlpha.x = a0.x * (1 - alpha) + a1.x * alpha;
            aAlpha.y = a0.y * (1 - alpha) + a1.y * alpha;
            aAlpha.z = a0.z * (1 - alpha) + a1.z * alpha;
        };
        Geo.prototype.scale = function (vec, scalar, result) {
            result.x = vec.x * scalar;
            result.y = vec.y * scalar;
            result.z = vec.z * scalar;
        };
        Geo.prototype.add = function (v1, v2, result) {
            result.x = v1.x + v2.x;
            result.y = v1.y + v2.y;
            result.z = v1.z + v2.z;
        };
        Geo.prototype.substract = function (v1, v2, result) {
            result.x = v1.x - v2.x;
            result.y = v1.y - v2.y;
            result.z = v1.z - v2.z;
        };
        Geo.prototype.dot = function (left, right) {
            return (left.x * right.x + left.y * right.y + left.z * right.z);
        };
        Geo.prototype.norme = function (vec) {
            return Math.sqrt(vec.x * vec.x + vec.y * vec.y + vec.z * vec.z);
        };
        Geo.prototype.squareNorme = function (vec) {
            return vec.x * vec.x + vec.y * vec.y + vec.z * vec.z;
        };
        Geo.prototype.cross = function (left, right, result) {
            this._crossResult.x = left.y * right.z - left.z * right.y;
            this._crossResult.y = left.z * right.x - left.x * right.z;
            this._crossResult.z = left.x * right.y - left.y * right.x;
            mathis.geo.copyXYZ(this._crossResult, result);
        };
        Geo.prototype.orthonormalizeKeepingFirstDirection = function (v1, v2, result1, result2) {
            this.normalize(v1, this._result1);
            mathis.geo.copyXYZ(v1, this.v1forSubstraction);
            this.scale(this.v1forSubstraction, this.dot(v1, v2), this.v1forSubstraction);
            this.substract(v2, this.v1forSubstraction, this._result2);
            if (this.squareNorme(this._result2) < mathis.geo.epsilon * mathis.geo.epsilon) {
                mathis.geo.copyXyzFromFloat(Math.random(), Math.random(), Math.random(), this.randV2);
                mathis.logger.c("beware: you try to orthonormalize two co-linear vectors");
                return this.orthonormalizeKeepingFirstDirection(v1, this.randV2, result1, result2);
            }
            this.normalize(this._result2, this._result2);
            mathis.geo.copyXYZ(this._result1, result1);
            mathis.geo.copyXYZ(this._result2, result2);
        };
        Geo.prototype.getOneOrthonormal = function (vec, result) {
            if (Math.abs(vec.x) + Math.abs(vec.y) > 0.0001)
                result.copyFromFloats(-vec.y, vec.x, 0);
            else
                result.copyFromFloats(0, -vec.z, vec.y);
            mathis.geo.normalize(result, result);
        };
        Geo.prototype.normalize = function (vec, result) {
            var norme = this.norme(vec);
            if (norme < mathis.geo.epsilon)
                throw "one can not normalize a the almost zero vector:" + vec;
            this.scale(vec, 1 / norme, result);
        };
        Geo.prototype.intersectionBetweenRayAndSphereFromRef = function (rayOrigine, rayDirection, aRadius, sphereCenter, result1, result2) {
            mathis.geo.copyXYZ(rayOrigine, this.spheCentToRayOri);
            this.substract(this.spheCentToRayOri, sphereCenter, this.spheCentToRayOri);
            var a = this.squareNorme(rayDirection);
            var b = 2 * this.dot(rayDirection, this.spheCentToRayOri);
            var c = this.squareNorme(this.spheCentToRayOri) - aRadius * aRadius;
            var discriminant = b * b - 4 * a * c;
            /**no solution, the ray do not touch*/
            if (discriminant < 0) {
                return false;
            }
            else {
                var t1 = (-b + Math.sqrt(discriminant)) / 2 / a;
                var t2 = (-b - Math.sqrt(discriminant)) / 2 / a;
                mathis.geo.copyXYZ(rayDirection, this._resultInters);
                this.scale(this._resultInters, t1, this._resultInters);
                this.add(this._resultInters, rayOrigine, this._resultInters);
                mathis.geo.copyXYZ(this._resultInters, result1);
                mathis.geo.copyXYZ(rayDirection, this._resultInters);
                this.scale(this._resultInters, t2, this._resultInters);
                this.add(this._resultInters, rayOrigine, this._resultInters);
                mathis.geo.copyXYZ(this._resultInters, result2);
                return true;
            }
        };
        Geo.prototype.distance = function (vect1, vect2) {
            this.copyXYZ(vect1, this.difference);
            this.substract(this.difference, vect2, this.difference);
            return this.norme(this.difference);
        };
        Geo.prototype.squaredDistance = function (vect1, vect2) {
            this.copyXYZ(vect1, this.difference);
            this.substract(this.difference, vect2, this.difference);
            return this.squareNorme(this.difference);
        };
        Geo.prototype.closerOf = function (candidat1, canditat2, reference, result) {
            var l1 = this.distance(candidat1, reference);
            var l2 = this.distance(canditat2, reference);
            if (l1 < l2)
                this.copyXYZ(candidat1, result);
            else
                this.copyXYZ(canditat2, result);
            return (l1 < l2) ? l1 : l2;
        };
        Geo.prototype.LookAtLH = function (eye, target, up, result) {
            // Z axis
            this.substract(target, eye, this._zAxis);
            //target.subtractToRef(eye, this._zAxis);
            this.normalize(this._zAxis, this._zAxis);
            //this._zAxis.normalize();
            // X axis
            this.cross(up, this._zAxis, this._xAxis);
            //Vector3.CrossToRef(up, this._zAxis, this._xAxis);
            if (mathis.geo.xyzAlmostZero(this._xAxis)) {
                this._xAxis.x = 1.0;
            }
            else {
                this._xAxis.normalize();
            }
            // Y axis
            this.cross(this._zAxis, this._xAxis, this._yAxis);
            this._yAxis.normalize();
            // Eye angles
            var ex = -this.dot(this._xAxis, eye);
            var ey = -this.dot(this._yAxis, eye);
            var ez = -this.dot(this._zAxis, eye);
            this.numbersToMM(this._xAxis.x, this._yAxis.x, this._zAxis.x, 0, this._xAxis.y, this._yAxis.y, this._zAxis.y, 0, this._xAxis.z, this._yAxis.z, this._zAxis.z, 0, ex, ey, ez, 1, result);
        };
        Geo.prototype.OrthoOffCenterLH = function (left, right, bottom, top, znear, zfar, result) {
            result.m[0] = 2.0 / (right - left);
            result.m[1] = result.m[2] = result.m[3] = 0;
            result.m[5] = 2.0 / (top - bottom);
            result.m[4] = result.m[6] = result.m[7] = 0;
            result.m[10] = -1.0 / (znear - zfar);
            result.m[8] = result.m[9] = result.m[11] = 0;
            result.m[12] = (left + right) / (left - right);
            result.m[13] = (top + bottom) / (bottom - top);
            result.m[14] = znear / (znear - zfar);
            result.m[15] = 1.0;
        };
        Geo.prototype.PerspectiveFovLH = function (fov, aspect, znear, zfar, result) {
            var tan = 1.0 / (Math.tan(fov * 0.5));
            var v_fixed = true; //TODO (fovMode === Camera.FOVMODE_VERTICAL_FIXED);
            if (v_fixed) {
                result.m[0] = tan / aspect;
            }
            else {
                result.m[0] = tan;
            }
            result.m[1] = result.m[2] = result.m[3] = 0.0;
            if (v_fixed) {
                result.m[5] = tan;
            }
            else {
                result.m[5] = tan * aspect;
            }
            result.m[4] = result.m[6] = result.m[7] = 0.0;
            result.m[8] = result.m[9] = 0.0;
            result.m[10] = -zfar / (znear - zfar);
            result.m[11] = 1.0;
            result.m[12] = result.m[13] = result.m[15] = 0.0;
            result.m[14] = (znear * zfar) / (znear - zfar);
        };
        Geo.prototype.numbersToMM = function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, res) {
            res.m[0] = a0;
            res.m[1] = a1;
            res.m[2] = a2;
            res.m[3] = a3;
            res.m[4] = a4;
            res.m[5] = a5;
            res.m[6] = a6;
            res.m[7] = a7;
            res.m[8] = a8;
            res.m[9] = a9;
            res.m[10] = a10;
            res.m[11] = a11;
            res.m[12] = a12;
            res.m[13] = a13;
            res.m[14] = a14;
            res.m[15] = a15;
        };
        //
        //numbersToBabylonMatrix(a0:number,a1:number,a2:number,a3:number,a4:number,a5:number,a6:number,a7:number,a8:number,a9:number,a10:number,a11:number,a12:number,a13:number,a14:number,a15:number,res:BABYLON.Matrix):void{
        //    res.m[0]=a0
        //    res.m[1]=a1
        //    res.m[2]=a2
        //    res.m[3]=a3
        //    res.m[4]=a4
        //    res.m[5]=a5
        //    res.m[6]=a6
        //    res.m[7]=a7
        //    res.m[8]=a8
        //    res.m[9]=a9
        //    res.m[10]=a10
        //    res.m[11]=a11
        //    res.m[12]=a12
        //    res.m[13]=a13
        //    res.m[14]=a14
        //    res.m[15]=a15
        //}
        //
        //
        //MMtoBabylonMatrix(mm:MM,res:BABYLON.Matrix){
        //    res.m[0]=mm.m[0]
        //    res.m[1]=mm.m[1]
        //    res.m[2]=mm.m[2]
        //    res.m[3]=mm.m[3]
        //    res.m[4]=mm.m[4]
        //    res.m[5]=mm.m[5]
        //    res.m[6]=mm.m[6]
        //    res.m[7]=mm.m[7]
        //    res.m[8]=mm.m[8]
        //    res.m[9]=mm.m[9]
        //    res.m[10]=mm.m[10]
        //    res.m[11]=mm.m[11]
        //    res.m[12]=mm.m[12]
        //    res.m[13]=mm.m[13]
        //    res.m[14]=mm.m[14]
        //    res.m[15]=mm.m[15]
        //}
        //
        //XYZtoBabVector(vect:XYZ,res:BABYLON.Vector3):void{
        //    res.x=vect.x
        //    res.y=vect.y
        //    res.z=vect.z
        //
        //}
        Geo.prototype.newHermite = function (value1, tangent1, value2, tangent2, amount) {
            var squared = amount * amount;
            var cubed = amount * squared;
            var part1 = ((2.0 * cubed) - (3.0 * squared)) + 1.0;
            var part2 = (-2.0 * cubed) + (3.0 * squared);
            var part3 = (cubed - (2.0 * squared)) + amount;
            var part4 = cubed - squared;
            var x = (((value1.x * part1) + (value2.x * part2)) + (tangent1.x * part3)) + (tangent2.x * part4);
            var y = (((value1.y * part1) + (value2.y * part2)) + (tangent1.y * part3)) + (tangent2.y * part4);
            var z = (((value1.z * part1) + (value2.z * part2)) + (tangent1.z * part3)) + (tangent2.z * part4);
            return new mathis.XYZ(x, y, z);
        };
        /** Be carefull:   the right point t2 is not in the output */
        Geo.prototype.hermiteSpline = function (p1, t1, p2, t2, nbPoints, result) {
            mathis.tab.clearArray(result);
            var step = 1 / nbPoints;
            for (var i = 0; i < nbPoints; i++) {
                result.push(this.newHermite(p1, t1, p2, t2, i * step));
            }
        };
        Geo.prototype.quadraticBezier = function (v0, v1, v2, nbPoints, result) {
            mathis.tab.clearArray(result);
            nbPoints = nbPoints > 2 ? nbPoints : 3;
            var equation = function (t, val0, val1, val2) {
                var res = (1 - t) * (1 - t) * val0 + 2 * t * (1 - t) * val1 + t * t * val2;
                return res;
            };
            for (var i = 0; i < nbPoints; i++) {
                result.push(new mathis.XYZ(equation(i / nbPoints, v0.x, v1.x, v2.x), equation(i / nbPoints, v0.y, v1.y, v2.y), equation(i / nbPoints, v0.z, v1.z, v2.z)));
            }
        };
        Geo.prototype.cubicBezier = function (v0, v1, v2, v3, nbPoints, result) {
            mathis.tab.clearArray(result);
            nbPoints = nbPoints > 3 ? nbPoints : 4;
            var equation = function (t, val0, val1, val2, val3) {
                var res = (1 - t) * (1 - t) * (1 - t) * val0 + 3 * t * (1 - t) * (1 - t) * val1 + 3 * t * t * (1 - t) * val2 + t * t * t * val3;
                return res;
            };
            for (var i = 0; i < nbPoints; i++) {
                result.push(new mathis.XYZ(equation(i / nbPoints, v0.x, v1.x, v2.x, v3.x), equation(i / nbPoints, v0.y, v1.y, v2.y, v3.y), equation(i / nbPoints, v0.z, v1.z, v2.z, v3.z)));
            }
        };
        Geo.prototype.affineTransformGenerator = function (originIN, endIN, originOUT, endOUT) {
            var amplitudeIN = mathis.XYZ.newFrom(endIN).substract(originIN);
            var amplitudeOUT = mathis.XYZ.newFrom(endOUT).substract(originOUT);
            /**we check intrance pav (which can be a rectangle if output pav is a rectangle*/
            if (amplitudeIN.x == 0 && amplitudeOUT.x != 0)
                throw "impossible affine transform from a rectangle to a pav";
            if (amplitudeIN.y == 0 && amplitudeOUT.y != 0)
                throw "impossible affine transform from a rectangle to a pav";
            if (amplitudeIN.z == 0 && amplitudeOUT.z != 0)
                throw "impossible affine transform from a rectangle to a pav";
            /**we forbid that intrance pav is a segment*/
            var nb0 = 0;
            if (amplitudeIN.x == 0)
                nb0++;
            if (amplitudeIN.y == 0)
                nb0++;
            if (amplitudeIN.z == 0)
                nb0++;
            if (nb0 >= 2)
                throw "intrance pav is too degenerated";
            var amplitudeINinv = new mathis.XYZ((amplitudeIN.x == 0) ? 1 : 1 / amplitudeIN.x, (amplitudeIN.y == 0) ? 1 : 1 / amplitudeIN.y, (amplitudeIN.z == 0) ? 1 : 1 / amplitudeIN.z);
            //console.log('amplitudeINinv',amplitudeINinv)
            var res = function (vecIn, vecOut) {
                //console.log('ampl',amplitudeINinv,amplitudeOUT)
                vecOut.copyFrom(vecIn).substract(originIN).multiply(amplitudeINinv).multiply(amplitudeOUT).add(originOUT);
            };
            return res;
        };
        return Geo;
    }());
    mathis.Geo = Geo;
    //geo.substract(points[1].position,points[0].position,this.segment)
    //        let lengthSegment=geo.norme(this.segment)
    //
    //        let tang0=this.computeNormalizedDemiTangent(points[0].position,points[1].position)
    //        tang0.scale(lengthSegment*this.ratioTan)
    //
    //        let currentTangNor=this.computeNormalizedTangent(points[0].position,points[1].position,points[2].position)
    //        let currentTangSca=XYZ.newFrom(currentTangNor).scale(lengthSegment*this.ratioTan)
    //
    //
    //        let hermiteBegin = BABYLON.Curve3.CreateHermiteSpline(<BABYLON.Vector3> points[0],<BABYLON.Vector3> tang0,<BABYLON.Vector3> points[1],<BABYLON.Vector3> currentTangSca, this.nbPointsToSmooth);
    //        hermiteBegin.getPoints().forEach(v=>{smoothLine.push(v)})
    //
    //
    //        for (let i=1;i<points.length-2;i++){
    //            geo.substract(points[1].position,points[0].position,this.segment)
    //            let lengthSegment=geo.norme(this.segment)
    //
    //            let nextTangentNor=this.computeNormalizedTangent(points[i].position,points[i+1].position,points[i+2].position)
    //            let nextTangentSca=XYZ.newFrom(nextTangentNor).scale(lengthSegment*this.ratioTan)
    //            let currentTangSca=XYZ.newFrom(currentTangNor).scale(lengthSegment*this.ratioTan)
    //
    //            let hermite=BABYLON.Curve3.CreateHermiteSpline(<BABYLON.Vector3>points[i],<BABYLON.Vector3>currentTangSca,<BABYLON.Vector3>points[i+1],<BABYLON.Vector3>nextTangentSca,this.nbPointsToSmooth)
    //            hermite.getPoints().forEach(v=>{smoothLine.push(v)})
    //
    //            currentTangNor.copyFrom(nextTangentNor)
    //        }
    //        //
    //        //let lastTan=this.computeNormalizedDemiTangent(points[points.length-1],points[points.length-2])
    //        //let hermiteLast=BABYLON.Curve3.CreateHermiteSpline(points[points.length-2],currentTang,points[points.length-1],lastTan,this.nbPointsToSmooth)
    //        //hermiteLast.getPoints().forEach(v=>{smoothLine.push(v)})
    //
    //
    var geometry;
    (function (geometry) {
        //TODO suppress : it is replaced by FindCloseVertices
        var CloseXYZfinder = (function () {
            function CloseXYZfinder(recepteurList, sourceList, nbDistinctPoint) {
                this.nbDistinctPoint = 1000;
                this.maxDistToBeClose = null;
                /**default: no deformation*/
                this.deformationFunction = function (point) { return point; };
                this.mins = new mathis.XYZ(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
                this.maxs = new mathis.XYZ(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
                this.nbDistinctPoint = nbDistinctPoint;
                this.recepteurList = recepteurList;
                if (sourceList == null || recepteurList == sourceList) {
                    this.sourceList = recepteurList;
                    this.sourceEqualRecepter = true;
                }
                else {
                    this.sourceList = sourceList;
                    this.sourceEqualRecepter = false;
                }
            }
            CloseXYZfinder.prototype.go = function () {
                this.buildScaler();
                var amplitude = new mathis.XYZ(Math.max(1, this.maxs.x - this.mins.x), Math.max(1, this.maxs.y - this.mins.y), Math.max(1, this.maxs.z - this.mins.z));
                var recepteurBalises = {};
                for (var i = 0; i < this.recepteurList.length; i++) {
                    var val = this.deformationFunction(this.recepteurList[i]);
                    var resx = Math.round((val.x - this.mins.x) / amplitude.x * this.nbDistinctPoint);
                    var resy = Math.round((val.y - this.mins.y) / amplitude.y * this.nbDistinctPoint);
                    var resz = Math.round((val.z - this.mins.z) / amplitude.z * this.nbDistinctPoint);
                    var key = resx + ',' + resy + ',' + resz;
                    if (recepteurBalises[key] == null)
                        recepteurBalises[key] = i;
                    else if (!this.sourceEqualRecepter)
                        mathis.logger.c('strange: the recepterList has several XYZ very close. This is, in general, only possible, when recepter equal source');
                }
                var res = {};
                for (var i = 0; i < this.sourceList.length; i++) {
                    var val = this.deformationFunction(this.sourceList[i]);
                    var resx = Math.round((val.x - this.mins.x) / amplitude.x * this.nbDistinctPoint);
                    var resy = Math.round((val.y - this.mins.y) / amplitude.y * this.nbDistinctPoint);
                    var resz = Math.round((val.z - this.mins.z) / amplitude.z * this.nbDistinctPoint);
                    var baliseIndex = recepteurBalises[resx + ',' + resy + ',' + resz];
                    if (baliseIndex != null) {
                        if (this.sourceEqualRecepter) {
                            /**to avoid i-> i when sourceEqualRecepter*/
                            if (baliseIndex != i)
                                res[i] = baliseIndex;
                        }
                        else
                            res[i] = baliseIndex;
                    }
                }
                return res;
            };
            CloseXYZfinder.prototype.buildScaler = function () {
                var _this = this;
                this.recepteurList.forEach(function (vv) {
                    var v = _this.deformationFunction(vv);
                    if (v.x < _this.mins.x)
                        _this.mins.x = v.x;
                    if (v.y < _this.mins.y)
                        _this.mins.y = v.y;
                    if (v.z < _this.mins.z)
                        _this.mins.z = v.z;
                    if (v.x > _this.maxs.x)
                        _this.maxs.x = v.x;
                    if (v.y > _this.maxs.y)
                        _this.maxs.y = v.y;
                    if (v.z > _this.maxs.z)
                        _this.maxs.z = v.z;
                });
                if (!this.sourceEqualRecepter) {
                    this.sourceList.forEach(function (vv) {
                        var v = _this.deformationFunction(vv);
                        if (v.x < _this.mins.x)
                            _this.mins.x = v.x;
                        if (v.y < _this.mins.y)
                            _this.mins.y = v.y;
                        if (v.z < _this.mins.z)
                            _this.mins.z = v.z;
                        if (v.x > _this.maxs.x)
                            _this.maxs.x = v.x;
                        if (v.y > _this.maxs.y)
                            _this.maxs.y = v.y;
                        if (v.z > _this.maxs.z)
                            _this.maxs.z = v.z;
                    });
                }
                if (this.maxDistToBeClose != null) {
                    this.nbDistinctPoint = mathis.geo.distance(this.maxs, this.mins) / this.maxDistToBeClose;
                }
            };
            return CloseXYZfinder;
        }());
        geometry.CloseXYZfinder = CloseXYZfinder;
        var LineInterpoler = (function () {
            function LineInterpoler(points) {
                this.options = new InterpolationOption();
                this.hermite = new Array();
                this.points = points;
            }
            LineInterpoler.prototype.checkArgs = function () {
                if (this.points == null || this.points.length < 2)
                    throw 'too few points';
            };
            LineInterpoler.prototype.go = function () {
                var _this = this;
                var smoothLine = new Array();
                if (this.points.length == 2) {
                    smoothLine = [];
                    for (var i = 0; i < this.options.nbSubdivisions + 1; i++) {
                        var intermediatePoint = new mathis.XYZ(0, 0, 0);
                        mathis.geo.between(this.points[0], this.points[1], i / this.options.nbSubdivisions, intermediatePoint);
                        smoothLine.push(intermediatePoint);
                    }
                    if (this.options.loopLine)
                        smoothLine.push(mathis.XYZ.newFrom(this.points[0]));
                }
                else if (this.options.interpolationStyle == InterpolationStyle.none) {
                    smoothLine = [];
                    this.points.forEach(function (p) { return smoothLine.push(mathis.XYZ.newFrom(p)); });
                    if (this.options.loopLine)
                        smoothLine.push(mathis.XYZ.newFrom(this.points[0]));
                }
                else if (this.options.interpolationStyle == InterpolationStyle.hermite) {
                    var tani_1 = mathis.XYZ.newZero();
                    var tanii_1 = mathis.XYZ.newZero();
                    //let afterLastIndex= (this.loopLine)? 0 : this.points.length-1
                    var oneStep = function (point0, point1, point2, point3) {
                        mathis.geo.substract(point1, point0, tani_1);
                        mathis.geo.substract(point3, point2, tanii_1);
                        tani_1.scale(_this.options.ratioTan);
                        tanii_1.scale(_this.options.ratioTan);
                        mathis.geo.hermiteSpline(point1, tani_1, point2, tanii_1, _this.options.nbSubdivisions, _this.hermite);
                        _this.hermite.forEach(function (v) { smoothLine.push(v); });
                    };
                    var last = this.points.length - 1;
                    if (!this.options.loopLine)
                        oneStep(this.points[0], this.points[0], this.points[1], this.points[2]);
                    else {
                        oneStep(this.points[last], this.points[0], this.points[1], this.points[2]);
                    }
                    for (var i = 1; i < this.points.length - 2; i++) {
                        oneStep(this.points[i - 1], this.points[i], this.points[i + 1], this.points[i + 2]);
                    }
                    if (!this.options.loopLine) {
                        oneStep(this.points[last - 2], this.points[last - 1], this.points[last], this.points[last]);
                        smoothLine.push(this.points[last]);
                    }
                    else {
                        oneStep(this.points[last - 2], this.points[last - 1], this.points[last], this.points[0]);
                        oneStep(this.points[last - 1], this.points[last], this.points[0], this.points[1]);
                        smoothLine.push(this.points[0]);
                    }
                }
                else if (this.options.interpolationStyle == InterpolationStyle.octavioStyle) {
                    if (this.points.length == 2)
                        return [mathis.XYZ.newFrom(this.points[0]), mathis.XYZ.newFrom(this.points[1])];
                    var last = this.points.length - 1;
                    var middle0_1 = mathis.XYZ.newZero();
                    var middle1_1 = mathis.XYZ.newZero();
                    var oneStep = function (point0, point1, point2) {
                        mathis.geo.between(point0, point1, 0.5, middle0_1);
                        mathis.geo.between(point1, point2, 0.5, middle1_1);
                        mathis.geo.quadraticBezier(middle0_1, point1, middle1_1, _this.options.nbSubdivisions, _this.hermite);
                        _this.hermite.forEach(function (v) { smoothLine.push(v); });
                    };
                    if (!this.options.loopLine) {
                        var begin = mathis.XYZ.newFrom(this.points[0]);
                        // let second=XYZ.newZero()
                        // geo.between(this.points[0],this.points[1],0.5,second)
                        smoothLine.push(begin);
                    }
                    else {
                        oneStep(this.points[last], this.points[0], this.points[1]);
                    }
                    for (var i = 1; i < this.points.length - 1; i++) {
                        oneStep(this.points[i - 1], this.points[i], this.points[i + 1]);
                    }
                    if (!this.options.loopLine) {
                        var end = mathis.XYZ.newFrom(this.points[last]);
                        // let beforEnd=XYZ.newZero()
                        // geo.between(this.points[last-1],this.points[last],0.5,beforEnd)
                        //smoothLine.push(beforEnd,end)
                        smoothLine.push(end);
                    }
                    else {
                        oneStep(this.points[last - 1], this.points[last], this.points[0]);
                        /**because bezier do not add the last point*/
                        var latest = mathis.XYZ.newZero();
                        mathis.geo.between(this.points[last], this.points[0], 0.5, latest);
                        smoothLine.push(latest);
                    }
                }
                else
                    throw 'line interporler style unknown';
                return smoothLine;
            };
            return LineInterpoler;
        }());
        geometry.LineInterpoler = LineInterpoler;
        //TODO hermiteWithNormalizedTangent : la norme des  tangentes est une proportion de la longueur du segment courant
        (function (InterpolationStyle) {
            InterpolationStyle[InterpolationStyle["hermite"] = 0] = "hermite";
            InterpolationStyle[InterpolationStyle["octavioStyle"] = 1] = "octavioStyle";
            InterpolationStyle[InterpolationStyle["none"] = 2] = "none";
        })(geometry.InterpolationStyle || (geometry.InterpolationStyle = {}));
        var InterpolationStyle = geometry.InterpolationStyle;
        var InterpolationOption = (function () {
            function InterpolationOption() {
                /** do not put loopLine=true if you have already make a loop with the path to interpolate ! */
                this.loopLine = false;
                this.interpolationStyle = InterpolationStyle.octavioStyle;
                this.nbSubdivisions = 10;
                /**for hermite only : ratio*segment length = the tangent length*/
                this.ratioTan = 0.5;
            }
            return InterpolationOption;
        }());
        geometry.InterpolationOption = InterpolationOption;
    })(geometry = mathis.geometry || (mathis.geometry = {}));
})(mathis || (mathis = {}));
/**
 * Created by vigon on 18/12/2015.
 */
var mathis;
(function (mathis) {
    //TODO emplacer par une rfrence sur le link pour pouvoir mettre plusieurs links ayant mme depart et arrive (mais pas mme opposite)
    var TwoInt = (function () {
        function TwoInt(c, d) {
            this.a = (c < d) ? c : d;
            this.b = (c < d) ? d : c;
        }
        return TwoInt;
    }());
    var graph;
    (function (graph) {
        function getGroup(startingGroup, admissibleForGroup) {
            var group = [];
            var newEdge = [];
            var newEdgeSelected = startingGroup;
            // initialisation
            for (var _i = 0, startingGroup_1 = startingGroup; _i < startingGroup_1.length; _i++) {
                var vertex = startingGroup_1[_i];
                group.push(vertex);
                admissibleForGroup.putValue(vertex, false);
            }
            // iteration
            while (newEdgeSelected.length > 0) {
                newEdge = getEdge(newEdgeSelected);
                newEdgeSelected = [];
                for (var _a = 0, newEdge_1 = newEdge; _a < newEdge_1.length; _a++) {
                    var vertex = newEdge_1[_a];
                    if (admissibleForGroup.getValue(vertex) == true) {
                        newEdgeSelected.push(vertex);
                        group.push(vertex);
                    }
                    admissibleForGroup.putValue(vertex, false);
                }
            }
            return group;
        }
        graph.getGroup = getGroup;
        var DistancesFromAGroup = (function () {
            function DistancesFromAGroup(centralCells) {
                this.OUT_distances_dico = new mathis.HashMap();
                this.centralCells = centralCells;
            }
            //OUT_maxDistance=0
            DistancesFromAGroup.prototype.OUT_distance = function (vertex) {
                return this.OUT_distances_dico.getValue(vertex);
            };
            DistancesFromAGroup.prototype.OUT_allGeodesics = function (vertex, onlyOne) {
                if (onlyOne === void 0) { onlyOne = false; }
                var res = [];
                var edge = [vertex];
                var nonAdmissible = new mathis.HashMap();
                var d = this.OUT_distances_dico.getValue(vertex);
                while (edge.length > 0) {
                    res.push(edge);
                    d--;
                    edge = getEdge(edge, nonAdmissible);
                    var selectedEdge = [];
                    for (var _i = 0, edge_1 = edge; _i < edge_1.length; _i++) {
                        var v = edge_1[_i];
                        if (this.OUT_distances_dico.getValue(v) == d) {
                            selectedEdge.push(v);
                            if (onlyOne)
                                break;
                        }
                    }
                    edge = selectedEdge;
                }
                return res;
            };
            DistancesFromAGroup.prototype.go = function () {
                var nonAdmissible = new mathis.HashMap();
                if (this.centralCells == null || this.centralCells.length == 0)
                    throw 'problme d argument';
                this.OUT_stratesAround = [];
                this.OUT_stratesAround.push(this.centralCells);
                var edge = getEdge(this.centralCells, nonAdmissible);
                while (edge.length > 0) {
                    this.OUT_stratesAround.push(edge);
                    edge = getEdge(edge, nonAdmissible);
                }
                for (var i = 0; i < this.OUT_stratesAround.length; i++) {
                    for (var _i = 0, _a = this.OUT_stratesAround[i]; _i < _a.length; _i++) {
                        var v = _a[_i];
                        this.OUT_distances_dico.putValue(v, i);
                    }
                }
                // let group:Vertex[]=[]
                // let newEdge:Vertex[]=[]
                // let newEdgeSelected:Vertex[]=this.startingGroup
                //
                // // initialisation
                // for (let vertex of this.startingGroup) {
                //     group.push(vertex)
                //     this.nonAdmissible.putValue(vertex,true)
                // }
                //
                // this.OUT_stratesAround.push(this.startingGroup)
                //
                //
                //
                //
                // // iteration
                // while (newEdgeSelected.length>0){
                //     newEdge = getEdge(newEdgeSelected);
                //     this.OUT_stratesAround.push(newEdge)
                //
                //     newEdgeSelected=[]
                //     for (let vertex of newEdge){
                //         /** nonAdmissible is none or false -> admissible  */
                //         if (!this.nonAdmissible.getValue(vertex)) {
                //             newEdgeSelected.push(vertex);
                //             group.push(vertex);
                //         }
                //         this.nonAdmissible.putValue(vertex,true)
                //     }
                // }
            };
            return DistancesFromAGroup;
        }());
        graph.DistancesFromAGroup = DistancesFromAGroup;
        var HeuristicDiameter = (function () {
            function HeuristicDiameter(vertices) {
                this.vertices = vertices;
                this.nbTimeOfNonEvolutionToStop = 2;
                this.lookNonEvolutionWithDistanceVersusWithGroups = true;
                //consecutiveExtremeGroups:Vertex[][]=[]
                this.consecutiveExtremetDistances = [];
                this.OUT_nbIteration = 0;
                this.OUT_twoExtremeVertices = [];
            }
            HeuristicDiameter.prototype.go = function () {
                var extremeGroup = [this.vertices[0]];
                var d = 0;
                var extremeVertices = [];
                while (this.evolution()) {
                    this.OUT_nbIteration++;
                    var distanceAround = new DistancesFromAGroup(extremeGroup);
                    distanceAround.go();
                    d = distanceAround.OUT_stratesAround.length;
                    var oneExtreme = distanceAround.OUT_stratesAround[d - 1][0];
                    extremeGroup = [oneExtreme];
                    this.consecutiveExtremetDistances.push(d);
                    extremeVertices.push(oneExtreme);
                }
                this.OUT_twoExtremeVertices.push(extremeVertices[this.OUT_nbIteration - 1], extremeVertices[this.OUT_nbIteration - 2]);
                return d - 1;
            };
            HeuristicDiameter.prototype.evolution = function () {
                if (this.lookNonEvolutionWithDistanceVersusWithGroups) {
                    var len = this.consecutiveExtremetDistances.length;
                    if (len < this.nbTimeOfNonEvolutionToStop)
                        return true;
                    var lastD = this.consecutiveExtremetDistances[len - 1];
                    for (var i = 1; i < this.nbTimeOfNonEvolutionToStop; i++) {
                        if (this.consecutiveExtremetDistances[len - 1 - i] != lastD)
                            return true;
                    }
                    return false;
                }
                else
                    throw "TODO";
            };
            return HeuristicDiameter;
        }());
        graph.HeuristicDiameter = HeuristicDiameter;
        var DistancesBetweenAllVertices = (function () {
            //useGraphDistanceVersusDistanceVersusLinkWeights=0
            function DistancesBetweenAllVertices(allVertices) {
                this.OUT_allExtremeVertex = [];
                this.allCounters = new mathis.HashMap();
                this.allToTransmit = new mathis.HashMap();
                // OUT_allGeodesics(vertex0:Vertex,vertex1:Vertex,onlyOne=false):Vertex[][]{
                //     let res:Vertex[][]=[]
                //     let edge=[vertex0]
                //     let nonAdmissible=new HashMap<Vertex,boolean>()
                //     //let d=this.allCounters.getValue(vertex0).getValue(vertex1)
                //
                //     while (edge.length>0){
                //         res.push(edge)
                //         let minDist=Number.POSITIVE_INFINITY
                //         edge=getEdge(edge,nonAdmissible)
                //         let selectedEdge:Vertex[]=[]
                //         for (let vertex of edge){
                //             let dist=this.allCounters.getValue(vertex).getValue(vertex1)
                //             if (dist<minDist) {
                //                 selectedEdge=[]
                //                 selectedEdge.push(vertex)
                //             }
                //             else if (dist==minDist&&!onlyOne) selectedEdge.push(vertex)
                //         }
                //         edge=selectedEdge
                //     }
                //
                //     return res
                // }
                this.OUT_diameter = null;
                this.allVertices = allVertices;
            }
            DistancesBetweenAllVertices.prototype.OUT_distance = function (vertex0, vertex1) {
                return this.allCounters.getValue(vertex0).getValue(vertex1);
            };
            DistancesBetweenAllVertices.prototype.OUT_allGeodesics = function (vertex0, vertex1, onlyOne) {
                if (onlyOne === void 0) { onlyOne = false; }
                var res = [];
                var edge = [vertex0];
                var nonAdmissible = new mathis.HashMap();
                var d = this.allCounters.getValue(vertex0).getValue(vertex1);
                while (edge.length > 0) {
                    res.push(edge);
                    d--;
                    edge = getEdge(edge, nonAdmissible);
                    var selectedEdge = [];
                    for (var _i = 0, edge_2 = edge; _i < edge_2.length; _i++) {
                        var vertex = edge_2[_i];
                        if (this.allCounters.getValue(vertex).getValue(vertex1) == d) {
                            selectedEdge.push(vertex);
                            if (onlyOne)
                                break;
                        }
                    }
                    edge = selectedEdge;
                }
                return res;
            };
            DistancesBetweenAllVertices.prototype.go = function () {
                /**initialisation*/
                for (var _i = 0, _a = this.allVertices; _i < _a.length; _i++) {
                    var vertex = _a[_i];
                    var myCounters = new mathis.HashMap(true);
                    myCounters.putValue(vertex, 0);
                    this.allCounters.putValue(vertex, myCounters);
                    var toTransmit = new mathis.HashMap(true);
                    toTransmit.putValue(vertex, 0);
                    this.allToTransmit.putValue(vertex, toTransmit);
                }
                var stillOneToTransmit = true;
                while (stillOneToTransmit) {
                    stillOneToTransmit = false;
                    this.allFreshlyReceived = new mathis.HashMap();
                    for (var _b = 0, _c = this.allVertices; _b < _c.length; _b++) {
                        var vertex = _c[_b];
                        this.allFreshlyReceived.putValue(vertex, new mathis.HashMap(true));
                    }
                    for (var _d = 0, _e = this.allVertices; _d < _e.length; _d++) {
                        var vertex = _e[_d];
                        var toTransmit = this.allToTransmit.getValue(vertex);
                        for (var _f = 0, _g = vertex.links; _f < _g.length; _f++) {
                            var link = _g[_f];
                            var voiCounter = this.allCounters.getValue(link.to);
                            //console.log(vertex,toTransmit.allKeys().length)
                            for (var _h = 0, _j = toTransmit.allKeys(); _h < _j.length; _h++) {
                                var v = _j[_h];
                                if (voiCounter.getValue(v) == null) {
                                    stillOneToTransmit = true;
                                    // let d:number
                                    // if (this.useGraphDistanceVersusDistanceVersusLinkWeights==0)d=1
                                    // else if (this.useGraphDistanceVersusDistanceVersusLinkWeights==1) d=geo.distance(vertex.position,link.to.position)
                                    // else if (link.weight!=null) d=link.weight
                                    // else throw "no weight defined"
                                    voiCounter.putValue(v, toTransmit.getValue(v) + 1);
                                    this.allFreshlyReceived.getValue(link.to).putValue(v, toTransmit.getValue(v) + 1);
                                }
                            }
                        }
                    }
                    this.allToTransmit = this.allFreshlyReceived;
                    this.OUT_diameter = 0;
                    for (var _k = 0, _l = this.allVertices; _k < _l.length; _k++) {
                        var vertex = _l[_k];
                        for (var _m = 0, _o = this.allCounters.getValue(vertex).allEntries(); _m < _o.length; _m++) {
                            var entry = _o[_m];
                            if (entry.value > this.OUT_diameter) {
                                this.OUT_diameter = entry.value;
                                this.OUT_aMaxCouple = [vertex, entry.key];
                                this.OUT_allExtremeVertex = [vertex];
                            }
                            if (entry.value == this.OUT_diameter)
                                this.OUT_allExtremeVertex.push(vertex);
                        }
                    }
                }
            };
            return DistancesBetweenAllVertices;
        }());
        graph.DistancesBetweenAllVertices = DistancesBetweenAllVertices;
        /**parmi admissibleForGroup, retourne la composante connexe autour de startingGroup. */
        // export function  getGroup( startingGroup:Vertex[],  admissibleForGroup :HashMap<Vertex,boolean>):Vertex[]{
        //
        //
        //     var group:Vertex[]=[]
        //     var newEdge:Vertex[]=[]
        //     var newEdgeSelected:Vertex[]=[]
        //
        //     // initialisation
        //     newEdgeSelected = startingGroup;
        //     startingGroup.forEach(c=>group.push(c));
        //     newEdgeSelected.forEach((c:Vertex)=>{admissibleForGroup.putValue(c,false) });
        //
        //     // iteration
        //     while (newEdgeSelected.length>0){
        //         newEdge = getEdge(newEdgeSelected);
        //         newEdgeSelected=[]
        //         newEdge.forEach((c:Vertex)=>{
        //             if (admissibleForGroup.getValue(c)==true) {
        //                 newEdgeSelected.push(c);
        //                 group.push(c);
        //             }
        //             admissibleForGroup.putValue(c,false)
        //         });
        //     }
        //
        //     return group;
        // }
        /**si admissibleForEdge n'est pas dfini, on accepte tout le monde*/
        function getEdge(aGroup, CHANGING_nonAdmissibleForEdge) {
            if (CHANGING_nonAdmissibleForEdge == null)
                CHANGING_nonAdmissibleForEdge = new mathis.HashMap();
            var edge = [];
            for (var _i = 0, aGroup_1 = aGroup; _i < aGroup_1.length; _i++) {
                var vertex = aGroup_1[_i];
                CHANGING_nonAdmissibleForEdge.putValue(vertex, true);
            }
            for (var _a = 0, aGroup_2 = aGroup; _a < aGroup_2.length; _a++) {
                var vertex = aGroup_2[_a];
                for (var _b = 0, _c = vertex.links; _b < _c.length; _b++) {
                    var link = _c[_b];
                    if (!CHANGING_nonAdmissibleForEdge.getValue(link.to)) {
                        //if (admissibleForEdge==null ||admissibleForEdge.getValue(link.to)) 
                        edge.push(link.to);
                    }
                    CHANGING_nonAdmissibleForEdge.putValue(link.to, true);
                }
            }
            return edge;
        }
        graph.getEdge = getEdge;
        function getEdgeConsideringAlsoDiagonalVoisin(aGroup, CHANGING_nonAdmissibleForEdge, exactltyTwo) {
            if (exactltyTwo === void 0) { exactltyTwo = false; }
            if (CHANGING_nonAdmissibleForEdge == null)
                CHANGING_nonAdmissibleForEdge = new mathis.HashMap();
            var edge = getEdge(aGroup, CHANGING_nonAdmissibleForEdge);
            var dicoEdge = new mathis.HashMap();
            for (var _i = 0, edge_3 = edge; _i < edge_3.length; _i++) {
                var c = edge_3[_i];
                dicoEdge.putValue(c, true);
            }
            var edgeAndGroup = edge.concat(aGroup);
            var edge2 = getEdge(edgeAndGroup);
            for (var _a = 0, edge2_1 = edge2; _a < edge2_1.length; _a++) {
                var c = edge2_1[_a];
                if (c.links.length <= 4) {
                    var nbLinkInEdge = 0;
                    for (var _b = 0, _c = c.links; _b < _c.length; _b++) {
                        var v = _c[_b];
                        if (dicoEdge.getValue(v.to) != null)
                            nbLinkInEdge++;
                    }
                    if (exactltyTwo && nbLinkInEdge == 2) {
                        edge.push(c);
                        CHANGING_nonAdmissibleForEdge.putValue(c, true);
                    }
                    else if (nbLinkInEdge >= 2) {
                        edge.push(c);
                        CHANGING_nonAdmissibleForEdge.putValue(c, true);
                    }
                }
            }
            return edge;
        }
        graph.getEdgeConsideringAlsoDiagonalVoisin = getEdgeConsideringAlsoDiagonalVoisin;
        //TODO suppress (un peu gadget)
        function ringify(centralCells) {
            var nonAdmissible = new mathis.HashMap();
            if (centralCells == null || centralCells.length == 0)
                throw 'problme d argument';
            var res = [];
            res.push(centralCells);
            var edge = getEdge(centralCells, nonAdmissible);
            while (edge.length > 0) {
                res.push(edge);
                edge = getEdge(edge, nonAdmissible);
            }
            return res;
        }
        graph.ringify = ringify;
        function ringifyConsideringAlsoDiagonalVoisin(centralCells) {
            if (centralCells == null || centralCells.length == 0)
                throw 'problme d argument';
            var res = [];
            res.push(centralCells);
            var interior = centralCells;
            var edge = getEdgeConsideringAlsoDiagonalVoisin(interior);
            while (edge.length > 0) {
                res.push(edge);
                interior = interior.concat(edge);
                edge = getEdgeConsideringAlsoDiagonalVoisin(interior);
            }
            return res;
        }
        graph.ringifyConsideringAlsoDiagonalVoisin = ringifyConsideringAlsoDiagonalVoisin;
    })(graph = mathis.graph || (mathis.graph = {}));
})(mathis || (mathis = {}));
/**
 * Created by vigon on 01/02/2017.
 */
var mathis;
(function (mathis) {
    var grateAndGlue;
    (function (grateAndGlue) {
        var GraphGrater = (function () {
            function GraphGrater() {
                this.IN_graphFamily = [];
                /**if null, seeds are computed*/
                this.seedsList = null;
                /**if true, seed of a graph  is the further cell of barycenters of other graph
                 * if false, seed of a graph is made of all the vertices which is sufficiently far from other seeds*/
                this.seedComputedFromBarycentersVersusFromAllPossibleCells = true;
                //
                // /**if a graph is include in an other, its corresponding seed can be empty. In this case, with the bellow true option selected, we chose as seed a vertex further as possible from barycenter of other graph*/
                // useBarycenterTechniqueOnlyForEmptySeeds=true
                //
                // /** The seeds is the cell the further of the barycenter.  best with false. Other technic: */
                // useBarycenterTechniqueForAllSeeds=false
                /**a very small decay for the case where barycenters are superposed*/
                this.barycenterDecay = new mathis.XYZ(0.0000000234, 0.000000000677, 0.000000000987);
                /** more big, and more IN_mamesh are grated
                 *  for a family made of  graph with square maille, all with the same size, the natural value is sqrt(2)/2
                 *  But : take care of rectangular maille*/
                this.proximityCoefToGrate = [0.7];
                /** bigger is theses coef, and more we chose seed for initiate grating  */
                this.proportionOfSeeds = [0.1];
                /** to introduce asymmetry */
                this.asymmetriesForSeeds = null;
            }
            GraphGrater.prototype.checkArgs = function () {
                if (this.IN_graphFamily == null || this.IN_graphFamily.length < 2)
                    throw 'SUB_grater works from 2 graphs';
            };
            GraphGrater.prototype.suppressTooCloseVertex = function (family) {
                var res = [];
                for (var i = 0; i < family.length; i++) {
                    var neighborhoodCoef = this.proximityCoefToGrate[i % this.proximityCoefToGrate.length];
                    res[i] = [];
                    for (var _i = 0, _a = family[i]; _i < _a.length; _i++) {
                        var verI = _a[_i];
                        var ok = true;
                        for (var j = 0; j < family.length; j++) {
                            if (i != j) {
                                ok = !this.proximityMeasurer.isCloseToMe(verI, family[j], neighborhoodCoef);
                                if (!ok)
                                    break;
                            }
                        }
                        if (ok)
                            res[i].push(verI);
                    }
                }
                return res;
            };
            GraphGrater.prototype.findSeeds = function () {
                var res = [];
                if (!this.seedComputedFromBarycentersVersusFromAllPossibleCells) {
                    // for (let i=0; i<this.IN_graphFamily.length; i++){
                    //     let neighborhoodCoef= this.proximityCoefToGrate[i%this.proximityCoefToGrate.length]
                    //     res[i]=[]
                    //     for (let verI of this.IN_graphFamily[i]){
                    //         let ok=true
                    //         for (let j=0; j<this.IN_graphFamily.length; j++) {
                    //             if (i != j) {
                    //                 ok = !this.isCloseToMe(verI, this.IN_graphFamily[j],neighborhoodCoef)
                    //                 if (!ok) break
                    //             }
                    //         }
                    //         if (ok) res[i].push(verI)
                    //     }
                    // }
                    res = this.suppressTooCloseVertex(this.IN_graphFamily);
                }
                else {
                    for (var i = 0; i < this.IN_graphFamily.length; i++) {
                        res[i] = [];
                    }
                    // let emptySeed:number[] = []
                    // for (let i = 0; i < this.IN_graphFamily.length; i++) if (res[i].length == 0) emptySeed.push(i)
                    //
                    // if (emptySeed.length > 0) {
                    var barycenters = [];
                    for (var i = 0; i < this.IN_graphFamily.length; i++) {
                        barycenters[i] = new mathis.XYZ(0, 0, 0);
                        for (var _i = 0, _a = this.IN_graphFamily[i]; _i < _a.length; _i++) {
                            var v = _a[_i];
                            barycenters[i].add(v.position);
                        }
                        barycenters[i].scale(1 / this.IN_graphFamily[i].length);
                        barycenters[i].add(this.barycenterDecay);
                    }
                    function toSort(a, b) { return b.distance - a.distance; }
                    for (var emp = 0; emp < this.IN_graphFamily.length; emp++) {
                        var baryOfOther = new mathis.XYZ(0, 0, 0);
                        for (var k = 0; k < this.IN_graphFamily.length; k++)
                            if (k != emp)
                                baryOfOther.add(barycenters[k]);
                        baryOfOther.scale(1 / (this.IN_graphFamily.length - 1));
                        var vertexAndDist = [];
                        var bary2Pos = new mathis.XYZ(0, 0, 0);
                        for (var _b = 0, _c = this.IN_graphFamily[emp]; _b < _c.length; _b++) {
                            var v = _c[_b];
                            bary2Pos.copyFrom(v.position).substract(baryOfOther);
                            var dd = mathis.geo.distance(v.position, baryOfOther);
                            /**we tried to take into account the barycenter of the current graph (as following), but this was worse
                             * let ddInternal = geo.distance(v.position, barycenters[emp])
                             vertexAndDist.push({vertex:v,distance:dd-ddInternal})
                             */
                            if (this.asymmetriesForSeeds != null && this.asymmetriesForSeeds[emp % this.asymmetriesForSeeds.length] != null) {
                                var asy = this.asymmetriesForSeeds[emp % this.asymmetriesForSeeds.length];
                                var angle = mathis.geo.angleBetweenTwoVectorsBetween0andPi(bary2Pos, asy.direction);
                                var modu = Math.PI;
                                if (asy.modulo != null) {
                                    modu = asy.modulo;
                                    if (isNaN(modu) || modu < 0 || modu > Math.PI)
                                        throw 'modulo must be a number between 0 and PI, but is:' + modu;
                                    angle = mathis.modulo(angle, modu);
                                }
                                var coef = 1 - angle / modu;
                                dd = dd * (1 - asy.influence) + coef * asy.influence;
                            }
                            vertexAndDist.push({ vertex: v, distance: dd });
                        }
                        vertexAndDist.sort(toSort);
                        // let longest = -1
                        // let furtherVertex =null// this.IN_graphFamily[emp][0]
                        // for (let v of this.IN_graphFamily[emp]) {
                        //     let dd = geo.distance(v.position, baryOfOther)
                        //     //cc('dd',dd,baryOfOther,v.position)
                        //     if (dd > longest) {
                        //         longest = dd
                        //         furtherVertex = v
                        //     }
                        // }
                        res[emp] = [];
                        var borne = void 0;
                        if (this.proportionOfSeeds[emp % this.proportionOfSeeds.length] > 0)
                            borne = vertexAndDist[0].distance * (1 - this.proportionOfSeeds[emp % this.proportionOfSeeds.length]);
                        else
                            borne = vertexAndDist[0].distance * 0.99;
                        var dist = Number.MAX_VALUE;
                        var i = 0;
                        while (dist >= borne && i < vertexAndDist.length - 1) {
                            res[emp].push(vertexAndDist[i].vertex);
                            i++;
                            dist = vertexAndDist[i].distance;
                        }
                    }
                }
                /**because seeds ca overlap themselves*/
                res = this.suppressTooCloseVertex(res);
                for (var i = 0; i < this.IN_graphFamily.length; i++)
                    if (res[i].length == 0)
                        throw 'an empty seeds, possible cause: 1/  two graphes are identical 2/ one of your graph is nearly includes into an other and you do not use the barycenter technique';
                return res;
            };
            GraphGrater.prototype.go = function () {
                this.checkArgs();
                if (this.proximityMeasurer == null)
                    this.proximityMeasurer = new ProximityMeasurer();
                if (this.seedsList == null) {
                    this.seedsList = this.findSeeds();
                    this.OUT_allSeeds = this.seedsList;
                }
                var alreadySomeVertex = true;
                var interior = [];
                //let interiorUnion:Vertex[]=[]
                //let admissible:HashMap<Vertex,boolean>[]=[]
                for (var i = 0; i < this.IN_graphFamily.length; i++) {
                    //interior[i]=[]
                    interior[i] = [].concat(this.seedsList[i]);
                }
                var nonAdmissibleForEdge = new mathis.HashMap();
                while (alreadySomeVertex) {
                    alreadySomeVertex = false;
                    for (var i = 0; i < this.IN_graphFamily.length; i++) {
                        var neighborhoodCoef = this.proximityCoefToGrate[i % this.proximityCoefToGrate.length];
                        var edge = mathis.graph.getEdge(interior[i], nonAdmissibleForEdge);
                        for (var _i = 0, edge_4 = edge; _i < edge_4.length; _i++) {
                            var ve = edge_4[_i];
                            var isClose = false;
                            for (var j = 0; j < this.IN_graphFamily.length; j++) {
                                if (i != j && this.proximityMeasurer.isCloseToMe(ve, interior[j], neighborhoodCoef)) {
                                    isClose = true;
                                    break;
                                }
                            }
                            if (!isClose) {
                                interior[i].push(ve);
                                alreadySomeVertex = true;
                            }
                        }
                    }
                }
                // for (let i=0; i<this.IN_graphFamily.length; i++) {
                //     admissible[i]=new HashMap<Vertex,boolean>()
                //     interior[i]=[]
                //
                //     this.IN_graphFamily[i].forEach(v=>admissible[i].putValue(v,true))
                //     this.seedsList[i].forEach(v=>{
                //
                //         interior[i].push(v)
                //         //interiorUnion.push(v)
                //         admissible[i].putValue(v,false)
                //     })
                // }
                //
                //
                //
                // while (alreadySomeVertex){
                //
                //     alreadySomeVertex=false
                //     for (let i=0; i<this.IN_graphFamily.length; i++){
                //         let neighborhoodCoef=this.proximityCoefToGrate[i%this.proximityCoefToGrate.length]
                //
                //         let edge=graph.getEdge(interior[i],admissible[i])
                //
                //
                //         for (let ve of edge){
                //             admissible[i].putValue(ve,false)
                //
                //             let isClose=false//this.isCloseToMe(ve,interiorUnion,neighborhoodCoef)
                //             for (let j=0; j<this.IN_graphFamily.length; j++){
                //                 if(i!=j&& this.proximityMeasurer.isCloseToMe(ve,interior[j],neighborhoodCoef)) {
                //                     isClose=true
                //                     break
                //                 }
                //             }
                //
                //             if (!isClose) {
                //                 interior[i].push(ve)
                //                 //interiorUnion.push(ve)
                //                 alreadySomeVertex=true
                //             }
                //         }
                //     }
                // }
                return interior;
            };
            return GraphGrater;
        }());
        grateAndGlue.GraphGrater = GraphGrater;
        var ProximityMeasurer = (function () {
            function ProximityMeasurer() {
                this.vertexToLinkLength = new mathis.HashMap();
            }
            ProximityMeasurer.prototype.meanLinksDist = function (vertex) {
                var res = this.vertexToLinkLength.getValue(vertex);
                if (res != null)
                    return res;
                var dist = 0;
                for (var _i = 0, _a = vertex.links; _i < _a.length; _i++) {
                    var link = _a[_i];
                    dist += mathis.geo.distance(vertex.position, link.to.position);
                }
                dist /= vertex.links.length;
                this.vertexToLinkLength.putValue(vertex, dist);
                return dist;
            };
            ProximityMeasurer.prototype.isCloseToMe = function (vertex, family, coef) {
                for (var _i = 0, family_1 = family; _i < family_1.length; _i++) {
                    var v = family_1[_i];
                    if (this.areClose(vertex, v, coef))
                        return true;
                }
                return false;
            };
            ProximityMeasurer.prototype.areClose = function (vertex0, vertex1, coef) {
                return (mathis.geo.distance(vertex0.position, vertex1.position) < (this.meanLinksDist(vertex0) + this.meanLinksDist(vertex1)) / 2 * coef);
            };
            ProximityMeasurer.prototype.areFar = function (vertex0, vertex1, coef) {
                return (mathis.geo.distance(vertex0.position, vertex1.position) > (this.meanLinksDist(vertex0) + this.meanLinksDist(vertex1)) / 2 * coef);
            };
            return ProximityMeasurer;
        }());
        var SubMameshExtractor = (function () {
            function SubMameshExtractor(mamesh, verticesToKeep) {
                this.verticesToKeepMustBeInMamesh = true;
                this.constructCutSegment = true;
                this.takeCareOfPolygons = true;
                this.addBorderPolygonInsteadOfSuppress = false;
                /**OUT*/
                this.OUT_BorderPolygon = [];
                this.OUT_BorderVerticesInside = [];
                this.OUTBorderVerticesOutside = [];
                this.mamesh = mamesh;
                this.verticesToKeep = verticesToKeep;
            }
            SubMameshExtractor.prototype.go = function () {
                var _this = this;
                var res = new mathis.Mamesh();
                this.verticesToKeep.forEach(function (vertex) {
                    if (_this.mamesh.hasVertex(vertex)) {
                        res.addVertex(vertex);
                    }
                    else if (_this.verticesToKeepMustBeInMamesh)
                        throw 'a vertex in the list to keep is not in the original mesh. If you want to allow this, please turn the boolean "verticesToKeepMustBeInMamesh" to false';
                });
                //res.linksOK = true
                //let verticesToAdd:Vertex[]=[]
                for (var i = 0; i < this.mamesh.smallestSquares.length; i += 4) {
                    var sumOfPresentVertex = 0;
                    if (res.hasVertex(this.mamesh.smallestSquares[i]))
                        sumOfPresentVertex++;
                    if (res.hasVertex(this.mamesh.smallestSquares[i + 1]))
                        sumOfPresentVertex++;
                    if (res.hasVertex(this.mamesh.smallestSquares[i + 2]))
                        sumOfPresentVertex++;
                    if (res.hasVertex(this.mamesh.smallestSquares[i + 3]))
                        sumOfPresentVertex++;
                    if (sumOfPresentVertex > 0 && sumOfPresentVertex < 4)
                        this.OUT_BorderPolygon.push([this.mamesh.smallestSquares[i], this.mamesh.smallestSquares[i + 1], this.mamesh.smallestSquares[i + 2], this.mamesh.smallestSquares[i + 3]]);
                    else if (sumOfPresentVertex == 4)
                        res.smallestSquares.push(this.mamesh.smallestSquares[i], this.mamesh.smallestSquares[i + 1], this.mamesh.smallestSquares[i + 2], this.mamesh.smallestSquares[i + 3]);
                }
                for (var i = 0; i < this.mamesh.smallestTriangles.length; i += 3) {
                    var sumOfPresentVertex = 0;
                    if (res.hasVertex(this.mamesh.smallestTriangles[i]))
                        sumOfPresentVertex++;
                    if (res.hasVertex(this.mamesh.smallestTriangles[i + 1]))
                        sumOfPresentVertex++;
                    if (res.hasVertex(this.mamesh.smallestTriangles[i + 2]))
                        sumOfPresentVertex++;
                    if (sumOfPresentVertex > 0 && sumOfPresentVertex < 3)
                        this.OUT_BorderPolygon.push([this.mamesh.smallestTriangles[i], this.mamesh.smallestTriangles[i + 1], this.mamesh.smallestTriangles[i + 2]]);
                    else if (sumOfPresentVertex == 3)
                        res.smallestTriangles.push(this.mamesh.smallestTriangles[i], this.mamesh.smallestTriangles[i + 1], this.mamesh.smallestTriangles[i + 2]);
                }
                for (var _i = 0, _a = this.OUT_BorderPolygon; _i < _a.length; _i++) {
                    var poly = _a[_i];
                    for (var _b = 0, poly_1 = poly; _b < poly_1.length; _b++) {
                        var v = poly_1[_b];
                        if (res.hasVertex(v)) {
                            if (this.OUT_BorderVerticesInside.indexOf(v) == -1)
                                this.OUT_BorderVerticesInside.push(v);
                        }
                        else {
                            if (this.OUTBorderVerticesOutside.indexOf(v) == -1)
                                this.OUTBorderVerticesOutside.push(v);
                        }
                    }
                }
                if (this.takeCareOfPolygons) {
                    if (this.addBorderPolygonInsteadOfSuppress) {
                        for (var _c = 0, _d = this.OUT_BorderPolygon; _c < _d.length; _c++) {
                            var poly = _d[_c];
                            if (poly.length == 3)
                                res.smallestTriangles.push(poly[0], poly[1], poly[2]);
                            else if (poly.length == 4)
                                res.smallestSquares.push(poly[0], poly[1], poly[2], poly[3]);
                        }
                        for (var _e = 0, _f = this.OUTBorderVerticesOutside; _e < _f.length; _e++) {
                            var vert = _f[_e];
                            res.addVertex(vert);
                        }
                    }
                    else {
                        var suppressedIndexOfBorderInside = [];
                        var suppressedIndexOfRes = [];
                        for (var i = 0; i < this.OUT_BorderVerticesInside.length; i++) {
                            var vert = this.OUT_BorderVerticesInside[i];
                            var isInAPoly = false;
                            for (var _g = 0, _h = res.smallestSquares; _g < _h.length; _g++) {
                                var v = _h[_g];
                                if (v.hashNumber == vert.hashNumber) {
                                    isInAPoly = true;
                                    break;
                                }
                            }
                            if (!isInAPoly) {
                                for (var _j = 0, _k = res.smallestTriangles; _j < _k.length; _j++) {
                                    var v = _k[_j];
                                    if (v.hashNumber == vert.hashNumber) {
                                        isInAPoly = true;
                                        break;
                                    }
                                }
                            }
                            if (!isInAPoly) {
                                //removeFromArray(res.vertices,vert)
                                suppressedIndexOfRes.push(res.vertices.indexOf(vert));
                                suppressedIndexOfBorderInside.push(i);
                            }
                        }
                        this.OUT_BorderVerticesInside = mathis.tab.arrayMinusSomeIndices(this.OUT_BorderVerticesInside, suppressedIndexOfBorderInside);
                        res.vertices = mathis.tab.arrayMinusSomeIndices(res.vertices, suppressedIndexOfRes);
                    }
                }
                if (this.constructCutSegment) {
                    for (var key in this.mamesh.cutSegmentsDico) {
                        var segment = this.mamesh.cutSegmentsDico[key];
                        if (!res.hasVertex(segment.a))
                            continue;
                        if (!res.hasVertex(segment.b))
                            continue;
                        if (!res.hasVertex(segment.middle))
                            continue;
                        res.cutSegmentsDico[key] = segment;
                    }
                }
                return res;
            };
            return SubMameshExtractor;
        }());
        grateAndGlue.SubMameshExtractor = SubMameshExtractor;
        var ExtractCentralPart = (function () {
            function ExtractCentralPart(mamesh, nb) {
                this.markBorder = true;
                this.suppressFromBorderVersusCorner = true;
                this.mamesh = mamesh;
                this.nb = nb;
            }
            ExtractCentralPart.prototype.go = function () {
                var border = [];
                if (this.suppressFromBorderVersusCorner) {
                    for (var _i = 0, _a = this.mamesh.vertices; _i < _a.length; _i++) {
                        var ver = _a[_i];
                        if (ver.hasMark(mathis.Vertex.Markers.border))
                            border.push(ver);
                    }
                }
                else {
                    for (var _b = 0, _c = this.mamesh.vertices; _b < _c.length; _b++) {
                        var ver = _c[_b];
                        if (ver.hasMark(mathis.Vertex.Markers.corner))
                            border.push(ver);
                    }
                }
                var rings = mathis.graph.ringify(border);
                var toSuppress = new mathis.HashMap();
                if (this.nb < 0)
                    this.nb = rings.length + this.nb - 1;
                if (this.nb >= rings.length - 1)
                    throw 'you want to suppress too much strates';
                for (var i = 0; i < this.nb; i++) {
                    for (var _d = 0, _e = rings[i]; _d < _e.length; _d++) {
                        var v = _e[_d];
                        toSuppress.putValue(v, true);
                    }
                }
                var toKeep = [];
                for (var _f = 0, _g = this.mamesh.vertices; _f < _g.length; _f++) {
                    var v = _g[_f];
                    if (toSuppress.getValue(v) == null) {
                        toKeep.push(v);
                    }
                }
                if (this.markBorder)
                    for (var _h = 0, _j = rings[this.nb]; _h < _j.length; _h++) {
                        var v = _j[_h];
                        v.markers.push(mathis.Vertex.Markers.border);
                    }
                var suber = new grateAndGlue.SubMameshExtractor(this.mamesh, toKeep);
                var res = suber.go();
                return res;
            };
            return ExtractCentralPart;
        }());
        grateAndGlue.ExtractCentralPart = ExtractCentralPart;
        var FindStickingMapFromSquare = (function () {
            function FindStickingMapFromSquare(receiver, source) {
                this.receiver = receiver;
                this.source = source;
            }
            FindStickingMapFromSquare.prototype.checkArgs = function () {
                if (this.receiver.length % 4 != 0)
                    throw 'receiver is not a list representing squares';
                if (this.source.length % 4 != 0)
                    throw 'source is not a list representing squares';
            };
            FindStickingMapFromSquare.prototype.go = function () {
                this.checkArgs();
                var res = new mathis.HashMap(true);
                var sourceBaryCenter = this.squareToBaryCenter(this.source);
                var receiverBaryCenter = this.squareToBaryCenter(this.receiver);
                for (var i = 0; i < sourceBaryCenter.length; i++) {
                    var minDist = Number.MAX_VALUE;
                    var bestReceiverIndex = -1;
                    for (var j = 0; j < receiverBaryCenter.length; j++) {
                        var dist = mathis.geo.distance(sourceBaryCenter[i], receiverBaryCenter[j]);
                        if (dist < minDist) {
                            minDist = dist;
                            bestReceiverIndex = j;
                        }
                    }
                    var receiverPaquet = [this.receiver[4 * bestReceiverIndex], this.receiver[4 * bestReceiverIndex + 1], this.receiver[4 * bestReceiverIndex + 2], this.receiver[4 * bestReceiverIndex + 3]];
                    var sourcePaquet = [this.source[4 * i], this.source[4 * i + 1], this.source[4 * i + 2], this.source[4 * i + 3]];
                    var permutedReceiverPaquet = this.getBestPermutationOfReceiver(receiverPaquet, sourcePaquet);
                    for (var k = 0; k < 4; k++) {
                        res.putValue(sourcePaquet[k], permutedReceiverPaquet[k]);
                    }
                }
                return res;
            };
            FindStickingMapFromSquare.prototype.getBestPermutationOfReceiver = function (receiverPaquet, sourcePaquet) {
                var minDist = Number.MAX_VALUE;
                var bestDecal = -1;
                for (var k_1 = 0; k_1 < 4; k_1++) {
                    var decalReceiver = [receiverPaquet[k_1], receiverPaquet[(k_1 + 1) % 4], receiverPaquet[(k_1 + 2) % 4], receiverPaquet[(k_1 + 3) % 4]];
                    var dist = 0;
                    for (var l = 0; l < 4; l++)
                        dist += mathis.geo.distance(sourcePaquet[l].position, decalReceiver[l].position);
                    if (dist < minDist) {
                        minDist = dist;
                        bestDecal = k_1;
                    }
                }
                var k = bestDecal;
                return [receiverPaquet[k], receiverPaquet[(k + 1) % 4], receiverPaquet[(k + 2) % 4], receiverPaquet[(k + 3) % 4]];
            };
            FindStickingMapFromSquare.prototype.squareToBaryCenter = function (vertices) {
                var res = [];
                for (var i = 0; i < vertices.length; i += 4) {
                    var paquet = [vertices[i].position, vertices[i + 1].position, vertices[i + 2].position, vertices[i + 3].position];
                    var bary = new mathis.XYZ(0, 0, 0);
                    mathis.geo.baryCenter(paquet, [1 / 4, 1 / 4, 1 / 4, 1 / 4], bary);
                    res.push(bary);
                }
                return res;
            };
            return FindStickingMapFromSquare;
        }());
        //
        // export class FindSickingMapFromVerticesOld{
        //
        //     receiver:Vertex[]
        //     source:Vertex[]
        //
        //     /**if zero, sticking is made only for closest voisin*/
        //     toleranceToBeOneOfTheClosest=0.3
        //
        //     constructor(receiver:Vertex[],source:Vertex[]){
        //
        //         this.receiver=receiver
        //         this.source=source
        //
        //     }
        //
        //     private checkArgs():void{
        //         //if (this.receiver.length%4!=0) throw 'receiver is not a list representing squares'
        //         //if (this.source.length%4!=0) throw 'source is not a list representing squares'
        //
        //     }
        //
        //     go ():Vertex[][]{
        //
        //         this.checkArgs()
        //
        //         let res:Vertex[][]=[]//=new HashMap<Vertex,Vertex>(true)
        //
        //         for (let i=0;i<this.source.length;i++){
        //             let minDist=Number.MAX_VALUE
        //             //let bestReceiverIndex=-1
        //             let distances:number[]=[]
        //             for (let j=0;j<this.receiver.length;j++){
        //                 distances[j]=geo.distance(this.source[i].position,this.receiver[j].position)
        //
        //                 if (distances[j]<minDist){
        //                     minDist=distances[j]
        //                     //bestReceiverIndex=j
        //                 }
        //             }
        //             let bestRecivers:number[]=[]
        //             for (let j=0;j<this.receiver.length;j++){
        //                 if (distances[j]<=minDist*(1+this.toleranceToBeOneOfTheClosest)){
        //                     bestRecivers.push(j)
        //                 }
        //             }
        //             for (let j of bestRecivers) res.push([this.source[i],this.receiver[j]])
        //
        //         }
        //         return res
        //     }
        //
        // }
        //
        var FindSickingMapFromVertices = (function () {
            function FindSickingMapFromVertices(receiver, source) {
                /**if zero, sticking is made only for closest voisin*/
                this.toleranceToBeOneOfTheClosest = 0.5;
                this.proximityCoef = 0.7;
                this.acceptOnlyDisjointReceiverAndSource = true;
                this.receiver = receiver;
                this.source = source;
            }
            FindSickingMapFromVertices.prototype.checkArgs = function () {
                if (this.acceptOnlyDisjointReceiverAndSource) {
                    var dico = new mathis.HashMap();
                    for (var _i = 0, _a = this.source; _i < _a.length; _i++) {
                        var v = _a[_i];
                        dico.putValue(v, true);
                    }
                    for (var _b = 0, _c = this.receiver; _b < _c.length; _b++) {
                        var v = _c[_b];
                        if (dico.getValue(v) != null)
                            throw 'source and receiver must be disjoint';
                    }
                }
            };
            FindSickingMapFromVertices.prototype.go = function () {
                this.checkArgs();
                if (this.proximityMeasurer == null)
                    this.proximityMeasurer = new ProximityMeasurer();
                this.checkArgs();
                var res = new mathis.HashMap(true);
                for (var _i = 0, _a = this.source; _i < _a.length; _i++) {
                    var vSource = _a[_i];
                    var minDist = Number.POSITIVE_INFINITY;
                    //let bestReceiverIndex=-1
                    var receiverToDist = new mathis.HashMap(true);
                    var veryBestReceiver = null;
                    for (var _b = 0, _c = this.receiver; _b < _c.length; _b++) {
                        var vReceiver = _c[_b];
                        /**we do not want a vertex which is in a same time receiver and source*/
                        var dist = mathis.geo.distance(vSource.position, vReceiver.position);
                        if (this.proximityMeasurer.areClose(vSource, vReceiver, this.proximityCoef)) {
                            receiverToDist.putValue(vReceiver, dist);
                            if (dist < minDist) {
                                minDist = dist;
                                veryBestReceiver = vReceiver;
                            }
                        }
                    }
                    /**veryBestReceiver==null means that source and all receivers are too far*/
                    if (veryBestReceiver != null) {
                        var bestReceivers = [];
                        /**we put in first the very best*/
                        bestReceivers.push(veryBestReceiver);
                        for (var _d = 0, _e = receiverToDist.allKeys(); _d < _e.length; _d++) {
                            var vReceiver = _e[_d];
                            if (vReceiver != veryBestReceiver && receiverToDist.getValue(vReceiver) <= minDist * (1 + this.toleranceToBeOneOfTheClosest)) {
                                bestReceivers.push(vReceiver);
                            }
                        }
                        res.putValue(vSource, bestReceivers);
                    }
                }
                return res;
            };
            return FindSickingMapFromVertices;
        }());
        grateAndGlue.FindSickingMapFromVertices = FindSickingMapFromVertices;
        //
        // export class FindMergingMapFast{
        //
        //
        //     source:Vertex[]
        //     receiver:Vertex[]
        //     nbDistinctPoint:number
        //    
        //     constructor( receiver:Vertex[],source:Vertex[],nbDistinctPoint:number){
        //         this.source=source
        //         this.receiver=receiver
        //         this.nbDistinctPoint=nbDistinctPoint
        //     }
        //    
        //     go():HashMap<Vertex,Vertex> {
        //
        //         // let indexToMerge:{[key:number]:number}
        //         //
        //         // this.merginMap = new HashMap<Vertex,Vertex>(true)
        //         //
        //         // let positionsRecepter:XYZ[] = []
        //         // this.receiverMamesh.vertices.forEach(v=> {
        //         //     positionsRecepter.push(v.position)
        //         // })
        //         //
        //         // if (this.sourceEqualRecepter) indexToMerge = new geometry.CloseXYZfinder(positionsRecepter,null,1000).go()
        //         // else {
        //         //     let positionsSource:XYZ[] = []
        //         //     this.sourceMamesh.vertices.forEach(v=> {
        //         //         positionsSource.push(v.position)
        //         //     })
        //         //     indexToMerge = new geometry.CloseXYZfinder(positionsRecepter, positionsSource,1000).go()
        //         // }
        //         //
        //         //
        //         // for (let index in indexToMerge) {
        //         //     this.merginMap.putValue(this.sourceMamesh.vertices[index], this.receiverMamesh.vertices[indexToMerge[index]])
        //         // }
        //        
        //        
        //         let indexToMerge:{[key:number]:number}
        //
        //         let merginMap = new HashMap<Vertex,Vertex>(true)
        //
        //         let positionsRecepter:XYZ[] = []
        //         this.receiver.forEach(v=> {
        //             positionsRecepter.push(v.position)
        //         })
        //
        //         if (this.source==null) indexToMerge = new geometry.CloseXYZfinder(positionsRecepter,null,this.nbDistinctPoint).go()
        //         else {
        //             let positionsSource:XYZ[] = []
        //             this.source.forEach(v=> {
        //                 positionsSource.push(v.position)
        //             })
        //             indexToMerge = new geometry.CloseXYZfinder(positionsRecepter, positionsSource,this.nbDistinctPoint).go()
        //         }
        //
        //
        //         for (let index in indexToMerge) {
        //             merginMap.putValue(this.source[index], this.receiver[indexToMerge[index]])
        //         }
        //
        //
        //         return merginMap
        //
        //     }
        //    
        // }
        var ConcurrentMameshesGraterAndSticker = (function () {
            function ConcurrentMameshesGraterAndSticker() {
                this.IN_mameshes = [];
                this.SUB_grater = new GraphGrater();
                this.justGrateDoNotStick = false;
                /**use for sticking. More big, and more links are added*/
                this.proximityCoefToStick = [2];
                /**if zero -> sticking is made only for closest voisin
                 * if 0.5 -> vertices up to 50% of the closest are stick*/
                this.toleranceToBeOneOfTheClosest = 0.5;
                /**some intermediate result, which can be use if the user want to "just grate and not stick" and then to stick with some custom mergingMap */
                this.OUTBorderVerticesToStick = [];
                /**be careful, if you stickAll (default), the zero-indexed IN_mamesh-vertices will be modified, and so the zero indexed grated mameh*/
                this.OUTGratedMameshes = [];
                this.takeCareOfPolygons = true;
                this.suppressLinksAngularlyTooClose = true;
                this.SUB_linkCleanerByAngle = new mathis.linkModule.LinksSorterAndCleanerByAngles(null, null);
                this.OUT_stickingMap = new mathis.HashMap(true);
                this.SUB_linkCleanerByAngle.suppressLinksAngularParam = 2 * Math.PI * 0.1;
            }
            ConcurrentMameshesGraterAndSticker.prototype.checkArgs = function () {
                //if (this.neighborhoodSizeCoefByFamily!=null && this.neighborhoodSizeCoefByFamily.length!=this.IN_mameshes.length) throw 'neighborhoodSizeCoefByFamily must have the same length as mameshFamily'
                //if (this.stickingSizeCoefByFamily!=null && this.stickingSizeCoefByFamily.length!=this.IN_mameshes.length) throw 'stickingSizeCoefByFamily must have the same length as mameshFamily'
            };
            ConcurrentMameshesGraterAndSticker.prototype.goChanging = function () {
                this.checkArgs();
                /**first we clean all opposite link of all IN_mamesh. They will be rebuild*/
                for (var _i = 0, _a = this.IN_mameshes; _i < _a.length; _i++) {
                    var mam = _a[_i];
                    for (var _b = 0, _c = mam.vertices; _b < _c.length; _b++) {
                        var ve = _c[_b];
                        for (var _d = 0, _e = ve.links; _d < _e.length; _d++) {
                            var li = _e[_d];
                            li.opposites = null;
                        }
                    }
                }
                var graphs = [];
                this.IN_mameshes.forEach(function (m) { return graphs.push(m.vertices); });
                this.SUB_grater.IN_graphFamily = graphs;
                var gratedGraph = this.SUB_grater.go();
                for (var i = 0; i < this.IN_mameshes.length; i++) {
                    var extractor = new grateAndGlue.SubMameshExtractor(this.IN_mameshes[i], gratedGraph[i]);
                    extractor.takeCareOfPolygons = this.takeCareOfPolygons;
                    extractor.addBorderPolygonInsteadOfSuppress = false;
                    this.OUTGratedMameshes[i] = extractor.go();
                    /**to stick perhaps: vertices where we have cut, but only one which have a link leading to outside*/
                    this.OUTBorderVerticesToStick[i] = [];
                    for (var _f = 0, _g = extractor.OUT_BorderVerticesInside; _f < _g.length; _f++) {
                        var vertex = _g[_f];
                        for (var _h = 0, _j = vertex.links; _h < _j.length; _h++) {
                            var link = _j[_h];
                            if (this.IN_mameshes[i].hasVertex(link.to) && !this.OUTGratedMameshes[i].hasVertex(link.to)) {
                                this.OUTBorderVerticesToStick[i].push(vertex);
                                break;
                            }
                        }
                    }
                    this.OUTGratedMameshes[i].isolateMameshVerticesFromExteriorVertices();
                    for (var _k = 0, _l = this.OUTGratedMameshes[i].vertices; _k < _l.length; _k++) {
                        var v = _l[_k];
                        if (v.hasMark(mathis.Vertex.Markers.border) && this.OUTBorderVerticesToStick[i].indexOf(v) == -1)
                            this.OUTBorderVerticesToStick[i].push(v);
                    }
                }
                var res = this.OUTGratedMameshes[0];
                for (var indexMamesh = 1; indexMamesh < this.IN_mameshes.length; indexMamesh++) {
                    var mapFinder = new FindSickingMapFromVertices(res.vertices, this.OUTBorderVerticesToStick[indexMamesh]);
                    mapFinder.toleranceToBeOneOfTheClosest = this.toleranceToBeOneOfTheClosest;
                    mapFinder.proximityCoef = this.proximityCoefToStick[indexMamesh % this.proximityCoefToStick.length];
                    var map = mapFinder.go();
                    this.OUT_stickingMap.extend(map);
                    // let indexToRemove:number[]=[]
                    // for (let i=0;i<map.length;i++){
                    //     if (!this.proximityMeasurer.areClose(map[i][0],map[i][1],stickingCoef)) {
                    //         indexToRemove.push(i)
                    //     }
                    // }
                    // map=tab.arrayMinusSomeIndices(map,indexToRemove)
                    var sticker = new Sticker(res, this.OUTGratedMameshes[indexMamesh], map);
                    sticker.zIndex1 = indexMamesh;
                    /**already done in this method*/
                    sticker.cleanOppositeLinksAtBegin = false;
                    sticker.createNewLinks = !this.justGrateDoNotStick;
                    sticker.goChanging();
                }
                res.isolateMameshVerticesFromExteriorVertices();
                for (var _m = 0, _o = res.vertices; _m < _o.length; _m++) {
                    var ve = _o[_m];
                    if (ve.links.length == 0)
                        throw ' grating process produce a vertex with no links';
                }
                if (this.suppressLinksAngularlyTooClose) {
                    this.SUB_linkCleanerByAngle.mamesh = res;
                    //this.SUB_linkCleanerByAngle.vertexToPositioning=new mameshAroundComputations.PositioningComputerForMameshVertices(res).go()
                    this.SUB_linkCleanerByAngle.goChanging();
                }
                return res;
            };
            return ConcurrentMameshesGraterAndSticker;
        }());
        grateAndGlue.ConcurrentMameshesGraterAndSticker = ConcurrentMameshesGraterAndSticker;
        var FindCloseVerticesFast = (function () {
            function FindCloseVerticesFast(receivers, sources) {
                this.nbDistinctPoint = 1000;
                this.maxDistToBeClose = null;
                this.throwExceptionIfReceiverHaveCloseVertices = false;
                this.receiverAndSourceMustBeDisjoint = false;
                /**default: no deformation*/
                this.deformationFunction = function (point) { return point; };
                this.mins = new mathis.XYZ(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
                this.maxs = new mathis.XYZ(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
                this.receivers = receivers;
                this.sources = sources;
            }
            FindCloseVerticesFast.prototype.go = function () {
                this.buildScaler();
                var amplitude = new mathis.XYZ(Math.max(1, this.maxs.x - this.mins.x), Math.max(1, this.maxs.y - this.mins.y), Math.max(1, this.maxs.z - this.mins.z));
                var roundPositionToReceiver = new mathis.StringMap(); //: {[id:string]:number}={}
                for (var _i = 0, _a = this.receivers; _i < _a.length; _i++) {
                    var receiver = _a[_i];
                    var val = this.deformationFunction(receiver.position);
                    var resx = Math.round((val.x - this.mins.x) / amplitude.x * this.nbDistinctPoint);
                    var resy = Math.round((val.y - this.mins.y) / amplitude.y * this.nbDistinctPoint);
                    var resz = Math.round((val.z - this.mins.z) / amplitude.z * this.nbDistinctPoint);
                    var key = resx + ',' + resy + ',' + resz;
                    if (roundPositionToReceiver.getValue(key) == null)
                        roundPositionToReceiver.putValue(key, receiver);
                    else if (this.throwExceptionIfReceiverHaveCloseVertices)
                        throw 'the receiver list has several XYZ very close, and you have forbidden that';
                }
                var res = new mathis.HashMap(true); //:{[id:number]:number}={}
                for (var _b = 0, _c = this.sources; _b < _c.length; _b++) {
                    var source = _c[_b];
                    var val = this.deformationFunction(source.position);
                    var resx = Math.round((val.x - this.mins.x) / amplitude.x * this.nbDistinctPoint);
                    var resy = Math.round((val.y - this.mins.y) / amplitude.y * this.nbDistinctPoint);
                    var resz = Math.round((val.z - this.mins.z) / amplitude.z * this.nbDistinctPoint);
                    var receiverFounded = roundPositionToReceiver.getValue(resx + ',' + resy + ',' + resz);
                    if (receiverFounded != null) {
                        /** receiver and source can be the same list (ex : if we want to make a cylinder by bending a plan );
                         *  in this case, we do not want to associate each receiver to itself */
                        if (receiverFounded != source) {
                            var perhapsAList = res.getValue(receiverFounded);
                            if (perhapsAList == null)
                                res.putValue(source, [receiverFounded]);
                            else {
                                /**some source already found near this receiver: we must put the closes source in the first position*/
                                if (mathis.geo.distance(receiverFounded.position, source.position) < mathis.geo.distance(receiverFounded.position, perhapsAList[0].position)) {
                                    res.putValue(source, [receiverFounded].concat(perhapsAList));
                                }
                                else
                                    perhapsAList.push(receiverFounded);
                            }
                        }
                        else if (this.receiverAndSourceMustBeDisjoint)
                            throw "receiver-list and source-list are not disjoint, and you have forbidden that";
                    }
                }
                // for (let i=0; i<this.sourceList.length; i++){
                //     let val=this.deformationFunction(this.sourceList[i].position)
                //     let resx=Math.round( (val.x-this.mins.x)/ amplitude.x*this.nbDistinctPoint)
                //     let resy=Math.round( (val.y-this.mins.y)/amplitude.y*this.nbDistinctPoint)
                //     let resz=Math.round( (val.z-this.mins.z)/amplitude.z*this.nbDistinctPoint)
                //
                //     let receiverFounded:Vertex=recepteurBalises[resx+','+resy+','+resz]
                //     if (receiverFounded!=null){
                //         if ()
                //        
                //     }
                //     if (this.receiverAndSourceMustBeDisjoint)
                //    
                //     if (baliseIndex!=null   ){
                //         if (this.sourceEqualRecepter){
                //             /**to avoid i-> i when sourceEqualRecepter*/
                //             if (baliseIndex!= i) res[i]=baliseIndex
                //         }
                //         else res[i]=baliseIndex
                //     }
                //
                // }
                return res;
            };
            FindCloseVerticesFast.prototype.buildScaler = function () {
                var _this = this;
                this.receivers.forEach(function (vv) {
                    var v = _this.deformationFunction(vv.position);
                    if (v.x < _this.mins.x)
                        _this.mins.x = v.x;
                    if (v.y < _this.mins.y)
                        _this.mins.y = v.y;
                    if (v.z < _this.mins.z)
                        _this.mins.z = v.z;
                    if (v.x > _this.maxs.x)
                        _this.maxs.x = v.x;
                    if (v.y > _this.maxs.y)
                        _this.maxs.y = v.y;
                    if (v.z > _this.maxs.z)
                        _this.maxs.z = v.z;
                });
                this.sources.forEach(function (vv) {
                    var v = _this.deformationFunction(vv.position);
                    if (v.x < _this.mins.x)
                        _this.mins.x = v.x;
                    if (v.y < _this.mins.y)
                        _this.mins.y = v.y;
                    if (v.z < _this.mins.z)
                        _this.mins.z = v.z;
                    if (v.x > _this.maxs.x)
                        _this.maxs.x = v.x;
                    if (v.y > _this.maxs.y)
                        _this.maxs.y = v.y;
                    if (v.z > _this.maxs.z)
                        _this.maxs.z = v.z;
                });
                if (this.maxDistToBeClose != null) {
                    this.nbDistinctPoint = mathis.geo.distance(this.maxs, this.mins) / this.maxDistToBeClose;
                }
            };
            return FindCloseVerticesFast;
        }());
        grateAndGlue.FindCloseVerticesFast = FindCloseVerticesFast;
        var Merger = (function () {
            function Merger(receiverMamesh, sourceMamesh, map) {
                this.sourceEqualRecepter = false;
                this.cleanDoubleLinks = false;
                this.cleanDoubleSquareAndTriangles = true;
                this.cleanLinksCrossingSegmentMiddle = true;
                this.suppressSomeTriangleAndSquareSuperposition = false;
                this.mergeLink = true;
                this.mergeTrianglesAndSquares = true;
                this.mergeSegmentsMiddle = true;
                /**so that only the source is drawable*/
                this.destroySource = true;
                this.receiverMamesh = receiverMamesh;
                if (sourceMamesh == null || receiverMamesh == sourceMamesh) {
                    this.sourceMamesh = receiverMamesh;
                    this.sourceEqualRecepter = true;
                }
                else {
                    this.sourceMamesh = sourceMamesh;
                    this.sourceEqualRecepter = false;
                }
                if (map == null)
                    map = new FindCloseVerticesFast(this.receiverMamesh.vertices, this.sourceMamesh.vertices).go();
                this.merginMap = new mathis.HashMap(true);
                for (var _i = 0, _a = map.allEntries(); _i < _a.length; _i++) {
                    var entry = _a[_i];
                    this.merginMap.putValue(entry.key, entry.value[0]);
                }
                // if (mergingMap==null){
                //     this.buildMergingMap()
                //     this.merginMap=new FindCloseVerticesFast(this.receiverMamesh.vertices,this.sourceMamesh.vertices).go()
                //     console.log(this.merginMap)
                //
                // }
                // else {
                //     let entries=mergingMap.allEntries()
                //     if (entries.length==0) {
                //         logger.c( 'empty merging map')
                //         this.merginMap=new HashMap<Vertex,Vertex>(true)
                //     }
                //     else{
                //         if (entries[0].value instanceof Array){
                //             this.merginMap=new HashMap<Vertex,Vertex>(true)
                //             for (let entry of entries) this.merginMap.putValue(entry.key,entry.value[0])
                //         }
                //         else this.merginMap=<HashMap<Vertex,Vertex>> mergingMap
                //     }
                //
                //
                //
                // }
            }
            //associateLinksWhichBecameOppositeFromMerging = true
            /**if null, no association is made*/
            //maxAngleToAssociateOppositeLink=Math.PI*0.4
            Merger.prototype.checkArgs = function () {
                var _this = this;
                if (!this.merginMap.memorizeKeys)
                    throw 'the merging map must memorize the keys';
                this.merginMap.allValues().forEach(function (v) {
                    if (_this.merginMap.getValue(v) != null)
                        throw 'a vertex cannot be the destination and the source of a merging';
                });
            };
            /**do the merging, changing the entry*/
            Merger.prototype.goChanging = function () {
                this.checkArgs();
                if (this.mergeLink)
                    this.mergeVerticesAndLinks();
                else
                    this.mergeOnlyVertices();
                if (this.mergeTrianglesAndSquares)
                    this.letsMergeTrianglesAndSquares();
                if (this.mergeSegmentsMiddle)
                    this.mergeCutSegment();
                /**at the end, we rebuild paramToVertex, the third coordinate of parameter is changed to show the superposition */
                // this.receiverMamesh.paramToVertex = new HashMap<XYZ,Vertex>(true)
                // this.receiverMamesh.vertices.forEach(v=> {
                //     while (this.receiverMamesh.paramToVertex.getValue(v.param)!=null) {
                //         v.param.z++
                //     }
                //     this.receiverMamesh.paramToVertex.putValue(v.param, v)
                // })
                //this.receiverMamesh.clearOppositeInLinks()
                // if (this.maxAngleToAssociateOppositeLink!=null) {
                //     let oppositeLinkAssocier=new linkModule.OppositeLinkAssocierByAngles(this.receiverMamesh.vertices)
                //     oppositeLinkAssocier.maxAngleToAssociateLinks=this.maxAngleToAssociateOppositeLink
                //     oppositeLinkAssocier.goChanging()
                // }
                this.receiverMamesh.lines = null;
                if (this.destroySource && !this.sourceEqualRecepter)
                    this.sourceMamesh.vertices = null;
            };
            //
            // private buildMergingMap():void {
            //     let indexToMerge:{[key:number]:number}
            //
            //     this.merginMap = new HashMap<Vertex,Vertex>(true)
            //
            //     let positionsRecepter:XYZ[] = []
            //     this.receiverMamesh.vertices.forEach(v=> {
            //         positionsRecepter.push(v.position)
            //     })
            //
            //     if (this.sourceEqualRecepter) indexToMerge = new geometry.CloseXYZfinder(positionsRecepter,null,1000).go()
            //     else {
            //         let positionsSource:XYZ[] = []
            //         this.sourceMamesh.vertices.forEach(v=> {
            //             positionsSource.push(v.position)
            //         })
            //         indexToMerge = new geometry.CloseXYZfinder(positionsRecepter, positionsSource,1000).go()
            //     }
            //
            //
            //     for (let index in indexToMerge) {
            //         this.merginMap.putValue(this.sourceMamesh.vertices[index], this.receiverMamesh.vertices[indexToMerge[index]])
            //     }
            //
            // }
            Merger.prototype.mergeOnlyVertices = function () {
                var _this = this;
                if (!this.sourceEqualRecepter)
                    this.receiverMamesh.vertices = this.receiverMamesh.vertices.concat(this.sourceMamesh.vertices);
                this.receiverMamesh.clearLinksAndLines();
                /**suppression of the sources*/
                this.merginMap.allKeys().forEach(function (v) {
                    mathis.tab.removeFromArray(_this.receiverMamesh.vertices, v);
                });
            };
            //
            // private mergeVerticesAndLinksOld():void {
            //
            //
            //     if (!this.sourceEqualRecepter) this.receiverMamesh.vertices = this.receiverMamesh.vertices.concat(this.sourceMamesh.vertices)
            //
            //
            //     this.merginMap.allKeys().forEach(v1=> {
            //
            //         var linksThatWeKeep:Link[] = []
            //         v1.links.forEach(link=> {
            //             /**the links must not be composed with suppressed vertex*/
            //             if (this.merginMap.getValue(link.to) == null || (link.opposite != null && this.merginMap.getValue(link.opposite.to) == null )) {
            //                 /** the link must not be contracted into one vertex after merging*/
            //                 if (this.merginMap.getValue(v1) != link.to) linksThatWeKeep.push(link)
            //             }
            //         })
            //         this.merginMap.getValue(v1).links = this.merginMap.getValue(v1).links.concat(linksThatWeKeep)
            //     })
            //
            //
            //     /**suppression of  sources*/
            //     this.merginMap.allKeys().forEach(v=> {
            //         removeFromArray(this.receiverMamesh.vertices, v)
            //     })
            //
            //
            //     /**we change links everywhere where a vertex-to-merge appears*/
            //     this.receiverMamesh.vertices.forEach((v1:Vertex)=> {
            //
            //         var perhapsLinkToSuppress:Link[] = null
            //         v1.links.forEach(link=> {
            //             if (this.merginMap.getValue(link.to) != null) {
            //                 if (this.merginMap.getValue(link.to) != v1) link.to = this.merginMap.getValue(link.to)
            //                 else {
            //                     if (perhapsLinkToSuppress == null) perhapsLinkToSuppress = []
            //                     perhapsLinkToSuppress.push(link)
            //                 }
            //             }
            //             if (link.opposite != null) {
            //                 if (this.merginMap.getValue(link.opposite.to) != null) {
            //                     if (this.merginMap.getValue(link.opposite.to) != v1) link.opposite.to = this.merginMap.getValue(link.opposite.to)
            //                     else link.opposite = null
            //                 }
            //             }
            //         })
            //         if (perhapsLinkToSuppress != null) {
            //             perhapsLinkToSuppress.forEach(li=> {
            //                 removeFromArray(v1.links, li)
            //             })
            //         }
            //
            //     })
            //
            //
            //     /** suppression of double links  with opposite equal to itself*/
            //     if (this.cleanDoubleLinks) {
            //
            //         this.receiverMamesh.vertices.forEach(vertex=> {
            //
            //             for (let link of vertex.links) {
            //                 if (link.opposite != null && (link.opposite.to.hashNumber == vertex.hashNumber || link.opposite.to.hashNumber == link.to.hashNumber )) link.opposite = null
            //             }
            //
            //             let dico = new HashMap<Vertex,number[]>()
            //             for (let i = 0; i < vertex.links.length; i++) {
            //                 let vert = vertex.links[i].to
            //                 if (dico.getValue(vert) == null) dico.putValue(vert, new Array<number>())
            //                 dico.getValue(vert).push(i)
            //
            //             }
            //
            //
            //
            //             /**we prefer to keep vertex with double links*/
            //
            //             let indexLinkToKeep:number[]=[]
            //             dico.allValues().forEach(linkIndices=> {
            //
            //                 if (linkIndices.length==1) indexLinkToKeep.push(linkIndices[0])
            //                 else if (linkIndices.length > 1) {
            //
            //                     let oneWithOpposite = -1
            //                     for (let ind of linkIndices) {
            //                         if (vertex.links[ind].opposite != null) {
            //                             oneWithOpposite = ind
            //                             break
            //                         }
            //                     }
            //                     if (oneWithOpposite != -1) {
            //                         //removeFromArray(linkIndices, oneWithOpposite)
            //                         indexLinkToKeep.push(oneWithOpposite)
            //                     }
            //                     else {
            //                         //linkIndices.pop()
            //                         indexLinkToKeep.push(linkIndices[0])
            //                     }
            //
            //
            //                 }
            //
            //             })
            //             vertex.links = arrayKeepingSomeIndices<Link>(vertex.links, indexLinkToKeep)
            //
            //             /**we remove malformation which can appears when removing links*/
            //             vertex.links.forEach(link=> {
            //                 if (link.opposite != null) {
            //                     if (link.opposite.opposite == null || link.opposite.opposite.to.hashNumber != link.to.hashNumber) link.opposite = null
            //                 }
            //             })
            //
            //
            //         })
            //
            //
            //     }
            //
            //
            //     this.receiverMamesh.vertices.forEach(central=> {
            //         for (let link of central.links) {
            //             let oppositeLink=link.opposite
            //
            //             if (oppositeLink != null) {
            //
            //                 if (central.links.indexOf(oppositeLink)==-1)
            //
            //                     if (oppositeLink.opposite!=link) throw "opposite of  opposite do not give the same link"
            //
            //             }
            //
            //         }
            //
            //     })
            //
            //
            //
            //
            //
            //
            //
            // }
            Merger.prototype.mergeVerticesAndLinks = function () {
                var _this = this;
                if (!this.sourceEqualRecepter)
                    this.receiverMamesh.vertices = this.receiverMamesh.vertices.concat(this.sourceMamesh.vertices);
                /**first we clean all opposite (too hard to keep them, cf. Old procedure which too often create irregularities)*/
                this.receiverMamesh.clearOppositeInLinks();
                //     .vertices.forEach(v=>{
                //     v.links.forEach(l=>l.opposite=null)
                // })
                /**we add source-links to receivers, except some links */
                this.merginMap.allKeys().forEach(function (v1) {
                    var linksThatWeKeep = [];
                    v1.links.forEach(function (link) {
                        /**the links must not be composed with suppressed vertex*/
                        if (_this.merginMap.getValue(link.to) == null) {
                            /** the link must not be contracted into one vertex after merging*/
                            if (_this.merginMap.getValue(v1) != link.to)
                                linksThatWeKeep.push(link);
                        }
                    });
                    _this.merginMap.getValue(v1).links = _this.merginMap.getValue(v1).links.concat(linksThatWeKeep);
                });
                /**suppression of  sources*/
                var newVertices = [];
                this.receiverMamesh.vertices.forEach(function (v) {
                    if (_this.merginMap.allKeys().indexOf(v) == -1)
                        newVertices.push(v);
                });
                this.receiverMamesh.vertices = newVertices;
                // this.merginMap.allKeys().forEach(v=> {
                //     removeFromArray(this.recepterMamesh.vertices, v)
                // })
                /**we change links everywhere where a vertex-to-merge appears*/
                this.receiverMamesh.vertices.forEach(function (v1) {
                    var perhapsLinkToSuppress = null;
                    v1.links.forEach(function (link) {
                        if (_this.merginMap.getValue(link.to) != null) {
                            if (_this.merginMap.getValue(link.to) != v1)
                                link.to = _this.merginMap.getValue(link.to);
                            else {
                                if (perhapsLinkToSuppress == null)
                                    perhapsLinkToSuppress = [];
                                perhapsLinkToSuppress.push(link);
                            }
                        }
                        // if (link.opposite != null) {
                        //     if (this.merginMap.getValue(link.opposite.to) != null) {
                        //         if (this.merginMap.getValue(link.opposite.to) != v1) link.opposite.to = this.merginMap.getValue(link.opposite.to)
                        //         else link.opposite = null
                        //     }
                        // }
                    });
                    if (perhapsLinkToSuppress != null) {
                        perhapsLinkToSuppress.forEach(function (li) {
                            mathis.tab.removeFromArray(v1.links, li);
                        });
                    }
                });
                /** suppression of double links*/
                if (this.cleanDoubleLinks) {
                }
            };
            Merger.prototype.mergeCutSegment = function () {
                var _this = this;
                if (!this.sourceEqualRecepter) {
                    for (var key in this.sourceMamesh.cutSegmentsDico)
                        this.receiverMamesh.cutSegmentsDico[key] = this.sourceMamesh.cutSegmentsDico[key];
                }
                for (var key in this.receiverMamesh.cutSegmentsDico) {
                    var segment = this.receiverMamesh.cutSegmentsDico[key];
                    if (segment.a.hashNumber == segment.middle.hashNumber || segment.b.hashNumber == segment.middle.hashNumber || segment.a.hashNumber == segment.b.hashNumber) {
                        delete this.receiverMamesh.cutSegmentsDico[key];
                        continue;
                    }
                    var segmentIsModified = false;
                    if (this.merginMap.getValue(segment.a) != null) {
                        segment.a = this.merginMap.getValue(segment.a);
                        segmentIsModified = true;
                    }
                    if (this.merginMap.getValue(segment.b) != null) {
                        segment.b = this.merginMap.getValue(segment.b);
                        segmentIsModified = true;
                    }
                    if (this.merginMap.getValue(segment.middle) != null) {
                        segment.middle = this.merginMap.getValue(segment.middle);
                        segmentIsModified = true;
                    }
                    if (segmentIsModified) {
                        delete this.receiverMamesh.cutSegmentsDico[key];
                        this.receiverMamesh.cutSegmentsDico[mathis.Segment.segmentId(segment.a.hashNumber, segment.b.hashNumber)] = segment;
                    }
                }
                if (this.cleanLinksCrossingSegmentMiddle) {
                    this.receiverMamesh.vertices.forEach(function (v) {
                        var linkToDelete = [];
                        for (var i = 0; i < v.links.length; i++) {
                            var link = v.links[i];
                            if (_this.receiverMamesh.cutSegmentsDico[mathis.Segment.segmentId(v.hashNumber, link.to.hashNumber)] != null)
                                linkToDelete.push(i);
                        }
                        v.links = mathis.tab.arrayMinusBlocksIndices(v.links, linkToDelete, 1);
                    });
                }
            };
            Merger.prototype.letsMergeTrianglesAndSquares = function () {
                /**addition source triangulatedRect and square*/
                if (!this.sourceEqualRecepter) {
                    this.receiverMamesh.smallestSquares = this.receiverMamesh.smallestSquares.concat(this.sourceMamesh.smallestSquares);
                    this.receiverMamesh.smallestTriangles = this.receiverMamesh.smallestTriangles.concat(this.sourceMamesh.smallestTriangles);
                }
                /**changing triangulatedRect;  perhaps deleted*/
                for (var i = 0; i < this.receiverMamesh.smallestTriangles.length; i++) {
                    var vert = this.receiverMamesh.smallestTriangles[i];
                    if (this.merginMap.getValue(vert) != null)
                        this.receiverMamesh.smallestTriangles[i] = this.merginMap.getValue(vert);
                }
                var triangleToSuppress = [];
                for (var i = 0; i < this.receiverMamesh.smallestTriangles.length; i += 3) {
                    if (this.receiverMamesh.smallestTriangles[i] == this.receiverMamesh.smallestTriangles[i + 1] || this.receiverMamesh.smallestTriangles[i + 1] == this.receiverMamesh.smallestTriangles[i + 2] || this.receiverMamesh.smallestTriangles[i + 2] == this.receiverMamesh.smallestTriangles[i]) {
                        triangleToSuppress.push(i);
                    }
                }
                this.receiverMamesh.smallestTriangles = mathis.tab.arrayMinusBlocksIndices(this.receiverMamesh.smallestTriangles, triangleToSuppress, 3);
                /**to remove doublon*/
                this.receiverMamesh.smallestTriangles = new mathis.tab.ArrayMinusBlocksElements(this.receiverMamesh.smallestTriangles, 3).go();
                /**changing square; perhaps into triangulatedRect; perhaps deleted*/
                for (var i = 0; i < this.receiverMamesh.smallestSquares.length; i++) {
                    var vert = this.receiverMamesh.smallestSquares[i];
                    if (this.merginMap.getValue(vert) != null)
                        this.receiverMamesh.smallestSquares[i] = this.merginMap.getValue(vert);
                }
                var squareToSuppress = [];
                for (var i = 0; i < this.receiverMamesh.smallestSquares.length; i += 4) {
                    var changedSquare = this.changeOneSquare([this.receiverMamesh.smallestSquares[i], this.receiverMamesh.smallestSquares[i + 1], this.receiverMamesh.smallestSquares[i + 2], this.receiverMamesh.smallestSquares[i + 3]]);
                    if (changedSquare == null) {
                        squareToSuppress.push(i);
                    }
                    else if (changedSquare.length == 3) {
                        this.receiverMamesh.smallestTriangles.push(changedSquare[0], changedSquare[1], changedSquare[2]);
                        squareToSuppress.push(i);
                    }
                }
                this.receiverMamesh.smallestSquares = mathis.tab.arrayMinusBlocksIndices(this.receiverMamesh.smallestSquares, squareToSuppress, 4);
                /**to remove doublon*/
                if (this.cleanDoubleSquareAndTriangles)
                    this.receiverMamesh.smallestSquares = new mathis.tab.ArrayMinusBlocksElements(this.receiverMamesh.smallestSquares, 4).go();
                if (this.suppressSomeTriangleAndSquareSuperposition) {
                    /**to remove triangulatedRect which superpose with square*/
                    var triInSquare = new mathis.StringMap();
                    for (var i = 0; i < this.receiverMamesh.smallestSquares.length; i += 4) {
                        triInSquare.putValue(mathis.tab.indicesUpPermutationToString([this.receiverMamesh.smallestSquares[i].hashNumber, this.receiverMamesh.smallestSquares[i + 1].hashNumber, this.receiverMamesh.smallestSquares[i + 2].hashNumber]), true);
                        triInSquare.putValue(mathis.tab.indicesUpPermutationToString([this.receiverMamesh.smallestSquares[i + 2].hashNumber, this.receiverMamesh.smallestSquares[i + 3].hashNumber, this.receiverMamesh.smallestSquares[i].hashNumber]), true);
                        triInSquare.putValue(mathis.tab.indicesUpPermutationToString([this.receiverMamesh.smallestSquares[i].hashNumber, this.receiverMamesh.smallestSquares[i + 1].hashNumber, this.receiverMamesh.smallestSquares[i + 3].hashNumber]), true);
                        triInSquare.putValue(mathis.tab.indicesUpPermutationToString([this.receiverMamesh.smallestSquares[i + 1].hashNumber, this.receiverMamesh.smallestSquares[i + 2].hashNumber, this.receiverMamesh.smallestSquares[i + 3].hashNumber]), true);
                    }
                    var triToSupp = [];
                    for (var i = 0; i < this.receiverMamesh.smallestTriangles.length; i += 3) {
                        var key = mathis.tab.indicesUpPermutationToString([this.receiverMamesh.smallestTriangles[i].hashNumber, this.receiverMamesh.smallestTriangles[i + 1].hashNumber, this.receiverMamesh.smallestTriangles[i + 2].hashNumber]);
                        if (triInSquare.getValue(key)) {
                            triToSupp.push(i, i + 1, i + 2);
                        }
                    }
                    this.receiverMamesh.smallestTriangles = mathis.tab.arrayMinusBlocksIndices(this.receiverMamesh.smallestTriangles, triToSupp, 3);
                    /** remove square which superpose with square : two of the edge of the first are the diagonal of the second. We remove half of the first*/
                    var diago = new mathis.StringMap();
                    for (var i = 0; i < this.receiverMamesh.smallestSquares.length; i += 4) {
                        diago.putValue(mathis.tab.indicesUpPermutationToString([this.receiverMamesh.smallestSquares[i].hashNumber, this.receiverMamesh.smallestSquares[i + 2].hashNumber]), true);
                        diago.putValue(mathis.tab.indicesUpPermutationToString([this.receiverMamesh.smallestSquares[i + 1].hashNumber, this.receiverMamesh.smallestSquares[i + 3].hashNumber]), true);
                    }
                    var squareToRemove = [];
                    var triToAdd = [];
                    for (var i = 0; i < this.receiverMamesh.smallestSquares.length; i += 4) {
                        for (var k = 0; k < 4; k++) {
                            var edge0 = [this.receiverMamesh.smallestSquares[i + k].hashNumber, this.receiverMamesh.smallestSquares[i + (k + 1) % 4].hashNumber];
                            var edge1 = [this.receiverMamesh.smallestSquares[i + (k + 1) % 4].hashNumber, this.receiverMamesh.smallestSquares[i + (k + 2) % 4].hashNumber];
                            if (diago.getValue(mathis.tab.indicesUpPermutationToString(edge0)) && diago.getValue(mathis.tab.indicesUpPermutationToString(edge1))) {
                                squareToRemove.push(i, i + 1, i + 2, i + 3);
                                triToAdd.push(this.receiverMamesh.smallestSquares[i + (k + 2) % 4], this.receiverMamesh.smallestSquares[i + (k + 3) % 4], this.receiverMamesh.smallestSquares[i + k % 4]);
                            }
                        }
                    }
                    if (triToAdd.length > 0) {
                        this.receiverMamesh.smallestSquares = mathis.tab.arrayMinusBlocksIndices(this.receiverMamesh.smallestSquares, squareToRemove, 4);
                        this.receiverMamesh.smallestTriangles = this.receiverMamesh.smallestTriangles.concat(triToAdd);
                    }
                }
            };
            Merger.prototype.changeOneSquare = function (square) {
                if (square[0] == square[2] || square[1] == square[3])
                    return null;
                var indexOfCollabsed = null;
                var nbOfCollapsed = 0;
                for (var i = 0; i < 4; i++) {
                    if (square[i] == square[(i + 1) % 4]) {
                        nbOfCollapsed++;
                        indexOfCollabsed = i;
                    }
                }
                if (nbOfCollapsed == 0)
                    return square;
                if (nbOfCollapsed > 1)
                    return null;
                if (indexOfCollabsed == 0)
                    return [square[1], square[2], square[3]];
                if (indexOfCollabsed == 1)
                    return [square[2], square[3], square[0]];
                if (indexOfCollabsed == 2)
                    return [square[3], square[0], square[1]];
                if (indexOfCollabsed == 3)
                    return [square[0], square[1], square[2]];
            };
            return Merger;
        }());
        grateAndGlue.Merger = Merger;
        /**TODO add new polygon where we stick
         * we need to use the links sorting before*/
        var Sticker = (function () {
            // constructor(mamesh0:Mamesh,mamesh1:Mamesh,stickingMap:HashMap<Vertex,Vertex[]>|HashMap<Vertex,Vertex>){
            //
            //     if (mamesh0==mamesh1 || mamesh1==null) this.twoMameshes=false
            //
            //     this.mamesh0=mamesh0
            //
            //     if(this.twoMameshes) this.mamesh1=mamesh1
            //     else this.mamesh1=null
            //
            //     let entries=stickingMap.allEntries()
            //     if (entries.length==0) {
            //         logger.c('empty sticking map')
            //         this.stickingMap=new HashMap<Vertex,Vertex[]>(true)
            //     }
            //     else{
            //         if (!(entries[0].value instanceof Array)){
            //             this.stickingMap=new HashMap<Vertex,Vertex[]>(true)
            //             for (let entry of entries) {
            //                 let value=<Vertex> entry.value
            //                 this.stickingMap.putValue(entry.key,[value])
            //             }
            //         }
            //         else this.stickingMap=<HashMap<Vertex,Vertex[]>> stickingMap
            //     }
            //
            //
            //
            // }
            function Sticker(mamesh0, mamesh1, stickingMap) {
                this.createNewLinks = true;
                this.cleanOppositeLinksAtBegin = true;
                this.twoMameshes = true;
                this.zIndex1 = Math.random();
                if (mamesh0 == mamesh1 || mamesh1 == null)
                    this.twoMameshes = false;
                this.mamesh0 = mamesh0;
                if (this.twoMameshes)
                    this.mamesh1 = mamesh1;
                else
                    this.mamesh1 = null;
                this.stickingMap = stickingMap;
                // let entries=stickingMap.allEntries()
                // if (entries.length==0) {
                //     logger.c('empty sticking map')
                //     this.stickingMap=new HashMap<Vertex,Vertex[]>(true)
                // }
                // else{
                //     if (!(entries[0].value instanceof Array)){
                //         this.stickingMap=new HashMap<Vertex,Vertex[]>(true)
                //         for (let entry of entries) {
                //             let value=<Vertex> entry.value
                //             this.stickingMap.putValue(entry.key,[value])
                //         }
                //     }
                //     else this.stickingMap=<HashMap<Vertex,Vertex[]>> stickingMap
                // }
            }
            Sticker.prototype.checkArgs = function () {
                if (!this.stickingMap.memorizeKeys)
                    throw 'the sticking map must memorize the keys';
                for (var _i = 0, _a = this.stickingMap.allValues(); _i < _a.length; _i++) {
                    var vs = _a[_i];
                    for (var _b = 0, vs_1 = vs; _b < vs_1.length; _b++) {
                        var v = vs_1[_b];
                        if (this.stickingMap.getValue(v) != null)
                            throw 'a vertex cannot be the destination and the source of a sticking';
                    }
                }
            };
            Sticker.prototype.goChanging = function () {
                if (this.stickingMap.allKeys().length == 0)
                    return;
                this.checkArgs();
                if (this.cleanOppositeLinksAtBegin) {
                    this.mamesh0.clearOppositeInLinks();
                    if (this.twoMameshes)
                        this.mamesh1.clearOppositeInLinks();
                }
                if (this.twoMameshes) {
                    for (var _i = 0, _a = this.mamesh1.vertices; _i < _a.length; _i++) {
                        var ve = _a[_i];
                        ve.param.z = this.zIndex1;
                        this.mamesh0.addVertex(ve);
                    }
                    this.mamesh0.smallestSquares = this.mamesh0.smallestSquares.concat(this.mamesh1.smallestSquares);
                    this.mamesh0.smallestTriangles = this.mamesh0.smallestTriangles.concat(this.mamesh1.smallestTriangles);
                }
                this.mamesh0.cutSegmentsDico = {};
                this.mamesh0.vertexToPositioning = null;
                this.mamesh0.lines = null;
                if (this.createNewLinks) {
                    for (var _b = 0, _c = this.stickingMap.allKeys(); _b < _c.length; _b++) {
                        var vSource = _c[_b];
                        for (var _d = 0, _e = this.stickingMap.getValue(vSource); _d < _e.length; _d++) {
                            var vReceiver = _e[_d];
                            vSource.setOneLink(vReceiver);
                            vReceiver.setOneLink(vSource);
                        }
                    }
                }
            };
            return Sticker;
        }());
        grateAndGlue.Sticker = Sticker;
    })(grateAndGlue = mathis.grateAndGlue || (mathis.grateAndGlue = {}));
})(mathis || (mathis = {}));
/**
 * Created by vigon on 21/04/2016.
 */
var mathis;
(function (mathis) {
    function nCanvasInOneLine(n, $containter) {
        var res = [];
        var width = mathis.roundWithGivenPrecision(100 / n, 2) + "%";
        for (var i = 0; i < n; i++) {
            var canvas = document.createElement('canvas');
            canvas.id = "renderCanvas" + i;
            //canvas.width  = 200;
            //canvas.height = 200*i;
            //canvas.style.zIndex   = 8;
            //canvas.style.position = "relative";
            //canvas.style.border   = "1px solid";
            canvas.style.width = width;
            canvas.style.height = "100%";
            canvas.style.backgroundColor = "red";
            $containter.appendChild(canvas);
            res.push(canvas);
        }
        return res;
    }
    mathis.nCanvasInOneLine = nCanvasInOneLine;
    function nDivInOneLine(n, $containter, separatorCSS) {
        var divs = [];
        $containter.style.position = "relative";
        var width = mathis.roundWithGivenPrecision(100 / n, 4);
        for (var i = 0; i < n; i++) {
            var div = document.createElement('div');
            div.id = "divContainer" + i;
            div.style.display = "inline-block";
            div.style.position = "absolute";
            div.style.top = "0";
            div.style.left = (i * width) + "%";
            div.style.width = width + "%";
            div.style.height = "100%";
            //div.style.backgroundColor="red"
            if (separatorCSS != null && i > 0)
                div.style.borderLeft = separatorCSS;
            $containter.appendChild(div);
            divs.push(div);
        }
        return divs;
    }
    mathis.nDivInOneLine = nDivInOneLine;
    function nDivContainningCanvasInOneLine(n, $containter, separatorCSS) {
        var canvass = [];
        var divs = [];
        $containter.style.position = "relative";
        var width = mathis.roundWithGivenPrecision(100 / n, 4);
        for (var i = 0; i < n; i++) {
            var div = document.createElement('div');
            div.id = "divContainer" + i;
            div.style.display = "inline-block";
            div.style.position = "absolute";
            div.style.top = "0";
            div.style.left = (i * width) + "%";
            div.style.width = width + "%";
            div.style.height = "100%";
            //div.style.backgroundColor="red"
            if (separatorCSS != null && i > 0)
                div.style.borderLeft = separatorCSS;
            $containter.appendChild(div);
            divs.push(div);
            var canvas = document.createElement('canvas');
            canvas.id = "renderCanvas" + i;
            canvas.style.width = "100%";
            canvas.style.height = "100%";
            //canvas.style.backgroundColor="red"
            div.appendChild(canvas);
            canvass.push(canvas);
        }
        return { divs: divs, canvass: canvass };
    }
    mathis.nDivContainningCanvasInOneLine = nDivContainningCanvasInOneLine;
    function legend(heightCSS, $container, bottom, separatorCSS) {
        if (bottom === void 0) { bottom = true; }
        var div = document.createElement('div');
        div.style.display = "inline-block";
        div.style.position = "absolute";
        if (bottom)
            div.style.bottom = "0";
        else
            div.style.top = "0";
        div.style.left = "0";
        div.style.width = "100%";
        div.style.height = heightCSS;
        div.style.zIndex = (parseInt($container.style.zIndex) + 10) + "";
        //div.style.backgroundColor="red"
        if (separatorCSS != null)
            div.style.borderTop = separatorCSS;
        $container.appendChild(div);
        return div;
        // position: absolute;
        // height: 20px;
        // width: 100%;
        // left: 0;
        // bottom: 0;
    }
    mathis.legend = legend;
})(mathis || (mathis = {}));
/**
 * Created by vigon on 16/12/2015.
 */
var mathis;
(function (mathis) {
    function allIntegerValueOfEnume(MyEnum) {
        var res = [];
        for (var prop in MyEnum) {
            if (MyEnum.hasOwnProperty(prop)) {
                var i = parseInt(prop);
                if (!isNaN(i))
                    res.push(i);
            }
        }
        return res;
    }
    mathis.allIntegerValueOfEnume = allIntegerValueOfEnume;
    function allStringValueOfEnume(MyEnum) {
        var res = [];
        for (var prop in MyEnum) {
            if (MyEnum.hasOwnProperty(prop) &&
                (isNaN(parseInt(prop)))) {
                res.push(prop);
            }
        }
        return res;
    }
    mathis.allStringValueOfEnume = allStringValueOfEnume;
    /**logging*/
    var Logger = (function () {
        function Logger() {
            this.showTrace = false;
            this.alreadyWroteWarning = [];
        }
        Logger.prototype.c = function (message, maxTimesFired) {
            if (maxTimesFired === void 0) { maxTimesFired = 1; }
            if (this.alreadyWroteWarning[message] != null)
                this.alreadyWroteWarning[message]++;
            else
                this.alreadyWroteWarning[message] = 1;
            if (this.alreadyWroteWarning[message] <= maxTimesFired) {
                if (this.showTrace) {
                    var err = new Error();
                    console.log("WARNING", message, '...........................................', err);
                }
                else {
                    console.log("WARNING", message);
                }
            }
        };
        return Logger;
    }());
    mathis.Logger = Logger;
    function roundWithGivenPrecision(value, nbDecimal) {
        value *= Math.pow(10, nbDecimal);
        value = Math.round(value);
        value /= Math.pow(10, nbDecimal);
        return value;
    }
    mathis.roundWithGivenPrecision = roundWithGivenPrecision;
    function applyMixins(derivedCtor, baseCtors) {
        baseCtors.forEach(function (baseCtor) {
            Object.getOwnPropertyNames(baseCtor.prototype).forEach(function (name) {
                if (name !== 'constructor') {
                    derivedCtor.prototype[name] = baseCtor.prototype[name];
                }
            });
        });
    }
    mathis.applyMixins = applyMixins;
    /** from http://www.javascripter.net/faq/stylesc.htm
     *
     auto        move           no-drop      col-resize
     all-scroll  pointer        not-allowed  row-resize
     crosshair   progress       e-resize     ne-resize
     default     text           n-resize     nw-resize
     help        vertical-text  s-resize     se-resize
     inherit     wait           w-resize     sw-resize
     * */
    function setCursorByID(id, cursorStyle) {
        var elem;
        if (document.getElementById &&
            (elem = document.getElementById(id))) {
            if (elem.style)
                elem.style.cursor = cursorStyle;
        }
    }
    mathis.setCursorByID = setCursorByID;
    var Bilan = (function () {
        function Bilan() {
            this.millisDuration = 0;
            this.nbTested = 0;
            this.nbOK = 0;
            this.millisDep = performance.now();
        }
        Bilan.prototype.computeTime = function () {
            this.millisDuration = performance.now() - this.millisDep;
        };
        Bilan.prototype.add = function (bilan) {
            bilan.computeTime();
            this.nbTested += bilan.nbTested;
            this.nbOK += bilan.nbOK;
            this.millisDuration += bilan.millisDuration;
        };
        Bilan.prototype.assertTrue = function (ok) {
            this.nbTested++;
            if (ok)
                this.nbOK++;
            else {
                var e = new Error();
                console.log(e.stack);
            }
        };
        Bilan.prototype.toString = function () {
            return 'nbTest:' + this.nbTested + ', nbOK:' + this.nbOK + ', millisDuration:' + this.millisDuration.toFixed(2);
        };
        return Bilan;
    }());
    mathis.Bilan = Bilan;
    function modulo(i, n, centered) {
        if (centered === void 0) { centered = false; }
        if (n < 0)
            throw 'second arg must be positif';
        var res = 0;
        if (i >= 0)
            res = i % n;
        else
            res = n - (-i) % n;
        if (centered && res > n / 2)
            res = res - n;
        if (Math.abs(res - n) < Number.MIN_VALUE * 10)
            res = 0;
        return res;
    }
    mathis.modulo = modulo;
    /**Fisher-Yates shuffle*/
    function shuffle(array) {
        var counter = array.length, temp, index;
        // While there are elements in the array
        while (counter > 0) {
            // Pick a random index
            index = Math.floor(Math.random() * counter);
            // Decrease counter by 1
            counter--;
            // And swap the last element with it
            temp = array[counter];
            array[counter] = array[index];
            array[index] = temp;
        }
        return array;
    }
    mathis.shuffle = shuffle;
    var Entry = (function () {
        function Entry(key, value) {
            this.key = key;
            this.value = value;
        }
        return Entry;
    }());
    mathis.Entry = Entry;
    var HashMap = (function () {
        function HashMap(memorizeKeys) {
            if (memorizeKeys === void 0) { memorizeKeys = false; }
            this.values = {};
            this.keys = {};
            this.memorizeKeys = memorizeKeys;
        }
        HashMap.prototype.putValue = function (key, value, nullKeyForbidden) {
            if (nullKeyForbidden === void 0) { nullKeyForbidden = true; }
            if (key == null) {
                if (nullKeyForbidden)
                    throw 'key must be non null';
                else
                    return null;
            }
            this.values[key.hashString] = value;
            if (this.memorizeKeys)
                this.keys[key.hashString] = key;
        };
        HashMap.prototype.removeKey = function (key) {
            delete this.values[key.hashString];
            if (this.memorizeKeys)
                delete this.keys[key.hashString];
        };
        HashMap.prototype.getValue = function (key, nullKeyForbidden) {
            if (nullKeyForbidden === void 0) { nullKeyForbidden = true; }
            if (key == null) {
                if (nullKeyForbidden)
                    throw 'key must be non null';
                else
                    return null;
            }
            return this.values[key.hashString];
        };
        HashMap.prototype.allValues = function () {
            var res = new Array();
            for (var index in this.values)
                res.push(this.values[index]);
            return res;
        };
        HashMap.prototype.allKeys = function () {
            if (!this.memorizeKeys)
                throw 'this hashMap has not memorized keys. Please, put args=true in the constructor';
            var res = new Array();
            for (var index in this.keys)
                res.push(this.keys[index]);
            return res;
        };
        HashMap.prototype.allEntries = function () {
            if (!this.memorizeKeys)
                throw 'this hashMap has not memorized keys. Please, put args=true in the constructor';
            var res = [];
            for (var index in this.keys)
                res.push(new Entry(this.keys[index], this.values[index]));
            return res;
        };
        HashMap.prototype.extend = function (otherHashMap) {
            if (!otherHashMap.memorizeKeys)
                throw "cannot extend this  with a HashMap which do not memorize keys";
            for (var _i = 0, _a = otherHashMap.allEntries(); _i < _a.length; _i++) {
                var entry = _a[_i];
                this.putValue(entry.key, entry.value);
            }
        };
        HashMap.prototype.size = function () {
            var res = 0;
            for (var key in this.values)
                res++;
            return res;
        };
        return HashMap;
    }());
    mathis.HashMap = HashMap;
    var StringMap = (function () {
        function StringMap() {
            this.values = {};
        }
        StringMap.prototype.putValue = function (key, value, nullKeyForbidden) {
            if (nullKeyForbidden === void 0) { nullKeyForbidden = true; }
            if (key == null) {
                if (nullKeyForbidden)
                    throw 'key must be non null';
                else
                    return null;
            }
            this.values[key] = value;
        };
        StringMap.prototype.removeKey = function (key) {
            delete this.values[key];
        };
        StringMap.prototype.getValue = function (key, nullKeyForbidden) {
            if (nullKeyForbidden === void 0) { nullKeyForbidden = true; }
            if (key == null) {
                if (nullKeyForbidden)
                    throw 'key must be non null';
                else
                    return null;
            }
            return this.values[key];
        };
        StringMap.prototype.allValues = function () {
            var res = new Array();
            for (var index in this.values)
                res.push(this.values[index]);
            return res;
        };
        StringMap.prototype.allKeys = function () {
            var res = [];
            for (var key in this.values)
                res.push(key);
            return res;
        };
        StringMap.prototype.size = function () {
            var res = 0;
            for (var key in this.values)
                res++;
            return res;
        };
        return StringMap;
    }());
    mathis.StringMap = StringMap;
})(mathis || (mathis = {}));
/**
 * Created by vigon on 10/08/2016.
 */
var mathis;
(function (mathis) {
    var lineModule;
    (function (lineModule) {
        var LineComputer = (function () {
            function LineComputer(mamesh) {
                this.cannotOverwriteExistingLines = true;
                this.startingVertices = null;
                this.restrictLinesToTheseVertices = null;
                this.lookAtBifurcation = true;
                this.mamesh = mamesh;
            }
            LineComputer.prototype.go = function () {
                if (this.mamesh == null)
                    throw ' a null mamesh';
                if (this.mamesh.vertices == null || this.mamesh.vertices.length == 0)
                    'no vertices in this mamesh';
                if (this.mamesh.linesWasMade && this.cannotOverwriteExistingLines)
                    throw 'lines already exist for this mamesh';
                if (this.startingVertices == null)
                    this.startingVertices = this.mamesh.vertices;
                var res = makeLineCatalogue2(this.startingVertices, this.lookAtBifurcation);
                if (this.restrictLinesToTheseVertices != null) {
                    var cutter = new LinesCuter(res, this.restrictLinesToTheseVertices);
                    res = cutter.go();
                }
                this.mamesh.lines = res;
                return res;
            };
            return LineComputer;
        }());
        lineModule.LineComputer = LineComputer;
        var LinesCuter = (function () {
            function LinesCuter(lines, vertices) {
                this.lines = lines;
                this.vertices = vertices;
            }
            LinesCuter.prototype.go = function () {
                var _this = this;
                this.allPresentVertices = new mathis.HashMap();
                for (var _i = 0, _a = this.vertices; _i < _a.length; _i++) {
                    var v = _a[_i];
                    this.allPresentVertices.putValue(v, true);
                }
                var res = [];
                this.lines.forEach(function (line) {
                    if (!line.isLoop) {
                        var linesAsVertex = _this.cutOneLine(line.vertices);
                        for (var _i = 0, linesAsVertex_1 = linesAsVertex; _i < linesAsVertex_1.length; _i++) {
                            var l = linesAsVertex_1[_i];
                            res.push(new mathis.Line(l, false));
                        }
                    }
                });
                this.lines.forEach(function (li) {
                    if (li.isLoop) {
                        var line = li.vertices;
                        var firstIndexWithHole = -1;
                        for (var i = 0; i < line.length; i++) {
                            if (_this.allPresentVertices.getValue(line[i]) == null) {
                                firstIndexWithHole = i;
                                break;
                            }
                        }
                        /**not cutted loop line*/
                        if (firstIndexWithHole == -1)
                            res.push(li);
                        else {
                            var shiftedLine = [];
                            for (var j = 0; j < line.length; j++) {
                                shiftedLine.push(line[(j + firstIndexWithHole) % line.length]);
                            }
                            var linesAsVertex = _this.cutOneLine(shiftedLine);
                            for (var _i = 0, linesAsVertex_2 = linesAsVertex; _i < linesAsVertex_2.length; _i++) {
                                var l = linesAsVertex_2[_i];
                                res.push(new mathis.Line(l, false));
                            }
                        }
                    }
                });
                return res;
            };
            LinesCuter.prototype.cutOneLine = function (path) {
                var allLittlePath = [];
                allLittlePath[0] = [];
                var currentPathIndex = -1;
                var previousWasZero = true;
                for (var i = 0; i < path.length; i++) {
                    if (this.allPresentVertices.getValue(path[i]) == true) {
                        if (!previousWasZero)
                            allLittlePath[currentPathIndex].push(path[i]);
                        else {
                            currentPathIndex++;
                            allLittlePath[currentPathIndex] = [];
                            allLittlePath[currentPathIndex].push(path[i]);
                            previousWasZero = false;
                        }
                    }
                    else {
                        previousWasZero = true;
                    }
                }
                var allLittlePathCleaned = [];
                allLittlePath.forEach(function (li) {
                    if (li.length >= 2)
                        allLittlePathCleaned.push(li);
                });
                // let lastLineAdded=allLittlePath.pop()
                // if (lastLineAdded.length==1){
                //     let lastVertex=path[path.length-1]
                //     if(this.IN_mamesh.paramToVertex.getValue(lastVertex.param)!=null&& lastVertex.hasVoisin(lastLineAdded[lastLineAdded.length-1]) ){
                //         lastLineAdded.push(lastVertex)
                //         allLittlePath.push(lastLineAdded)
                //     }
                // }
                // else if (lastLineAdded.length>1){
                //     let lastVertex=path[path.length-1]
                //     if(this.IN_mamesh.paramToVertex.getValue(lastVertex.param)!=null){
                //         lastLineAdded.push(lastVertex)
                //         allLittlePath.push(lastLineAdded)
                //     }
                // }
                return allLittlePathCleaned;
            };
            return LinesCuter;
        }());
        lineModule.LinesCuter = LinesCuter;
        function makeLineCatalogue2(magraph, lookAtBifurcations) {
            var segmentsAlreadySeen = new mathis.HashMap();
            var lines = [];
            function addOneSegment(isLoop, lineInConstruction, segmentsAlreadySeenInTheBuildLine, hasBifurcate) {
                var last = lineInConstruction[lineInConstruction.length - 1];
                var beforeLast = lineInConstruction[lineInConstruction.length - 2];
                segmentsAlreadySeen.putValue(new mathis.Segment(beforeLast, last), true);
                var opposites = last.getOpposites(beforeLast);
                /**end of line*/
                if (opposites == null) {
                    if (isLoop)
                        throw 'a loop line which not loop';
                    lines.push(new mathis.Line(lineInConstruction, false));
                }
                else if (opposites.length == 0)
                    throw 'convention: is no opposite, the array opposite must be null, and not empty';
                else if (segmentsAlreadySeenInTheBuildLine.getValue(new mathis.Segment(beforeLast, last)) == true) {
                    lines.push(new mathis.Line(lineInConstruction, false));
                }
                else {
                    segmentsAlreadySeenInTheBuildLine.putValue(new mathis.Segment(beforeLast, last), true);
                    var nbOp = opposites.length;
                    if (!lookAtBifurcations)
                        nbOp = 1;
                    for (var i = 0; i < nbOp; i++) {
                        var opposite = opposites[i];
                        if (opposite == lineInConstruction[0]) {
                            //if (!isLoop) logger.c('a li')
                            lines.push(new mathis.Line(lineInConstruction, true));
                            segmentsAlreadySeen.putValue(new mathis.Segment(last, lineInConstruction[0]), true);
                        }
                        else {
                            if (i < nbOp - 1) {
                                var copySegmentsAlreadySeenIn = new mathis.HashMap();
                                for (var i_1 = 0; i_1 < lineInConstruction.length - 1; i_1++)
                                    copySegmentsAlreadySeenIn.putValue(new mathis.Segment(lineInConstruction[i_1], lineInConstruction[i_1 + 1]), true);
                                var copyLineInConstruction = lineInConstruction.concat([opposite]);
                                addOneSegment(isLoop, copyLineInConstruction, copySegmentsAlreadySeenIn, true);
                            }
                            else {
                                lineInConstruction.push(opposite);
                                addOneSegment(isLoop, lineInConstruction, segmentsAlreadySeenInTheBuildLine, hasBifurcate);
                            }
                        }
                    }
                }
            }
            /** we look for the starts of straight lines */
            magraph.forEach(function (cell) {
                cell.links.forEach(function (nei) {
                    if (nei.opposites == null) {
                        if (lookAtBifurcations || segmentsAlreadySeen.getValue(new mathis.Segment(cell, nei.to)) == null) {
                            var lineInConstruction = [cell, nei.to];
                            var segmentAlreadySeenInThisBuildLine = new mathis.HashMap();
                            addOneSegment(false, lineInConstruction, segmentAlreadySeenInThisBuildLine, false);
                        }
                    }
                });
            });
            /**when we look at bifurcation, we create several times the sames lines*/
            if (lookAtBifurcations) {
                var lineDico = new mathis.HashMap();
                var straightWithoutRepetitions = [];
                for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {
                    var line = lines_1[_i];
                    if (lineDico.getValue(line) == null)
                        straightWithoutRepetitions.push(line);
                    lineDico.putValue(line, true);
                }
                lines = straightWithoutRepetitions;
            }
            /**Now, only loop lines  remain*/
            magraph.forEach(function (cell) {
                cell.links.forEach(function (nei) {
                    /**Contrary to straight line, when we look for bifurcation, we do not start a line from a segment already seen: this would create too much equivalents lines */
                    if (segmentsAlreadySeen.getValue(new mathis.Segment(cell, nei.to)) == null) {
                        var lineInConstruction = [cell, nei.to];
                        var segmentAlreadySeenInThisBuildLine = new mathis.HashMap();
                        addOneSegment(true, lineInConstruction, segmentAlreadySeenInThisBuildLine, false);
                    }
                });
            });
            return lines;
        }
        lineModule.makeLineCatalogue2 = makeLineCatalogue2;
        var PackSegment = (function (_super) {
            __extends(PackSegment, _super);
            function PackSegment() {
                _super.call(this, true);
            }
            return PackSegment;
        }(mathis.HashMap));
        //TODO separer en 2 classes
        var CreateAColorIndexRespectingBifurcationsAndSymmetries = (function () {
            function CreateAColorIndexRespectingBifurcationsAndSymmetries(mamesh) {
                this.packSymmetricLines = true;
                this.forSymmetriesUsePositionVersusParam = true;
                this.useConsecutiveIntegerForPackNumber = true;
                this.symmetries = null;
                this.OUT_nbFoundSymmetricLines = 0;
                this.mamesh = mamesh;
            }
            CreateAColorIndexRespectingBifurcationsAndSymmetries.prototype.go = function () {
                if (!this.mamesh.linesWasMade)
                    throw 'no line for this IN_mamesh';
                var res = [];
                var packIndex = 0;
                var segmentToPack = new mathis.HashMap();
                for (var _i = 0, _a = this.mamesh.lines; _i < _a.length; _i++) {
                    var line = _a[_i];
                    var segmentAlreadyCatalogued = [];
                    var segmentNeverCatalogued = [];
                    for (var _b = 0, _c = line.allSegments(); _b < _c.length; _b++) {
                        var segment = _c[_b];
                        if (segmentToPack.getValue(segment) != null)
                            segmentAlreadyCatalogued.push(segment);
                        else
                            segmentNeverCatalogued.push(segment);
                    }
                    if (segmentAlreadyCatalogued.length == 0) {
                        var newPack = new PackSegment();
                        newPack.index = packIndex++;
                        for (var _d = 0, _e = line.allSegments(); _d < _e.length; _d++) {
                            var segment = _e[_d];
                            newPack.putValue(segment, true);
                            segmentToPack.putValue(segment, newPack);
                        }
                    }
                    else {
                        var firstPack = segmentToPack.getValue(segmentAlreadyCatalogued[0]);
                        for (var i = 1; i < segmentAlreadyCatalogued.length; i++)
                            this.segmentAndHisPackJoinNewPack(segmentAlreadyCatalogued[i], firstPack, segmentToPack);
                        for (var _f = 0, segmentNeverCatalogued_1 = segmentNeverCatalogued; _f < segmentNeverCatalogued_1.length; _f++) {
                            var seg = segmentNeverCatalogued_1[_f];
                            firstPack.putValue(seg, true);
                            segmentToPack.putValue(seg, firstPack);
                        }
                    }
                }
                if (this.packSymmetricLines) {
                    if (this.symmetries == null) {
                        if (this.mamesh.symmetries == null)
                            throw 'no symmetry given. If no symmetry is register in mamesh.symmetries, you have to give some in this.symmetries';
                        this.symmetries = this.mamesh.symmetries;
                    }
                    /** e5j8wvx
                     Mot de passe	w8m5Yz3W */
                    /**to look for symmetries, we round a lot the hashes of XYZ*/
                    mathis.XYZ.nbDecimalForHash = 1;
                    var symCheck = new mathis.StringMap();
                    for (var i = 0; i < this.mamesh.lines.length; i++) {
                        var line = this.mamesh.lines[i];
                        var hash = line.hashStringUpToSymmetries(this.symmetries, this.forSymmetriesUsePositionVersusParam);
                        var packSegment = symCheck.getValue(hash);
                        if (packSegment == null)
                            symCheck.putValue(hash, segmentToPack.getValue(new mathis.Segment(line.vertices[0], line.vertices[1])));
                        else {
                            this.OUT_nbFoundSymmetricLines++;
                            var otherPackSegment = segmentToPack.getValue(new mathis.Segment(line.vertices[0], line.vertices[1]));
                            /**on ne change la couleur que si les deux pack on la mme longueur, ce qui est toujours le cas si le pack n'est constitu que d'une seule ligne
                             * cela vite de mettre la mme couleur sur deux pack qui ont une ligne symtrique, mais pas les autres*/
                            if (otherPackSegment.size() == packSegment.size())
                                otherPackSegment.index = packSegment.index;
                        }
                    }
                    mathis.XYZ.nbDecimalForHash = 5;
                }
                /**each line get the packet index*/
                for (var i = 0; i < this.mamesh.lines.length; i++) {
                    var line = this.mamesh.lines[i];
                    res[i] = segmentToPack.getValue(new mathis.Segment(line.vertices[0], line.vertices[1])).index;
                }
                if (this.useConsecutiveIntegerForPackNumber && this.packSymmetricLines) {
                    var newRes = [];
                    var maxIndex = mathis.tab.maxIndexOfNumericList(res);
                    var max = res[maxIndex];
                    var decay = 0;
                    for (var a = 0; a <= max; a++) {
                        var aIsFound = false;
                        for (var j = 0; j < res.length; j++) {
                            if (res[j] == a) {
                                newRes[j] = a - decay;
                                aIsFound = true;
                            }
                        }
                        if (!aIsFound)
                            decay++;
                    }
                    res = newRes;
                }
                var res2 = new mathis.HashMap();
                for (var i = 0; i < this.mamesh.lines.length; i++) {
                    res2.putValue(this.mamesh.lines[i], res[i]);
                }
                return res2;
            };
            CreateAColorIndexRespectingBifurcationsAndSymmetries.prototype.segmentAndHisPackJoinNewPack = function (segment, pack, segmentToPack) {
                var oldPack = segmentToPack.getValue(segment);
                for (var _i = 0, _a = oldPack.allKeys(); _i < _a.length; _i++) {
                    var seg = _a[_i];
                    pack.putValue(seg, true);
                    segmentToPack.putValue(seg, pack);
                }
                segmentToPack.putValue(segment, pack);
            };
            return CreateAColorIndexRespectingBifurcationsAndSymmetries;
        }());
        lineModule.CreateAColorIndexRespectingBifurcationsAndSymmetries = CreateAColorIndexRespectingBifurcationsAndSymmetries;
    })(lineModule = mathis.lineModule || (mathis.lineModule = {}));
})(mathis || (mathis = {}));
/**
 * Created by vigon on 23/02/2016.
 */
var mathis;
(function (mathis) {
    var linkModule;
    (function (linkModule) {
        var SimpleLinkFromPolygonCreator = (function () {
            function SimpleLinkFromPolygonCreator(mamesh) {
                this.mamesh = mamesh;
            }
            SimpleLinkFromPolygonCreator.prototype.goChanging = function () {
                this.mamesh.clearLinksAndLines();
                var alreadyCreatedLinks = new mathis.StringMap();
                for (var _i = 0, _a = this.mamesh.polygons; _i < _a.length; _i++) {
                    var poly = _a[_i];
                    for (var i = 0; i < poly.length; i++) {
                        var segmentId = mathis.Segment.segmentId(poly[i].hashNumber, poly[(i + 1) % poly.length].hashNumber);
                        if (alreadyCreatedLinks.getValue(segmentId) == null) {
                            alreadyCreatedLinks.putValue(segmentId, true);
                            poly[i].setOneLink(poly[(i + 1) % poly.length]);
                            poly[(i + 1) % poly.length].setOneLink(poly[i]);
                        }
                    }
                }
            };
            return SimpleLinkFromPolygonCreator;
        }());
        linkModule.SimpleLinkFromPolygonCreator = SimpleLinkFromPolygonCreator;
        //TODO create LinksSorterByPolygons, already in linkModule module
        var LinksSorterAndCleanerByAngles = (function () {
            function LinksSorterAndCleanerByAngles(mamesh, normals) {
                this.normals = normals;
                this.suppressLinksAngularlyTooCloseVersusNot = true;
                this.suppressLinksAngularParam = 2 * Math.PI * 0.1;
                this.keepShorterLinksVersusGiveSomePriorityToLinksWithOpposite = true;
                this.mamesh = mamesh;
            }
            LinksSorterAndCleanerByAngles.prototype.goChanging = function () {
                var _this = this;
                if (this.mamesh == null)
                    throw 'mamesh is null';
                if (this.normals == null)
                    this.vertexToPositioning = new mathis.mameshAroundComputations.PositioningComputerForMameshVertices(this.mamesh).go();
                else if (this.normals instanceof mathis.HashMap)
                    this.vertexToPositioning = this.normals;
                else if (this.normals instanceof mathis.XYZ) {
                    this.vertexToPositioning = new mathis.HashMap();
                    var positioning = new mathis.Positioning();
                    positioning.upVector = this.normals;
                    for (var _i = 0, _a = this.mamesh.vertices; _i < _a.length; _i++) {
                        var vertex = _a[_i];
                        this.vertexToPositioning.putValue(vertex, positioning);
                    }
                }
                this.mamesh.vertices.forEach(function (center) {
                    //cc('center',center)
                    var vectorLinks = [];
                    for (var i = 0; i < center.links.length; i++) {
                        vectorLinks[i] = new mathis.XYZ(0, 0, 0).copyFrom(center.links[i].to.position).substract(center.position);
                        if (vectorLinks[i].length() < mathis.geo.epsilon)
                            throw 'a IN_mamesh with two voisins at the same position';
                    }
                    var angles = [];
                    angles.push({
                        angle: 0,
                        i: 0
                    });
                    var normal = _this.vertexToPositioning.getValue(center).upVector;
                    for (var i = 1; i < center.links.length; i++) {
                        angles.push({
                            angle: mathis.geo.angleBetweenTwoVectorsBetweenMinusPiAndPi(vectorLinks[0], vectorLinks[i], normal),
                            i: i
                        });
                    }
                    angles.sort(function (a, b) { return a.angle - b.angle; });
                    var newLinks = [];
                    for (var k = 0; k < angles.length; k++) {
                        //cc(angles[k])
                        newLinks.push(center.links[angles[k].i]);
                    }
                    center.links = newLinks;
                    // let linksToSuppress:Link[]=[]
                    // for (let k=0;k<angles.length;k++){
                    //     let diff=modulo(angles[(k+1)%angles.length].angle-angles[k].angle,2*Math.PI,true)
                    //     if (Math.abs(diff)<this.minimalAngleBetweenLinks) {
                    //         let link0=center.links[angles[k].i]
                    //         let link1=center.links[angles[(k+1)%angles.length].i]
                    //         /**we favorise link with opposite*/
                    //         if (link0.opposite==null&& link1.opposite!=null) linksToSuppress.push(link0)
                    //         else linksToSuppress.push(link1)
                    //     }
                    // }
                    //
                    // for (let link of linksToSuppress){
                    //     if (link.opposite!=null) link.opposite.opposite=null
                    //     removeFromArray(center.links,link)
                    //     link.to.suppressOneLink(center,false)
                    // }
                });
                if (this.suppressLinksAngularlyTooCloseVersusNot)
                    this.letsSuppressLinks();
            };
            LinksSorterAndCleanerByAngles.prototype.letsSuppressLinks = function () {
                for (var _i = 0, _a = this.mamesh.vertices; _i < _a.length; _i++) {
                    var center = _a[_i];
                    var currentIndex = 0;
                    var oneMoreTime = true;
                    while (oneMoreTime && center.links.length >= 2) {
                        oneMoreTime = false;
                        for (var k = currentIndex; k < currentIndex + center.links.length; k++) {
                            var i = k % center.links.length;
                            var ii = (k + 1) % center.links.length;
                            var vecti = mathis.XYZ.newFrom(center.links[i].to.position).substract(center.position);
                            var vectii = mathis.XYZ.newFrom(center.links[ii].to.position).substract(center.position);
                            var angle = mathis.geo.angleBetweenTwoVectorsBetween0andPi(vecti, vectii);
                            if (angle < this.suppressLinksAngularParam) {
                                /**next time we will start to check from the next index*/
                                var disti = mathis.geo.distance(center.position, center.links[i].to.position);
                                var distii = mathis.geo.distance(center.position, center.links[ii].to.position);
                                var linkToSuppress = void 0;
                                if (this.keepShorterLinksVersusGiveSomePriorityToLinksWithOpposite) {
                                    if (disti < distii)
                                        linkToSuppress = center.links[ii];
                                    else
                                        linkToSuppress = center.links[i];
                                }
                                else {
                                    var ratio = disti / (disti + distii);
                                    /**if length are comparable, we favorise links with opposite*/
                                    if (ratio < 0.6 && ratio > 0.4) {
                                        if (center.links[ii].opposites == null && center.links[i].opposites != null)
                                            linkToSuppress = center.links[ii];
                                        else
                                            linkToSuppress = center.links[i];
                                    }
                                    else {
                                        if (disti < distii)
                                            linkToSuppress = center.links[ii];
                                        else
                                            linkToSuppress = center.links[i];
                                    }
                                }
                                mathis.Vertex.separateTwoVoisins(center, linkToSuppress.to);
                                // removeFromArray(center.links,linkToSuppress)
                                // if (linkToSuppress.opposite!=null) linkToSuppress.opposite.opposite=null
                                // linkToSuppress.to.suppressOneLink(center,true)
                                oneMoreTime = true;
                                currentIndex = (ii + 1);
                                break;
                            }
                        }
                    }
                }
            };
            return LinksSorterAndCleanerByAngles;
        }());
        linkModule.LinksSorterAndCleanerByAngles = LinksSorterAndCleanerByAngles;
        var OppositeLinkAssocierByAngles = (function () {
            function OppositeLinkAssocierByAngles(vertices) {
                this.maxAngleToAssociateLinks = Math.PI * 0.3; //0.3
                /**to make bifurcation on a vertex where two link are exactly aligned  (this shape: _\_ )   ,you must put a value >=1  */
                //propToleranceForBifurcation=0.2
                this.clearAllExistingOppositeBefore = false;
                this.canCreateBifurcations = true;
                this.doNotBranchOnBorder = false;
                this.OUT_nbBranching = 0;
                this.vertices = vertices;
            }
            OppositeLinkAssocierByAngles.prototype.associateOppositeLinks = function () {
                var _this = this;
                var verticeCoupleToSeparateAtTheEnd = [];
                this.vertices.forEach(function (center) {
                    var valence = 0;
                    for (var _i = 0, _a = center.links; _i < _a.length; _i++) {
                        var li = _a[_i];
                        if (li.opposites == null)
                            valence++;
                    }
                    var vectorLinks = [];
                    for (var i = 0; i < center.links.length; i++) {
                        vectorLinks[i] = new mathis.XYZ(0, 0, 0).copyFrom(center.links[i].to.position).substract(center.position);
                        if (vectorLinks[i].lengthSquared() < mathis.geo.epsilonSquare)
                            throw 'the IN_mamesh has two voisins at the same position';
                    }
                    var allAngleBetweenLinks = [];
                    var bestAngle = [];
                    for (var i = 0; i < center.links.length; i++) {
                        bestAngle[i] = Number.POSITIVE_INFINITY;
                        for (var j = i + 1; j < center.links.length; j++) {
                            var angle = Math.abs(mathis.modulo(mathis.geo.angleBetweenTwoVectorsBetween0andPi(vectorLinks[i], vectorLinks[j]) - Math.PI, Math.PI * 2, true));
                            /**keep only small angle. We do not touch to existing opposites; but opposite could had been clear at the begin of this*/
                            if (angle < _this.maxAngleToAssociateLinks && (center.links[i].opposites == null && center.links[j].opposites == null)) {
                                if (angle < bestAngle[i])
                                    bestAngle[i] = angle;
                                allAngleBetweenLinks.push({
                                    angle: angle,
                                    i: i,
                                    j: j
                                });
                            }
                        }
                    }
                    // if (center.links.length>6){
                    //
                    //     let worstLinkIndex=tab.maxIndex(bestAngle)
                    //     verticeCoupleToSeparateAtTheEnd.push([center,center.links[worstLinkIndex].to])
                    //     //Vertex.separateTwoVoisins(center,center.links[worstLinkIndex].to)
                    //     // allAngleBetweenLinks = arrayMinusElements(allAngleBetweenLinks, (el)=> {
                    //     //     return el.i == worstLinkIndex || el.j == worstLinkIndex
                    //     // })
                    //
                    // }
                    //allAngleBetweenLinks=arrayMinusElements(allAngleBetweenLinks,(elem)=>{return elem.angle>this.maxAngleToAssociateLinks})
                    //
                    // if (!this.clearAllExistingOppositeBefore){
                    //     allAngleBetweenLinks=arrayMinusElements(allAngleBetweenLinks,(elem)=>{return })
                    // }
                    allAngleBetweenLinks.sort(function (a, b) { return b.angle - a.angle; });
                    if (!_this.canCreateBifurcations || (_this.doNotBranchOnBorder && center.hasMark(mathis.Vertex.Markers.border))) {
                        while (allAngleBetweenLinks.length > 0) {
                            var elem = allAngleBetweenLinks.pop();
                            var link0 = center.links[elem.i];
                            var link1 = center.links[elem.j];
                            // if (link0.opposites != null) allAngleBetweenLinks = arrayMinusElements(allAngleBetweenLinks, (el)=> {
                            //     return el.i == elem.i || el.j == elem.i
                            // })
                            // else if (link1.opposites != null) allAngleBetweenLinks = arrayMinusElements(allAngleBetweenLinks, (el)=> {
                            //     return el.i == elem.j || el.j == elem.j
                            // })
                            // else {
                            link0.opposites = [link1];
                            link1.opposites = [link0];
                            allAngleBetweenLinks = mathis.tab.arrayMinusElements(allAngleBetweenLinks, function (el) {
                                return el.i == elem.i || el.j == elem.i || el.i == elem.j || el.j == elem.j;
                            });
                        }
                    }
                    else {
                        while (allAngleBetweenLinks.length > 0) {
                            //cc('allAngleBetweenLinks',allAngleBetweenLinks.length)
                            var elem = allAngleBetweenLinks.pop();
                            var nextElem = allAngleBetweenLinks[allAngleBetweenLinks.length - 1];
                            var link0 = void 0;
                            var link1 = void 0;
                            var link2 = void 0;
                            //if (nextElem!=null&& (nextElem.angle-elem.angle)/(elem.angle+nextElem.angle+0.00001)<this.propToleranceForBifurcation) {
                            if (valence == 3 && nextElem != null) {
                                if (elem.i == nextElem.i) {
                                    link0 = center.links[elem.i];
                                    link1 = center.links[elem.j];
                                    link2 = center.links[nextElem.j];
                                }
                                else if (elem.i == nextElem.j) {
                                    link0 = center.links[elem.i];
                                    link1 = center.links[elem.j];
                                    link2 = center.links[nextElem.i];
                                }
                                else if (elem.j == nextElem.i) {
                                    link0 = center.links[elem.j];
                                    link1 = center.links[elem.i];
                                    link2 = center.links[nextElem.j];
                                }
                                else if (elem.j == nextElem.j) {
                                    link0 = center.links[elem.j];
                                    link1 = center.links[elem.i];
                                    link2 = center.links[nextElem.i];
                                }
                                else {
                                    link0 = center.links[elem.i];
                                    link1 = center.links[elem.j];
                                }
                            }
                            else {
                                link0 = center.links[elem.i];
                                link1 = center.links[elem.j];
                            }
                            if (link2 == null) {
                                link0.opposites = [link1];
                                link1.opposites = [link0];
                                allAngleBetweenLinks = mathis.tab.arrayMinusElements(allAngleBetweenLinks, function (el) {
                                    return el.i == elem.i || el.j == elem.i || el.i == elem.j || el.j == elem.j;
                                });
                                valence -= 2;
                            }
                            else {
                                _this.OUT_nbBranching++;
                                allAngleBetweenLinks.pop();
                                link0.opposites = [link1, link2];
                                link1.opposites = [link0];
                                link2.opposites = [link0];
                                valence -= 1;
                                allAngleBetweenLinks = mathis.tab.arrayMinusElements(allAngleBetweenLinks, function (el) {
                                    return el.i == elem.i || el.j == elem.i || el.i == elem.j || el.j == elem.j || el.i == nextElem.i || el.j == nextElem.i || el.i == nextElem.j || el.j == nextElem.j;
                                });
                            }
                        }
                    }
                });
                // for (let pair of verticeCoupleToSeparateAtTheEnd){
                //     Vertex.separateTwoVoisins(pair[0],pair[1])
                // }
            };
            // private findOneBadLinkIndex(){
            //     for (let v of this.vertices){
            //         if (v.links.length>=5){
            //             for (let i=0;i<v.links.length;i++){
            //                 let li=v.links[i]
            //                 if (li.opposites==null) return i
            //             }
            //         }
            //     }
            //     return null
            // }
            OppositeLinkAssocierByAngles.prototype.goChanging = function () {
                if (this.clearAllExistingOppositeBefore) {
                    this.vertices.forEach(function (v) {
                        v.links.forEach(function (li) {
                            li.opposites = null;
                        });
                    });
                }
                if (this.maxAngleToAssociateLinks != null)
                    this.associateOppositeLinks();
            };
            return OppositeLinkAssocierByAngles;
        }());
        linkModule.OppositeLinkAssocierByAngles = OppositeLinkAssocierByAngles;
        // export class GraphCleaning{
        //
        //     vertices:Vertex[]
        //
        //     constructor(vertices:Vertex[]){
        //         this.vertices=vertices
        //     }
        //
        //     goChanging():void{
        //
        //         this.cleanDoubleLinksKeepingInPriorityThoseWithOpposite()
        //
        //     }
        //
        //     private cleanDoubleLinksKeepingInPriorityThoseWithOpposite(){
        //
        //
        //         this.vertices.forEach(vertex=> {
        //           
        //             /**dico of links to keep*/
        //             let dico = new HashMap<Vertex,Link>()
        //             let linksToDelete:Link[]=[]
        //             for (let link of vertex.links) {
        //
        //                 if (dico.getValue(link.to)==null) dico.putValue(link.to,link)
        //                 else {
        //                     if (dico.getValue(link.to).opposites==null && link.opposites!=null ) {
        //                         linksToDelete.push(dico.getValue(link.to))
        //                         dico.putValue(link.to,link)
        //                     }
        //                     else linksToDelete.push(link)
        //                 }
        //             }
        //           
        //             for (let link of linksToDelete){
        //                 removeFromArray(vertex.links,link)
        //                 if (link.opposite!=null) link.opposite.opposite=null
        //             }
        //
        //           
        //
        //
        //
        //         })
        //
        //     }
        //   
        // }
        var LinkCreaterSorterAndBorderDetecterByPolygons = (function () {
            function LinkCreaterSorterAndBorderDetecterByPolygons(mamesh) {
                /**
                 * a T jonction is that
                 *   7
                 *   |
                 * - 5
                 *   |
                 *   6
                 *
                 * or that
                 *
                 *   7
                 *  \|
                 * - 5
                 *  /|
                 *   6
                 *
                 * in this case we add
                 * XXXTJonction: {[id:5]:[7,6]}
                 *
                 * */
                this.interiorTJonction = new mathis.HashMap(); //:{[id:number]:boolean}={}
                this.borderTJonction = new mathis.HashMap();
                this.forcedOpposite = new mathis.HashMap();
                /**build by createPolygonesFromSmallestTrianglesAnSquares */
                this.polygonesAroundEachVertex = new mathis.HashMap();
                this.polygones = [];
                /** an isolate vertex is a corner which belongs only to one polygone.  */
                this.markIsolateVertexAsCorner = true;
                this.markBorder = true;
                this.forceOppositeLinksAtCorners = false;
                this.mamesh = mamesh;
            }
            LinkCreaterSorterAndBorderDetecterByPolygons.prototype.goChanging = function () {
                this.checkArgs();
                this.createPolygonesFromSmallestTrianglesAnSquares();
                this.detectBorder();
                this.createLinksTurningAround();
                this.makeLinksFinaly();
                //this.mamesh.linksOK=true
            };
            LinkCreaterSorterAndBorderDetecterByPolygons.prototype.checkArgs = function () {
                if ((this.mamesh.smallestSquares == null || this.mamesh.smallestSquares.length == 0) && (this.mamesh.smallestTriangles == null || this.mamesh.smallestTriangles.length == 0))
                    throw 'no triangles nor squares given';
                this.mamesh.clearLinksAndLines();
            };
            LinkCreaterSorterAndBorderDetecterByPolygons.prototype.createPolygonesFromSmallestTrianglesAnSquares = function () {
                var _this = this;
                for (var i = 0; i < this.mamesh.smallestTriangles.length; i += 3) {
                    this.polygones.push(new Polygone([
                        this.mamesh.smallestTriangles[i],
                        this.mamesh.smallestTriangles[i + 1],
                        this.mamesh.smallestTriangles[i + 2],
                    ]));
                }
                for (var i = 0; i < this.mamesh.smallestSquares.length; i += 4) {
                    this.polygones.push(new Polygone([
                        this.mamesh.smallestSquares[i],
                        this.mamesh.smallestSquares[i + 1],
                        this.mamesh.smallestSquares[i + 2],
                        this.mamesh.smallestSquares[i + 3],
                    ]));
                }
                for (var _i = 0, _a = this.polygones; _i < _a.length; _i++) {
                    var polygone = _a[_i];
                    var length_1 = polygone.points.length;
                    for (var i = 0; i < length_1; i++) {
                        var vert1 = polygone.points[i % length_1];
                        var vert2 = polygone.points[(i + 1) % length_1];
                        this.subdivideSegment(polygone, vert1, vert2, this.mamesh.cutSegmentsDico);
                    }
                }
                this.mamesh.vertices.forEach(function (v) {
                    _this.polygonesAroundEachVertex.putValue(v, new Array());
                });
                this.polygones.forEach(function (poly) {
                    poly.points.forEach(function (vert) {
                        _this.polygonesAroundEachVertex.getValue(vert).push(poly);
                    });
                });
                //cc('polygonesAroundEachVertex',this.polygonesAroundEachVertex.toString())
                if (this.markIsolateVertexAsCorner) {
                    this.mamesh.vertices.forEach(function (v) {
                        if (_this.polygonesAroundEachVertex.getValue(v).length == 1) {
                            v.markers.push(mathis.Vertex.Markers.corner);
                            mathis.logger.c('new corners was added when we automatically create then links from the triangulatedRect/square');
                        }
                    });
                }
                //for (let poly of this.polygones) {
                //    for (let vert of poly.points){
                //    }
                //}
            };
            LinkCreaterSorterAndBorderDetecterByPolygons.prototype.detectBorder = function () {
                var _this = this;
                for (var ind = 0; ind < this.mamesh.vertices.length; ind++) {
                    var center = this.mamesh.vertices[ind];
                    var polygonesAround = this.polygonesAroundEachVertex.getValue(center);
                    /**we look at all the polygon aroung a vertex (the center) we count the number of times that a vertex appear as a border of a polygon*/
                    var segmentMultiplicity = new mathis.HashMap(true); //:{[id:number]:number} = {}
                    for (var _i = 0, polygonesAround_1 = polygonesAround; _i < polygonesAround_1.length; _i++) {
                        var polygone = polygonesAround_1[_i];
                        var twoAngles = polygone.theTwoAnglesAdjacentFrom(center);
                        var side0id = twoAngles[0];
                        var side1id = twoAngles[1];
                        if (segmentMultiplicity.getValue(side0id) == null)
                            segmentMultiplicity.putValue(side0id, 1);
                        else
                            segmentMultiplicity.putValue(side0id, segmentMultiplicity.getValue(side0id) + 1);
                        if (segmentMultiplicity.getValue(side1id) == null)
                            segmentMultiplicity.putValue(side1id, 1);
                        else
                            segmentMultiplicity.putValue(side1id, segmentMultiplicity.getValue(side1id) + 1);
                    }
                    var count = 0;
                    segmentMultiplicity.allKeys().forEach(function (key) {
                        if (segmentMultiplicity.getValue(key) == 1) {
                            count++;
                            if (_this.borderTJonction.getValue(center) == null) {
                                _this.borderTJonction.putValue(center, new Array());
                                if (_this.markBorder)
                                    center.markers.push(mathis.Vertex.Markers.border);
                            }
                            /**we colect the link in a T-jonction*/
                            _this.borderTJonction.getValue(center).push(key);
                        }
                        else if (segmentMultiplicity.getValue(key) > 2)
                            throw " non conform mesh: a link appear strictly more than 2 times as side of polygones turning around a vertex   ";
                    });
                    if (!(count == 0 || count == 2))
                        throw "strange mesh (perhaps too holy): the vertex: " + center.toString(0) + " has:" + count + " link with multiplicity 1";
                }
            };
            LinkCreaterSorterAndBorderDetecterByPolygons.prototype.createLinksTurningAround = function () {
                var _this = this;
                var doIi = function (v, vv) {
                    var cutSegment = _this.mamesh.cutSegmentsDico[mathis.Segment.segmentId(v.hashNumber, vv.hashNumber)];
                    if (cutSegment != null) {
                        if (_this.interiorTJonction.getValue(cutSegment.middle) != null) {
                            console.log('attention, une double interiorTjonction');
                        }
                        else
                            _this.interiorTJonction.putValue(cutSegment.middle, true);
                        _this.forcedOpposite.putValue(cutSegment.middle, [v, vv]);
                    }
                };
                /** we detect polygone with several colinear points  */
                for (var _i = 0, _a = this.polygones; _i < _a.length; _i++) {
                    var polygone = _a[_i];
                    var length_2 = polygone.points.length;
                    if (length_2 > 3) {
                        if (length_2 == 4) {
                            doIi(polygone.points[0], polygone.points[2]);
                            doIi(polygone.points[1], polygone.points[3]);
                        }
                        else {
                            for (var i = 0; i < length_2; i++) {
                                var v = polygone.points[i];
                                var vv = polygone.points[(i + 2) % length_2];
                                doIi(v, vv);
                            }
                        }
                    }
                }
                this.mamesh.vertices.forEach(function (central) {
                    //list of polygones which have the central cell at one angle
                    // be careful : in very exceptional case, this list can have only one element
                    var polygonesAround = _this.polygonesAroundEachVertex.getValue(central);
                    if (_this.borderTJonction.getValue(central) != null && _this.interiorTJonction.getValue(central) != null)
                        throw 'a vertex cannot be a interior and border T-jonction';
                    if (_this.borderTJonction.getValue(central) == null) {
                        /**we take any polygone */
                        var poly0 = polygonesAround[0];
                        if (poly0 == null)
                            mathis.logger.c('some vertex was not around a square/triangulatedRect');
                        else
                            _this.createLinksTurningFromOnePolygone(central, poly0, polygonesAround, false);
                    }
                    else {
                        var poly = _this.findAPolygoneWithOrientedEdge(central, _this.borderTJonction.getValue(central)[0], polygonesAround);
                        if (poly == null)
                            poly = _this.findAPolygoneWithOrientedEdge(central, _this.borderTJonction.getValue(central)[1], polygonesAround);
                        _this.createLinksTurningFromOnePolygone(central, poly, polygonesAround, true);
                    }
                });
            };
            LinkCreaterSorterAndBorderDetecterByPolygons.prototype.makeLinksFinaly = function () {
                var _this = this;
                this.mamesh.vertices.forEach(function (vertex) {
                    if (_this.forceOppositeLinksAtCorners || !vertex.hasMark(mathis.Vertex.Markers.corner)) {
                        var length_3 = vertex.links.length;
                        if (_this.borderTJonction.getValue(vertex) != null) {
                            var nei1 = vertex.links[0];
                            var nei2 = vertex.links[length_3 - 1];
                            nei1.opposites = [nei2];
                            nei2.opposites = [nei1];
                        }
                        else {
                            if (length_3 % 2 == 0) {
                                for (var i = 0; i < length_3; i++) {
                                    var nei1 = vertex.links[i];
                                    var nei2 = vertex.links[(i + length_3 / 2) % length_3];
                                    nei1.opposites = [nei2];
                                    nei2.opposites = [nei1];
                                }
                            }
                            if (_this.forcedOpposite.getValue(vertex) != null) {
                                var voi0 = _this.forcedOpposite.getValue(vertex)[0];
                                var voi1 = _this.forcedOpposite.getValue(vertex)[1];
                                /**important to suppress opposite before create some new. If not we create bifurcations*/
                                vertex.changeToLinkWithoutOpposite(voi0);
                                vertex.changeToLinkWithoutOpposite(voi1);
                                vertex.setTwoOppositeLinks(voi0, voi1);
                            }
                        }
                    }
                });
            };
            //    function completSegment(segment:Segment){
            //    /**premier passage */
            //    if (segment.middle==null){
            //        segment.middle=graphManip.addNewVertex(this.IN_mamesh.vertices,this.IN_mamesh.vertices.length)
            //        segment.middle.dichoLevel=Math.max(segment.a.dichoLevel,segment.b.dichoLevel)+1
            //        segment.middle.position=geo.newXYZ(0,0,0)
            //        geo.between(segment.a.position,segment.b.position,0.5,segment.middle.position)
            //
            //    }
            //}
            LinkCreaterSorterAndBorderDetecterByPolygons.prototype.findAPolygoneWithOrientedEdge = function (vertDeb, vertFin, aList) {
                for (var _i = 0, aList_1 = aList; _i < aList_1.length; _i++) {
                    var polygone = aList_1[_i];
                    var length_4 = polygone.points.length;
                    for (var i = 0; i < length_4; i++) {
                        if (polygone.points[i % length_4].hashNumber == vertDeb.hashNumber && polygone.points[(i + 1) % length_4].hashNumber == vertFin.hashNumber)
                            return polygone;
                    }
                }
                return null;
            };
            LinkCreaterSorterAndBorderDetecterByPolygons.prototype.findAPolygoneWithThisEdge = function (vert1, vert2, aList) {
                for (var _i = 0, aList_2 = aList; _i < aList_2.length; _i++) {
                    var polygone = aList_2[_i];
                    var length_5 = polygone.points.length;
                    for (var i = 0; i < length_5; i++) {
                        var id = mathis.Segment.segmentId(polygone.points[i % length_5].hashNumber, polygone.points[(i + 1) % length_5].hashNumber);
                        var idBis = mathis.Segment.segmentId(vert1.hashNumber, vert2.hashNumber);
                        if (id == idBis)
                            return polygone;
                    }
                }
                return null;
            };
            LinkCreaterSorterAndBorderDetecterByPolygons.prototype.createLinksTurningFromOnePolygone = function (central, poly0, polygonesAround, isBorder) {
                var currentAngle = poly0.theOutgoingAnglesAdjacentFrom(central);
                var currentPolygone = poly0;
                var allIsWellOriented = true;
                while (polygonesAround.length > 0) {
                    central.links.push(new mathis.Link(currentAngle));
                    if (allIsWellOriented)
                        currentAngle = currentPolygone.theIngoingAnglesAdjacentFrom(central);
                    else {
                        var angles = currentPolygone.theTwoAnglesAdjacentFrom(central);
                        if (angles[0].hashNumber == currentAngle.hashNumber)
                            currentAngle = angles[1];
                        else
                            currentAngle = angles[0];
                    }
                    mathis.tab.removeFromArray(polygonesAround, currentPolygone);
                    /**maintenant il n' y en a plus qu' un seul (ou zro) polygone ayant comme ct [central,currentAngle], car on a supprim l' autre polygone*/
                    //TODO improte considering only outgoing
                    currentPolygone = this.findAPolygoneWithOrientedEdge(central, currentAngle, polygonesAround);
                    if (currentPolygone == null) {
                        currentPolygone = this.findAPolygoneWithOrientedEdge(currentAngle, central, polygonesAround);
                        //TODO console.log(' orientations of the faces of your surface are not all compatible')
                        allIsWellOriented = false;
                    }
                }
                /** si les polygones ne font pas le tour complet, il faut rajouter un dernier link*/
                if (isBorder) {
                    central.links.push(new mathis.Link(currentAngle));
                }
            };
            /**at the beginning polygones are simply square or triangulatedRect. But perhaps, some of their edge were subdivide.
             * In this case, we add the middle in the polygone points. This method is recursive because segment could had been several time subdivided*/
            LinkCreaterSorterAndBorderDetecterByPolygons.prototype.subdivideSegment = function (polygone, vertex1, vertex2, cutSegmentDico) {
                var segment = cutSegmentDico[mathis.Segment.segmentId(vertex1.hashNumber, vertex2.hashNumber)];
                if (segment != null) {
                    var index1 = polygone.points.indexOf(vertex1);
                    var index2 = polygone.points.indexOf(vertex2);
                    var minIndex = Math.min(index1, index2);
                    var maxIndex = Math.max(index1, index2);
                    if (maxIndex == polygone.points.length - 1 && minIndex == 0)
                        polygone.points.splice(length, 0, segment.middle);
                    else
                        polygone.points.splice(minIndex + 1, 0, segment.middle);
                    this.subdivideSegment(polygone, vertex1, segment.middle, cutSegmentDico);
                    this.subdivideSegment(polygone, vertex2, segment.middle, cutSegmentDico);
                }
            };
            return LinkCreaterSorterAndBorderDetecterByPolygons;
        }());
        linkModule.LinkCreaterSorterAndBorderDetecterByPolygons = LinkCreaterSorterAndBorderDetecterByPolygons;
        var Polygone = (function () {
            function Polygone(points) {
                this.points = points;
                //for (let i = 0; i < points.length; i++) {
                //    let side = new Segment(points[i], points[(i + 1) % points.length]);
                //    this.sides.push(side);
                //}
            }
            //hasSide(ab:Segment):boolean {
            //    for (let i = 0; i < this.sides.length; i++) {
            //
            //        let side:Segment = this.sides[i];
            //
            //        if (ab.equals(side)) {
            //            return true;
            //        }
            //    }
            //    return false;
            //}
            Polygone.prototype.hasAngle = function (point) {
                for (var _i = 0, _a = this.points; _i < _a.length; _i++) {
                    var vert = _a[_i];
                    if (vert.hashNumber == point.hashNumber)
                        return true;
                }
                return false;
            };
            //theTwoSidesContaining(point:Vertex):Array<Segment> {
            //
            //    let twoSides = new Array<Segment>();
            //
            //    for (let i in this.sides) {
            //        let side:Segment = this.sides[i];
            //        if (side.has(point)) twoSides.push(side);
            //    }
            //
            //    if (twoSides.length != 2) throw "Non conform polygone";
            //
            //    return twoSides;
            //
            //}
            Polygone.prototype.theOutgoingAnglesAdjacentFrom = function (point) {
                var length = this.points.length;
                for (var i = 0; i < length; i++) {
                    if (this.points[i] == point) {
                        return this.points[(i + 1) % length];
                    }
                }
                throw 'we do not find the point in this polygone';
            };
            Polygone.prototype.theIngoingAnglesAdjacentFrom = function (point) {
                var length = this.points.length;
                for (var i = 0; i < length; i++) {
                    if (this.points[i] == point) {
                        return this.points[(i - 1 + length) % length];
                    }
                }
                throw 'we do not find the point in this polygone';
            };
            Polygone.prototype.theTwoAnglesAdjacentFrom = function (point) {
                var length = this.points.length;
                for (var i = 0; i < length; i++) {
                    if (this.points[i] == point) {
                        return [this.points[(i - 1 + length) % length], this.points[(i + 1) % length]];
                    }
                }
                throw 'we do not find the point in this polygone';
            };
            Polygone.prototype.toString = function () {
                var res = "[";
                for (var _i = 0, _a = this.points; _i < _a.length; _i++) {
                    var vertex = _a[_i];
                    res += vertex.hashNumber + ',';
                }
                return res + "]";
            };
            return Polygone;
        }());
        linkModule.Polygone = Polygone;
    })(linkModule = mathis.linkModule || (mathis.linkModule = {}));
})(mathis || (mathis = {}));
/**
 * Created by vigon on 06/11/2015.
 */
var mathis;
(function (mathis) {
    var macamera;
    (function (macamera) {
        var Tools = BABYLON.Tools;
        var Collider = BABYLON.Collider;
        var GrabberCamera = (function (_super) {
            __extends(GrabberCamera, _super);
            function GrabberCamera(mathisFrame, grabber) {
                _super.call(this, name, new BABYLON.Vector3(0, 0, -10), mathisFrame.scene);
                this.translationSpeed = 1;
                this.checkCollisions = false;
                this.showPredefinedConsoleLog = false;
                this.grabbers = [];
                this.useOnlyFreeMode = false;
                this.useFreeModeWhenCursorOutOfGrabber = true;
                this.onGrabberChange = null;
                this.onTranslate = null;
                this.tooSmallAngle = 0.001;
                this.tooBigAngle = 0.3;
                this.cumulatedAngle = 0;
                this.relativeCursorPositionOnGrabber = new mathis.XYZ(0, 0, 0);
                this.cursorPositionOnGrabberOld = new mathis.XYZ(0, 0, 0);
                this.angleOfRotationAroundGrabber = 0;
                this.axeOfRotationAroundGrabber = new mathis.XYZ(0, 0, 0);
                this.camDir = new mathis.XYZ(0, 0, 0);
                this.oldCamDir = new mathis.XYZ(0, 0, 0);
                this.angleForCamRot = 0;
                this.axisForCamRot = new mathis.XYZ(0, 0, 0);
                /**un vecteur gal  {@link myNullVector} est considr comme null
                 * cependant, on n' aura pas besoin d' un new pour le raffecter*/
                this.myNullVector = new mathis.XYZ(123, 234, 345);
                this.frozonProjectionMatrix = new mathis.MM();
                this.frozonViewMatrix = new mathis.MM();
                this.pickingRay = { origin: new mathis.XYZ(0, 0, 0), direction: new mathis.XYZ(0, 0, 0) };
                this.aPartOfTheFrontDir = new mathis.XYZ(0, 0, 0);
                this.whishedCamPos = new WishedPositioning(this);
                this.trueCamPos = new CamPositioning(this);
                this._paralDisplacement = new mathis.XYZ(0, 0, 0);
                this._matrixRotationAroundCam = new mathis.MM();
                this._matrixRotationAroundZero = new mathis.MM();
                this.camRelativePos = new mathis.XYZ(0, 0, 0);
                /**TRANSLATION MOVEMENT*/
                this._collider = new Collider();
                this.correctionToRecenter = new mathis.XYZ(0, 0, 0);
                this._deltaPosition = new mathis.XYZ(0, 0, 0);
                this._popo = new mathis.XYZ(0, 0, 0);
                /** #############################################
                 *  POINTER
                 * ##############################################*/
                this._babylonRay = new BABYLON.Ray(new BABYLON.Vector3(0, 0, 0), new BABYLON.Vector3(0, 0, 1));
                this.pointerIsOnCurrentGrabber = false;
                this._tempCN = new mathis.XYZ(0, 0, 0);
                this._end = new mathis.XYZ(0, 0, 0);
                this.pointerIsDown = false;
                this._lookForTheBestGrabber = true;
                this._target = mathis.XYZ.newZero();
                this.viewMM = new mathis.MM();
                // private projectionMM = new MM()
                //
                // /**Ici on a saut l'tape _getProjectionMatrix et _isSynchronizedProjectionMatrix */
                // public getProjectionMatrix():MM {
                //    
                //     if (this._isSynchronized() ) return this.projectionMM
                //    
                //     var engine = this.getEngine();
                //     if (this.minZ <= 0) {
                //         this.minZ = 0.1;
                //     }
                //     geo.PerspectiveFovLH(this.fov, engine.getAspectRatio(this), this.minZ, this.maxZ, this.projectionMM);
                //     return this.projectionMM;
                //
                //     //var halfWidth = engine.getRenderWidth() / 2.0;
                //     //var halfHeight = engine.getRenderHeight() / 2.0;
                //     //Matrix.OrthoOffCenterLHToRef(this.orthoLeft || -halfWidth, this.orthoRight || halfWidth, this.orthoBottom || -halfHeight, this.orthoTop || halfHeight, this.minZ, this.maxZ, this._projectionMatrix);
                //     //return this._projectionMatrix;
                // }
                /** ############################################
                                KEYBOARD
                 ############################################### */
                this._keys = [];
                this.keysUp = [38];
                this.keysDown = [40];
                this.keysLeft = [37];
                this.keysRight = [39];
                this.keysFrontward = []; //[66, 78];
                this.keysBackward = []; //[32];
                this._axeForKeyRotation = new mathis.XYZ(0, 0, 0);
                this._additionnalVec = new mathis.XYZ(0, 0, 0);
                /** #################################################
                                CONTROLS BINDING
                ##################################################*/
                this.wheelPrecision = 1.0;
                this.eventPrefix = Tools.GetPointerPrefix();
                this.scene = mathisFrame.scene;
                /**pour indiquer que les old vectors ne sont pas attribus (sans pour autant les nullifier, pour viter des affectations)*/
                mathis.geo.copyXYZ(this.myNullVector, this.cursorPositionOnGrabberOld);
                mathis.geo.copyXYZ(this.myNullVector, this.oldCamDir);
                //if (this.viewport != null) this.camera.viewport = this.viewport
                //this.whishedCamPos.copyFrom(this.trueCamPos)
                this.$canvasElement = mathisFrame.canvas;
                this.toogleIconCursor('cursorDefault');
                this.replaceTheFirstGrabber(grabber);
                this.attachControl(mathisFrame.canvas);
            }
            GrabberCamera.prototype.changePosition = function (position, smoothMovement) {
                if (smoothMovement === void 0) { smoothMovement = true; }
                this.whishedCamPos.changePosition(position);
                if (!smoothMovement) {
                    this.trueCamPos.position = position;
                }
            };
            GrabberCamera.prototype.changeFrontDir = function (position, smoothMovement) {
                if (smoothMovement === void 0) { smoothMovement = true; }
                this.whishedCamPos.changeFrontDir(position);
                if (!smoothMovement) {
                    this.trueCamPos.changeFrontDir(position);
                }
            };
            GrabberCamera.prototype.changeUpVector = function (position, smoothMovement) {
                if (smoothMovement === void 0) { smoothMovement = true; }
                this.whishedCamPos.changeUpVector(position);
                if (!smoothMovement) {
                    this.trueCamPos.changeUpVector(position);
                }
            };
            GrabberCamera.prototype.addGrabber = function (grabber) {
                grabber.checkArgs();
                this.grabbers.push(grabber);
                //if (checkForChangingCurrentGrabber) this.chooseCurrentGrabberAccordingToDistance()
            };
            GrabberCamera.prototype.replaceTheFirstGrabber = function (grabber) {
                if (this.grabbers[0] != null)
                    this.grabbers[0].dispose();
                grabber.checkArgs();
                grabber.grabberCamera = this;
                this.grabbers[0] = grabber;
                this.currentGrabber = this.grabbers[0];
            };
            /** #############################################
             * ROTATION MOVEMENTS
             #################################################### */
            GrabberCamera.prototype.freeRotation = function () {
                if (this.showPredefinedConsoleLog)
                    console.log('free rotation angle', this.angleForCamRot.toFixed(4));
                this.rotate(this.axisForCamRot, this.angleForCamRot);
                this.toogleIconCursor("cursorMove");
            };
            GrabberCamera.prototype.grabberMovement = function () {
                if (this.currentGrabber.parallelDisplacementInsteadOfRotation) {
                    this._paralDisplacement.copyFrom(this.relativeCursorPositionOnGrabber).substract(this.cursorPositionOnGrabberOld).scale(-1);
                    this._paralDisplacement.add(this.whishedCamPos.getPosition());
                    this.whishedCamPos.changePosition(this._paralDisplacement);
                }
                else {
                    if (this.showPredefinedConsoleLog)
                        console.log('grabber rotation angle', this.angleOfRotationAroundGrabber.toFixed(4));
                    this.rotateAroundCenter(this.axeOfRotationAroundGrabber, this.angleOfRotationAroundGrabber, this.currentGrabber.referenceCenter);
                }
                this.toogleIconCursor("cursorGrabbing");
                if (this.currentGrabber.showGrabberOnlyWhenGrabbing)
                    this.currentGrabber.mesh.visibility = 1;
            };
            GrabberCamera.prototype.mixedRotation = function (alpha) {
                if (this.showPredefinedConsoleLog)
                    console.log('free rotation angle', this.angleForCamRot.toFixed(4), 'grabber rotation angle', this.angleOfRotationAroundGrabber.toFixed(4));
                this.twoRotations(this.axisForCamRot, this.angleForCamRot, this.axeOfRotationAroundGrabber, this.angleOfRotationAroundGrabber, alpha);
                this.toogleIconCursor("cursorGrabbing");
                if (this.currentGrabber.showGrabberOnlyWhenGrabbing)
                    this.currentGrabber.mesh.visibility = 1;
            };
            GrabberCamera.prototype.rotate = function (axis, angle) {
                mathis.geo.axisAngleToMatrix(axis, angle, this._matrixRotationAroundCam);
                mathis.geo.multiplicationMatrixVector(this._matrixRotationAroundCam, this.whishedCamPos.frontDir, this.whishedCamPos.frontDir);
                mathis.geo.multiplicationMatrixVector(this._matrixRotationAroundCam, this.whishedCamPos.upVector, this.whishedCamPos.upVector);
            };
            GrabberCamera.prototype.rotateAroundCenter = function (axis, angle, center) {
                if (this.currentGrabber.referenceCenter == null)
                    return;
                mathis.geo.axisAngleToMatrix(axis, angle, this._matrixRotationAroundZero);
                mathis.geo.multiplicationMatrixVector(this._matrixRotationAroundZero, this.whishedCamPos.frontDir, this.whishedCamPos.frontDir);
                mathis.geo.multiplicationMatrixVector(this._matrixRotationAroundZero, this.whishedCamPos.upVector, this.whishedCamPos.upVector);
                this.camRelativePos.copyFrom(this.whishedCamPos.getPosition()).substract(center);
                mathis.geo.multiplicationMatrixVector(this._matrixRotationAroundZero, this.camRelativePos, this.camRelativePos);
                //this.whishedCamPos.position.copyFrom(this.camRelativePos).add(center)
                this.camRelativePos.add(center);
                this.whishedCamPos.changePosition(this.camRelativePos);
            };
            GrabberCamera.prototype.twoRotations = function (axeOfRotationAroundCam, angleBetweenRays, axeOfRotationAroundZero, angleOfRotationAroundZero, alpha) {
                this.rotate(axeOfRotationAroundCam, angleBetweenRays * (1 - alpha));
                this.rotateAroundCenter(axeOfRotationAroundZero, angleOfRotationAroundZero * alpha, this.currentGrabber.referenceCenter);
            };
            /**fired wy wheeling or by keys*/
            GrabberCamera.prototype.translateCam = function (delta) {
                var impultion = delta * this.translationSpeed;
                /** amout <0 when we goChanging backward. when we goChanging backward, we align our vision to zero.*/
                if (delta < 0 && this.currentGrabber.focusOnMyCenterWhenCameraGoDownWard && this.currentGrabber.referenceCenter != null) {
                    var alpha = Math.min(1, mathis.geo.distance(this.whishedCamPos.getPosition(), this.currentGrabber.referenceCenter) / this.currentGrabber.endOfZone3);
                    /**modification of alpha. The re-axis must be sufficiently slow */
                    alpha = alpha * alpha * 0.1;
                    mathis.geo.scale(this.whishedCamPos.frontDir, 1 - alpha, this.aPartOfTheFrontDir);
                    mathis.geo.substract(this.currentGrabber.referenceCenter, this.whishedCamPos.getPosition(), this.correctionToRecenter);
                    if (this.correctionToRecenter.lengthSquared() > mathis.geo.epsilon) {
                        mathis.geo.normalize(this.correctionToRecenter, this.correctionToRecenter);
                        mathis.geo.scale(this.correctionToRecenter, alpha, this.correctionToRecenter);
                        mathis.geo.add(this.correctionToRecenter, this.aPartOfTheFrontDir, this.aPartOfTheFrontDir);
                    }
                    this.whishedCamPos.changeFrontDir(this.aPartOfTheFrontDir);
                }
                if (impultion != 0) {
                    mathis.geo.scale(this.whishedCamPos.frontDir, impultion, this._deltaPosition);
                    //if(this.checkCollisions) this._collideWithWorld(this._deltaPosition)
                    //else {
                    /**attention : sans utiliser l'intermdiatre popo, cela cre un bug incomprhensible*/
                    mathis.geo.add(this.whishedCamPos.getPosition(), this._deltaPosition, this._popo);
                    this.whishedCamPos.changePosition(this._popo);
                    //}
                    if (this.onTranslate != null)
                        this.onTranslate();
                }
            };
            GrabberCamera.prototype.onPointerMove = function (actualPointerX, actualPointerY) {
                if (!this.pointerIsDown)
                    return;
                /**a priori on va faire les rotation, sauf si ... (cf plus loin)*/
                var grabberRotationOK = true;
                var freeRotationOK = true;
                /**if the actual current grabber has lost the pointer, we look for an other.
                 *  But if not other, the currentGrabber stay (ex : we we goChanging down, we center on it)*/
                /**le picking ray est relatif  un objet donn; ici : this.currentGrabber.mesh  */
                this.createPickingRayWithFrozenCamera(actualPointerX, actualPointerY, this.currentGrabber.mesh.getWorldMatrix(), this.frozonViewMatrix, this.frozonProjectionMatrix, this.pickingRay);
                mathis.geo.copyXYZ(this.pickingRay.direction, this.camDir);
                //
                //
                // this.createPickingRayWithFrozenCamera(actualPointerX, actualPointerY,
                //     <MM> this.currentGrabber.mesh.getWorldMatrix(),
                //     this.frozonViewMatrix,
                //     this.frozonProjectionMatrix,
                //     this.pickingRay)
                // let worldMatrix=<MM>this.currentGrabber.mesh.getWorldMatrix()
                // //geo.inverse(worldMatrix,worldMatrix)
                // geo.multiplicationMatrixVector(worldMatrix,this.pickingRay.direction,this.pickingRay.direction)
                // geo.multiplicationMatrixVector(worldMatrix,this.pickingRay.origin,this.pickingRay.origin)
                /**Be carefull: pickInfo.hit is true also when we are inside the grabber*/
                this._babylonRay.direction = this.pickingRay.direction;
                this._babylonRay.origin = this.pickingRay.origin;
                var pickInfo = this.currentGrabber.mesh.intersects(this._babylonRay, false);
                this.pointerIsOnCurrentGrabber = pickInfo.hit;
                var distToGrabbed = pickInfo.distance;
                if (this.pointerIsOnCurrentGrabber) {
                    this.relativeCursorPositionOnGrabber.x = pickInfo.pickedPoint.x;
                    this.relativeCursorPositionOnGrabber.y = pickInfo.pickedPoint.y;
                    this.relativeCursorPositionOnGrabber.z = pickInfo.pickedPoint.z;
                }
                if (this.currentGrabber.referenceCenter != null)
                    this.relativeCursorPositionOnGrabber.substract(this.currentGrabber.referenceCenter);
                /**
                 * Cette mthode tait sympa (pas de boucle pour trouver le point d'intersection avec le grabber). Malheureusement, cela ne marche pas quand le grabber n'est pas centr en zro
                 *
                 let radius=(<SphericalGrabber> this.currentGrabber).radius
                 this.pointerIsOnCurrentGrabber = geo.intersectionBetweenRayAndSphereFromRef(this.pickingRay.origin, this.pickingRay.direction,radius,this.currentGrabber.referenceCenter,this.candidate1,this.candidate2 )
                 distToGrabbed=geo.closerOf(this.candidate1,this.candidate2,this.whishedCamPos.position,this.relativeCursorPositionOnGrabber)
                 *
                 * */
                var alpha = this.currentGrabber.interpolationCoefAccordingToCamPosition(this.trueCamPos.position, distToGrabbed);
                if (this.showPredefinedConsoleLog)
                    console.log('alpha', alpha);
                //console.log('alpha', alpha)
                if (mathis.geo.xyzEquality(this.oldCamDir, this.myNullVector)) {
                    mathis.geo.copyXYZ(this.camDir, this.oldCamDir);
                    freeRotationOK = false;
                }
                if (mathis.geo.xyzEquality(this.cursorPositionOnGrabberOld, this.myNullVector)) {
                    if (this.pointerIsOnCurrentGrabber) {
                        mathis.geo.copyXYZ(this.relativeCursorPositionOnGrabber, this.cursorPositionOnGrabberOld);
                    }
                    grabberRotationOK = false;
                }
                else if (!this.pointerIsOnCurrentGrabber) {
                    mathis.geo.copyXYZ(this.myNullVector, this.cursorPositionOnGrabberOld);
                    grabberRotationOK = false;
                }
                if (freeRotationOK) {
                    this.angleForCamRot = mathis.geo.angleBetweenTwoVectorsBetween0andPi(this.camDir, this.oldCamDir);
                    if (this.angleForCamRot > this.tooSmallAngle) {
                        mathis.geo.cross(this.camDir, this.oldCamDir, this.axisForCamRot);
                        mathis.geo.normalize(this.axisForCamRot, this.axisForCamRot);
                    }
                    else
                        freeRotationOK = false;
                }
                if (grabberRotationOK) {
                    this.angleOfRotationAroundGrabber = mathis.geo.angleBetweenTwoVectorsBetween0andPi(this.relativeCursorPositionOnGrabber, this.cursorPositionOnGrabberOld);
                    if (this.angleOfRotationAroundGrabber > this.tooSmallAngle) {
                        mathis.geo.cross(this.relativeCursorPositionOnGrabber, this.cursorPositionOnGrabberOld, this.axeOfRotationAroundGrabber);
                        this.axeOfRotationAroundGrabber.normalize();
                    }
                    else
                        grabberRotationOK = false;
                }
                /**un pensement ici pour une erreur non compris : quand on est proche de la sphre, l'angle de la rotation autour de zro prend parfois de trs grand valeur*/
                if (grabberRotationOK && this.angleOfRotationAroundGrabber > this.tooBigAngle) {
                    console.log('a too big angle around zero : ignored' + this.angleOfRotationAroundGrabber.toFixed(4));
                    mathis.geo.copyXYZ(this.relativeCursorPositionOnGrabber, this.cursorPositionOnGrabberOld);
                    return;
                }
                if (this.useOnlyFreeMode && freeRotationOK)
                    this.freeRotation();
                else if (this.pointerIsOnCurrentGrabber) {
                    if (alpha == 0) {
                        if (freeRotationOK)
                            this.freeRotation();
                    }
                    else if (alpha < 1 && alpha > 0) {
                        if (freeRotationOK && grabberRotationOK) {
                            this.mixedRotation(alpha);
                        }
                        else if (grabberRotationOK)
                            this.grabberMovement();
                    }
                    else if (alpha == 1 && grabberRotationOK)
                        this.grabberMovement();
                }
                else if (this.useFreeModeWhenCursorOutOfGrabber && freeRotationOK)
                    this.freeRotation();
                /**on  affecte les nouvelles positions si l' on vient d' effectuer une rotation
                 * Attention, il ne faut pas affecter de nouvelle valeur  chaque fois, sinon les angles ne dpassent jamais les seuils critiques*/
                if (grabberRotationOK)
                    mathis.geo.copyXYZ(this.relativeCursorPositionOnGrabber, this.cursorPositionOnGrabberOld);
                if (freeRotationOK)
                    mathis.geo.copyXYZ(this.camDir, this.oldCamDir);
                if (grabberRotationOK)
                    this.cumulatedAngle += this.angleOfRotationAroundGrabber;
                if (freeRotationOK)
                    this.cumulatedAngle += this.angleForCamRot;
                if (this.cumulatedAngle > Math.PI / 12) {
                    mathis.geo.copyMat(this.getProjectionMatrix(), this.frozonProjectionMatrix);
                    mathis.geo.copyMat(this.getViewMatrix(), this.frozonViewMatrix);
                    this.cumulatedAngle = 0;
                    mathis.geo.copyXYZ(this.myNullVector, this.oldCamDir);
                    mathis.geo.copyXYZ(this.myNullVector, this.cursorPositionOnGrabberOld);
                    if (this.showPredefinedConsoleLog)
                        console.log('nouvelles matrices enregistres');
                }
            };
            /**copi sur {@link BABYLON.Scene.createPickingRay}  */
            GrabberCamera.prototype.createPickingRayWithFrozenCamera = function (x, y, world, frozenViewMatrix, frozonProjectionMatrix, result) {
                var engine = this.getEngine();
                var cameraViewport = this.viewport;
                var viewport = cameraViewport.toGlobal(engine);
                // Moving coordinates to local viewport world
                x = x / engine.getHardwareScalingLevel() - viewport.x;
                y = y / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - viewport.y - viewport.height);
                this.createNewRay(x, y, viewport.width, viewport.height, world, frozenViewMatrix, frozonProjectionMatrix, result);
            };
            GrabberCamera.prototype.createNewRay = function (x, y, viewportWidth, viewportHeight, world, view, projection, result) {
                mathis.geo.unproject(mathis.geo.copyXyzFromFloat(x, y, 0, this._tempCN), viewportWidth, viewportHeight, world, view, projection, result.origin);
                mathis.geo.unproject(mathis.geo.copyXyzFromFloat(x, y, 1, this._tempCN), viewportWidth, viewportHeight, world, view, projection, this._end);
                //var start = BABYLON.Vector3.Unproject(new BABYLON.Vector3(x, y, 0), viewportWidth, viewportHeight, world, view, projection);
                //var end = BABYLON.Vector3.Unproject(new BABYLON.Vector3(x, y, 1), viewportWidth, viewportHeight, world, view, projection);
                mathis.geo.substract(this._end, result.origin, result.direction);
                mathis.geo.normalize(result.direction, result.direction);
            };
            GrabberCamera.prototype.onPointerDown = function (actualPointerX, actualPointerY) {
                this.pointerIsDown = true;
                /**on glace ces matrices pour viter les instabilits*/
                mathis.geo.copyMat(this.getProjectionMatrix(), this.frozonProjectionMatrix);
                mathis.geo.copyMat(this.getViewMatrix(), this.frozonViewMatrix);
                this.cumulatedAngle = 0;
                if (this._lookForTheBestGrabber && this.grabbers.length > 1) {
                    this.lookForTheBestGrabber(actualPointerX, actualPointerY);
                    this._lookForTheBestGrabber = false;
                }
            };
            GrabberCamera.prototype.lookForTheBestGrabber = function (actualPointerX, actualPointerY) {
                var shorterDist = Number.POSITIVE_INFINITY;
                var closerGraber = null;
                for (var _i = 0, _a = this.grabbers; _i < _a.length; _i++) {
                    var gra = _a[_i];
                    this.createPickingRayWithFrozenCamera(actualPointerX, actualPointerY, gra.mesh.getWorldMatrix(), this.frozonViewMatrix, this.frozonProjectionMatrix, this.pickingRay);
                    mathis.geo.copyXYZ(this.pickingRay.direction, this.camDir);
                    /**true also we we are inside the grabber*/
                    this._babylonRay.direction = this.pickingRay.direction;
                    this._babylonRay.origin = this.pickingRay.origin;
                    /**fast checking*/
                    var pickInfo = gra.mesh.intersects(this._babylonRay, true);
                    if (pickInfo.hit) {
                        if (pickInfo.distance < shorterDist) {
                            shorterDist = pickInfo.distance;
                            closerGraber = gra;
                        }
                    }
                }
                if (closerGraber != null && closerGraber != this.currentGrabber) {
                    if (this.onGrabberChange != null)
                        this.onGrabberChange(this.currentGrabber, closerGraber);
                    this.currentGrabber = closerGraber;
                    console.log('we have changed grabber, the new one is: ', closerGraber.name);
                }
            };
            GrabberCamera.prototype.onPointerUp = function () {
                this._lookForTheBestGrabber = true;
                this.toogleIconCursor('cursorDefault');
                if (this.currentGrabber.showGrabberOnlyWhenGrabbing)
                    this.currentGrabber.mesh.visibility = 0;
                this.pointerIsDown = false;
                mathis.geo.copyXYZ(this.myNullVector, this.oldCamDir);
                mathis.geo.copyXYZ(this.myNullVector, this.cursorPositionOnGrabberOld);
            };
            /** called when we detach control  */
            GrabberCamera.prototype.reset = function () {
                this._keys = [];
                //TODO what else ?
            };
            GrabberCamera.prototype.toogleIconCursor = function (style) {
                if (this.cursorActualStyle != style) {
                    this.$canvasElement.className = style;
                    //this.$canvasElement.className += "cursorGrabbing";
                    this.cursorActualStyle = style;
                }
            };
            /** #################################################
                 VIEW MATRIX, PROJECTION MATRIX, UPDATE, CASH
            ##################################################*/
            // /**mthode de Node. Est appele par isSynchronized qui appelle aussi les mthodes _isSynchronized des parents */
            // private computedOnce=false
            // _isSynchronized(){
            //     if (!this.computedOnce) {
            //         this.computedOnce=true
            //         return false
            //     }
            //     return this.trueCamPos.almostEqual(this.whishedCamPos)
            // }
            /**Attention, dans Camera, ils font l'inverse : ils cre 2 mthodes _isSynchronizedProjectionMatrix et _isSynchronizedViewMatrix
             * et _isSynchronized renvoit true quand les 2 prcdentes renvoient true */
            GrabberCamera.prototype._isSynchronizedViewMatrix = function () {
                if (!_super.prototype._isSynchronizedViewMatrix.call(this)) {
                    return false;
                }
                return this.trueCamPos.almostEqual(this.whishedCamPos);
                //return this.isSynchronized()
            };
            /**Est appele par Camera.getViewMatrix uniquement lorsque _isSynchronizedViewMatrix renvoit faux
             * Le lien entre Camera.getViewMatrix et Camera.getViewMatrix._getViewMatrix est bizarrement compliqu.
             * */
            GrabberCamera.prototype._getViewMatrix = function () {
                mathis.geo.copyXYZ(this.trueCamPos.position, this._target);
                mathis.geo.add(this._target, this.trueCamPos.frontDir, this._target);
                mathis.geo.LookAtLH(this.trueCamPos.position, this._target, this.trueCamPos.upVector, this.viewMM);
                return this.viewMM;
            };
            // // Cache
            //  _initCache() {
            //     super._initCache();
            // }
            //
            //
            //  _updateCache(ignoreParentClass?:boolean):void {
            //
            //     if (!ignoreParentClass) {
            //         /**ici sont mis en cache, notamment upVector et position */
            //         super._updateCache();
            //     }
            // }
            /**lanc  chaque frame */
            GrabberCamera.prototype._update = function () {
                this.checkForKeyPushed();
                /**cela fait le lissage*/
                if (!this.trueCamPos.almostEqual(this.whishedCamPos)) {
                    this.trueCamPos.goCloser(this.whishedCamPos);
                }
                this.position.copyFrom(this.trueCamPos.position);
                this.upVector.copyFrom(this.trueCamPos.upVector);
            };
            GrabberCamera.prototype.onKeyDown = function (evt) {
                if (this.keysUp.indexOf(evt.keyCode) !== -1 ||
                    this.keysDown.indexOf(evt.keyCode) !== -1 ||
                    this.keysLeft.indexOf(evt.keyCode) !== -1 ||
                    this.keysRight.indexOf(evt.keyCode) !== -1 ||
                    this.keysBackward.indexOf(evt.keyCode) !== -1 ||
                    this.keysFrontward.indexOf(evt.keyCode) !== -1) {
                    var index = this._keys.indexOf(evt.keyCode);
                    if (index === -1) {
                        this._keys.push(evt.keyCode);
                    }
                    if (evt.preventDefault) {
                        //if (!noPreventDefault) {
                        evt.preventDefault();
                    }
                }
            };
            GrabberCamera.prototype.onKeyUp = function (evt) {
                if (this.keysUp.indexOf(evt.keyCode) !== -1 ||
                    this.keysDown.indexOf(evt.keyCode) !== -1 ||
                    this.keysLeft.indexOf(evt.keyCode) !== -1 ||
                    this.keysRight.indexOf(evt.keyCode) !== -1 ||
                    this.keysBackward.indexOf(evt.keyCode) !== -1 ||
                    this.keysFrontward.indexOf(evt.keyCode) !== -1) {
                    var index = this._keys.indexOf(evt.keyCode);
                    if (index >= 0) {
                        this._keys.splice(index, 1);
                    }
                    if (evt.preventDefault) {
                        evt.preventDefault();
                    }
                }
            };
            GrabberCamera.prototype.checkForKeyPushed = function () {
                if (this._keys.length == 0)
                    return;
                mathis.geo.copyXyzFromFloat(0, 0, 0, this._axeForKeyRotation);
                for (var index = 0; index < this._keys.length; index++) {
                    var keyCode = this._keys[index];
                    if (this.keysLeft.indexOf(keyCode) !== -1) {
                        mathis.geo.copyXYZ(this.whishedCamPos.upVector, this._additionnalVec);
                        mathis.geo.scale(this._additionnalVec, -1, this._additionnalVec);
                        mathis.geo.add(this._axeForKeyRotation, this._additionnalVec, this._axeForKeyRotation);
                    }
                    if (this.keysUp.indexOf(keyCode) !== -1) {
                        mathis.geo.cross(this.whishedCamPos.frontDir, this.whishedCamPos.upVector, this._additionnalVec);
                        mathis.geo.add(this._additionnalVec, this._axeForKeyRotation, this._axeForKeyRotation);
                    }
                    if (this.keysRight.indexOf(keyCode) !== -1) {
                        mathis.geo.copyXYZ(this.whishedCamPos.upVector, this._additionnalVec);
                        mathis.geo.add(this._additionnalVec, this._axeForKeyRotation, this._axeForKeyRotation);
                    }
                    if (this.keysDown.indexOf(keyCode) !== -1) {
                        mathis.geo.cross(this.whishedCamPos.upVector, this.whishedCamPos.frontDir, this._additionnalVec);
                        mathis.geo.add(this._additionnalVec, this._axeForKeyRotation, this._axeForKeyRotation);
                    }
                    if (this.keysBackward.indexOf(keyCode) !== -1)
                        this.translateCam(-0.1);
                    else if (this.keysFrontward.indexOf(keyCode) !== -1)
                        this.translateCam(0.1);
                }
                /**it was already appears that the axis was too small : */
                if (mathis.geo.squareNorme(this._axeForKeyRotation) < mathis.geo.epsilon)
                    return;
                var angle = -0.02;
                /**when key pushed, we always use free mode*/
                this.rotate(this._axeForKeyRotation, angle);
            };
            //private _viewMatrix = new BABYLON.Matrix()
            // public _getViewMatrix():Matrix {
            //     //geo.MMtoBabylonMatrix(this.cameraPilot.getViewMatrix(),this._viewMatrix)
            //     //return this._viewMatrix;
            //     return this.cameraPilot.getViewMatrix()
            // }
            GrabberCamera.prototype.deltaNotToBigFunction = function (delta) {
                if (delta > 0.1)
                    return 0.1;
                if (delta < -0.1)
                    return -0.1;
                return delta;
            };
            // Methods
            GrabberCamera.prototype.attachControl = function (element, noPreventDefault) {
                var _this = this;
                var pointerId; //=null//Math.random();
                if (this._attachedElement) {
                    return;
                }
                this._attachedElement = element;
                //if (this._onPointerDown === undefined) {
                this._onPointerDown = function (evt) {
                    if (pointerId) {
                        return;
                    }
                    pointerId = evt.pointerId;
                    if (!noPreventDefault) {
                        evt.preventDefault();
                    }
                    var rect = element.getBoundingClientRect();
                    _this.onPointerDown(evt.clientX - rect.left, evt.clientY - rect.top);
                };
                this._onPointerUp = function (evt) {
                    pointerId = null;
                    if (!noPreventDefault) {
                        evt.preventDefault();
                    }
                    _this.onPointerUp();
                };
                this._onPointerMove = function (evt) {
                    if (pointerId !== evt.pointerId) {
                        return;
                    }
                    var rect = element.getBoundingClientRect();
                    _this.onPointerMove(evt.clientX - rect.left, evt.clientY - rect.top);
                    if (!noPreventDefault) {
                        evt.preventDefault();
                    }
                };
                this._onMouseMove = this._onPointerMove;
                //this._onMouseMove = evt => {
                //    if (!engine.isPointerLock) {
                //        return;
                //    }
                //
                //    var offsetX = evt.movementX || evt.mozMovementX || evt.webkitMovementX || evt.msMovementX || 0;
                //    var offsetY = evt.movementY || evt.mozMovementY || evt.webkitMovementY || evt.msMovementY || 0;
                //
                //    this.inertialAlphaOffset -= offsetX / this.angularSensibility;
                //    this.inertialBetaOffset -= offsetY / this.angularSensibility;
                //
                //    if (!noPreventDefault) {
                //        evt.preventDefault();
                //    }
                //};
                this._wheel = function (event) {
                    var delta = 0;
                    if (event.wheelDelta) {
                        delta = _this.deltaNotToBigFunction(event.wheelDelta / (_this.wheelPrecision * 300));
                    }
                    else if (event.detail) {
                        delta = _this.deltaNotToBigFunction(-event.detail / (_this.wheelPrecision * 30));
                    }
                    /**MATHIS*/
                    if (delta)
                        _this.translateCam(delta);
                    if (event.preventDefault) {
                        if (!noPreventDefault) {
                            event.preventDefault();
                        }
                    }
                };
                this._onKeyDown = function (evt) {
                    /**MATHIS*/
                    _this.onKeyDown(evt);
                };
                this._onKeyUp = function (evt) {
                    /**MATHIS*/
                    _this.onKeyUp(evt);
                };
                this._onLostFocus = function () {
                    _this._keys = [];
                    pointerId = null;
                };
                this._onGestureStart = function (e) {
                    if (window.MSGesture === undefined) {
                        return;
                    }
                    if (!_this._MSGestureHandler) {
                        _this._MSGestureHandler = new MSGesture();
                        _this._MSGestureHandler.target = element;
                    }
                    _this._MSGestureHandler.addPointer(e.pointerId);
                };
                this._onGesture = function (e) {
                    //TODO this.radius *= e.scale;
                    //
                    //
                    //if (e.preventDefault) {
                    //    if (!noPreventDefault) {
                    //        e.stopPropagation();
                    //        e.preventDefault();
                    //    }
                    //}
                };
                this._reset = function () {
                    /**MATHIS*/
                    _this.reset();
                    pointerId = null;
                };
                //}
                element.addEventListener(this.eventPrefix + "down", this._onPointerDown, false);
                element.addEventListener(this.eventPrefix + "up", this._onPointerUp, false);
                element.addEventListener(this.eventPrefix + "out", this._onPointerUp, false);
                element.addEventListener(this.eventPrefix + "move", this._onPointerMove, false);
                element.addEventListener("mousemove", this._onMouseMove, false);
                element.addEventListener("MSPointerDown", this._onGestureStart, false);
                element.addEventListener("MSGestureChange", this._onGesture, false);
                element.addEventListener('mousewheel', this._wheel, false);
                element.addEventListener('DOMMouseScroll', this._wheel, false);
                Tools.RegisterTopRootEvents([
                    { name: "keydown", handler: this._onKeyDown },
                    { name: "keyup", handler: this._onKeyUp },
                    { name: "blur", handler: this._onLostFocus }
                ]);
            };
            GrabberCamera.prototype.detachControl = function (element) {
                if (this._attachedElement != element) {
                    return;
                }
                element.removeEventListener(this.eventPrefix + "down", this._onPointerDown);
                element.removeEventListener(this.eventPrefix + "up", this._onPointerUp);
                element.removeEventListener(this.eventPrefix + "out", this._onPointerUp);
                element.removeEventListener(this.eventPrefix + "move", this._onPointerMove);
                element.removeEventListener("mousemove", this._onMouseMove);
                element.removeEventListener("MSPointerDown", this._onGestureStart);
                element.removeEventListener("MSGestureChange", this._onGesture);
                element.removeEventListener('mousewheel', this._wheel);
                element.removeEventListener('DOMMouseScroll', this._wheel);
                Tools.UnregisterTopRootEvents([
                    { name: "keydown", handler: this._onKeyDown },
                    { name: "keyup", handler: this._onKeyUp },
                    { name: "blur", handler: this._onLostFocus }
                ]);
                this._MSGestureHandler = null;
                this._attachedElement = null;
                if (this._reset) {
                    this._reset();
                }
            };
            return GrabberCamera;
        }(BABYLON.Camera));
        macamera.GrabberCamera = GrabberCamera;
        var CamPositioning = (function (_super) {
            __extends(CamPositioning, _super);
            function CamPositioning(grabberPilot) {
                _super.call(this);
                this.grabberPilot = grabberPilot;
                this.position = new mathis.XYZ(0, 0, -3);
                this.upVector = new mathis.XYZ(0, 1, 0);
                this.frontDir = new mathis.XYZ(0, 0, 1);
                this.sizes = new mathis.XYZ(1, 1, 1);
                this.smoothParam = 0.5;
                this.positioningCopy = new mathis.Positioning();
            }
            CamPositioning.prototype.almostEqual = function (camCarac) {
                return mathis.geo.xyzAlmostEquality(this.position, camCarac.getPosition()) && mathis.geo.xyzAlmostEquality(this.upVector, camCarac.upVector) && mathis.geo.xyzAlmostEquality(this.frontDir, camCarac.frontDir);
            };
            /**TODO problme ici si l'on prend une wished positionning trs loin de la cam positionning*/
            CamPositioning.prototype.goCloser = function (positioning) {
                mathis.geo.between(positioning.position, this.position, this.smoothParam, this.position);
                mathis.geo.between(positioning.upVector, this.upVector, this.smoothParam, this.upVector);
                mathis.geo.between(positioning.frontDir, this.frontDir, this.smoothParam, this.frontDir);
                if (this.upVector.lengthSquared() < mathis.geo.epsilonSquare) {
                    this.upVector.copyFrom(positioning.upVector).scale(-1);
                    mathis.logger.c('a wished upVector was opposite to the true upVector');
                }
                if (this.frontDir.lengthSquared() < mathis.geo.epsilonSquare) {
                    this.frontDir.copyFrom(positioning.frontDir).scale(-1);
                    mathis.logger.c('a wished frontDir was opposite to the true frontDir');
                }
                if (this.grabberPilot.onPositioningChange != null) {
                    this.positioningCopy.copyFrom(this);
                    this.grabberPilot.onPositioningChange(this.positioningCopy);
                }
            };
            CamPositioning.prototype.copyFrom = function (positioning) {
                mathis.geo.copyXYZ(positioning.position, this.position);
                mathis.geo.copyXYZ(positioning.upVector, this.upVector);
                mathis.geo.copyXYZ(positioning.frontDir, this.frontDir);
                // if(this.grabberPilot.onPositioningChange!=null) {
                //     this.positioningCopy.copyFrom(this)
                //     this.grabberPilot.onPositioningChange(this.positioningCopy)
                // }
            };
            CamPositioning.prototype.changeFrontDir = function (vector) {
                mathis.geo.orthonormalizeKeepingFirstDirection(vector, this.upVector, this.frontDir, this.upVector);
                // if(this.grabberPilot.onPositioningChange!=null) {
                //     this.positioningCopy.copyFrom(this)
                //     this.grabberPilot.onPositioningChange(this.positioningCopy)
                // }
            };
            CamPositioning.prototype.changeUpVector = function (vector) {
                mathis.geo.orthonormalizeKeepingFirstDirection(this.upVector, vector, this.upVector, this.frontDir);
                // if(this.grabberPilot.onPositioningChange!=null) {
                //     this.positioningCopy.copyFrom(this)
                //     this.grabberPilot.onPositioningChange(this.positioningCopy)
                // }
            };
            return CamPositioning;
        }(mathis.Positioning));
        macamera.CamPositioning = CamPositioning;
        var WishedPositioning = (function (_super) {
            __extends(WishedPositioning, _super);
            function WishedPositioning(camera) {
                var _this = this;
                _super.call(this);
                this.camera = camera;
                this.upVector = new mathis.XYZ(0, 1, 0);
                this.frontDir = new mathis.XYZ(0, 0, 1);
                this.position = new mathis.XYZ(0, 0, -3);
                this._newPositionBeforCollision = new mathis.XYZ(0, 0, 0);
                this._velocity = new mathis.XYZ(0, 0, 0);
                // changeFrontDir(vector:XYZ):void {
                //     geo.orthonormalizeKeepingFirstDirection(vector, this.upVector, this.frontDir, this.upVector)
                //
                // }
                // changeUpVector(vector:XYZ):void {
                //     geo.orthonormalizeKeepingFirstDirection( this.upVector,vector , this.upVector,this.frontDir)
                // }
                //
                // changePositioning(positioning:Positioning){
                //     this.position.copyFrom(positioning.position)
                //     this.upVector.copyFrom(positioning.upVector)
                //     this.frontDir.copyFrom(positioning.frontDir)
                // }
                /**COLLISION*/
                this._collider = new Collider();
                this.ellipsoid = new mathis.XYZ(1, 1, 1);
                this._oldPosition = new mathis.XYZ(0, 0, 0);
                //private getScene():BABYLON.Scene{return this.grabberPilot.camera.getScene()}
                this._diffPosition = new mathis.XYZ(0, 0, 0);
                this._newPosition = new mathis.XYZ(0, 0, 0);
                this._inter = new mathis.XYZ(0, 0, 0);
                this._upPerturbation = new mathis.XYZ(0, 0, 0);
                this._onCollisionPositionChange = function (collisionId, newPosition, collidedMesh) {
                    //if (this.getScene().workerCollisions) newPosition.multiplyInPlace(this._collider.radius);
                    if (collidedMesh === void 0) { collidedMesh = null; }
                    _this._newPosition.copyFrom(newPosition);
                    _this._newPosition.subtractToRef(_this._oldPosition, _this._diffPosition).scale(2);
                    //this._position.copyFrom(this._newPosition)
                    if (collidedMesh != null) {
                        console.log('collision');
                        _this._upPerturbation.copyFrom(_this.upVector).scale(0.005);
                        _this.position.add(_this._diffPosition).add(_this._upPerturbation);
                    }
                    else
                        _this.position.copyFrom(_this._oldPosition);
                    // if (this._diffPosition.length() > BABYLON.Engine.CollisionsEpsilon) {
                    //
                    //     this._position.add(this._diffPosition)
                    //     //this._inter.copyFrom(this.getPosition()).add(this._diffPosition)
                    //     //this.whishedCamPos.changePosition(this._inter,this.currentConstraints)
                    // }
                    // var updatePosition = (newPos) => {
                    // }
                    //
                    // updatePosition(newPosition);
                };
            }
            WishedPositioning.prototype.getPosition = function () {
                return this.position;
            };
            WishedPositioning.prototype.changePosition = function (newPosition) {
                // if (positionConstraint==null) {
                //     this._positionBeforCollision=newPosition
                //
                // }
                // else if (positionConstraint.positionConstraint0==null && positionConstraint.positionConstraint1==null){
                //     this._positionBeforCollision=newPosition
                // }
                // else if (positionConstraint.positionConstraint0!=null && positionConstraint.positionConstraint1==null){
                //     geo.orthogonalProjectionOnLine(positionConstraint.positionConstraint0,this._projMat)
                //     geo.multiplicationMatrixVector(this._projMat,newPosition,this._positionBeforCollision)
                //
                // }
                // else if (positionConstraint.positionConstraint0!=null && positionConstraint.positionConstraint1!=null){
                //     geo.orthogonalProjectionOnPlane(positionConstraint.positionConstraint0,positionConstraint.positionConstraint1,this._projMat)
                //     geo.multiplicationMatrixVector(this._projMat,newPosition,this._positionBeforCollision)
                //
                // }
                if (this.camera.positionChangesBiaiser != null) {
                    this._newPositionBeforCollision.copyFrom(this.camera.positionChangesBiaiser(this.position, newPosition, this.camera.currentGrabber));
                }
                else
                    this._newPositionBeforCollision.copyFrom(newPosition);
                if (this.camera.checkCollisions) {
                    this._velocity.copyFrom(this._newPositionBeforCollision).substract(this.camera.trueCamPos.position);
                    this._collideWithWorld(this._velocity, this._newPositionBeforCollision);
                }
                else
                    this.position.copyFrom(this._newPositionBeforCollision);
                //if (this.grabberPilot.onPositioningChange!=null) this.grabberPilot.onPositioningChange(this,this.grabberPilot.currentGrabber)
            };
            WishedPositioning.prototype._collideWithWorld = function (velocity, candidatePos) {
                // var globalPosition=this.getPosition()
                // /** in babylon Free Camera, they decal the impact point by ellipsoid.y, but this is not very natural */
                // globalPosition.subtractFromFloatsToRef(0, 0, 0, this._oldPosition);
                this._collider.radius = this.ellipsoid;
                this._oldPosition.copyFrom(candidatePos);
                //this.grabberPilot.camera.getScene().collisionCoordinator.getNewPosition(this._oldPosition, velocity, this._collider, 3, null, this._onCollisionPositionChange, -13);
                this.camera.scene.collisionCoordinator.getNewPosition(this._oldPosition, velocity, this._collider, 3, null, this._onCollisionPositionChange, -13);
            };
            return WishedPositioning;
        }(mathis.Positioning));
        macamera.WishedPositioning = WishedPositioning;
        var Grabber = (function () {
            function Grabber(scene) {
                this.parallelDisplacementInsteadOfRotation = false;
                this.showGrabberOnlyWhenGrabbing = true;
                /**can stay null e.g. for plane grabber
                 * but if null no grabber rotation is possible, and no "recentring while goChanging back" */
                this.referenceCenter = null;
                //rotationAxis:XYZ=null
                this.onGrabbingActions = new mathis.StringMap();
                //radius = 1
                /**inside zone1: free displacement
                 * outside zone2: grabbing
                 * in zone2 minus zone1: interpolation between the two rotation
                 * outside zone3: the camera is detached from the grabber
                 * this distance are absolute. But in sphericalGrabber they are fixed proportionnaly to the radius of the grabber*/
                this.endOfZone1 = 1;
                this.endOfZone2 = 3;
                this.endOfZone3 = 10;
                this.zoneAreDefinedFromCenterRatherFromSurface = true;
                /**will produce no effect if no {@link Grabber.referenceCenter} is given*/
                this.focusOnMyCenterWhenCameraGoDownWard = true;
                this.scene = scene;
                this.material = new BABYLON.StandardMaterial('', this.scene);
                this.material = new BABYLON.StandardMaterial("texture1", this.scene);
                this.material.alpha = 0.3;
                this.material.diffuseColor = new BABYLON.Color3(1, 1, 1);
            }
            Grabber.prototype.dispose = function () {
                this.mesh.dispose();
            };
            /** return
             * 0 is we are too close of the wrapper, so we use freeMovement
             * 1 if wee are far, so we use pure wrapping mode
             * between 0 and 1 we can use mixed mode (or not depending to a boolean)
             * */
            Grabber.prototype.interpolationCoefAccordingToCamPosition = function (camPosition, distCamToGrabber) {
                //let l = geo.distance(this.rotationCenter, cameraPosition)
                var distance = 0;
                if (this.zoneAreDefinedFromCenterRatherFromSurface)
                    distance = mathis.geo.distance(camPosition, this.referenceCenter);
                else
                    distance = distCamToGrabber;
                if (distance <= this.endOfZone1)
                    return 0;
                if (distance >= this.endOfZone2)
                    return 1;
                return (distance - this.endOfZone1) / (this.endOfZone2 - this.endOfZone1);
            };
            Grabber.prototype.checkArgs = function () {
                if (this.zoneAreDefinedFromCenterRatherFromSurface && this.referenceCenter == null)
                    throw 'you must define a reference center when zoneAreDefinedFromCenterRatherFromSurface';
                if (this.focusOnMyCenterWhenCameraGoDownWard && this.referenceCenter == null)
                    throw 'you must define a reference center when focusOnMyCenterWhenCameraGoDownWard';
                if (this.endOfZone1 > this.endOfZone2)
                    throw 'zone2 must contains zone1';
                if (this.endOfZone2 > this.endOfZone3)
                    throw 'zone3 must contains zone2';
            };
            return Grabber;
        }());
        var SphericalGrabber = (function (_super) {
            __extends(SphericalGrabber, _super);
            function SphericalGrabber(scene, sizes, positionAndReferenceCenter, isPickable) {
                if (sizes === void 0) { sizes = new mathis.XYZ(1, 1, 1); }
                if (positionAndReferenceCenter === void 0) { positionAndReferenceCenter = new mathis.XYZ(0, 0, 0); }
                if (isPickable === void 0) { isPickable = false; }
                _super.call(this, scene);
                this.radius = 1;
                this.radius = sizes.x;
                this.endOfZone1 = this.radius;
                this.endOfZone2 = 3 * this.radius;
                this.endOfZone3 = 10 * this.radius;
                this.referenceCenter = positionAndReferenceCenter;
                this.focusOnMyCenterWhenCameraGoDownWard = true;
                this.parallelDisplacementInsteadOfRotation = false;
                this.showGrabberOnlyWhenGrabbing = true;
                this.mesh = BABYLON.Mesh.CreateSphere("default sphere for grabbing", 10, 2, scene);
                this.mesh.position = positionAndReferenceCenter;
                this.mesh.scaling = sizes;
                this.mesh.material = this.material;
                this.mesh.isPickable = isPickable;
            }
            return SphericalGrabber;
        }(Grabber));
        macamera.SphericalGrabber = SphericalGrabber;
        var PlanarGrabber = (function (_super) {
            __extends(PlanarGrabber, _super);
            function PlanarGrabber(scene, scaling, position, quaternion, isPickable) {
                if (scaling === void 0) { scaling = new mathis.XYZ(1, 1, 1); }
                if (position === void 0) { position = new mathis.XYZ(0, 0, 0); }
                if (quaternion === void 0) { quaternion = new mathis.XYZW(0, 0, 0, 1); }
                if (isPickable === void 0) { isPickable = false; }
                _super.call(this, scene);
                this.referenceCenter = null;
                this.focusOnMyCenterWhenCameraGoDownWard = false;
                this.parallelDisplacementInsteadOfRotation = true;
                this.zoneAreDefinedFromCenterRatherFromSurface = false;
                this.endOfZone1 = 0;
                this.endOfZone2 = 0;
                this.mesh = BABYLON.Mesh.CreatePlane("default plane for grabbing", 1, scene);
                this.mesh.position = position;
                this.mesh.scaling = scaling;
                this.mesh.rotationQuaternion = quaternion;
                //material.sideOrientation=BABYLON.Mesh.DOUBLESIDE
                this.mesh.material = this.material;
                this.mesh.isPickable = isPickable;
            }
            return PlanarGrabber;
        }(Grabber));
        macamera.PlanarGrabber = PlanarGrabber;
    })(macamera = mathis.macamera || (mathis.macamera = {}));
})(mathis || (mathis = {}));
/**
 * Created by vigon on 06/06/2016.
 */
var mathis;
(function (mathis) {
    var mameshAroundComputations;
    (function (mameshAroundComputations) {
        /**TODO code duplicate with surfaceVisuMaker*/
        var PositioningComputerForMameshVertices = (function () {
            function PositioningComputerForMameshVertices(mamesh) {
                /**default value : the x-axis, but for orthogonals : the y-axis, but for orthogonals: the z-axis*/
                this.attractionOfTangent = new mathis.XYZ(1, 0.0123456721, 0.00078654343);
                this.computeTangent = true;
                this.computeNormal = true;
                this.computeSizes = true;
                this.sizesProp = new mathis.XYZ(0.3, 0.3, 0.3);
                this.allVerticesHaveSameSizes = true;
                this.temp = new mathis.XYZ(0, 0, 0);
                this._side1 = new mathis.XYZ(0, 0, 0);
                this._side2 = new mathis.XYZ(0, 0, 0);
                this.mamesh = mamesh;
            }
            PositioningComputerForMameshVertices.prototype.checkArgs = function () {
                if (this.mamesh.smallestSquares.length == 0 && this.mamesh.smallestTriangles.length == 0)
                    throw "no triangles nor Square. The normals cannot be computed";
            };
            PositioningComputerForMameshVertices.prototype.go = function () {
                var _this = this;
                var res = new mathis.HashMap();
                if (this.mamesh.vertices.length == 0) {
                    cc('you try to compute normal, tangent, diameter for an empty IN_mamesh');
                    return;
                }
                this.mamesh.vertices.forEach(function (v) {
                    var positioning = new mathis.Positioning();
                    positioning.position = v.position;
                    positioning.upVector = new mathis.XYZ(0, 0, 0);
                    positioning.frontDir = new mathis.XYZ(0, 0, 0);
                    res.putValue(v, positioning);
                });
                /**tangent*/
                if (this.computeTangent) {
                    this.mamesh.vertices.forEach(function (vertex) {
                        //let smalestAngle = Number.MAX_VALUE
                        var greaterDotProduct = Number.NEGATIVE_INFINITY;
                        var smallerDotProduct = Number.POSITIVE_INFINITY;
                        var bestDirection = new mathis.XYZ(0, 0, 0);
                        var worstDirection = new mathis.XYZ(0, 0, 0);
                        if (vertex.links.length == 0)
                            throw 'a vertex with no links. Impossible to compute a tangent';
                        var attractionOfTangentLenght = _this.attractionOfTangent.length();
                        for (var i = 0; i < vertex.links.length; i++) {
                            _this.temp.copyFrom(vertex.links[i].to.position).substract(vertex.position);
                            if (_this.temp.length() < mathis.geo.epsilon) {
                                mathis.logger.c('a IN_mamesh has two vertices at almost the same position');
                            }
                            else {
                                var sca = mathis.geo.dot(_this.temp, _this.attractionOfTangent) / _this.temp.length() / attractionOfTangentLenght;
                                if (sca > greaterDotProduct) {
                                    greaterDotProduct = sca;
                                    bestDirection.copyFrom(_this.temp);
                                }
                                if (sca < smallerDotProduct) {
                                    smallerDotProduct = sca;
                                    worstDirection.copyFrom(_this.temp);
                                }
                            }
                        }
                        /**sometimes we prefer the opposite direction of the worst*/
                        if (-smallerDotProduct > 2 * greaterDotProduct)
                            res.getValue(vertex).frontDir.copyFrom(worstDirection.scale(-1));
                        else
                            res.getValue(vertex).frontDir.copyFrom(bestDirection);
                    });
                }
                /**normals*/
                if (this.computeNormal) {
                    /**triangulatedRect and square normal must be computed first*/
                    var triangleNormal = [];
                    for (var i = 0; i < this.mamesh.smallestTriangles.length / 3; i++) {
                        this._side1.copyFrom(this.mamesh.smallestTriangles[3 * i + 1].position).substract(this.mamesh.smallestTriangles[3 * i].position);
                        this._side2.copyFrom(this.mamesh.smallestTriangles[3 * i + 2].position).substract(this.mamesh.smallestTriangles[3 * i].position);
                        triangleNormal[i] = new mathis.XYZ(0, 0, 0);
                        mathis.geo.cross(this._side1, this._side2, triangleNormal[i]);
                        triangleNormal[i].normalize();
                    }
                    var squareNormal = [];
                    for (var i = 0; i < this.mamesh.smallestSquares.length / 4; i++) {
                        this._side1.copyFrom(this.mamesh.smallestSquares[4 * i + 1].position).substract(this.mamesh.smallestSquares[4 * i].position);
                        this._side2.copyFrom(this.mamesh.smallestSquares[4 * i + 3].position).substract(this.mamesh.smallestSquares[4 * i].position);
                        squareNormal[i] = new mathis.XYZ(0, 0, 0);
                        mathis.geo.cross(this._side1, this._side2, squareNormal[i]);
                        try {
                            squareNormal[i].normalize();
                        }
                        catch (e) {
                            throw 'the square' + this.mamesh.smallestSquares[4 * i].hashNumber + ',' + this.mamesh.smallestSquares[4 * i + 1].hashNumber + ',' + this.mamesh.smallestSquares[4 * i + 2].hashNumber + ',' + this.mamesh.smallestSquares[4 * i + 3].hashNumber + ' is degenerated';
                        }
                    }
                    /** now vertices normal are computed*/
                    for (var i = 0; i < triangleNormal.length; i++) {
                        var v0 = this.mamesh.smallestTriangles[3 * i];
                        var v1 = this.mamesh.smallestTriangles[3 * i + 1];
                        var v2 = this.mamesh.smallestTriangles[3 * i + 2];
                        res.getValue(v0).upVector.add(triangleNormal[i]);
                        res.getValue(v1).upVector.add(triangleNormal[i]);
                        res.getValue(v2).upVector.add(triangleNormal[i]);
                    }
                    for (var i = 0; i < squareNormal.length; i++) {
                        var v0 = this.mamesh.smallestSquares[4 * i];
                        var v1 = this.mamesh.smallestSquares[4 * i + 1];
                        var v2 = this.mamesh.smallestSquares[4 * i + 2];
                        var v3 = this.mamesh.smallestSquares[4 * i + 3];
                        res.getValue(v0).upVector.add(squareNormal[i]);
                        res.getValue(v1).upVector.add(squareNormal[i]);
                        res.getValue(v2).upVector.add(squareNormal[i]);
                        res.getValue(v3).upVector.add(squareNormal[i]);
                    }
                    var vertexWithoutNormal_1 = [];
                    this.mamesh.vertices.forEach(function (v) {
                        try {
                            res.getValue(v).upVector.normalize();
                        }
                        catch (e) {
                            mathis.logger.c('a too small upVector for a vertex, probably a vertex which is not in any polygone. The upVector will be the mean of other upVector');
                            vertexWithoutNormal_1.push(v);
                        }
                    });
                    if (vertexWithoutNormal_1.length > 0) {
                        var mean = new mathis.XYZ(0, 0, 0);
                        for (var _i = 0, _a = this.mamesh.vertices; _i < _a.length; _i++) {
                            var v = _a[_i];
                            mean.add(res.getValue(v).upVector); //perhaps zero
                        }
                        try {
                            mean.normalize();
                        }
                        catch (e) {
                            throw 'canot manage to compute upVector for any vertex';
                        }
                        for (var _b = 0, vertexWithoutNormal_2 = vertexWithoutNormal_1; _b < vertexWithoutNormal_2.length; _b++) {
                            var poorVertex = vertexWithoutNormal_2[_b];
                            res.getValue(poorVertex).upVector.copyFrom(mean);
                        }
                    }
                }
                /**sizes*/
                if (this.computeSizes) {
                    if (!this.allVerticesHaveSameSizes) {
                        this.mamesh.vertices.forEach(function (vertex) {
                            var sum = 0;
                            vertex.links.forEach(function (li) {
                                sum += mathis.geo.distance(vertex.position, li.to.position);
                            });
                            res.getValue(vertex).scaling.copyFrom(_this.sizesProp).scale(sum / vertex.links.length);
                        });
                    }
                    else {
                        var diam_1 = 0;
                        var vertex_1 = this.mamesh.vertices[0];
                        var sum_1 = 0;
                        vertex_1.links.forEach(function (li) {
                            sum_1 += mathis.geo.distance(vertex_1.position, li.to.position);
                        });
                        diam_1 = sum_1 / vertex_1.links.length;
                        this.mamesh.vertices.forEach(function (v) { return res.getValue(v).scaling.copyFrom(_this.sizesProp).scale(diam_1); });
                    }
                }
                return res;
            };
            return PositioningComputerForMameshVertices;
        }());
        mameshAroundComputations.PositioningComputerForMameshVertices = PositioningComputerForMameshVertices;
    })(mameshAroundComputations = mathis.mameshAroundComputations || (mathis.mameshAroundComputations = {}));
})(mathis || (mathis = {}));
/**
 * Created by vigon on 22/02/2016.
 */
var mathis;
(function (mathis) {
    var mameshModification;
    (function (mameshModification) {
        //import RadiusFunction = mathis.visu3d.LineGameoStatic.RadiusFunction;
        function completSegment(newParamForMiddle, mamesh, segment, orthogonalVertex) {
            /**premier passage. Pas de milieu */
            if (segment.middle == null) {
                var position = new mathis.XYZ(0, 0, 0);
                mathis.geo.between(segment.a.position, segment.b.position, 0.5, position);
                segment.middle = mamesh.newVertex(position, Math.max(segment.a.dichoLevel, segment.b.dichoLevel) + 1, newParamForMiddle(segment.a.param, segment.b.param));
                if (segment.a.hasMark(mathis.Vertex.Markers.border) && segment.b.hasMark(mathis.Vertex.Markers.border))
                    segment.middle.markers.push(mathis.Vertex.Markers.border);
                /**1 heure de perdue parce que j avais mis if (orthoIndex) au lieu de :if (orthoIndex!=null).
                 * Ne pas oubli que if(0) renvoit false !!! */
                if (orthogonalVertex != null)
                    segment.orth1 = orthogonalVertex;
            }
            else if (orthogonalVertex != null)
                segment.orth2 = orthogonalVertex;
        }
        var TriangleDichotomer = (function () {
            function TriangleDichotomer(mamesh) {
                this.makeLinks = true;
                this.trianglesToCut = null;
                this.nbDicho = 1;
                /**what is the new param? Can be adapted, e.g. for cyclic parametrisation*/
                this.newParamForMiddle = function (p1, p2) {
                    var res = new mathis.XYZ(0, 0, 0);
                    mathis.geo.between(p1, p2, 1 / 2, res);
                    return res;
                };
                this.mamesh = mamesh;
            }
            TriangleDichotomer.prototype.checkArgs = function () {
                // if (!this.mamesh.linksOK && this.createNewLinks) {
                //     logger.c('be carefull : it is impossible to make links because links are not ok')
                //     this.createNewLinks = false
                // }
                // if (!this.createNewLinks) {
                //     this.mamesh.linksOK = false
                // }
                if (this.mamesh.smallestTriangles.length == 0)
                    mathis.logger.c('no triangulatedRect for triangulatedRect dichotomy');
            };
            /** two methods to make your IN_mamesh thiner */
            TriangleDichotomer.prototype.go = function () {
                this.checkArgs();
                if (!this.makeLinks)
                    this.mamesh.clearLinksAndLines();
                /**else links and opposite are made during dichotomy process (which is not the case with squareDichotomer)*/
                var newTriangles;
                if (this.trianglesToCut == null) {
                    this.trianglesToCut = this.mamesh.smallestTriangles;
                    newTriangles = new Array();
                }
                else {
                    newTriangles = new mathis.tab.ArrayMinusBlocksElements(this.mamesh.smallestTriangles, 3, this.trianglesToCut).go();
                }
                //if (this.createNewLinks && !this.mamesh.linksOK) throw 'you cannot make links during dichotomy, because your links was not updated'
                //if (!this.createNewLinks) this.mamesh.linksOK = false
                var segments = this.createAndAddSegmentsFromTriangles(this.trianglesToCut);
                /**first passage : we add middle points everywhere, and create the segment list */
                for (var f = 0; f < this.trianglesToCut.length; f += 3) {
                    var v1 = this.trianglesToCut[f];
                    var v2 = this.trianglesToCut[f + 1];
                    var v3 = this.trianglesToCut[f + 2];
                    var segment3 = segments[mathis.Segment.segmentId(v1.hashNumber, v2.hashNumber)];
                    var segment1 = segments[mathis.Segment.segmentId(v2.hashNumber, v3.hashNumber)]; //mesh.getSegmentFromIndex(v2,v3)
                    var segment2 = segments[mathis.Segment.segmentId(v3.hashNumber, v1.hashNumber)]; //mesh.getSegmentFromIndex(v3,v1)
                    if (this.makeLinks) {
                        completSegment(this.newParamForMiddle, this.mamesh, segment3, v3);
                        completSegment(this.newParamForMiddle, this.mamesh, segment1, v1);
                        completSegment(this.newParamForMiddle, this.mamesh, segment2, v2);
                    }
                    else {
                        completSegment(this.newParamForMiddle, this.mamesh, segment3);
                        completSegment(this.newParamForMiddle, this.mamesh, segment1);
                        completSegment(this.newParamForMiddle, this.mamesh, segment2);
                    }
                    var f3 = segment3.middle;
                    var f1 = segment1.middle;
                    var f2 = segment2.middle;
                    //let f3 = getMiddlePoint(mesh.vertices, v1, v2, v3);
                    //let f1 = getMiddlePoint(mesh.vertices, v2, v3, v1);
                    //let f2 = getMiddlePoint(mesh.vertices, v3, v1, v2);
                    newTriangles.push(v1, f3, f2);
                    newTriangles.push(v2, f1, f3);
                    newTriangles.push(v3, f2, f1);
                    newTriangles.push(f3, f1, f2);
                }
                if (this.makeLinks) {
                    for (var segId in segments) {
                        var segment = segments[segId];
                        var segA1 = segments[mathis.Segment.segmentId(segment.a.hashNumber, segment.orth1.hashNumber)];
                        var segB1 = segments[mathis.Segment.segmentId(segment.b.hashNumber, segment.orth1.hashNumber)];
                        if (segment.orth2 != null) {
                            var segA2 = segments[mathis.Segment.segmentId(segment.a.hashNumber, segment.orth2.hashNumber)];
                            var segB2 = segments[mathis.Segment.segmentId(segment.b.hashNumber, segment.orth2.hashNumber)];
                            segment.middle.setTwoOppositeLinks(segA1.middle, segB2.middle);
                            segment.middle.setTwoOppositeLinks(segA2.middle, segB1.middle);
                        }
                        else {
                            segment.middle.setOneLink(segA1.middle);
                            segment.middle.setOneLink(segB1.middle);
                        }
                        try {
                            function changeFleArrival(v, old, newVoi) {
                                var fle = v.findLink(old);
                                fle.to = newVoi;
                            }
                            changeFleArrival(segment.a, segment.b, segment.middle);
                            changeFleArrival(segment.b, segment.a, segment.middle);
                            segment.middle.setTwoOppositeLinks(segment.a, segment.b);
                        }
                        catch (e) {
                            throw 'a bad segment, probably your triangles are not corrects (e.g. one missing, or one more)';
                        }
                    }
                }
                //at the end, only the last ilist is kept : this is the list of the thiner triangles.
                this.mamesh.smallestTriangles = newTriangles;
            };
            //private removeTriangleFromList(longList:Vertex[],listToRemove:Vertex[]):Vertex[]{
            //
            //
            //    let  funcToSort=function(a:number, b:number){return a-b}
            //    function key(i,list:Vertex[]):string{
            //        let array=[list[i].hash,list[i+1].hash,list[i+2].hash]
            //        array.sort(funcToSort)
            //        return array[0]+','+array[1]+','+array[2]
            //    }
            //
            //    let dicoToRemove:{ [id:string]:boolean }={}
            //
            //    for (let i=0;i<listToRemove.length;i+=3){
            //        dicoToRemove[key(i,listToRemove)]=true
            //    }
            //
            //    let newLongList=new Array<Vertex>()
            //    for (let i=0;i<longList.length;i+=3){
            //        if (!dicoToRemove[key(i,longList)]){
            //            newLongList.push(longList[i],longList[i+1],longList[i+2])
            //        }
            //    }
            //
            //    return newLongList
            //
            //}
            TriangleDichotomer.prototype.createAndAddSegmentsFromTriangles = function (triangles) {
                var segments = {};
                for (var f = 0; f < triangles.length; f += 3) {
                    var v1 = triangles[f];
                    var v2 = triangles[f + 1];
                    var v3 = triangles[f + 2];
                    this.mamesh.getOrCreateSegment(v1, v2, segments);
                    this.mamesh.getOrCreateSegment(v2, v3, segments);
                    this.mamesh.getOrCreateSegment(v3, v1, segments);
                }
                return segments;
            };
            return TriangleDichotomer;
        }());
        mameshModification.TriangleDichotomer = TriangleDichotomer;
        /** mauvais interaction avec le triangle dichotomer : but quand on fait la dicho sur des polyhedrons */
        var SquareDichotomer = (function () {
            function SquareDichotomer(mamesh) {
                this.makeLinks = true;
                this.squareToCut = null;
                this.dichoStyle = SquareDichotomer.DichoStyle.fourSquares;
                /**what is the new param? Can be adapted, e.g. for cyclic parametrisation*/
                this.newParamForMiddle = function (p1, p2) {
                    var res = new mathis.XYZ(0, 0, 0);
                    mathis.geo.between(p1, p2, 1 / 2, res);
                    return res;
                };
                this.newParamForCenter = function (p1, p2, p3, p4) {
                    var res = new mathis.XYZ(0, 0, 0);
                    mathis.geo.baryCenter([p1, p2, p3, p4], [1 / 4, 1 / 4, 1 / 4, 1 / 4], res);
                    return res;
                };
                this.mamesh = mamesh;
            }
            SquareDichotomer.prototype.checkArgs = function () {
                // if (this.mamesh.linksOK) {
                //     logger.c('you  break  existing links')
                //     this.mamesh.linksOK = false
                //
                // }
                if (this.mamesh.smallestSquares.length == 0)
                    throw 'no square for square dichotomy';
                this.mamesh.clearLinksAndLines();
            };
            SquareDichotomer.prototype.go = function () {
                this.checkArgs();
                var newSquares;
                if (this.squareToCut == null) {
                    this.squareToCut = this.mamesh.smallestSquares;
                    newSquares = new Array();
                }
                else {
                    /**we keep square that we do not want to cut*/
                    newSquares = new mathis.tab.ArrayMinusBlocksElements(this.mamesh.smallestSquares, 4, this.squareToCut).go();
                }
                var segments = this.createAndAddSegmentsFromSquare(this.squareToCut);
                /**first passage : we add middle points everywhere, and create the segment list */
                for (var f = 0; f < this.squareToCut.length; f += 4) {
                    var v1 = this.squareToCut[f];
                    var v2 = this.squareToCut[f + 1];
                    var v3 = this.squareToCut[f + 2];
                    var v4 = this.squareToCut[f + 3];
                    var segment1 = segments[mathis.Segment.segmentId(v1.hashNumber, v2.hashNumber)];
                    var segment2 = segments[mathis.Segment.segmentId(v2.hashNumber, v3.hashNumber)];
                    var segment3 = segments[mathis.Segment.segmentId(v3.hashNumber, v4.hashNumber)];
                    var segment4 = segments[mathis.Segment.segmentId(v4.hashNumber, v1.hashNumber)];
                    completSegment(this.newParamForMiddle, this.mamesh, segment1);
                    completSegment(this.newParamForMiddle, this.mamesh, segment2);
                    completSegment(this.newParamForMiddle, this.mamesh, segment3);
                    completSegment(this.newParamForMiddle, this.mamesh, segment4);
                    var f1 = segment1.middle;
                    var f2 = segment2.middle;
                    var f3 = segment3.middle;
                    var f4 = segment4.middle;
                    if (this.dichoStyle == SquareDichotomer.DichoStyle.fourSquares) {
                        //this.IN_mamesh.vertices.push(center)
                        var position = new mathis.XYZ(0, 0, 0);
                        mathis.geo.baryCenter([segment1.a.position, segment1.b.position, segment3.a.position, segment3.b.position], [1 / 4, 1 / 4, 1 / 4, 1 / 4], position);
                        var dichoLevel = Math.max(segment1.a.dichoLevel, segment1.b.dichoLevel, segment3.a.dichoLevel, segment3.b.dichoLevel) + 1;
                        var center = this.mamesh.newVertex(position, dichoLevel, this.newParamForCenter(segment1.a.param, segment1.b.param, segment3.a.param, segment3.b.param));
                        /** we chose arbitrary to put the new point on the middle of the segment (f1,f3), it could also be (f2,f4). This is important for the fractal construction that each new point is in a middle a a single segment */
                        var aNewCetSegment = new mathis.Segment(f1, f3);
                        aNewCetSegment.middle = center;
                        this.mamesh.cutSegmentsDico[mathis.Segment.segmentId(f1.hashNumber, f3.hashNumber)] = aNewCetSegment;
                        newSquares.push(v1, f1, center, f4);
                        newSquares.push(v2, f2, center, f1);
                        newSquares.push(v3, f3, center, f2);
                        newSquares.push(v4, f4, center, f3);
                    }
                    else if (this.dichoStyle == SquareDichotomer.DichoStyle.fourTriangles) {
                        newSquares.push(f1, f2, f3, f4);
                        this.mamesh.smallestTriangles.push(v1, f1, f4);
                        this.mamesh.smallestTriangles.push(v2, f2, f1);
                        this.mamesh.smallestTriangles.push(v3, f3, f2);
                        this.mamesh.smallestTriangles.push(v4, f4, f3);
                    }
                    else
                        throw 'ho ho';
                }
                //at the end, only the last ilist is kept : this is the list of the thiner triangles.
                this.mamesh.smallestSquares = newSquares;
                //TODO : heavy works because links are not made during dichotomy process
                if (this.makeLinks) {
                    var linker = new mathis.linkModule.LinkCreaterSorterAndBorderDetecterByPolygons(this.mamesh);
                    linker.goChanging();
                }
            };
            //private removeSquareFromList(longList:Vertex[],listToRemove:Vertex[]):Vertex[]{
            //
            //
            //    let  funcToSort=function(a:number, b:number){return a-b}
            //
            //    function key(i,list:Vertex[]):string{
            //        let array=[list[i].hash,list[i+1].hash,list[i+2].hash,list[i+3].hash]
            //        array.sort(funcToSort)
            //        return array[0]+','+array[1]+','+array[2]+','+array[3]
            //    }
            //
            //    let dicoToRemove:{ [id:string]:boolean }={}
            //
            //    for (let i=0;i<listToRemove.length;i+=4){
            //        dicoToRemove[key(i,listToRemove)]=true
            //    }
            //
            //    let newLongList=new Array<Vertex>()
            //    for (let i=0;i<longList.length;i+=4){
            //        if (dicoToRemove[key(i,longList)]!=null){
            //            newLongList.push(longList[i],longList[i+1],longList[i+2],longList[i+3])
            //        }
            //    }
            //
            //    return newLongList
            //
            //}
            SquareDichotomer.prototype.createAndAddSegmentsFromSquare = function (squares) {
                var segments = {};
                for (var f = 0; f < squares.length; f += 4) {
                    var v1 = squares[f];
                    var v2 = squares[f + 1];
                    var v3 = squares[f + 2];
                    var v4 = squares[f + 3];
                    this.mamesh.getOrCreateSegment(v1, v2, segments);
                    this.mamesh.getOrCreateSegment(v2, v3, segments);
                    this.mamesh.getOrCreateSegment(v3, v4, segments);
                    this.mamesh.getOrCreateSegment(v4, v1, segments);
                }
                return segments;
            };
            return SquareDichotomer;
        }());
        mameshModification.SquareDichotomer = SquareDichotomer;
        var SquareDichotomer;
        (function (SquareDichotomer) {
            (function (DichoStyle) {
                DichoStyle[DichoStyle["fourSquares"] = 0] = "fourSquares";
                DichoStyle[DichoStyle["fourTriangles"] = 1] = "fourTriangles";
            })(SquareDichotomer.DichoStyle || (SquareDichotomer.DichoStyle = {}));
            var DichoStyle = SquareDichotomer.DichoStyle;
        })(SquareDichotomer = mameshModification.SquareDichotomer || (mameshModification.SquareDichotomer = {}));
        var MameshDeepCopier = (function () {
            function MameshDeepCopier(oldMamesh) {
                this.copyCutSegmentsDico = true;
                this.copyLines = true;
                this.oldMamesh = oldMamesh;
            }
            MameshDeepCopier.prototype.go = function () {
                var o2n = new mathis.HashMap();
                var newMamesh = new mathis.Mamesh();
                this.oldMamesh.vertices.forEach(function (oldV) {
                    var param = mathis.XYZ.newFrom(oldV.param);
                    var newVertex = newMamesh.newVertex(oldV.position, oldV.dichoLevel, param);
                    o2n.putValue(oldV, newVertex);
                    newVertex.importantMarker = oldV.importantMarker;
                    oldV.markers.forEach(function (enu) { return newVertex.markers.push(enu); });
                });
                this.oldMamesh.vertices.forEach(function (oldV) {
                    var newV = o2n.getValue(oldV);
                    for (var i = 0; i < oldV.links.length; i++) {
                        newV.links[i] = new mathis.Link(o2n.getValue(oldV.links[i].to));
                    }
                    for (var i = 0; i < oldV.links.length; i++) {
                        var oldLink = oldV.links[i];
                        var newLink = newV.links[i];
                        if (oldLink.opposites != null) {
                            newLink.opposites = [];
                            for (var _i = 0, _a = oldLink.opposites; _i < _a.length; _i++) {
                                var li = _a[_i];
                                var liIndex = oldV.links.indexOf(li);
                                newLink.opposites.push(newV.links[liIndex]);
                            }
                        }
                    }
                });
                this.oldMamesh.smallestTriangles.forEach(function (v) {
                    newMamesh.smallestTriangles.push(o2n.getValue(v));
                });
                this.oldMamesh.smallestSquares.forEach(function (v) {
                    newMamesh.smallestSquares.push(o2n.getValue(v));
                });
                if (this.copyLines) {
                    if (this.oldMamesh.linesWasMade) {
                        var oldStraight = this.oldMamesh.getStraightLinesAsVertices();
                        var oldLoop = this.oldMamesh.getLoopLinesAsVertices();
                        newMamesh.lines = [];
                        oldStraight.forEach(function (line) {
                            var newLine = [];
                            line.forEach(function (v) {
                                newLine.push(o2n.getValue(v));
                            });
                            newMamesh.lines.push(new mathis.Line(newLine, false));
                        });
                        oldLoop.forEach(function (line) {
                            var newLine = [];
                            line.forEach(function (v) {
                                newLine.push(o2n.getValue(v));
                            });
                            newMamesh.lines.push(new mathis.Line(newLine, true));
                        });
                    }
                }
                //newMamesh.linksOK = this.oldMamesh.linksOK
                if (this.copyCutSegmentsDico) {
                    for (var key in this.oldMamesh.cutSegmentsDico) {
                        var oldSegment = this.oldMamesh.cutSegmentsDico[key];
                        var newA = o2n.getValue(oldSegment.a);
                        var newB = o2n.getValue(oldSegment.b);
                        var newSegment = new mathis.Segment(newA, newB);
                        newSegment.middle = o2n.getValue(oldSegment.middle);
                        if (oldSegment.orth1 != null)
                            newSegment.orth1 = o2n.getValue(oldSegment.orth1);
                        if (oldSegment.orth2 != null)
                            newSegment.orth2 = o2n.getValue(oldSegment.orth2);
                        newMamesh.cutSegmentsDico[mathis.Segment.segmentId(newA.hashNumber, newB.hashNumber)] = newSegment;
                    }
                }
                else
                    this.copyCutSegmentsDico = null;
                return newMamesh;
            };
            return MameshDeepCopier;
        }());
        mameshModification.MameshDeepCopier = MameshDeepCopier;
        var PercolationOnLinks = (function () {
            function PercolationOnLinks(mameshOrVertices) {
                var _this = this;
                this.percolationProba = 0.5;
                this.probaToPercolateFunction = function (vertex) {
                    if (vertex.links.length == 3)
                        return 0;
                    if (vertex.links.length == 4)
                        return 0.3 * _this.percolationProba;
                    if (vertex.links.length == 5)
                        return 0.6 * _this.percolationProba;
                    if (vertex.links.length >= 6)
                        return _this.percolationProba;
                };
                this.SUB_random = new mathis.proba.Random();
                this.doNotPercolateOnBorder = true;
                this.maxPercolationForAVertexAlreadyPercolate = 0;
                if (mameshOrVertices instanceof mathis.Mamesh) {
                    this.IN_vertices = mameshOrVertices.vertices;
                }
                else {
                    this.IN_vertices = mameshOrVertices;
                }
            }
            PercolationOnLinks.prototype.goChanging = function () {
                if (this.IN_vertices == null)
                    throw 'vertices must be specifiate';
                var vertexToNbLink = new mathis.HashMap();
                for (var _i = 0, _a = this.IN_vertices; _i < _a.length; _i++) {
                    var v = _a[_i];
                    vertexToNbLink.putValue(v, v.links.length);
                }
                for (var _b = 0, _c = this.IN_vertices; _b < _c.length; _b++) {
                    var v = _c[_b];
                    if (!(this.doNotPercolateOnBorder && v.hasMark(mathis.Vertex.Markers.border))) {
                        if (this.SUB_random.pseudoRand() < this.probaToPercolateFunction(v)) {
                            var randInd = this.SUB_random.pseudoRandInt(v.links.length);
                            var randVoi = v.links[randInd].to;
                            if (randVoi.links.length >= vertexToNbLink.getValue(randVoi) - this.maxPercolationForAVertexAlreadyPercolate)
                                mathis.Vertex.separateTwoVoisins(v, randVoi);
                        }
                    }
                }
            };
            return PercolationOnLinks;
        }());
        mameshModification.PercolationOnLinks = PercolationOnLinks;
        var MameshCleaner = (function () {
            function MameshCleaner(mamesh) {
                this.OUT_nbLinkSuppressed = 0;
                this.OUT_nbVerticesSuppressed = 0;
                this.suppressCellWithNoVoisin = true;
                /**other interesting function : (v:Vertex)=> (!v.isBorder()) which is better that the following or percolated IN_mamesh  */
                this.suppressLinkWithoutOppositeFunction = function (v) { return (v.links.length >= 5); };
                this.IN_mamesh = mamesh;
            }
            MameshCleaner.prototype.goChanging = function () {
                if (this.IN_mamesh == null)
                    throw 'a Mamesh is require as IN_arg';
                if (this.suppressLinkWithoutOppositeFunction != null)
                    this.suppressLinkWithoutOpposite();
            };
            MameshCleaner.prototype.suppressLinkWithoutOpposite = function () {
                var goOn = true;
                while (goOn) {
                    goOn = false;
                    for (var _i = 0, _a = this.IN_mamesh.vertices; _i < _a.length; _i++) {
                        var v = _a[_i];
                        if (this.suppressLinkWithoutOppositeFunction(v)) {
                            for (var i = 0; i < v.links.length; i++) {
                                var li = v.links[i];
                                if (li.opposites == null) {
                                    goOn = true;
                                    mathis.Vertex.separateTwoVoisins(v, li.to);
                                    this.OUT_nbLinkSuppressed++;
                                    break;
                                }
                            }
                        }
                    }
                }
                if (this.suppressCellWithNoVoisin) {
                    var indexToSuppress = [];
                    for (var i = 0; i < this.IN_mamesh.vertices.length; i++) {
                        if (this.IN_mamesh.vertices[i].links.length == 0) {
                            indexToSuppress.push(i);
                            this.OUT_nbVerticesSuppressed++;
                        }
                    }
                    this.IN_mamesh.vertices = mathis.tab.arrayMinusSomeIndices(this.IN_mamesh.vertices, indexToSuppress);
                }
            };
            return MameshCleaner;
        }());
        mameshModification.MameshCleaner = MameshCleaner;
    })(mameshModification = mathis.mameshModification || (mathis.mameshModification = {}));
})(mathis || (mathis = {}));
/**
 * Created by vigon on 05/12/2016.
 */
var mathis;
(function (mathis) {
    var PeriodicActionBeforeRender = (function () {
        function PeriodicActionBeforeRender(action) {
            /**if 1, the action is just done 1 times*/
            this.nbTimesThisActionMustBeFired = Number.POSITIVE_INFINITY;
            this.firedCount = 0;
            this.id = "";
            this.frameInterval = null;
            this.timeIntervalMilli = null;
            this.passageOrderIndex = 1;
            this.action = action;
            this.lastTimeFired = performance.now();
        }
        return PeriodicActionBeforeRender;
    }());
    mathis.PeriodicAction = PeriodicActionBeforeRender;
    var MathisFrame = (function () {
        function MathisFrame(htmlElementOrId, addDefaultCameraAndLight) {
            var _this = this;
            if (htmlElementOrId === void 0) { htmlElementOrId = null; }
            if (addDefaultCameraAndLight === void 0) { addDefaultCameraAndLight = true; }
            /**
             * If no canvasContainer is given, it is affected to document.body
              */
            //canvasContainer:any//html or jquery element
            //backgroundColorInHexa:string=null
            this.callbackIfWebglNotHere = null;
            this.actionsBeforeRender = [];
            this.sortAction = function (action1, action2) { return action1.passageOrderIndex - action2.passageOrderIndex; };
            this.backgroundColor = new mathis.Color("#d3d3d3");
            this.parentWidth = null;
            if (htmlElementOrId == null) {
                var html = document.getElementsByTagName("html")[0];
                html.style.height = "100%";
                html.style.width = "100%";
                html.style.padding = "0";
                html.style.margin = "0";
                this.canvasParent = document.getElementsByTagName("body")[0];
                this.canvasParent.style.height = "100%";
                this.canvasParent.style.width = "100%";
                this.canvasParent.style.padding = "0";
                this.canvasParent.style.margin = "0";
            }
            else {
                if (typeof htmlElementOrId == 'string') {
                    this.canvasParent = document.getElementById(htmlElementOrId);
                    if (this.canvasParent == null)
                        throw 'the id:' + htmlElementOrId + ' does not correspond to any HTMLElement';
                }
                else if (htmlElementOrId instanceof HTMLElement)
                    this.canvasParent = htmlElementOrId;
                else
                    throw 'htmlElementOrId must be an htmlElement or the id of an html element';
            }
            if (this.canvasParent.offsetHeight < 10)
                throw "the container-height is too small";
            if (this.canvasParent.offsetWidth < 10)
                throw "the container-width is too small";
            this.canvas = document.createElement('canvas');
            /**ils mettent cette ligne dans le premier tuto de Babylon. J'imagine pour utiliser hand.JS*/
            this.canvas.style.touchAction = "none";
            this.canvasParent.appendChild(this.canvas);
            this.canvasParent.style.position = "relative";
            this.set100(this.canvas);
            this.callbackIfWebglNotHere = function () {
                setTimeout(function () {
                    var $noWebGL = document.createElement("DIV");
                    $noWebGL.id = "noWebGL";
                    $noWebGL.innerHTML =
                        "<h3> Activez WebGL et relancez la page.</h3>\n                     <p> Safari: D\u00E9veloppement > Activer WebGL</p>";
                    _this.canvasParent.appendChild($noWebGL);
                    _this.canvasParent.style.position = "absolute";
                    _this.canvasParent.style.top = "0";
                    _this.canvasParent.style.left = "0";
                    _this.canvasParent.style.textAlign = "center";
                    _this.canvasParent.style.zIndex = "1001";
                    _this.canvasParent.style.backgroundColor = "red";
                    // position: absolute;
                    // top:0;
                    // left:0;
                    // width:100%;
                    // text-align: center;
                    // height: 20px;
                    // z-index: 1000;
                }, 100);
            };
            /** be careful, the style must be load before, if the canvas dimension are decide after the engine creation, the pixed are really big */
            try {
                this.engine = new BABYLON.Engine(this.canvas, true);
            }
            catch (e) {
                mathis.logger.c('webGL seems to not be present. Here is the message from Babylon:' + e);
                this.callbackIfWebglNotHere();
                this.engine = null;
            }
            if (this.engine != null) {
                this.resetScene();
                //TODO this.scene=new BABYLON.Scene(this.engine)
                var count = 0;
                var minFps = 0;
                var frameCount_1 = 0;
                this.engine.runRenderLoop(function () {
                    frameCount_1++;
                    for (var key in _this.actionsBeforeRender) {
                        var act = _this.actionsBeforeRender[key];
                        //cc(frameCount%4)
                        if (act.timeIntervalMilli == null && act.frameInterval == null) {
                            act.frameInterval = 1;
                            mathis.logger.c("no intervalle given for a periodic action: by default the action is fired every frame");
                        }
                        if (act.timeIntervalMilli != null) {
                            var time = performance.now();
                            if (time - act.lastTimeFired > act.timeIntervalMilli) {
                                _this.fireAction(act);
                                act.lastTimeFired = time;
                            }
                        }
                        else if (act.frameInterval != null && frameCount_1 % act.frameInterval == 0)
                            _this.fireAction(act);
                    }
                    _this.scene.render();
                    count++;
                    var fps = _this.engine.getFps();
                    if (fps < minFps)
                        minFps = fps;
                    if (count % 100 == 0) {
                        if (_this.$info != null)
                            _this.$info.textContent = minFps.toFixed();
                        minFps = Number.MAX_VALUE;
                    }
                });
                this.domEventsHandler();
            }
            if (addDefaultCameraAndLight) {
                this.addDefaultLight();
                this.addDefaultCamera();
            }
            this.messageDiv = new MessageDiv(this);
        }
        MathisFrame.prototype.showFPSinCorner = function () {
            this.$info = document.createElement("DIV");
            this.canvasParent.appendChild(this.$info);
            this.$info.style.position = 'absolute';
            this.$info.style.top = '0';
            this.$info.style.left = '0';
            this.$info.style.width = '100px';
            this.$info.style.height = '20px';
            this.$info.style.backgroundColor = 'red';
            this.$info.style.zIndex = '1000';
        };
        MathisFrame.prototype.dispose = function () {
            this.engine.dispose();
        };
        MathisFrame.prototype.resetScene = function () {
            if (this.scene != null)
                this.scene.dispose();
            this.scene = new BABYLON.Scene(this.engine);
            this.scene.clearColor = this.backgroundColor.toBABYLON_Color4(); //new BABYLON.Color3(this.backgroundColorRGB.r,this.backgroundColorRGB.g,this.backgroundColorRGB.b);
        };
        MathisFrame.prototype.clearScene = function (clearCamera, clearLights, clearSkybox) {
            if (clearCamera === void 0) { clearCamera = true; }
            if (clearLights === void 0) { clearLights = true; }
            if (clearSkybox === void 0) { clearSkybox = true; }
            if (this.scene == null)
                throw 'no scene to clear';
            var meshesToKeep = [];
            if (this.scene.activeCamera != null && !clearCamera) {
                if (this.scene.activeCamera instanceof mathis.macamera.GrabberCamera) {
                    var macam = this.scene.activeCamera;
                    for (var _i = 0, _a = macam.grabbers; _i < _a.length; _i++) {
                        var grab = _a[_i];
                        meshesToKeep.push(grab.mesh);
                    }
                }
            }
            else {
                this.scene.cameras = [];
                if (this.scene.activeCamera != null)
                    this.scene.activeCamera.detachControl(this.canvas);
                this.scene.activeCamera = null;
            }
            if (!clearSkybox)
                meshesToKeep.push(this.skybox);
            else
                this.skybox = null;
            this.scene.meshes = meshesToKeep;
            if (clearLights)
                this.scene.lights = [];
            //else this.scene.meshes=[]
        };
        MathisFrame.prototype.addDefaultLight = function () {
            var light0 = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(-1, 1, -1), this.scene);
            // light0.diffuse = new BABYLON.Color3(1, 1, 1);
            // light0.specular = new BABYLON.Color3(1, 1, 1);
            // light0.groundColor = new BABYLON.Color3(0, 0, 0);
            light0.diffuse = new BABYLON.Color3(1, 1, 1);
            light0.specular = new BABYLON.Color3(1, 1, 1);
            light0.groundColor = new BABYLON.Color3(0.5, 0.5, 0.5);
        };
        MathisFrame.prototype.getGrabberCamera = function () {
            if (this.scene.activeCamera == null)
                throw "no camera defined";
            if (this.scene.activeCamera instanceof mathis.macamera.GrabberCamera)
                return this.scene.activeCamera;
            else
                throw "active camera is not a grabber camera";
        };
        MathisFrame.prototype.addDefaultCamera = function () {
            var grabber0 = new mathis.macamera.SphericalGrabber(this.scene);
            //TODO
            this.scene.activeCamera = new mathis.macamera.GrabberCamera(this, grabber0);
            this.scene.activeCamera.attachControl(this.canvas);
            //this.scene.activeCamera=this.camera
        };
        MathisFrame.prototype.pushPeriodicAction = function (action) {
            this.actionsBeforeRender.push(action);
            this.actionsBeforeRender.sort(this.sortAction);
        };
        MathisFrame.prototype.suppressPeriodicAction = function (action) {
            var index = this.actionsBeforeRender.indexOf(action);
            if (index == -1)
                throw 'this action is not registered';
            this.actionsBeforeRender.splice(index, 1);
        };
        MathisFrame.prototype.fireAction = function (ac) {
            ac.action();
            ac.firedCount++;
            if (ac.firedCount >= ac.nbTimesThisActionMustBeFired) {
                this.suppressPeriodicAction(ac);
            }
        };
        MathisFrame.prototype.set100 = function (element) {
            element.style.position = "absolute";
            element.style.top = "0";
            element.style.left = "0";
            element.style.width = "100%";
            element.style.height = "100%";
            // position: absolute;
            // top:0;
            // left: 0;
            // width: 100%;
            // height: 100%;
        };
        MathisFrame.prototype.onParentDimChange = function () {
            var width = this.canvasParent.offsetWidth;
            if (this.parentWidth == null)
                this.parentWidth = width;
            else {
                if (width != this.parentWidth) {
                    this.parentWidth = width;
                    this.engine.resize();
                    console.log("dim of parent of canvas  changes");
                }
            }
        };
        MathisFrame.prototype.domEventsHandler = function () {
            var _this = this;
            this.parentWidth = this.canvasParent.offsetWidth;
            window.addEventListener("resize", function () {
                _this.onParentDimChange();
            });
            /**because the parent can change without any change of the window*/
            setInterval(function () {
                _this.onParentDimChange();
            }, 1000);
            var globalClickAction = function () {
                var pickResult = _this.scene.pick(_this.scene.pointerX, _this.scene.pointerY, function (mesh) { return mesh.isPickable; }, false);
                if (pickResult.pickedMesh != null) {
                    var clickFuntion = pickResult.pickedMesh.onClick;
                    if (clickFuntion != null) {
                        clickFuntion(pickResult.pickedPoint);
                    }
                }
            };
            var timeOfDown;
            var downAction = function () {
                timeOfDown = performance.now();
            };
            var upAction = function () {
                if (performance.now() - timeOfDown < 500)
                    globalClickAction();
            };
            var prefix = BABYLON.Tools.GetPointerPrefix(); //'pointer' if possible, or 'mouse' if not
            this.canvas.addEventListener(prefix + "down", downAction, false);
            this.canvas.addEventListener(prefix + "up", upAction, false);
        };
        return MathisFrame;
    }());
    mathis.MathisFrame = MathisFrame;
    var MessageDiv = (function () {
        function MessageDiv(mathisFrame) {
            this.mathisFrame = mathisFrame;
        }
        MessageDiv.prototype.addInMathisFrame = function () {
            this.$logDiv = document.createElement("DIV");
            this.mathisFrame.canvasParent.appendChild(this.$logDiv);
            this.$logDiv.style.position = 'absolute';
            this.$logDiv.style.top = '0';
            this.$logDiv.style.left = '0';
            this.$logDiv.style.width = '100%';
            //this.$info.style.height= '20px';
            this.$logDiv.style.backgroundColor = 'white';
            this.$logDiv.style.zIndex = '900';
        };
        MessageDiv.prototype.append = function (message) {
            if (this.$logDiv == null)
                this.addInMathisFrame();
            var $message = document.createElement("DIV");
            $message.innerHTML = message;
            this.$logDiv.appendChild($message);
        };
        MessageDiv.prototype.empty = function () {
            if (this.$logDiv == null)
                return;
            this.$logDiv.innerHTML = "";
        };
        return MessageDiv;
    }());
})(mathis || (mathis = {}));
// /**
//  * Created by vigon on 05/12/2016.
//  */
//
//
// module mathis{
//
//
//
//     export class PeriodicActionBeforeRender{
//
//         /**if 1, the action is just done 1 times*/
//         nbTimesThisActionMustBeFired=Number.POSITIVE_INFINITY
//         firedCount=0
//
//         id:string=""
//         action:()=>void
//         frameInterval:number=null
//         timeIntervalMilli:number=null
//
//         constructor(action:()=>void){
//             this.action=action
//             this.lastTimeFired=performance.now()
//         }
//
//         lastTimeFired:number
//         passageOrderIndex=1
//
//     }
//
//
//     export class MathisFrame{
//        
//         canvas:HTMLElement
//         scene:BABYLON.Scene
//         engine:BABYLON.Engine
//         /**
//          * If no canvasContainer is given, it is affected to document.body
//          * Warning: if you give a canvasContainer, it must have position:something, because some childs are positionned with top/left... CSS properties */
//         canvasContainer:any//html or jquery element
//         //backgroundColorInHexa:string=null
//         callbackIfWebglNotHere:()=>void=null
//
//
//         showFPSinCorner=false
//
//         dispose():void{
//             this.engine.dispose()
//         }
//         resetScene():void{
//             if (this.scene!=null) this.scene.dispose()
//             this.scene=new BABYLON.Scene(this.engine)
//             this.scene.clearColor = this.backgroundColor.toBABYLON_Color4()//new BABYLON.Color3(this.backgroundColorRGB.r,this.backgroundColorRGB.g,this.backgroundColorRGB.b);
//         }
//         /**faster than reseting (but meshes are not disposed)*/
//         skybox:BABYLON.Mesh
//         clearScene(clearCamera=true,clearLights=true,clearSkybox=true):void{
//
//             if (this.scene==null) throw 'no scene to clear'
//
//             let meshesToKeep=[]
//
//             if (this.scene.activeCamera!=null && !clearCamera){
//                 if (this.scene.activeCamera instanceof macamera.GrabberCamera) {
//                     let macam=<macamera.GrabberCamera>this.scene.activeCamera
//                     for (let grab of macam.grabbers)  meshesToKeep.push(grab.mesh)
//                 }
//             }
//             else{
//
//                 this.scene.cameras=[]
//                 if(this.scene.activeCamera!=null)this.scene.activeCamera.detachControl(this.canvas)
//                 this.scene.activeCamera=null
//             }
//
//             if (!clearSkybox) meshesToKeep.push(this.skybox)
//             else this.skybox=null
//
//
//             this.scene.meshes=meshesToKeep
//
//             if(clearLights) this.scene.lights=[]
//
//
//             //else this.scene.meshes=[]
//         }
//
//
//         addDefaultLight(){
//             var light0 = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(-1, 1, -1), this.scene);
//             // light0.diffuse = new BABYLON.Color3(1, 1, 1);
//             // light0.specular = new BABYLON.Color3(1, 1, 1);
//             // light0.groundColor = new BABYLON.Color3(0, 0, 0);
//
//             light0.diffuse = new BABYLON.Color3(1,1,1);
//             light0.specular = new BABYLON.Color3(1,1,1);
//             light0.groundColor = new BABYLON.Color3(0.5,0.5,0.5);
//
//         }
//
//         getGrabberCamera(){
//             if (this.scene.activeCamera==null) throw "no camera defined"
//             if (this.scene.activeCamera instanceof macamera.GrabberCamera) return <macamera.GrabberCamera> this.scene.activeCamera
//             else throw "active camera is not a grabber camera"
//         }
//         addDefaultCamera(){
//             let grabber0 = new macamera.SphericalGrabber(this.scene)
//             this.scene.activeCamera = new macamera.GrabberCamera(this, grabber0)
//             this.scene.activeCamera.attachControl(this.canvas)
//             //this.scene.activeCamera=this.camera
//
//
//         }
//
//
//        
//         private actionsBeforeRender:Array<PeriodicActionBeforeRender>=[]
//         private sortAction=(action1:PeriodicActionBeforeRender,action2:PeriodicActionBeforeRender)=>action1.passageOrderIndex-action2.passageOrderIndex
//         pushPeriodicAction(action:PeriodicActionBeforeRender):void{
//             this.actionsBeforeRender.push(action)
//             this.actionsBeforeRender.sort(this.sortAction)
//         }
//         private suppressPeriodicAction(action:PeriodicActionBeforeRender):void{
//             let index=this.actionsBeforeRender.indexOf(action)
//             if (index==-1) throw 'this action is not registered'
//             this.actionsBeforeRender.splice(index,1)
//
//         }
//
//        
//         backgroundColor =new Color("#d3d3d3")
//        
//         private fireAction(ac:PeriodicActionBeforeRender){
//             ac.action()
//             ac.firedCount++
//             if (ac.firedCount>=ac.nbTimesThisActionMustBeFired) {
//                 this.suppressPeriodicAction(ac)
//             }
//
//         }
//
//        
//        
//         constructor(addDefaultCameraAndLight=true,canvas=null,canvasContainer=null) {
//             this.canvas=canvas
//             this.canvasContainer=canvasContainer
//            
//
//             /**the default id of canvas is renderCanvas*/
//             if (this.canvasContainer==null){
//                 cc('no container given : the default one is the whole body')
//                 this.canvasContainer=document.body
//             }
//
//             if (this.canvas==null) {
//                 cc('no canvas given, the default one must have id "renderCanvas"')
//                 this.canvas=document.getElementById("renderCanvas");
//                 if (this.canvas==null){
//                     throw "you must precise a canvas for your MathisFrame, or add a canvas with the default id: 'renderCanvas'"
//                 }
//             }
//
//             console.log("this.canvas",this.canvas)
//
//            
//             if (this.callbackIfWebglNotHere==null){
//                 this.callbackIfWebglNotHere=()=>{
//                     setTimeout(()=>{
//                         var $noWebGL:HTMLElement = document.createElement("DIV");
//                         $noWebGL.id="noWebGL"
//                         $noWebGL.innerHTML=
//                             `<h3> Activez WebGL et relancez la page.</h3>
//                      <p> Safari: Dveloppement > Activer WebGL</p>`
//                         this.canvasContainer.appendChild($noWebGL)
//                     },100)
//                 }
//             }
//
//
//
//
//             /** be careful, the style must be load before, if the canvas dimension are decide after the engine creation, the pixed are really big */
//
//             try{
//                 this.engine = new BABYLON.Engine(<HTMLCanvasElement> this.canvas, true);
//             }
//             catch(e){
//                 logger.c('webGL seems to not be present. Here is the message from Babylon:'+e)
//                 this.callbackIfWebglNotHere()
//                 this.engine=null
//             }
//
//
//
//             if (this.engine!=null){
//
//                 this.resetScene()
//
//                 //TODO this.scene=new BABYLON.Scene(this.engine)
//
//
//
//                 var count = 0
//                 var minFps = 0
//                 var $info:HTMLElement
//                 if (this.showFPSinCorner){
//                     var $info:HTMLElement = document.createElement("DIV");
//                     $info.id="info"
//                     this.canvasContainer.appendChild($info)
//
//                 }
//
//
//
//                 let frameCount=0
//                 this.engine.runRenderLoop(()=> {
//
//                     frameCount++
//
//
//                     for (let key in this.actionsBeforeRender){
//                         let act:PeriodicActionBeforeRender=this.actionsBeforeRender[key]
//
//                         //cc(frameCount%4)
//                         if (act.timeIntervalMilli==null && act.frameInterval==null) {
//                             act.frameInterval=1
//                             logger.c("no intervalle given for a periodic action: by default the action is fired every frame")
//                         }
//
//                         if (act.timeIntervalMilli!=null ){
//                             let time=performance.now()
//                             if (time-act.lastTimeFired>act.timeIntervalMilli) {
//                                 this.fireAction(act)
//                                 act.lastTimeFired=time
//                             }
//                         }
//                         else if (act.frameInterval!=null && frameCount%act.frameInterval==0) this.fireAction(act)
//                     }
//
//                     this.scene.render();
//                     count++
//                     let fps=this.engine.getFps()
//                     if(fps<minFps) minFps =fps
//                     if (count % 100 == 0) {
//                         if($info!=null) $info.textContent = minFps.toFixed()
//                         minFps = Number.MAX_VALUE
//                     }
//                 })
//                
//                 this.domEventsHandler()
//             }
//
//            
//             if (addDefaultCameraAndLight){
//                 this.addDefaultLight()
//                 this.addDefaultCamera()
//             }
//            
//
//         }
//
//
//
//
//         private domEventsHandler(){
//
//             window.addEventListener("resize",  ()=> {
//                 this.engine.resize();
//             });
//
//
//             let globalClickAction=()=>{
//                 let pickResult = this.scene.pick(this.scene.pointerX, this.scene.pointerY,(mesh)=>mesh.isPickable,false);
//
//
//
//                 if(pickResult.pickedMesh!=null){
//
//                     let clickFuntion= (<any> pickResult.pickedMesh).onClick
//
//                     if (clickFuntion!=null){
//                         clickFuntion(pickResult.pickedPoint)
//                     }
//
//                     //let gameo:GameO=(<any>pickResult.pickedMesh).gameo
//                     //if(gameo!=null) gameo.onClick()
//                 }
//             }
//
//
//
//             let timeOfDown
//             let downAction=()=>{
//                 timeOfDown=performance.now()
//             }
//             let upAction=()=>{
//                 if (performance.now()-timeOfDown<500) globalClickAction()
//             }
//
//             let prefix=BABYLON.Tools.GetPointerPrefix()//'pointer' if possible, or 'mouse' if not
//             this.canvas.addEventListener(prefix + "down",downAction , false);
//             this.canvas.addEventListener(prefix + "up", upAction, false);
//
//
//
//         }
//
//     }
//
//
//
//
// } 
var mathis;
(function (mathis) {
    var periodicWorld;
    (function (periodicWorld) {
        var Vector3 = BABYLON.Vector3;
        var StandardMaterial = BABYLON.StandardMaterial;
        var FundamentalDomain = (function () {
            function FundamentalDomain(vecA, vecB, vecC) {
                this.vecA = vecA;
                this.vecB = vecB;
                this.vecC = vecC;
                this.matWebCoordinateToPoint = new mathis.MM();
                this.matPointToWebCoordinate = new mathis.MM();
                this.isCartesian = false;
                this.pointWC = new mathis.XYZ(0, 0, 0);
                this.domainCenter = new mathis.XYZ(0, 0, 0);
                this.domainAroundCenter = new mathis.XYZ(0, 0, 0);
                // le nombre de domaine pour courvir la distMax.
                // private  bounding:XYZ;
                // private formerDistMax:number;
                // private tempV = new XYZ(0, 0, 0)
                //
                //
                // public getBounding(distMax:number):XYZ {
                //     if (this.bounding != undefined && this.formerDistMax == distMax) return this.bounding;
                //     if (this.isCartesian) {
                //         this.formerDistMax = distMax;
                //         this.tempV.x = 1;
                //         this.tempV.y = 1;
                //         this.tempV.z = 1;
                //         this.webCoordinateToPoint(this.tempV, this.tempV)
                //         //this.webCoordinateToPointToRef(this.tempV, this.tempV);
                //         this.bounding = new XYZ((Math.abs(this.tempV.x)), ( Math.abs(this.tempV.y)), (Math.abs(this.tempV.z)));
                //         this.bounding.scaleInPlace(distMax);
                //         return this.bounding;
                //     }
                //     throw "for non paralleoid, must be rewrited"
                //
                // }
                this._positionWC = new WebCoordinate(0, 0, 0);
                this._domainPosition = new Domain(0, 0, 0);
                this._domainPositioncenter = new mathis.XYZ(0, 0, 0);
                this._zero = new mathis.XYZ(0, 0, 0);
                mathis.geo.matrixFromLines(vecA, vecB, vecC, this.matWebCoordinateToPoint);
                mathis.geo.inverse(this.matWebCoordinateToPoint, this.matPointToWebCoordinate);
            }
            FundamentalDomain.prototype.contains = function (point) {
                throw "must be override";
            };
            FundamentalDomain.prototype.webCoordinateToPoint = function (webCoordinate, result) {
                return mathis.geo.multiplicationMatrixVector(this.matWebCoordinateToPoint, webCoordinate, result); //XYZ.TransformCoordinates(webCoordinate, this.matWebCoordinateToPoint);
            };
            FundamentalDomain.prototype.pointToWebCoordinate = function (point, result) {
                mathis.geo.multiplicationMatrixVector(this.matPointToWebCoordinate, point, result);
            };
            FundamentalDomain.prototype.getDomainContaining = function (point) {
                this.pointToWebCoordinate(point, this.pointWC);
                //var pointWC = this.pointToWebCoordinate(point);
                if (this.isCartesian)
                    return new Domain(this.pointWC.x, this.pointWC.y, this.pointWC.z);
                else {
                    for (var i = -1; i <= 1; i++) {
                        for (var j = -1; j <= 1; j++) {
                            for (var k = -1; k <= 1; k++) {
                                var domainAround = new Domain(this.pointWC.x + i, this.pointWC.y + j, this.pointWC.z + k);
                                if (domainAround.contains(point, this))
                                    return domainAround;
                            }
                        }
                    }
                }
            };
            FundamentalDomain.prototype.getDomainsAround = function (nbRepetitions, distMax, exludeCentralDomain) {
                if (exludeCentralDomain === void 0) { exludeCentralDomain = true; }
                // domain.getCenter(this, this.domainCenter);
                var result = [];
                // var bounding = this.getBounding(distMax);
                // bounding.x = Math.ceil(bounding.x);
                // bounding.y = Math.ceil(bounding.y);
                // bounding.z = Math.ceil(bounding.z);
                var intRep = Math.floor(nbRepetitions /= 2);
                var bounding = new mathis.XYZ(intRep, intRep, intRep);
                for (var i = -bounding.x; i <= bounding.x; i++) {
                    for (var j = -bounding.y; j <= bounding.y; j++) {
                        for (var k = -bounding.z; k <= bounding.z; k++) {
                            var domainAround = new Domain(i, j, k);
                            if (!(exludeCentralDomain && i == 0 && j == 0 && k == 0)) {
                                domainAround.getCenter(this, this.domainAroundCenter);
                                if (mathis.XYZ.DistanceSquared(this.domainAroundCenter, this.domainCenter) < distMax * distMax)
                                    result.push(domainAround);
                            }
                        }
                    }
                }
                return result;
            };
            FundamentalDomain.prototype.modulo = function (position, positionInsideFD) {
                this.pointToWebCoordinate(position, this._positionWC);
                this._domainPosition.whichContains(this._positionWC);
                this._domainPosition.getCenter(this, this._domainPositioncenter);
                positionInsideFD.copyFrom(position).substract(this._domainPositioncenter);
                //if (!geo.xyzAlmostEquality(this._domainPositioncenter,this._zero) )  positionInsideFD
            };
            return FundamentalDomain;
        }());
        periodicWorld.FundamentalDomain = FundamentalDomain;
        var CartesianFundamentalDomain = (function (_super) {
            __extends(CartesianFundamentalDomain, _super);
            function CartesianFundamentalDomain(vecA, vecB, vecC) {
                _super.call(this, vecA, vecB, vecC);
                this.pointWC2 = new mathis.XYZ(0, 0, 0);
                this.isCartesian = true;
            }
            CartesianFundamentalDomain.prototype.contains = function (point) {
                _super.prototype.pointToWebCoordinate.call(this, point, this.pointWC2);
                //var pointWC = this.pointToWebCoordinate(point);
                if (Math.abs(this.pointWC2.x) > 1 / 2)
                    return false;
                if (Math.abs(this.pointWC2.y) > 1 / 2)
                    return false;
                if (Math.abs(this.pointWC2.z) > 1 / 2)
                    return false;
                return true;
            };
            CartesianFundamentalDomain.prototype.drawMe = function (scene) {
                var box = BABYLON.Mesh.CreateBox('', 1, scene);
                box.scaling = new Vector3(this.vecA.length(), this.vecB.length(), this.vecC.length());
                box.material = new StandardMaterial('', scene);
                box.material.alpha = 0.2;
                // let corner=this.getCorner()
                // box.position=corner
            };
            CartesianFundamentalDomain.prototype.getCorner = function () {
                var corner = new mathis.XYZ(0, 0, 0);
                corner.add(this.vecA).add(this.vecB).add(this.vecC);
                corner.scaleInPlace(-0.5);
                return corner;
            };
            CartesianFundamentalDomain.prototype.getArretes = function (scene) {
                var corner = this.getCorner();
                var result = new Array();
                var radius = 1;
                var originalMesh = BABYLON.Mesh.CreateCylinder('', 1, radius, radius, 12, null, scene);
                var originalMesh1 = BABYLON.Mesh.CreateCylinder('', 1, radius, radius, 12, null, scene);
                var originalMesh2 = BABYLON.Mesh.CreateCylinder('', 1, radius, radius, 12, null, scene);
                new mathis.visu3d.ElongateAMeshFromBeginToEnd(corner, mathis.XYZ.newFrom(corner).add(this.vecA), originalMesh).goChanging();
                new mathis.visu3d.ElongateAMeshFromBeginToEnd(corner, mathis.XYZ.newFrom(corner).add(this.vecB), originalMesh1).goChanging();
                new mathis.visu3d.ElongateAMeshFromBeginToEnd(corner, mathis.XYZ.newFrom(corner).add(this.vecC), originalMesh2).goChanging();
                result.push(originalMesh);
                result.push(originalMesh1);
                result.push(originalMesh2);
                return result;
            };
            return CartesianFundamentalDomain;
        }(FundamentalDomain));
        periodicWorld.CartesianFundamentalDomain = CartesianFundamentalDomain;
        var WebCoordinate = (function (_super) {
            __extends(WebCoordinate, _super);
            function WebCoordinate() {
                _super.apply(this, arguments);
            }
            return WebCoordinate;
        }(mathis.XYZ));
        periodicWorld.WebCoordinate = WebCoordinate;
        //TODO maitre FD en champs
        var Domain = (function (_super) {
            __extends(Domain, _super);
            function Domain(i, j, k) {
                _super.call(this, Math.round(i), Math.round(j), Math.round(k));
                this._point = new mathis.XYZ(0, 0, 0);
                this._domainCenter = new mathis.XYZ(0, 0, 0);
            }
            Domain.prototype.whichContains = function (webCo) {
                this.x = Math.round(webCo.x);
                this.y = Math.round(webCo.y);
                this.z = Math.round(webCo.z);
                return this;
            };
            Domain.prototype.equals = function (otherDomain) {
                if (otherDomain.x != this.x)
                    return false;
                if (otherDomain.y != this.y)
                    return false;
                if (otherDomain.z != this.z)
                    return false;
                return true;
            };
            Domain.prototype.getCenter = function (fundamentalDomain, result) {
                fundamentalDomain.webCoordinateToPoint(this, result);
            };
            Domain.prototype.contains = function (point, fundamentalDomain) {
                this._point.copyFrom(point);
                this.getCenter(fundamentalDomain, this._domainCenter);
                this._point.substract(this._domainCenter);
                return fundamentalDomain.contains(this._point);
            };
            return Domain;
        }(WebCoordinate));
        periodicWorld.Domain = Domain;
        var Multiply = (function () {
            function Multiply(fd, maxDistance, nbRepetitions) {
                this.fd = fd;
                this.maxDistance = maxDistance;
                this.nbRepetitions = nbRepetitions;
            }
            Multiply.prototype.addMesh = function (mesh) {
                //mesh.isVisible = false;
                //mesh.visibility=0
                var _this = this;
                var visibleDomains = this.fd.getDomainsAround(this.nbRepetitions, this.maxDistance);
                visibleDomains.forEach(function (domain) {
                    var domainCenter = new mathis.XYZ(0, 0, 0);
                    var clone = mesh.createInstance('');
                    domain.getCenter(_this.fd, domainCenter);
                    clone.position.addInPlace(domainCenter);
                    clone.visibility = 1;
                    clone.isVisible = true;
                });
            };
            Multiply.prototype.addInstancedMesh = function (mesh) {
                var _this = this;
                var visibleDomains = this.fd.getDomainsAround(this.nbRepetitions, this.maxDistance);
                visibleDomains.forEach(function (domain) {
                    var domainCenter = new mathis.XYZ(0, 0, 0);
                    var clone = mesh.sourceMesh.createInstance('');
                    clone.scaling.copyFrom(mesh.scaling);
                    clone.position.copyFrom(mesh.position);
                    clone.rotationQuaternion = new BABYLON.Quaternion(0, 0, 0, 0);
                    clone.rotationQuaternion.copyFrom(mesh.rotationQuaternion);
                    domain.getCenter(_this.fd, domainCenter);
                    clone.position.addInPlace(domainCenter);
                    clone.visibility = 1;
                    clone.isVisible = true;
                });
            };
            Multiply.prototype.addAbstractMesh = function (abMesh) {
                if (abMesh instanceof BABYLON.Mesh)
                    this.addMesh(abMesh);
                else if (abMesh instanceof BABYLON.InstancedMesh)
                    this.addInstancedMesh(abMesh);
            };
            return Multiply;
        }());
        periodicWorld.Multiply = Multiply;
    })(periodicWorld = mathis.periodicWorld || (mathis.periodicWorld = {}));
})(mathis || (mathis = {}));
/**
 * Created by vigon on 24/03/2016.
 */
var mathis;
(function (mathis) {
    var reseau;
    (function (reseau) {
        (function (Maille) {
            Maille[Maille["square"] = 0] = "square";
            Maille[Maille["triangle"] = 1] = "triangle";
            Maille[Maille["diamond"] = 2] = "diamond";
            Maille[Maille["hexagonal"] = 3] = "hexagonal";
            Maille[Maille["slash"] = 4] = "slash";
            Maille[Maille["croisillon"] = 5] = "croisillon";
        })(reseau.Maille || (reseau.Maille = {}));
        var Maille = reseau.Maille;
        var SingleTriangle = (function () {
            function SingleTriangle(mamesh) {
                this.makeLinks = true;
                this.markCorners = true;
                this.addALoopLineAround = false;
                this.mamesh = mamesh;
            }
            SingleTriangle.prototype.go = function () {
                var vert0 = this.mamesh.newVertex(new mathis.XYZ(0, 0, 0));
                var vert1 = this.mamesh.newVertex(new mathis.XYZ(0, 1, 0));
                var vert2 = this.mamesh.newVertex(new mathis.XYZ(1, 0, 0));
                //let triangulatedRect=new Polygone([vert1,vert2,vert3])
                //mesh.polygones.push(triangulatedRect)
                this.mamesh.addATriangle(vert0, vert1, vert2);
                if (this.markCorners) {
                    vert0.markers.push(mathis.Vertex.Markers.corner);
                    vert1.markers.push(mathis.Vertex.Markers.corner);
                    vert2.markers.push(mathis.Vertex.Markers.corner);
                }
                if (this.makeLinks) {
                    if (!this.addALoopLineAround) {
                        vert0.setOneLink(vert1);
                        vert0.setOneLink(vert2);
                        vert1.setOneLink(vert0);
                        vert1.setOneLink(vert2);
                        vert2.setOneLink(vert0);
                        vert2.setOneLink(vert1);
                    }
                    else {
                        vert0.setTwoOppositeLinks(vert1, vert2);
                        vert1.setTwoOppositeLinks(vert2, vert0);
                        vert2.setTwoOppositeLinks(vert0, vert1);
                    }
                }
                //else this.mamesh.linksOK=false
            };
            return SingleTriangle;
        }());
        reseau.SingleTriangle = SingleTriangle;
        var TriangulatedTriangle = (function () {
            function TriangulatedTriangle() {
                this.markCorner = true;
                this.markBorder = true;
                this.origin = new mathis.XYZ(-1, -1, 0);
                this.end = new mathis.XYZ(1, 1, 0);
                this.nbSubdivisionInSide = 6;
                this.setAllDichoLevelTo0 = true;
                this.mamesh = new mathis.Mamesh();
            }
            TriangulatedTriangle.prototype.go = function () {
                //this.mamesh.linksOK=true
                for (var i = 0; i < 3; i++) {
                    var param = new mathis.XYZ(Math.cos(2 * Math.PI * i / 3 - Math.PI / 2), Math.sin(2 * Math.PI * i / 3 - Math.PI / 2), 0);
                    var position = mathis.XYZ.newFrom(param);
                    var v = this.mamesh.newVertex(position, 0, param);
                    v.markers.push(mathis.Vertex.Markers.corner);
                }
                this.mamesh.addATriangle(this.mamesh.vertices[0], this.mamesh.vertices[1], this.mamesh.vertices[2]);
                var nbDic = Math.floor(Math.log(this.nbSubdivisionInSide) / Math.log(2));
                for (var dic = 0; dic < nbDic; dic++) {
                    var dicotomer = new mathis.mameshModification.TriangleDichotomer(this.mamesh);
                    dicotomer.makeLinks = false;
                    dicotomer.go();
                }
                if (Math.pow(2, nbDic) != this.nbSubdivisionInSide) {
                    var dicotomer = new mathis.mameshModification.TriangleDichotomer(this.mamesh);
                    dicotomer.makeLinks = false;
                    dicotomer.go();
                }
                /** to detect border we use the triangles*/
                var linkMaker = new mathis.linkModule.LinkCreaterSorterAndBorderDetecterByPolygons(this.mamesh);
                linkMaker.markIsolateVertexAsCorner = false;
                linkMaker.goChanging();
                /**for each strate suppressed, the side decrease of 3 segments*/
                if (Math.pow(2, nbDic) != this.nbSubdivisionInSide) {
                    var supress = new mathis.grateAndGlue.ExtractCentralPart(this.mamesh, Math.floor((Math.pow(2, nbDic + 1) - this.nbSubdivisionInSide) / 3));
                    supress.markBorder = this.markBorder;
                    this.mamesh = supress.go();
                    this.mamesh.isolateMameshVerticesFromExteriorVertices();
                }
                if (this.markCorner) {
                    for (var _i = 0, _a = this.mamesh.vertices; _i < _a.length; _i++) {
                        var v = _a[_i];
                        if (v.links.length == 2)
                            v.markers.push(mathis.Vertex.Markers.corner);
                    }
                }
                if (this.setAllDichoLevelTo0)
                    for (var _b = 0, _c = this.mamesh.vertices; _b < _c.length; _b++) {
                        var vertex = _c[_b];
                        vertex.dichoLevel = 0;
                    }
                mathis.spacialTransformations.adjustInASquare(this.mamesh, this.origin, this.end);
                return this.mamesh;
            };
            return TriangulatedTriangle;
        }());
        reseau.TriangulatedTriangle = TriangulatedTriangle;
        var TriangulatedPolygone = (function () {
            function TriangulatedPolygone(nbSides) {
                this.markCorner = true;
                this.markBorder = true;
                this.origin = new mathis.XYZ(-1, -1, 0);
                this.end = new mathis.XYZ(1, 1, 0);
                this.nbSubdivisionInARadius = 1;
                this.setAllDichoLevelTo0 = true;
                this.mamesh = new mathis.Mamesh();
                this.nbSides = nbSides;
            }
            TriangulatedPolygone.prototype.go = function () {
                //this.mamesh.linksOK=true
                var vert0 = this.mamesh.newVertex(new mathis.XYZ(0, 0, 0), 0, new mathis.XYZ(0, 0, 0));
                vert0.markers.push(mathis.Vertex.Markers.center);
                for (var i = 0; i < this.nbSides; i++) {
                    var param = new mathis.XYZ(Math.cos(2 * Math.PI * i / this.nbSides - Math.PI / 2), Math.sin(2 * Math.PI * i / this.nbSides - Math.PI / 2), 0);
                    var position = mathis.XYZ.newFrom(param);
                    var v = this.mamesh.newVertex(position, 0, param);
                    //if(this.markCorner) v.markers.push(Vertex.Markers.corner)
                    if (this.markBorder)
                        v.markers.push(mathis.Vertex.Markers.border);
                }
                for (var i = 1; i < this.nbSides + 1; i++) {
                    this.mamesh.addATriangle(this.mamesh.vertices[0], this.mamesh.vertices[i], this.mamesh.vertices[i % this.nbSides + 1]);
                }
                if (this.nbSides % 2 == 0) {
                    for (var i = 1; i <= this.nbSides / 2; i++) {
                        vert0.setTwoOppositeLinks(this.mamesh.vertices[i], this.mamesh.vertices[i + this.nbSides / 2]);
                    }
                }
                else {
                    for (var i = 1; i <= this.nbSides; i++)
                        vert0.setOneLink(this.mamesh.vertices[i]);
                }
                for (var i = 1; i <= this.nbSides; i++) {
                    var verti = this.mamesh.vertices[i];
                    var vertNext = (i == this.nbSides) ? this.mamesh.vertices[1] : this.mamesh.vertices[i + 1];
                    var vertPrev = (i == 1) ? this.mamesh.vertices[this.nbSides] : this.mamesh.vertices[i - 1];
                    verti.setOneLink(vert0);
                    // if (this.aLoopLineAround) verti.setTwoOppositeLinks(vertPrev,vertNext)
                    // else{
                    verti.setOneLink(vertNext);
                    verti.setOneLink(vertPrev);
                }
                var nbDic = Math.log(this.nbSubdivisionInARadius) / Math.log(2);
                for (var dic = 0; dic < nbDic; dic++) {
                    var dicotomer = new mathis.mameshModification.TriangleDichotomer(this.mamesh);
                    dicotomer.makeLinks = true;
                    dicotomer.go();
                }
                if (nbDic != Math.floor(nbDic)) {
                    /**one more dichotomy to add too much strates, and suppress some*/
                    var dicotomer = new mathis.mameshModification.TriangleDichotomer(this.mamesh);
                    dicotomer.makeLinks = true;
                    dicotomer.go();
                    var supress = new mathis.grateAndGlue.ExtractCentralPart(this.mamesh, -this.nbSubdivisionInARadius);
                    supress.markBorder = this.markBorder;
                    this.mamesh = supress.go();
                    this.mamesh.isolateMameshVerticesFromExteriorVertices();
                }
                if (this.markCorner) {
                    for (var _i = 0, _a = this.mamesh.vertices; _i < _a.length; _i++) {
                        var v = _a[_i];
                        if (v.links.length == 3)
                            v.markers.push(mathis.Vertex.Markers.corner);
                    }
                }
                mathis.spacialTransformations.adjustInASquare(this.mamesh, this.origin, this.end);
                if (this.setAllDichoLevelTo0)
                    for (var _b = 0, _c = this.mamesh.vertices; _b < _c.length; _b++) {
                        var vertex = _c[_b];
                        vertex.dichoLevel = 0;
                    }
                this.mamesh.symmetries = mathis.symmetries.getAllPolygonalRotations(this.nbSides);
                return this.mamesh;
            };
            return TriangulatedPolygone;
        }());
        reseau.TriangulatedPolygone = TriangulatedPolygone;
        var BasisForRegularReseau = (function () {
            function BasisForRegularReseau() {
                this.nbI = 3;
                this.set_nbJ_toHaveRegularReseau = false;
                this.nbJ = 3;
                this.origin = new mathis.XYZ(0, 0, 0);
                this.end = new mathis.XYZ(1, 1, 0);
                this.kComponentTranslation = 0;
                this.nbVerticalDecays = 0;
                this.nbHorizontalDecays = 0;
                /**only usefull when we use set_nbJ_toHaveRegularReseau=true*/
                this.squareMailleInsteadOfTriangle = true;
            }
            BasisForRegularReseau.prototype.go = function () {
                this.checkArgs();
                var deltaX = (this.end.x - this.origin.x) / (this.nbI - 1);
                var deltaY;
                if (this.set_nbJ_toHaveRegularReseau) {
                    if (this.squareMailleInsteadOfTriangle)
                        deltaY = deltaX;
                    else
                        deltaY = deltaX * Math.sqrt(3) / 2;
                    this.nbJ = Math.floor(((this.end.y - this.origin.y) / deltaY + 1));
                }
                else {
                    deltaY = (this.end.y - this.origin.y) / (this.nbJ - 1);
                }
                var A = (this.end.x - this.origin.x);
                var B = (this.end.y - this.origin.y);
                var VX = this.computeDecayVector(deltaX, A, deltaY, B, this.nbVerticalDecays, this.nbHorizontalDecays);
                var preVY = this.computeDecayVector(deltaY, B, deltaX, A, this.nbHorizontalDecays, this.nbVerticalDecays);
                var VY = new mathis.XYZ(preVY.y, preVY.x, 0);
                VX.z += this.kComponentTranslation;
                VY.z += this.kComponentTranslation;
                return { Vi: VX, Vj: VY, nbI: this.nbI, nbJ: this.nbJ };
            };
            BasisForRegularReseau.prototype.checkArgs = function () {
                var A = (this.end.x - this.origin.x);
                var B = (this.end.y - this.origin.y);
                if (Math.abs(A) < mathis.geo.epsilon || Math.abs(B) < mathis.geo.epsilon)
                    throw 'origin and end are almost in the same line';
                if (this.nbI < 2)
                    throw 'this.nbI must be >=2';
                if (this.nbJ < 2)
                    throw 'this.nbJ must be >=2';
            };
            BasisForRegularReseau.prototype.computeDecayVector = function (a, A, b, B, dV, dH) {
                var res = new mathis.XYZ(0, 0, 0);
                res.x = a * A * B / (A * B - a * b * dH * dV);
                res.y = b * dV / A * res.x;
                return res;
            };
            return BasisForRegularReseau;
        }());
        reseau.BasisForRegularReseau = BasisForRegularReseau;
        var aParam = new mathis.XYZ(0, 0, 0);
        function makeLinksFromDeltaParam(cell, dir1, dir2, paramToVertex) {
            {
                aParam.copyFromFloats(cell.param.x, cell.param.y, cell.param.z).add(dir1);
                var c = paramToVertex.getValue(aParam);
                aParam.copyFromFloats(cell.param.x, cell.param.y, cell.param.z).add(dir2);
                var cc_1 = paramToVertex.getValue(aParam);
                if (c != null && cc_1 != null)
                    cell.setTwoOppositeLinks(c, cc_1);
                else if (c == null && cc_1 != null)
                    cell.setOneLink(cc_1);
                else if (c != null && cc_1 == null)
                    cell.setOneLink(c);
            }
        }
        var tempPapa = new mathis.XYZ(0, 0, 0);
        function makeSquareFromDeltaParam(cell, mamesh, dir1, dir2, paramToVertex) {
            var v1 = cell;
            if (v1 == null)
                return;
            var v2 = paramToVertex.getValue(tempPapa.copyFrom(cell.param).add(dir1)); //this.getVertex(i+1,j)
            if (v2 == null)
                return;
            var v3 = paramToVertex.getValue(tempPapa.copyFrom(cell.param).add(dir1).add(dir2)); //this.getVertex(i+1,j+1)
            if (v3 == null)
                return;
            var v4 = paramToVertex.getValue(tempPapa.copyFrom(cell.param).add(dir2));
            if (v4 == null)
                return;
            mamesh.addASquare(v1, v2, v3, v4);
        }
        var Regular = (function () {
            function Regular(generator) {
                this.nbI = 3;
                this.nbJ = 3;
                this.fixedK = 0;
                this.Vi = new mathis.XYZ(1, 0, 0);
                this.Vj = new mathis.XYZ(0, 1, 0);
                this.Vk = new mathis.XYZ(0, 0, 0);
                this.origine = new mathis.XYZ(0, 0, 0);
                /**these 3 fields are reported on Regular3d*/
                this.makeLinks = true;
                this.makeTriangleOrSquare = true;
                this.squareVersusTriangleMaille = true;
                this.oneMoreVertexForOddLine = false;
                this.holeParameters = new mathis.HashMap();
                this.markCorner = true;
                this.markBorder = true;
                this.markCenter = true;
                this.putAVertexOnlyAtXYZCheckingThisCondition = null;
                this._xyz = new mathis.XYZ(0, 0, 0);
                this._iDirection = new mathis.XYZ(0, 0, 0);
                this._jDirection = new mathis.XYZ(0, 0, 0);
                this._kDirection = new mathis.XYZ(0, 0, 0);
                this.paramToVertex = new mathis.HashMap(true);
                this.mamesh = new mathis.Mamesh();
                if (generator != null) {
                    var VV = generator.go();
                    this.Vi.copyFrom(VV.Vi);
                    this.Vj.copyFrom(VV.Vj);
                    this.nbI = VV.nbI;
                    this.nbJ = VV.nbJ;
                    this.origine.copyFrom(generator.origin);
                    this.squareVersusTriangleMaille = generator.squareMailleInsteadOfTriangle;
                }
            }
            Regular.prototype.checkArgs = function () {
                if (!this.makeTriangleOrSquare && !this.makeLinks)
                    mathis.logger.c('few interest if you do not add neither square nor links');
                var cros = new mathis.XYZ(0, 0, 0);
                mathis.geo.cross(this.Vi, this.Vj, cros);
                if (cros.x == Number.NaN || cros.y == Number.NaN || cros.z == Number.NaN)
                    throw 'a problem with Vi of Vj';
                if (cros.length() < mathis.geo.epsilon)
                    throw 'origin and end are almost in the same line';
            };
            Regular.prototype.getVertex = function (i, j) {
                this._xyz.x = i;
                this._xyz.y = j;
                this._xyz.z = this.fixedK;
                return this.paramToVertex.getValue(this._xyz); //this.paramToVertex[i+','+j]
            };
            Regular.prototype.go = function () {
                this.checkArgs();
                for (var i = 0; i < this.nbI; i++) {
                    for (var j = 0; j < this.nbJ; j++) {
                        var param = new mathis.XYZ(i, j, this.fixedK);
                        if (this.holeParameters == null || !this.holeParameters.getValue(param)) {
                            var decay = (!this.squareVersusTriangleMaille && j % 2 == 0) ? 0.5 : 0;
                            this._iDirection.copyFrom(this.Vi).scale(i + decay);
                            this._jDirection.copyFrom(this.Vj).scale(j);
                            this._kDirection.copyFrom(this.Vk).scale(this.fixedK);
                            var position = new mathis.XYZ(0, 0, 0).add(this._iDirection).add(this._jDirection).add(this._kDirection).add(this.origine);
                            if (this.putAVertexOnlyAtXYZCheckingThisCondition == null || this.putAVertexOnlyAtXYZCheckingThisCondition(position)) {
                                var vertex = this.mamesh.newVertex(position, 0, param);
                                this.paramToVertex.putValue(param, vertex);
                            }
                        }
                    }
                }
                /**to get a vertical symmetry when vertex are in quinconce*/
                if (this.oneMoreVertexForOddLine) {
                    var i = this.nbI;
                    for (var j = 0; j < this.nbJ; j++) {
                        if (j % 2 == 1) {
                            var param = new mathis.XYZ(i, j, this.fixedK);
                            if (this.holeParameters == null || !this.holeParameters.getValue(param)) {
                                var decay = (!this.squareVersusTriangleMaille && j % 2 == 0) ? 0.5 : 0;
                                this._iDirection.copyFrom(this.Vi).scale(i + decay);
                                this._jDirection.copyFrom(this.Vj).scale(j);
                                this._kDirection.copyFrom(this.Vk).scale(this.fixedK);
                                var position = new mathis.XYZ(0, 0, 0).add(this._iDirection).add(this._jDirection).add(this._kDirection).add(this.origine);
                                if (this.putAVertexOnlyAtXYZCheckingThisCondition == null || this.putAVertexOnlyAtXYZCheckingThisCondition(position)) {
                                    var vertex = this.mamesh.newVertex(position, 0, param);
                                    this.paramToVertex.putValue(param, vertex);
                                }
                            }
                        }
                    }
                }
                if (this.mamesh.vertices.length == 0)
                    console.log('you have created a IN_mamesh with no vertex. Perhaps because of {@link Regular.putAVertexOnlyAtXYZCheckingThisCondition }');
                if (this.makeLinks) {
                    //this.mamesh.linksOK=true
                    if (!this.squareVersusTriangleMaille)
                        this.linksCreationForTriangle();
                    else
                        this.linksCreationForSquare();
                }
                if (this.makeTriangleOrSquare) {
                    if (!this.squareVersusTriangleMaille)
                        this.triangleCreation();
                    else
                        this.squareCreation();
                }
                if (this.markBorder) {
                    if (this.squareVersusTriangleMaille) {
                        for (var _i = 0, _a = this.mamesh.vertices; _i < _a.length; _i++) {
                            var v = _a[_i];
                            if (v.links.length != 4)
                                v.markers.push(mathis.Vertex.Markers.border);
                        }
                    }
                    else {
                        for (var _b = 0, _c = this.mamesh.vertices; _b < _c.length; _b++) {
                            var v = _c[_b];
                            if (v.links.length != 6)
                                v.markers.push(mathis.Vertex.Markers.border);
                        }
                    }
                }
                if (this.markCorner) {
                    var oneMore = (this.oneMoreVertexForOddLine && this.nbJ % 2 == 0) ? 1 : 0;
                    var vertex = void 0;
                    vertex = this.getVertex(0, 0);
                    if (vertex != null)
                        vertex.markers.push(mathis.Vertex.Markers.corner);
                    vertex = this.getVertex(this.nbI - 1 + oneMore, this.nbJ - 1);
                    if (vertex != null)
                        vertex.markers.push(mathis.Vertex.Markers.corner);
                    vertex = this.getVertex(0, this.nbJ - 1);
                    if (vertex != null)
                        vertex.markers.push(mathis.Vertex.Markers.corner);
                    vertex = this.getVertex(this.nbI - 1, 0);
                    if (vertex != null)
                        vertex.markers.push(mathis.Vertex.Markers.corner);
                }
                if (this.markCenter) {
                    var iCenter = this.nbI / 2;
                    var iCenters = [];
                    if (Math.floor(iCenter) != iCenter) {
                        iCenters.push(Math.floor(iCenter));
                    }
                    else
                        iCenters.push(Math.floor(iCenter), Math.floor(iCenter) - 1);
                    var jCenter = this.nbJ / 2;
                    var jCenters = [];
                    if (Math.floor(jCenter) != jCenter) {
                        jCenters.push(Math.floor(jCenter));
                    }
                    else
                        jCenters.push(Math.floor(jCenter), Math.floor(jCenter) - 1);
                    for (var _d = 0, iCenters_1 = iCenters; _d < iCenters_1.length; _d++) {
                        var i = iCenters_1[_d];
                        for (var _e = 0, jCenters_1 = jCenters; _e < jCenters_1.length; _e++) {
                            var j = jCenters_1[_e];
                            var vertex = this.getVertex(i, j);
                            if (vertex != null)
                                vertex.markers.push(mathis.Vertex.Markers.center);
                        }
                    }
                }
                this.mamesh.symmetries = mathis.symmetries.cartesianAsArray(this.nbI, this.nbJ, this.oneMoreVertexForOddLine);
                return this.mamesh;
            };
            Regular.prototype.linksCreationForSquare = function () {
                var _this = this;
                this.mamesh.vertices.forEach(function (cell) {
                    makeLinksFromDeltaParam(cell, mathis.XYZ.temp0(1, 0, 0), mathis.XYZ.temp1(-1, 0, 0), _this.paramToVertex);
                    makeLinksFromDeltaParam(cell, mathis.XYZ.temp0(0, 1, 0), mathis.XYZ.temp1(0, -1, 0), _this.paramToVertex);
                    // {
                    //     let c:Vertex = this.getVertex(cell.param.x + 1, cell.param.y)
                    //     let cc:Vertex = this.getVertex(cell.param.x - 1, cell.param.y)
                    //
                    //     if (c != null && cc != null) cell.setTwoOppositeLinks(c,cc,false)
                    //     else if (c == null && cc != null) cell.setOneLink(cc,true)
                    //     else if (c != null && cc == null) cell.setOneLink(c,true)
                    //
                    // }
                    //
                    // {
                    //
                    //     let c:Vertex = this.getVertex(cell.param.x  , cell.param.y+1);
                    //     let cc:Vertex = this.getVertex(cell.param.x  , cell.param.y-1);
                    //     if (c != null && cc != null) cell.setTwoOppositeLinks(c,cc,false)
                    //     else if (c == null && cc != null) cell.setOneLink(cc,true)
                    //     else if (c != null && cc == null) cell.setOneLink(c,true)
                    //
                    // }
                });
            };
            Regular.prototype.squareCreation = function () {
                var dir1 = new mathis.XYZ(1, 0, 0);
                var dir2 = new mathis.XYZ(0, 1, 0);
                for (var _i = 0, _a = this.mamesh.vertices; _i < _a.length; _i++) {
                    var vertex = _a[_i];
                    makeSquareFromDeltaParam(vertex, this.mamesh, dir1, dir2, this.paramToVertex);
                }
                // for (let i = 0; i<this.nbI-1; i++){
                //     for (let j=0; j<this.nbJ-1; j++){
                //
                //         let v1=this.getVertex(i,j)
                //         if (v1==null)  continue;
                //
                //         let v2=this.getVertex(i+1,j)
                //         if (v2==null) continue;
                //
                //         let v3=this.getVertex(i+1,j+1)
                //         if (v3==null) continue;
                //
                //         let v4=this.getVertex(i,j+1)
                //         if (v4==null)  continue;
                //
                //         this.IN_mamesh.addASquare(v1,v2,v3,v4)
                //     }
                // }
            };
            Regular.prototype.linksCreationForTriangle = function () {
                var _this = this;
                this.mamesh.vertices.forEach(function (cell) {
                    makeLinksFromDeltaParam(cell, mathis.XYZ.temp0(1, 0, 0), mathis.XYZ.temp1(-1, 0, 0), _this.paramToVertex);
                    /**even lines */
                    if (cell.param.y % 2 == 0) {
                        /** sud est - nord ouest*/
                        makeLinksFromDeltaParam(cell, mathis.XYZ.temp0(1, 1, 0), mathis.XYZ.temp1(0, -1, 0), _this.paramToVertex);
                        /** sud ouest - nord est*/
                        makeLinksFromDeltaParam(cell, mathis.XYZ.temp0(0, 1, 0), mathis.XYZ.temp1(1, -1, 0), _this.paramToVertex);
                    }
                    else {
                        /**sud est - nord ouest*/
                        makeLinksFromDeltaParam(cell, mathis.XYZ.temp0(0, 1, 0), mathis.XYZ.temp1(-1, -1, 0), _this.paramToVertex);
                        /**sud ouest - nord est*/
                        makeLinksFromDeltaParam(cell, mathis.XYZ.temp0(-1, 1, 0), mathis.XYZ.temp1(0, -1, 0), _this.paramToVertex);
                    }
                });
            };
            Regular.prototype.triangleCreation = function () {
                for (var _i = 0, _a = this.mamesh.vertices; _i < _a.length; _i++) {
                    var vertex = _a[_i];
                    var i = vertex.param.x;
                    var j = vertex.param.y;
                    if (j % 2 == 0) {
                        var v1 = vertex;
                        var v2 = this.getVertex(i + 1, j + 1);
                        if (v2 == null)
                            continue;
                        var v3 = this.getVertex(i, j + 1);
                        if (v3 != null)
                            this.mamesh.addATriangle(v1, v2, v3);
                        var v4 = this.getVertex(i + 1, j);
                        if (v4 != null)
                            this.mamesh.addATriangle(v1, v4, v2);
                    }
                    else {
                        var v1 = vertex;
                        var v2 = this.getVertex(i, j + 1);
                        if (v2 == null)
                            continue;
                        var v3 = this.getVertex(i + 1, j);
                        if (v3 != null)
                            this.mamesh.addATriangle(v1, v3, v2);
                        var v4 = this.getVertex(i + 1, j + 1);
                        if (v4 != null)
                            this.mamesh.addATriangle(v2, v3, v4);
                    }
                }
            };
            return Regular;
        }());
        reseau.Regular = Regular;
        var Regular3D = (function () {
            function Regular3D() {
                this.nbI = 3;
                this.nbJ = 3;
                this.nbK = 3;
                this.Vi = new mathis.XYZ(1, 0, 0);
                this.Vj = new mathis.XYZ(0, 1, 0);
                this.Vk = new mathis.XYZ(0, 0, 1);
                this.origine = new mathis.XYZ(0, 0, 0);
                this.decayOddStrates = false;
                /**these 3 fields are reported on Regular3d*/
                this.makeLinks = true;
                this.makeTriangleOrSquare = true;
                this.strateHaveSquareMailleVersusTriangleMaille = true;
                this.oneMoreVertexForOddLine = false;
                this.interStrateMailleAreSquareVersusTriangle = true;
                this.createJKSquares = true;
                this.createIKSquaresOrTriangles = true;
                this.putAVertexOnlyAtXYZCheckingThisCondition = null;
                this.paramToVertex = new mathis.HashMap();
            }
            Regular3D.prototype.go = function () {
                var _this = this;
                this.mamesh = new mathis.Mamesh();
                //this.mamesh.linksOK=true
                var xDecay = new mathis.XYZ(0, 0, 0);
                if (this.decayOddStrates)
                    xDecay.add(this.Vi).scale(0.5);
                for (var k = 0; k < this.nbK; k++) {
                    var twoD = new Regular();
                    twoD.makeTriangleOrSquare = this.makeTriangleOrSquare;
                    twoD.makeLinks = true;
                    twoD.oneMoreVertexForOddLine = this.oneMoreVertexForOddLine;
                    twoD.squareVersusTriangleMaille = this.strateHaveSquareMailleVersusTriangleMaille;
                    twoD.nbI = this.nbI;
                    twoD.nbJ = this.nbJ;
                    twoD.fixedK = k;
                    twoD.Vi = this.Vi;
                    twoD.Vj = this.Vj;
                    twoD.Vk.copyFrom(this.Vk);
                    twoD.origine = mathis.XYZ.newFrom(this.origine);
                    if (k % 2 == 1)
                        twoD.origine.substract(xDecay);
                    twoD.putAVertexOnlyAtXYZCheckingThisCondition = this.putAVertexOnlyAtXYZCheckingThisCondition;
                    /** chaque strate est un mamesh. On ne les mmorise plus comme avant*/
                    var twoDimMamesh = twoD.go();
                    for (var _i = 0, _a = twoD.paramToVertex.allEntries(); _i < _a.length; _i++) {
                        var entry = _a[_i];
                        this.mamesh.vertices.push(entry.value);
                        this.paramToVertex.putValue(entry.key, entry.value);
                    }
                    for (var _b = 0, _c = twoDimMamesh.smallestSquares; _b < _c.length; _b++) {
                        var vertex = _c[_b];
                        this.mamesh.smallestSquares.push(vertex);
                    }
                    for (var _d = 0, _e = twoDimMamesh.smallestTriangles; _d < _e.length; _d++) {
                        var vertex = _e[_d];
                        this.mamesh.smallestTriangles.push(vertex);
                    }
                }
                if (this.interStrateMailleAreSquareVersusTriangle) {
                    this.linksCreationForSquareMaille();
                    if (this.createJKSquares) {
                        var dir1_1 = new mathis.XYZ(0, 1, 0);
                        var dir2_1 = new mathis.XYZ(0, 0, 1);
                        this.mamesh.vertices.forEach(function (v) {
                            makeSquareFromDeltaParam(v, _this.mamesh, dir1_1, dir2_1, _this.paramToVertex);
                        });
                    }
                    if (this.createIKSquaresOrTriangles) {
                        var dir1_2 = new mathis.XYZ(1, 0, 0);
                        var dir2_2 = new mathis.XYZ(0, 0, 1);
                        this.mamesh.vertices.forEach(function (v) {
                            makeSquareFromDeltaParam(v, _this.mamesh, dir1_2, dir2_2, _this.paramToVertex);
                        });
                    }
                }
                else {
                    this.linksCreationForTriangleMaille();
                    if (this.createJKSquares) {
                        var dir1_3 = new mathis.XYZ(0, 1, 0);
                        var dir2_3 = new mathis.XYZ(0, 0, 1);
                        this.mamesh.vertices.forEach(function (v) {
                            makeSquareFromDeltaParam(v, _this.mamesh, dir1_3, dir2_3, _this.paramToVertex);
                        });
                    }
                    if (this.createIKSquaresOrTriangles) {
                        this.triangleCreation();
                    }
                }
                //
                //
                // if (this.createIMameshes) {
                //     for (let i = 0; i < this.nbI; i++) {
                //
                //         let mamesh = new Mamesh()
                //         this.mamesh3D.iMameshes.push(mamesh)
                //
                //         for (let j = 0; j < this.nbJ; j++) {
                //             for (let k = 0; k < this.nbK; k++) {
                //                 let genericParam=new XYZ(i, j, k)
                //                 let vertex = this.mamesh3D.iMameshes[k].findVertexFromParam(genericParam)
                //                 if (vertex != null) {
                //                     mamesh.vertices.push(vertex)
                //                     this.paramToVertex.putValue(genericParam,vertex)
                //
                //                 }
                //
                //             }
                //         }
                //
                //
                //
                //         mamesh.vertices.forEach(cell=> {
                //             makeLinksFromDeltaParam(cell, mamesh, XYZ.temp0(0, 1, 0), XYZ.temp1(0, -1, 0),this.paramToVertex)
                //             makeLinksFromDeltaParam(cell, mamesh, XYZ.temp0(0, 0, 1), XYZ.temp1(0, 0, -1),this.paramToVertex)
                //         })
                //         mamesh.linksOK = true
                //
                //
                //
                //         if (this.makeSquares) {
                //             let dir1=new XYZ(0,1,0)
                //             let dir2=new XYZ(0,0,1)
                //             mamesh.vertices.forEach(v=> {
                //                 makeSquareFromDeltaParam(v, mamesh, dir1, dir2,this.paramToVertex)
                //             })
                //         }
                //
                //     }
                //
                // }
                //
                // if (this.createJMameshes) {
                //     for (let j = 0; j < this.nbJ; j++) {
                //
                //         let mamesh = new Mamesh()
                //         this.mamesh3D.jMameshes.push(mamesh)
                //
                //         for (let i = 0; i < this.nbI; i++) {
                //             for (let k = 0; k < this.nbK; k++) {
                //                 let genericParam=new XYZ(i, j, k)
                //                 let vertex = this.mamesh3D.kMameshes[k].findVertexFromParam(genericParam)
                //                 if (vertex != null) {
                //                     mamesh.vertices.push(vertex)
                //                     this.paramToVertex.putValue(genericParam, vertex)
                //                 }
                //
                //             }
                //         }
                //
                //         mamesh.vertices.forEach(cell=> {
                //             makeLinksFromDeltaParam(cell, mamesh, XYZ.temp0(1, 0, 0), XYZ.temp1(-1, 0, 0),this.paramToVertex)
                //             makeLinksFromDeltaParam(cell, mamesh, XYZ.temp0(0, 0, 1), XYZ.temp1(0, 0, -1),this.paramToVertex)
                //         })
                //         mamesh.linksOK = true
                //
                //         if (this.makeSquares) {
                //             let dir1 = new XYZ(1, 0, 0)
                //             let dir2 = new XYZ(0, 0, 1)
                //             mamesh.vertices.forEach(v=> {
                //                 makeSquareFromDeltaParam(v, mamesh, dir1, dir2,this.paramToVertex)
                //             })
                //         }
                //
                //     }
                // }
                return this.mamesh;
            };
            Regular3D.prototype.linksCreationForSquareMaille = function () {
                var _this = this;
                var vec001 = new mathis.XYZ(0, 0, 1);
                var vec_001 = new mathis.XYZ(0, 0, -1);
                this.mamesh.vertices.forEach(function (v) {
                    makeLinksFromDeltaParam(v, vec001, vec_001, _this.paramToVertex);
                });
            };
            Regular3D.prototype.linksCreationForTriangleMaille = function () {
                var _this = this;
                this.mamesh.vertices.forEach(function (cell) {
                    /**even lines */
                    if (cell.param.z % 2 == 0) {
                        /** sud est - nord ouest*/
                        makeLinksFromDeltaParam(cell, mathis.XYZ.temp0(1, 0, 1), mathis.XYZ.temp1(0, 0, -1), _this.paramToVertex);
                        /** sud ouest - nord est*/
                        makeLinksFromDeltaParam(cell, mathis.XYZ.temp0(0, 0, 1), mathis.XYZ.temp1(1, 0, -1), _this.paramToVertex);
                    }
                    else {
                        /**sud est - nord ouest*/
                        makeLinksFromDeltaParam(cell, mathis.XYZ.temp0(0, 0, 1), mathis.XYZ.temp1(-1, 0, -1), _this.paramToVertex);
                        /**sud ouest - nord est*/
                        makeLinksFromDeltaParam(cell, mathis.XYZ.temp0(-1, 0, 1), mathis.XYZ.temp1(0, 0, -1), _this.paramToVertex);
                    }
                });
            };
            Regular3D.prototype.getVertex = function (i, j, givenK) {
                return this.paramToVertex.getValue(new mathis.XYZ(i, givenK, j));
            };
            Regular3D.prototype.triangleCreation = function () {
                for (var _i = 0, _a = this.mamesh.vertices; _i < _a.length; _i++) {
                    var vertex = _a[_i];
                    var i = vertex.param.x;
                    var j = vertex.param.z;
                    var k = vertex.param.y;
                    if (j % 2 == 0) {
                        var v1 = vertex;
                        var v2 = this.getVertex(i + 1, j + 1, k);
                        if (v2 == null)
                            continue;
                        var v3 = this.getVertex(i, j + 1, k);
                        if (v3 != null)
                            this.mamesh.addATriangle(v1, v2, v3);
                        var v4 = this.getVertex(i + 1, j, k);
                        if (v4 != null)
                            this.mamesh.addATriangle(v1, v4, v2);
                    }
                    else {
                        var v1 = vertex;
                        var v2 = this.getVertex(i, j + 1, k);
                        if (v2 == null)
                            continue;
                        var v3 = this.getVertex(i + 1, j, k);
                        if (v3 != null)
                            this.mamesh.addATriangle(v1, v3, v2);
                        var v4 = this.getVertex(i + 1, j + 1, k);
                        if (v4 != null)
                            this.mamesh.addATriangle(v2, v3, v4);
                    }
                }
            };
            return Regular3D;
        }());
        reseau.Regular3D = Regular3D;
    })(reseau = mathis.reseau || (mathis.reseau = {}));
})(mathis || (mathis = {}));
/**
 * Created by vigon on 04/07/2016.
 */
var mathis;
(function (mathis) {
    var spacialTransformations;
    (function (spacialTransformations) {
        var RoundSomeStrates = (function () {
            function RoundSomeStrates(mamesh) {
                this.propBeginToRound = 0;
                this.propEndToRound = 1;
                /**if it stays null, this interval is computed from propIntervalToRound*/
                this.integerBeginToRound = null;
                this.integerEndToRound = null;
                this.exponentOfRoundingFunction = 1;
                this.referenceRadiusIsMinVersusMaxVersusMean = 2;
                this.preventStratesCrossings = true;
                this.mamesh = mamesh;
            }
            RoundSomeStrates.prototype.goChanging = function () {
                if (isNaN(this.exponentOfRoundingFunction))
                    throw 'must be a number';
                if (this.propBeginToRound < 0 || this.propBeginToRound > 1)
                    throw 'must be in [0,1]';
                if (this.propEndToRound < 0 || this.propEndToRound > 1)
                    throw 'must be in [0,1]';
                if (this.propBeginToRound >= this.propEndToRound)
                    return;
                var border = [];
                for (var _i = 0, _a = this.mamesh.vertices; _i < _a.length; _i++) {
                    var ver = _a[_i];
                    if (ver.hasMark(mathis.Vertex.Markers.border))
                        border.push(ver);
                }
                var rings = mathis.graph.ringify(border);
                if (this.integerBeginToRound == null)
                    this.integerBeginToRound = Math.floor(rings.length * this.propBeginToRound);
                if (this.integerEndToRound == null)
                    this.integerEndToRound = Math.ceil(rings.length * this.propEndToRound);
                if (this.integerEndToRound < 0)
                    this.integerEndToRound = rings.length + this.integerEndToRound;
                if (this.integerBeginToRound > rings.length || this.integerBeginToRound < 0)
                    throw 'problem';
                if (this.integerEndToRound > rings.length || this.integerEndToRound < 0)
                    throw 'problem';
                if (this.integerEndToRound <= this.integerBeginToRound)
                    return;
                var barycenter = new mathis.XYZ(0, 0, 0);
                for (var _b = 0, _c = this.mamesh.vertices; _b < _c.length; _b++) {
                    var vertex = _c[_b];
                    barycenter.add(vertex.position);
                }
                barycenter.scale(1 / this.mamesh.vertices.length);
                var temp = new mathis.XYZ(0, 0, 0);
                var lastReferenceRadius = null;
                //let i:number
                for (var i = this.integerBeginToRound; i < this.integerEndToRound; i++) {
                    var maxRadius = -1;
                    var minRadius = Number.POSITIVE_INFINITY;
                    var meanRadois = 0;
                    for (var _d = 0, _e = rings[i]; _d < _e.length; _d++) {
                        var v = _e[_d];
                        var radius = mathis.geo.distance(v.position, barycenter);
                        if (radius > maxRadius)
                            maxRadius = radius;
                        if (radius < minRadius)
                            minRadius = radius;
                        meanRadois += radius;
                    }
                    meanRadois /= rings[i].length;
                    /** when the last strate is made of a vertex which position is the barycenter, maxRadius si zero */
                    if (maxRadius > mathis.geo.epsilon) {
                        var referenceRadius = void 0;
                        if (this.referenceRadiusIsMinVersusMaxVersusMean == 0)
                            referenceRadius = minRadius;
                        else if (this.referenceRadiusIsMinVersusMaxVersusMean == 1)
                            referenceRadius = maxRadius;
                        else if (this.referenceRadiusIsMinVersusMaxVersusMean == 2)
                            referenceRadius = meanRadois;
                        lastReferenceRadius = referenceRadius;
                        for (var _f = 0, _g = rings[i]; _f < _g.length; _f++) {
                            var v = _g[_f];
                            var newPosition = temp.copyFrom(v.position).substract(barycenter);
                            var length_6 = newPosition.length();
                            var ratio = Math.pow(referenceRadius / length_6, this.exponentOfRoundingFunction);
                            newPosition.scale(ratio);
                            v.position.copyFrom(newPosition.add(barycenter));
                        }
                    }
                }
                if (this.preventStratesCrossings) {
                    if (this.integerBeginToRound > 0) {
                        var maxRadiusOfRound = -1;
                        for (var _h = 0, _j = rings[this.integerBeginToRound]; _h < _j.length; _h++) {
                            var v = _j[_h];
                            var radius = mathis.geo.distance(v.position, barycenter);
                            if (radius > maxRadiusOfRound)
                                maxRadiusOfRound = radius;
                        }
                        var minRadiusOfNonExterior = Number.POSITIVE_INFINITY;
                        for (var _k = 0, _l = rings[this.integerBeginToRound - 1]; _k < _l.length; _k++) {
                            var v = _l[_k];
                            var radius = mathis.geo.distance(v.position, barycenter);
                            if (radius < minRadiusOfNonExterior)
                                minRadiusOfNonExterior = radius;
                        }
                        var factor = null;
                        if (1.1 * maxRadiusOfRound > minRadiusOfNonExterior)
                            factor = (1.1 * maxRadiusOfRound) / minRadiusOfNonExterior;
                        if (factor != null) {
                            for (var j = 0; j < this.integerBeginToRound; j++) {
                                for (var _m = 0, _o = rings[j]; _m < _o.length; _m++) {
                                    var v = _o[_m];
                                    v.position.copyFrom(temp.copyFrom(v.position).substract(barycenter).scale(factor).add(barycenter));
                                }
                            }
                        }
                    }
                    if (this.integerEndToRound < rings.length) {
                        var minRadiusOfRound = Number.POSITIVE_INFINITY;
                        for (var _p = 0, _q = rings[this.integerEndToRound - 1]; _p < _q.length; _p++) {
                            var v = _q[_p];
                            var radius = mathis.geo.distance(v.position, barycenter);
                            if (radius < minRadiusOfRound)
                                minRadiusOfRound = radius;
                        }
                        var maxRadiusOfInterior = -1;
                        for (var _r = 0, _s = rings[this.integerEndToRound]; _r < _s.length; _r++) {
                            var v = _s[_r];
                            var radius = mathis.geo.distance(v.position, barycenter);
                            if (radius > maxRadiusOfInterior)
                                maxRadiusOfInterior = radius;
                        }
                        var factor = null;
                        if (1.1 * maxRadiusOfInterior > minRadiusOfRound)
                            factor = minRadiusOfRound / (1.1 * maxRadiusOfInterior);
                        if (factor != null) {
                            for (var j = this.integerEndToRound; j < rings.length; j++) {
                                for (var _t = 0, _u = rings[j]; _t < _u.length; _t++) {
                                    var v = _u[_t];
                                    v.position.copyFrom(temp.copyFrom(v.position).substract(barycenter).scale(factor).add(barycenter));
                                }
                            }
                        }
                    }
                }
            };
            return RoundSomeStrates;
        }());
        spacialTransformations.RoundSomeStrates = RoundSomeStrates;
        var Similitude = (function () {
            function Similitude(vertices, angle, vectorForTranslation, sizesForResize) {
                if (vectorForTranslation === void 0) { vectorForTranslation = new mathis.XYZ(0, 0, 0); }
                if (sizesForResize === void 0) { sizesForResize = new mathis.XYZ(1, 1, 1); }
                this.axisForRotation = new mathis.XYZ(0, 0, 1);
                /**if null, it is the barycenter*/
                this.centerForSimilitude = null;
                this.vertices = vertices;
                this.angle = angle;
                this.vectorForTranslation = vectorForTranslation;
                this.sizesForResize = sizesForResize;
            }
            Similitude.prototype.goChanging = function () {
                var _this = this;
                if (this.centerForSimilitude == null) {
                    this.centerForSimilitude = new mathis.XYZ(0, 0, 0);
                    var w_1 = 1 / this.vertices.length;
                    var ws_1 = [];
                    var positions_1 = [];
                    this.vertices.forEach(function (v) {
                        positions_1.push(v.position);
                        ws_1.push(w_1);
                    });
                    mathis.geo.baryCenter(positions_1, ws_1, this.centerForSimilitude);
                }
                var mat = new mathis.MM();
                mathis.geo.axisAngleToMatrix(this.axisForRotation, this.angle, mat);
                this.vertices.forEach(function (v) {
                    v.position.substract(_this.centerForSimilitude);
                    v.position.resizes(_this.sizesForResize);
                    mathis.geo.multiplicationMatrixVector(mat, v.position, v.position);
                    v.position.add(_this.centerForSimilitude).add(_this.vectorForTranslation);
                });
            };
            return Similitude;
        }());
        spacialTransformations.Similitude = Similitude;
        function adjustInASquare(mamesh, origine, end) {
            var actualEnd = mathis.XYZ.newFrom(mamesh.vertices[0].position);
            var actualOrigin = mathis.XYZ.newFrom(mamesh.vertices[0].position);
            for (var _i = 0, _a = mamesh.vertices; _i < _a.length; _i++) {
                var vert = _a[_i];
                if (vert.position.x > actualEnd.x)
                    actualEnd.x = vert.position.x;
                if (vert.position.y > actualEnd.y)
                    actualEnd.y = vert.position.y;
                if (vert.position.x < actualOrigin.x)
                    actualOrigin.x = vert.position.x;
                if (vert.position.y < actualOrigin.y)
                    actualOrigin.y = vert.position.y;
            }
            var actualAmplitude = mathis.XYZ.newFrom(actualEnd).substract(actualOrigin);
            var ampli = mathis.XYZ.newFrom(end).substract(origine);
            var factor = new mathis.XYZ(ampli.x / actualAmplitude.x, ampli.y / actualAmplitude.y, 0);
            for (var _b = 0, _c = mamesh.vertices; _b < _c.length; _b++) {
                var vert = _c[_b];
                vert.position.substract(actualOrigin).resizes(factor).add(origine);
            }
        }
        spacialTransformations.adjustInASquare = adjustInASquare;
    })(spacialTransformations = mathis.spacialTransformations || (mathis.spacialTransformations = {}));
})(mathis || (mathis = {}));
/**
 * Created by vigon on 25/04/2016.
 */
var mathis;
(function (mathis) {
    var symmetries;
    (function (symmetries_2) {
        symmetries_2.squareMainSymmetries = [function (a) { return new mathis.XYZ(1 - a.x, a.y, a.z); }, function (a) { return new mathis.XYZ(a.x, 1 - a.y, a.z); }, function (a) { return new mathis.XYZ(1 - a.x, 1 - a.y, a.z); }]; //,(a:XYZ)=>new XYZ(a.y,a.x,a.z),(a:XYZ)=>new XYZ(1-a.y,1-a.x,a.z)  ]
        var keyWords;
        (function (keyWords) {
            keyWords.verticalAxis = 'symI';
            keyWords.horizontalAxis = 'symJ';
            keyWords.slashAxis = 'symIJ';
            keyWords.rotation = 'rotation';
        })(keyWords = symmetries_2.keyWords || (symmetries_2.keyWords = {}));
        function cartesian(nbI, nbJ, oneMoreVertexForOddLine) {
            if (oneMoreVertexForOddLine === void 0) { oneMoreVertexForOddLine = false; }
            var symmetries = new mathis.StringMap();
            symmetries.putValue(keyWords.verticalAxis, function (v) {
                var hereNbI = nbI;
                if (v.y % 2 == 1 && oneMoreVertexForOddLine)
                    hereNbI++;
                return new mathis.XYZ(hereNbI - 1 - v.x, v.y, v.z);
            });
            symmetries.putValue(keyWords.horizontalAxis, function (v) {
                return new mathis.XYZ(v.x, nbJ - 1 - v.y, v.z);
            });
            symmetries.putValue(keyWords.slashAxis, function (v) {
                var hereNbI = nbI;
                if (v.y % 2 == 1 && oneMoreVertexForOddLine)
                    hereNbI++;
                return new mathis.XYZ(hereNbI - 1 - v.x, nbJ - 1 - v.y, v.z);
            });
            return symmetries;
        }
        symmetries_2.cartesian = cartesian;
        function cartesianAsArray(nbI, nbJ, oneMoreVertexForOddLine) {
            if (oneMoreVertexForOddLine === void 0) { oneMoreVertexForOddLine = false; }
            var symDic = cartesian(nbI, nbJ, oneMoreVertexForOddLine);
            var res = [];
            for (var _i = 0, _a = symDic.allValues(); _i < _a.length; _i++) {
                var sym = _a[_i];
                res.push(sym);
            }
            return res;
        }
        symmetries_2.cartesianAsArray = cartesianAsArray;
        function polygonRotations(nbSides) {
            var symmetries = new mathis.StringMap();
            var _loop_2 = function(t) {
                var angle = Math.PI * 2 / nbSides * t;
                symmetries.putValue(keyWords.rotation + t, function (param) {
                    var res = new mathis.XYZ(0, 0, 0);
                    res.x = param.x * Math.cos(angle) - param.y * Math.sin(angle);
                    res.y = param.x * Math.sin(angle) + param.y * Math.cos(angle);
                    res.z = param.z;
                    return res;
                });
            };
            for (var t = 1; t < nbSides; t++) {
                _loop_2(t);
            }
            return symmetries;
        }
        symmetries_2.polygonRotations = polygonRotations;
        function getAllPolygonalRotations(nbSides) {
            var symMap = polygonRotations(nbSides);
            var res = [];
            for (var _i = 0, _a = symMap.allValues(); _i < _a.length; _i++) {
                var sym = _a[_i];
                res.push(sym);
            }
            return res;
        }
        symmetries_2.getAllPolygonalRotations = getAllPolygonalRotations;
    })(symmetries = mathis.symmetries || (mathis.symmetries = {}));
})(mathis || (mathis = {}));
/**
 * Created by vigon on 17/08/2016.
 */
var mathis;
(function (mathis) {
    /**helper for array manipulations*/
    var tab;
    (function (tab) {
        function maxIndex(list) {
            if (list == null || list.length == 0)
                throw 'empty list';
            var maxValue = list[0];
            var maxIndex = 0;
            for (var i = 1; i < list.length; i++) {
                if (list[i] > maxValue) {
                    maxValue = list[i];
                    maxIndex = i;
                }
            }
            return maxIndex;
        }
        tab.maxIndex = maxIndex;
        function maxValue(list) {
            return list[maxIndex(list)];
        }
        tab.maxValue = maxValue;
        function maxValueString(list) {
            return list[maxIndex(list)];
        }
        tab.maxValueString = maxValueString;
        function minIndex(list) {
            if (list == null || list.length == 0)
                throw 'empty list';
            var maxValue = list[0];
            var maxIndex = 0;
            for (var i = 1; i < list.length; i++) {
                if (list[i] < maxValue) {
                    maxValue = list[i];
                    maxIndex = i;
                }
            }
            return maxIndex;
        }
        tab.minIndex = minIndex;
        function minValue(list) {
            return list[minIndex(list)];
        }
        tab.minValue = minValue;
        function minValueString(list) {
            return list[minIndex(list)];
        }
        tab.minValueString = minValueString;
        function minIndexOb(list, comparisonFunction) {
            if (list == null || list.length == 0)
                throw 'empty list';
            var minValue = list[0];
            var minIndex = 0;
            for (var i = 1; i < list.length; i++) {
                if (comparisonFunction(list[i], minValue) < 0) {
                    minValue = list[i];
                    minIndex = i;
                }
            }
            return minIndex;
        }
        tab.minIndexOb = minIndexOb;
        function minValueOb(list, comparisonFunction) {
            return list[minIndexOb(list, comparisonFunction)];
        }
        tab.minValueOb = minValueOb;
        function clearArray(array) {
            while (array.length > 0)
                array.pop();
        }
        tab.clearArray = clearArray;
        function removeFromArray(array, object) {
            var index = array.indexOf(object);
            if (index != -1)
                array.splice(index, 1);
            else {
                cc("l'objet n'est pas dans le tableau", object);
                throw "l'objet prcdent n'est pas dans le tableau:";
            }
        }
        tab.removeFromArray = removeFromArray;
        function arrayMinusElements(array, criteriumToSuppress) {
            var res = [];
            for (var _i = 0, array_2 = array; _i < array_2.length; _i++) {
                var elem = array_2[_i];
                if (!criteriumToSuppress(elem))
                    res.push(elem);
            }
            return res;
        }
        tab.arrayMinusElements = arrayMinusElements;
        function arrayKeepingSomeIndices(array, indicesToKeep) {
            var res = [];
            for (var i = 0; i < array.length; i++) {
                if (indicesToKeep.indexOf(i) != -1)
                    res.push(array[i]);
            }
            return res;
        }
        tab.arrayKeepingSomeIndices = arrayKeepingSomeIndices;
        function arrayMinusSomeIndices(array, indicesSuppress) {
            var res = [];
            for (var i = 0; i < array.length; i++) {
                if (indicesSuppress.indexOf(i) == -1)
                    res.push(array[i]);
            }
            return res;
        }
        tab.arrayMinusSomeIndices = arrayMinusSomeIndices;
        function arrayMinusBlocksIndices(list, indicesOfBlocksToRemove, blockSize) {
            var res = [];
            for (var i = 0; i < list.length; i += blockSize) {
                if (indicesOfBlocksToRemove.indexOf(i) == -1) {
                    for (var j = 0; j < blockSize; j++) {
                        res.push(list[i + j]);
                    }
                }
            }
            return res;
        }
        tab.arrayMinusBlocksIndices = arrayMinusBlocksIndices;
        function minIndexOfNumericList(list) {
            var minValue = Number.MAX_VALUE;
            var minIndex = -1;
            for (var i = 0; i < list.length; i++) {
                if (list[i] < minValue) {
                    minValue = list[i];
                    minIndex = i;
                }
            }
            if (minIndex == -1)
                mathis.logger.c('an empty line has no minimum');
            return minIndex;
        }
        tab.minIndexOfNumericList = minIndexOfNumericList;
        function maxIndexOfNumericList(list) {
            var maxValue = Number.NEGATIVE_INFINITY;
            var maxIndex = -1;
            for (var i = 0; i < list.length; i++) {
                if (list[i] > maxValue) {
                    maxValue = list[i];
                    maxIndex = i;
                }
            }
            return maxIndex;
        }
        tab.maxIndexOfNumericList = maxIndexOfNumericList;
        function minIndexOfStringList(list) {
            if (list.length == 0) {
                mathis.logger.c('an empty line has no minimum');
                return -1;
            }
            var minValue = list[0];
            var minIndex = 0;
            for (var i = 0; i < list.length; i++) {
                if (list[i] < minValue) {
                    minValue = list[i];
                    minIndex = i;
                }
            }
            return minIndex;
        }
        tab.minIndexOfStringList = minIndexOfStringList;
        function indicesUpPermutationToString(indices) {
            var minIndex = minIndexOfNumericList(indices);
            var permuted = [];
            for (var i = 0; i < indices.length; i++) {
                permuted[i] = indices[(i + minIndex) % indices.length];
            }
            return JSON.stringify(permuted);
        }
        tab.indicesUpPermutationToString = indicesUpPermutationToString;
        var ArrayMinusBlocksElements = (function () {
            function ArrayMinusBlocksElements(longList, blockSize, listToRemove) {
                this.dicoOfExistingBlocks = {};
                this.removeAlsoCircularPermutation = true;
                this.longList = longList;
                this.blockSize = blockSize;
                if (listToRemove == null) {
                    this.listToRemove = longList;
                    this.removeOnlyDoublon = true;
                }
                else {
                    this.listToRemove = listToRemove;
                    this.removeOnlyDoublon = false;
                }
            }
            ArrayMinusBlocksElements.prototype.go = function () {
                /**construction of the dictionary */
                for (var i = 0; i < this.listToRemove.length; i += this.blockSize) {
                    try {
                        var block = [];
                        for (var j = 0; j < this.blockSize; j++)
                            block.push(this.listToRemove[i + j].hashString);
                        this.dicoOfExistingBlocks[this.key(block)] = 1;
                    }
                    catch (e) {
                        throw "a block is not in your list";
                    }
                }
                /**construction of the resulting array, checking the dictionnary*/
                var newLongList = [];
                for (var i = 0; i < this.longList.length; i += this.blockSize) {
                    var block = [];
                    for (var j = 0; j < this.blockSize; j++)
                        block.push(this.longList[i + j].hashString);
                    if (!this.removeOnlyDoublon) {
                        if (this.dicoOfExistingBlocks[this.key(block)] == null) {
                            for (var j = 0; j < this.blockSize; j++)
                                newLongList.push(this.longList[i + j]);
                        }
                    }
                    else {
                        if (this.dicoOfExistingBlocks[this.key(block)] == 1) {
                            for (var j = 0; j < this.blockSize; j++)
                                newLongList.push(this.longList[i + j]);
                            this.dicoOfExistingBlocks[this.key(block)]++;
                        }
                    }
                }
                return newLongList;
            };
            //
            //private allCircularPermutations(list:number[]):number[][]{
            //    let res:number[][]=[]
            //
            //    for (let i=0;i<this.blockSize;i++){
            //        let perm:number[]=[]
            //        for (let j=0;j<this.blockSize;j++) perm.push(list[(i+j)%this.blockSize])
            //        res.push(perm)
            //    }
            //
            //    return res
            //
            //
            //}
            ArrayMinusBlocksElements.prototype.key = function (list) {
                var rearangedList = [];
                if (!this.removeAlsoCircularPermutation)
                    rearangedList = list;
                else {
                    rearangedList = [];
                    var minIndex_1 = minIndexOfStringList(list);
                    for (var i = 0; i < list.length; i++)
                        rearangedList[i] = list[(i + minIndex_1) % list.length];
                }
                var key = "";
                rearangedList.forEach(function (nu) {
                    key += nu + ',';
                });
                return key;
            };
            return ArrayMinusBlocksElements;
        }());
        tab.ArrayMinusBlocksElements = ArrayMinusBlocksElements;
    })(tab = mathis.tab || (mathis.tab = {}));
})(mathis || (mathis = {}));
/**
 * Created by vigon on 16/12/2015.
 */
var mathis;
(function (mathis) {
    var visu3d;
    (function (visu3d) {
        var VerticesViewer = (function () {
            function VerticesViewer(mamesh, scene, positionings) {
                this.nbSegments = 32;
                /**if null, default model will be used*/
                this.meshModel = null;
                this.meshModels = null;
                this.useCloneInsteadOfInstances = false;
                this.checkCollision = false;
                this.color = mathis.color.thema.defaultVertexColor;
                this.constantRadius = null;
                /**if no constantRadius and no positioning.size is given, the radius of vertex representation is a proportion of the distance
                 * between two linked vertices*/
                this.radiusProp = 0.1;
                this.vertexToCopiedMeshes = new mathis.HashMap();
                if (mamesh == null)
                    throw 'no Mamesh given';
                else
                    this.mamesh = mamesh;
                if (scene == null)
                    throw 'scene is null';
                else
                    this.scene = scene;
                this.positionings = positionings;
            }
            VerticesViewer.prototype.checkArgs = function () {
                if (this.mamesh.vertices[0] == null)
                    cc('no vertex to draw');
            };
            VerticesViewer.prototype.go = function () {
                this.checkArgs();
                if (this.selectedVertices == null)
                    this.selectedVertices = this.mamesh.vertices;
                if (this.meshModel == null && this.meshModels == null) {
                    /**diameter of model : 0.5 because then, we think of radius*/
                    this.meshModel = BABYLON.Mesh.CreateSphere('', this.nbSegments, 2, this.scene);
                    this.meshModels = [this.meshModel];
                }
                else {
                    if (this.meshModels == null)
                        this.meshModels = [];
                    if (this.meshModel != null)
                        this.meshModels.push(this.meshModel);
                    for (var _i = 0, _a = this.meshModels; _i < _a.length; _i++) {
                        var mesh = _a[_i];
                        mesh.bakeCurrentTransformIntoVertices();
                    }
                }
                //if (this.material==null) this.material=new BABYLON.StandardMaterial('',this.scene)
                for (var _b = 0, _c = this.meshModels; _b < _c.length; _b++) {
                    var mesh = _c[_b];
                    if (mesh.material == null) {
                        var material = new BABYLON.StandardMaterial("", this.scene);
                        material.diffuseColor = this.color.toBABYLON_Color3();
                        mesh.material = material;
                    }
                }
                /**models are hidden*/
                for (var _d = 0, _e = this.meshModels; _d < _e.length; _d++) {
                    var mesh = _e[_d];
                    mesh.scaling = new mathis.XYZ(0, 0, 0);
                }
                if (this.positionings == null) {
                    // if (this.mamesh != null) {
                    //     logger.c('no positioning given: it is computed from mamesh')
                    //     let posi = new mameshAroundComputations.PositioningComputerForMameshVertices(this.mamesh)
                    //     this.vertexToPositioning = posi.goChanging()
                    // }
                    // else {
                    //logger.c('no positioning given: elementary positioning is compute from vertex position. This positioning is only convenient for spherical representation of vertices')
                    this.positionings = new mathis.HashMap();
                    for (var _f = 0, _g = this.selectedVertices; _f < _g.length; _f++) {
                        var v = _g[_f];
                        var radius = void 0;
                        if (this.constantRadius == null) {
                            var minDist = Number.MAX_VALUE;
                            if (v.links.length != 0) {
                                for (var _h = 0, _j = v.links; _h < _j.length; _h++) {
                                    var li = _j[_h];
                                    var d = mathis.geo.distance(v.position, li.to.position);
                                    if (d < minDist)
                                        minDist = d;
                                }
                            }
                            else {
                                for (var _k = 0, _l = this.selectedVertices; _k < _l.length; _k++) {
                                    var other = _l[_k];
                                    if (!other.position.almostEqual(v.position)) {
                                        var d = mathis.geo.distance(v.position, other.position);
                                        if (d < minDist)
                                            minDist = d;
                                    }
                                }
                            }
                            radius = minDist * this.radiusProp;
                        }
                        else
                            radius = this.constantRadius;
                        var pos = new mathis.Positioning();
                        pos.frontDir = new mathis.XYZ(1, 0, 0);
                        pos.upVector = new mathis.XYZ(0, 1, 0);
                        pos.scaling = new mathis.XYZ(radius, radius, radius);
                        this.positionings.putValue(v, pos);
                    }
                }
                this.buildVertexVisu();
            };
            /**can also be use to rebuild a part of the visualisation */
            VerticesViewer.prototype.buildVertexVisu = function (verticesToUpdate, verticesToClear) {
                var _this = this;
                if (verticesToUpdate === void 0) { verticesToUpdate = this.selectedVertices; }
                if (verticesToClear === void 0) { verticesToClear = []; }
                verticesToUpdate.forEach(function (vertex) {
                    var copiedMeshes = [];
                    if (_this.useCloneInsteadOfInstances) {
                        for (var _i = 0, _a = _this.meshModels; _i < _a.length; _i++) {
                            var mesh = _a[_i];
                            copiedMeshes.push(mesh.clone(''));
                        }
                    }
                    else {
                        for (var _b = 0, _c = _this.meshModels; _b < _c.length; _b++) {
                            var mesh = _c[_b];
                            copiedMeshes.push(mesh.createInstance(''));
                        }
                    }
                    for (var _d = 0, copiedMeshes_1 = copiedMeshes; _d < copiedMeshes_1.length; _d++) {
                        var mesh = copiedMeshes_1[_d];
                        mesh.checkCollisions = _this.checkCollision;
                        if (_this.parentNode != null)
                            mesh.parent = _this.parentNode;
                    }
                    if (_this.vertexToCopiedMeshes.getValue(vertex) != null) {
                        for (var _e = 0, _f = _this.vertexToCopiedMeshes.getValue(vertex); _e < _f.length; _e++) {
                            var mesh = _f[_e];
                            mesh.dispose();
                        }
                    }
                    _this.vertexToCopiedMeshes.putValue(vertex, copiedMeshes);
                    _this.updatePositioning(vertex);
                });
                verticesToClear.forEach(function (vertex) {
                    if (_this.vertexToCopiedMeshes.getValue(vertex) != null) {
                        for (var _i = 0, _a = _this.vertexToCopiedMeshes.getValue(vertex); _i < _a.length; _i++) {
                            var mesh = _a[_i];
                            mesh.dispose();
                        }
                    }
                    _this.vertexToCopiedMeshes.removeKey(vertex);
                });
            };
            /**can also be used to modify a part of the visualisation*/
            VerticesViewer.prototype.updatePositionings = function (vertice) {
                var _this = this;
                if (vertice === void 0) { vertice = this.selectedVertices; }
                vertice.forEach(function (v) { return _this.updatePositioning(v); });
            };
            VerticesViewer.prototype.updatePositioning = function (vertex) {
                var position = mathis.XYZ.newFrom(vertex.position);
                for (var _i = 0, _a = this.vertexToCopiedMeshes.getValue(vertex); _i < _a.length; _i++) {
                    var mesh = _a[_i];
                    if (this.positionings.getValue(vertex) == null)
                        throw "a vertex without associated positioning";
                    if (Math.abs(this.positionings.getValue(vertex).scaling.x) < mathis.geo.epsilon) {
                        mesh.visibility = 0;
                    }
                    else {
                        mesh.visibility = 1;
                        mesh.rotationQuaternion = this.positionings.getValue(vertex).quaternion();
                        mesh.position = position;
                        mesh.scaling = this.positionings.getValue(vertex).scaling;
                    }
                }
            };
            return VerticesViewer;
        }());
        visu3d.VerticesViewer = VerticesViewer;
        var SurfaceViewer = (function () {
            function SurfaceViewer(mamesh, scene) {
                //(IN_mamesh:Mamesh, scene:BABYLON.Scene, options?: {  sideOrientation?: number }, name='rectangleWithDifferentsParameters')
                this.parentNode = null;
                this.sideOrientation = BABYLON.Mesh.DOUBLESIDE;
                this.normalDuplication = NormalDuplication.duplicateOnlyWhenNormalsAreTooFarr; //SurfaceVisuStatic.NormalDuplication.duplicateOnlyWhenNormalsAreTooFarr
                this.maxAngleBetweenNormals = Math.PI / 4;
                this.color = mathis.color.thema.defaultSurfaceColor;
                this.alpha = 0.4;
                this.backFaceCulling = true;
                this.mamesh = mamesh;
                this.scene = scene;
            }
            SurfaceViewer.prototype.checkArgs = function () {
                if (this.scene == null)
                    throw 'the scene must but not null';
            };
            SurfaceViewer.prototype.go = function () {
                var positions = new Array();
                var uvs = [];
                for (var _i = 0, _a = this.mamesh.vertices; _i < _a.length; _i++) {
                    var v = _a[_i];
                    positions.push(v.position.x, v.position.y, v.position.z);
                }
                var hashToIndex = new Array();
                for (var index = 0; index < this.mamesh.vertices.length; index++)
                    hashToIndex[this.mamesh.vertices[index].hashNumber] = index;
                var indices = new Array();
                for (var i = 0; i < this.mamesh.smallestTriangles.length; i += 3) {
                    var v0 = this.mamesh.smallestTriangles[i];
                    var v1 = this.mamesh.smallestTriangles[i + 1];
                    var v2 = this.mamesh.smallestTriangles[i + 2];
                    indices.push(hashToIndex[v0.hashNumber], hashToIndex[v1.hashNumber], hashToIndex[v2.hashNumber]);
                }
                for (var i = 0; i < this.mamesh.smallestSquares.length; i += 4) {
                    var v0 = this.mamesh.smallestSquares[i];
                    var v1 = this.mamesh.smallestSquares[i + 1];
                    var v2 = this.mamesh.smallestSquares[i + 2];
                    var v3 = this.mamesh.smallestSquares[i + 3];
                    indices.push(hashToIndex[v0.hashNumber], hashToIndex[v1.hashNumber], hashToIndex[v3.hashNumber]);
                    indices.push(hashToIndex[v1.hashNumber], hashToIndex[v2.hashNumber], hashToIndex[v3.hashNumber]);
                }
                var normalsOfTriangles = this.computeOneNormalPerTriangle(positions, indices);
                var normalsOfVertices = this.computeVertexNormalFromTrianglesNormal(positions, indices, normalsOfTriangles);
                /**must be done after the normal computations*/
                this._ComputeSides(this.sideOrientation, positions, indices, normalsOfVertices, uvs);
                var vertexData = new BABYLON.VertexData();
                vertexData.indices = indices;
                vertexData.positions = positions;
                vertexData.normals = normalsOfVertices;
                vertexData.uvs = uvs;
                var mesh = new BABYLON.Mesh('', this.scene);
                vertexData.applyToMesh(mesh);
                if (this.parentNode != null)
                    mesh.parent = this.parentNode;
                if (this.material == null) {
                    var material = new BABYLON.StandardMaterial('', this.scene);
                    material.diffuseColor = this.color.toBABYLON_Color3();
                    this.material = material;
                    /**put backFaceCulling=false if you want to allow clik on both sides*/
                    this.material.backFaceCulling = this.backFaceCulling;
                    if (!this.backFaceCulling)
                        mathis.logger.c("backFaceCulling is desactivate on this mamesh.");
                    this.material.sideOrientation = BABYLON.Mesh.BACKSIDE;
                    material.alpha = this.alpha;
                }
                mesh.material = this.material;
                return mesh;
                //if (this.scene!=null){
                //
                //    if (this.material==null) {
                //        this.material=new BABYLON.StandardMaterial("mat1", this.scene);
                //        this.material.alpha = this.alpha;
                //        this.material.diffuseColor = new BABYLON.Color3(1,0.2,0.2)
                //        this.material.backFaceCulling = true
                //    }
                //
                //
                //    let babMesh = new BABYLON.Mesh(name, this.scene)
                //    vertexData.applyToMesh(babMesh)
                //    babMesh.material=this.material
                //
                //
                //
                //}
            };
            SurfaceViewer.prototype._ComputeSides = function (sideOrientation, positions, indices, normals, uvs) {
                var li = indices.length;
                var ln = normals.length;
                var i;
                var n;
                sideOrientation = sideOrientation || BABYLON.Mesh.DEFAULTSIDE;
                switch (sideOrientation) {
                    case BABYLON.Mesh.FRONTSIDE:
                        // nothing changed
                        break;
                    case BABYLON.Mesh.BACKSIDE:
                        var tmp;
                        // indices
                        for (i = 0; i < li; i += 3) {
                            tmp = indices[i];
                            indices[i] = indices[i + 2];
                            indices[i + 2] = tmp;
                        }
                        // normals
                        for (n = 0; n < ln; n++) {
                            normals[n] = -normals[n];
                        }
                        break;
                    case BABYLON.Mesh.DOUBLESIDE:
                        // positions
                        var lp = positions.length;
                        var l = lp / 3;
                        for (var p = 0; p < lp; p++) {
                            positions[lp + p] = positions[p];
                        }
                        // indices
                        for (i = 0; i < li; i += 3) {
                            indices[i + li] = indices[i + 2] + l;
                            indices[i + 1 + li] = indices[i + 1] + l;
                            indices[i + 2 + li] = indices[i] + l;
                        }
                        // normals
                        for (n = 0; n < ln; n++) {
                            normals[ln + n] = -normals[n];
                        }
                        // uvs
                        var lu = uvs.length;
                        for (var u = 0; u < lu; u++) {
                            uvs[u + lu] = uvs[u];
                        }
                        break;
                }
            };
            SurfaceViewer.prototype.computeOneNormalPerTriangle = function (positions, indices) {
                var res = [];
                var p1p2x = 0.0;
                var p1p2y = 0.0;
                var p1p2z = 0.0;
                var p3p2x = 0.0;
                var p3p2y = 0.0;
                var p3p2z = 0.0;
                var faceNormalx = 0.0;
                var faceNormaly = 0.0;
                var faceNormalz = 0.0;
                var length = 0.0;
                var i1 = 0;
                var i2 = 0;
                var i3 = 0;
                // indice triplet = 1 face
                var nbFaces = indices.length / 3;
                for (var index = 0; index < nbFaces; index++) {
                    i1 = indices[index * 3]; // get the indexes of each vertex of the face
                    i2 = indices[index * 3 + 1];
                    i3 = indices[index * 3 + 2];
                    p1p2x = positions[i1 * 3] - positions[i2 * 3]; // compute two vectors per face
                    p1p2y = positions[i1 * 3 + 1] - positions[i2 * 3 + 1];
                    p1p2z = positions[i1 * 3 + 2] - positions[i2 * 3 + 2];
                    p3p2x = positions[i3 * 3] - positions[i2 * 3];
                    p3p2y = positions[i3 * 3 + 1] - positions[i2 * 3 + 1];
                    p3p2z = positions[i3 * 3 + 2] - positions[i2 * 3 + 2];
                    faceNormalx = p1p2y * p3p2z - p1p2z * p3p2y; // compute the face normal with cross product
                    faceNormaly = p1p2z * p3p2x - p1p2x * p3p2z;
                    faceNormalz = p1p2x * p3p2y - p1p2y * p3p2x;
                    length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);
                    length = (length === 0) ? 1.0 : length;
                    faceNormalx /= length; // normalize this normal
                    faceNormaly /= length;
                    faceNormalz /= length;
                    res[index] = new mathis.XYZ(faceNormalx, faceNormaly, faceNormalz);
                }
                return res;
            };
            SurfaceViewer.prototype.computeVertexNormalFromTrianglesNormal = function (positions, indices, triangleNormals) {
                var _this = this;
                var positionNormals = [];
                //for (let i=0;i<lengthPosition;i++) res[i]=0
                for (var k = 0; k < positions.length / 3; k++)
                    positionNormals[k] = new mathis.XYZ(0, 0, 0);
                if (this.normalDuplication == NormalDuplication.none) {
                    for (var k = 0; k < indices.length; k += 3) {
                        var triangleIndex = Math.floor(k / 3);
                        positionNormals[indices[k]].add(triangleNormals[triangleIndex]);
                        positionNormals[indices[k + 1]].add(triangleNormals[triangleIndex]);
                        positionNormals[indices[k + 2]].add(triangleNormals[triangleIndex]);
                    }
                    positionNormals.forEach(function (v) {
                        v.normalize();
                    });
                }
                else if (this.normalDuplication == NormalDuplication.duplicateVertex || this.normalDuplication == NormalDuplication.duplicateOnlyWhenNormalsAreTooFarr) {
                    var oneStep = function (vertexNormal, triangleNormal, posX, posY, posZ, indexInIndices) {
                        if (_this.normalDuplication == NormalDuplication.duplicateOnlyWhenNormalsAreTooFarr) {
                            if (mathis.geo.xyzAlmostZero(vertexNormal) || mathis.geo.xyzAlmostZero(triangleNormal) || mathis.geo.angleBetweenTwoVectorsBetween0andPi(vertexNormal, triangleNormal) < _this.maxAngleBetweenNormals) {
                                vertexNormal.add(triangleNormal);
                            }
                            else {
                                var newIndex = positions.length / 3;
                                positions.push(posX, posY, posZ);
                                indices[indexInIndices] = newIndex;
                                positionNormals.push(triangleNormal);
                            }
                        }
                        else {
                            var newIndex = positions.length / 3;
                            positions.push(posX, posY, posZ);
                            indices[indexInIndices] = newIndex;
                            positionNormals.push(triangleNormal);
                        }
                    };
                    for (var k = 0; k < indices.length; k += 3) {
                        var triangleIndex = Math.floor(k / 3);
                        var positionIndex = indices[k];
                        oneStep(positionNormals[positionIndex], triangleNormals[triangleIndex], positions[3 * positionIndex], positions[3 * positionIndex + 1], positions[3 * positionIndex + 2], k);
                        positionIndex = indices[k + 1];
                        oneStep(positionNormals[positionIndex], triangleNormals[triangleIndex], positions[3 * positionIndex], positions[3 * positionIndex + 1], positions[3 * positionIndex + 2], k + 1);
                        positionIndex = indices[k + 2];
                        oneStep(positionNormals[positionIndex], triangleNormals[triangleIndex], positions[3 * positionIndex], positions[3 * positionIndex + 1], positions[3 * positionIndex + 2], k + 2);
                    }
                }
                else
                    throw 'wtf';
                var res = [];
                positionNormals.forEach(function (v) {
                    res.push(v.x, v.y, v.z);
                });
                return res;
            };
            return SurfaceViewer;
        }());
        visu3d.SurfaceViewer = SurfaceViewer;
        (function (NormalDuplication) {
            NormalDuplication[NormalDuplication["none"] = 0] = "none";
            NormalDuplication[NormalDuplication["duplicateOnlyWhenNormalsAreTooFarr"] = 1] = "duplicateOnlyWhenNormalsAreTooFarr";
            NormalDuplication[NormalDuplication["duplicateVertex"] = 2] = "duplicateVertex";
        })(visu3d.NormalDuplication || (visu3d.NormalDuplication = {}));
        var NormalDuplication = visu3d.NormalDuplication;
        var LinksViewer = (function () {
            function LinksViewer(mamesh, scene) {
                //lineRadius=0.05
                this.lateralScalingConstant = null;
                this.lateralScalingProp = 0.05;
                this.tesselation = 12;
                this.material = null;
                this.color = mathis.color.thema.defaultLinkColor;
                this.res = [];
                this.pairVertexToLateralDirection = null;
                /**if null (default) all segments will be drawn*/
                this.segmentOrientationFunction = null;
                this.clonesInsteadOfInstances = false;
                this.checkCollision = true;
                this.barycenter = null;
                this.middle = new mathis.XYZ(0, 0, 0);
                this.mamesh = mamesh;
                this.scene = scene;
            }
            LinksViewer.prototype.checkArgs = function () {
                if (this.scene == null)
                    throw 'scene is null';
                if (this.mamesh.vertices.length == 0)
                    cc('your IN_mamesh has no vertex');
            };
            LinksViewer.prototype.go = function () {
                this.checkArgs();
                //if (this.IN_mamesh.loopLines==null && this.IN_mamesh.straightLines==null) this.IN_mamesh.fillLineCatalogue()
                if (this.meshModel == null) {
                    if (this.material == null) {
                        this.material = new BABYLON.StandardMaterial('', this.scene);
                        this.material.diffuseColor = this.color.toBABYLON_Color3();
                    }
                    this.meshModel = BABYLON.Mesh.CreateCylinder('', 1, 1, 1, this.tesselation, 5, this.scene);
                    this.meshModel.material = this.material;
                }
                /**we hide the model*/
                this.meshModel.scaling = new mathis.XYZ(0, 0, 0);
                if (this.lateralScalingConstant == null) {
                    var distance = 0;
                    var nbVerticesWithLinks = 0;
                    for (var _i = 0, _a = this.mamesh.vertices; _i < _a.length; _i++) {
                        var v = _a[_i];
                        if (v.links.length != 0) {
                            var minDist = Number.MAX_VALUE;
                            for (var _b = 0, _c = v.links; _b < _c.length; _b++) {
                                var li = _c[_b];
                                var d = mathis.geo.distance(v.position, li.to.position);
                                if (d < minDist)
                                    minDist = d;
                            }
                            distance += minDist;
                            nbVerticesWithLinks++;
                        }
                    }
                    distance /= nbVerticesWithLinks;
                    this.lateralScalingConstant = distance * this.lateralScalingProp;
                }
                var alreadyDraw = new mathis.StringMap();
                for (var _d = 0, _e = this.mamesh.vertices; _d < _e.length; _d++) {
                    var vertex = _e[_d];
                    for (var _f = 0, _g = vertex.links; _f < _g.length; _f++) {
                        var link = _g[_f];
                        var key = mathis.tab.indicesUpPermutationToString([vertex.hashNumber, link.to.hashNumber]);
                        if (alreadyDraw.getValue(key) == null) {
                            this.drawOneLink(vertex, link.to);
                            alreadyDraw.putValue(key, true);
                        }
                    }
                }
                return this.res;
            };
            LinksViewer.prototype.drawOneLink = function (beginVertex, endVertex) {
                if (this.segmentOrientationFunction != null) {
                    if (this.segmentOrientationFunction(beginVertex, endVertex) == 0)
                        return;
                    if (this.segmentOrientationFunction(beginVertex, endVertex) < 0) {
                        var temp = beginVertex;
                        beginVertex = endVertex;
                        endVertex = temp;
                    }
                }
                var segment;
                if (this.clonesInsteadOfInstances)
                    segment = this.meshModel.clone('');
                else
                    segment = this.meshModel.createInstance('');
                segment.checkCollisions = this.checkCollision;
                var elongateAMeshFromBeginToEnd = new ElongateAMeshFromBeginToEnd(beginVertex.position, endVertex.position, segment);
                elongateAMeshFromBeginToEnd.lateralScaling = this.lateralScalingConstant;
                if (this.pairVertexToLateralDirection != null) {
                    elongateAMeshFromBeginToEnd.lateralDirection = this.pairVertexToLateralDirection(beginVertex, endVertex);
                }
                else {
                    if (this.barycenter == null) {
                        this.barycenter = new mathis.XYZ(0, 0, 0);
                        for (var _i = 0, _a = this.mamesh.vertices; _i < _a.length; _i++) {
                            var v = _a[_i];
                            this.barycenter.add(v.position);
                        }
                        this.barycenter.scale(1 / this.mamesh.vertices.length);
                    }
                    this.middle.copyFrom(beginVertex.position).add(endVertex.position).scale(0.5);
                    this.middle.substract(this.barycenter);
                    elongateAMeshFromBeginToEnd.lateralDirection.copyFrom(this.middle);
                }
                elongateAMeshFromBeginToEnd.goChanging();
                if (this.parentNode != null)
                    segment.parent = this.parentNode;
                this.res.push(segment);
            };
            return LinksViewer;
        }());
        visu3d.LinksViewer = LinksViewer;
        var LinesViewer = (function () {
            function LinesViewer(mamesh, scene) {
                this.doNotDrawLinesContainingOnlyInvisibleVertices = true;
                /**priority 1*/
                this.color = null;
                /**priority 2*/
                this.lineToColor = null;
                /**priority 3*/
                this.lineToLevel = null;
                this.levelPropToColorFunc = function (prop) { return new mathis.Color(new mathis.HSV_01(prop, 1, 0.8)); };
                this.cap = BABYLON.Mesh.NO_CAP;
                this.tesselation = 10;
                /**if null, no interpolation*/
                this.interpolationOption = new mathis.geometry.InterpolationOption();
                this.isThin = false;
                this.constantRadius = null;
                this.radiusProp = 0.05;
                this.radiusFunction = null;
                this.seedForRandomColor = 12345;
                this.res = [];
                this.mamesh = mamesh;
                this.scene = scene;
            }
            LinesViewer.prototype.go = function () {
                if (this.scene == null)
                    throw 'scene is null';
                /**very small rotation because of a bug of babylon : Some strictly vertical lines disappear
                 * TODO: complain*/
                new mathis.spacialTransformations.Similitude(this.mamesh.vertices, 0.0001).goChanging();
                if (!this.mamesh.linesWasMade)
                    this.mamesh.fillLineCatalogue();
                this.buildLineToColor();
                for (var _i = 0, _a = this.mamesh.lines; _i < _a.length; _i++) {
                    var line = _a[_i];
                    if (this.lineToColor.getValue(line) != null)
                        this.drawOneLine(line);
                }
                return this.res;
            };
            LinesViewer.prototype.buildLineToColor = function () {
                /**priority 1*/
                if (this.color != null) {
                    this.lineToColor = new mathis.HashMap();
                    for (var _i = 0, _a = this.mamesh.lines; _i < _a.length; _i++) {
                        var line = _a[_i];
                        this.lineToColor.putValue(line, this.color);
                    }
                    return;
                }
                /**priority 2*/
                if (this.lineToColor != null)
                    return;
                /**priority 3*/
                /**nothing is specified. The level is the index of the line*/
                if (this.lineToLevel == null) {
                    this.lineToLevel = new mathis.HashMap();
                    for (var i = 0; i < this.mamesh.lines.length; i++)
                        this.lineToLevel.putValue(this.mamesh.lines[i], i);
                }
                /**from level to color*/
                var max = mathis.tab.maxValue(this.lineToLevel.allValues());
                var min = mathis.tab.minValue(this.lineToLevel.allValues());
                this.lineToColor = new mathis.HashMap();
                for (var _b = 0, _c = this.mamesh.lines; _b < _c.length; _b++) {
                    var line = _c[_b];
                    var value = this.lineToLevel.getValue(line);
                    if (value != null) {
                        var prop = (value - min) / (max - min);
                        this.lineToColor.putValue(line, this.levelPropToColorFunc(prop));
                    }
                    else
                        this.lineToColor.putValue(line, null);
                }
            };
            LinesViewer.prototype.drawOneLine = function (line) {
                var path = [];
                var onlyInvisible = true;
                line.vertices.forEach(function (v) {
                    path.push(v.position);
                    if (!v.isInvisible)
                        onlyInvisible = false;
                });
                if (onlyInvisible && this.doNotDrawLinesContainingOnlyInvisibleVertices)
                    return;
                var mesh = this.drawOnePath(line, path);
                this.res.push(mesh);
            };
            LinesViewer.prototype.drawOnePath = function (line, path) {
                var _this = this;
                var res;
                var smoothPath;
                if (this.interpolationOption != null && this.interpolationOption.interpolationStyle != mathis.geometry.InterpolationStyle.none) {
                    var lineInterpoler = new mathis.geometry.LineInterpoler(path);
                    lineInterpoler.options = this.interpolationOption;
                    if (line.isLoop)
                        lineInterpoler.options.loopLine = true;
                    smoothPath = lineInterpoler.go();
                }
                else {
                    smoothPath = path;
                    if (line.isLoop)
                        smoothPath.push(path[0]);
                }
                path = smoothPath;
                var color = this.lineToColor.getValue(line).toBABYLON_Color3();
                if (this.isThin) {
                    var aa = BABYLON.Mesh.CreateLines('', path, this.scene);
                    aa.color = color;
                    res = aa;
                }
                else {
                    var modifiedFunction = null;
                    if (this.radiusFunction != null) {
                        var pathTotalLength_1 = 0;
                        for (var i = 0; i < path.length - 1; i++) {
                            pathTotalLength_1 += mathis.geo.distance(path[i], path[i + 1]);
                        }
                        modifiedFunction = function (ind, alphaProp) { return _this.radiusFunction(ind, alphaProp / pathTotalLength_1); };
                        res = BABYLON.Mesh.CreateTube('', path, null, this.tesselation, modifiedFunction, this.cap, this.scene, true, BABYLON.Mesh.FRONTSIDE);
                    }
                    else {
                        if (this.constantRadius == null) {
                            var distance = 0;
                            var nbVerticesWithLinks = 0;
                            for (var _i = 0, _a = this.mamesh.vertices; _i < _a.length; _i++) {
                                var v = _a[_i];
                                nbVerticesWithLinks++;
                                if (v.links.length != 0) {
                                    var minDist = Number.MAX_VALUE;
                                    for (var _b = 0, _c = v.links; _b < _c.length; _b++) {
                                        var li = _c[_b];
                                        var d = mathis.geo.distance(v.position, li.to.position);
                                        if (d < minDist)
                                            minDist = d;
                                    }
                                    distance += minDist;
                                }
                            }
                            distance /= nbVerticesWithLinks;
                            this.constantRadius = distance * this.radiusProp;
                        }
                        res = BABYLON.Mesh.CreateTube('', path, this.constantRadius, this.tesselation, null, this.cap, this.scene, true, BABYLON.Mesh.FRONTSIDE);
                    }
                }
                var material = new BABYLON.StandardMaterial('', this.scene);
                material.diffuseColor = color;
                res.material = material;
                if (this.parentNode != null)
                    res.parent = this.parentNode;
                return res;
            };
            /**TODO transfert to the line filler*/
            LinesViewer.directionnalLineSelector = function (nbExceptionAllowed, direction) {
                return function (index, line) {
                    var referenceParam = line[0].param;
                    var exceptionCount = 0;
                    cc('new line');
                    for (var _i = 0, line_1 = line; _i < line_1.length; _i++) {
                        var vertex = line_1[_i];
                        if (vertex.param == null)
                            throw 'no param, we can not see vertical lines';
                        var a = void 0, b = -1;
                        if (direction == mathis.Direction.vertical) {
                            a = vertex.param.x;
                            b = referenceParam.x;
                        }
                        else if (direction == mathis.Direction.horizontal) {
                            a = vertex.param.y;
                            b = referenceParam.y;
                        }
                        else
                            throw 'not yet done';
                        cc(referenceParam, vertex.param);
                        if (!mathis.geo.almostEquality(a, b)) {
                            exceptionCount++;
                            referenceParam = vertex.param;
                        }
                        if (exceptionCount > nbExceptionAllowed) {
                            cc('false');
                            return false;
                        }
                    }
                    return (exceptionCount <= nbExceptionAllowed);
                };
            };
            return LinesViewer;
        }());
        visu3d.LinesViewer = LinesViewer;
        //
        // class OneLineVisuMaker {
        //
        //     private path:XYZ[]
        //    
        //     isLoop:boolean
        //     babMesh:BABYLON.Mesh
        //     parentNode:BABYLON.Node
        //    
        //     constructor(path:XYZ[],isLoop:boolean,scene:BABYLON.Scene){
        //        
        //         this.scene=scene
        //         this.path=path
        //         this.isLoop=isLoop
        //        
        //     }
        //
        //    
        //
        //
        //
        // }
        var ElongateAMeshFromBeginToEnd = (function () {
            function ElongateAMeshFromBeginToEnd(begin, end, originalMesh) {
                this.lateralScaling = 0.05;
                /**if the orignal is a round-cylinder, this do not change nothing*/
                this.lateralDirection = new mathis.XYZ(0, 0, 1);
                this.yAxis = new mathis.XYZ(0, 1, 0);
                this.zAxis = new mathis.XYZ(0, 0, 1);
                this.direction = new mathis.XYZ(0, 0, 0);
                this.nothing = new mathis.XYZ(0, 0, 0);
                this.begin = begin;
                this.end = end;
                this.modelMesh = originalMesh;
            }
            ElongateAMeshFromBeginToEnd.prototype.goChanging = function () {
                this.direction.copyFrom(this.end).substract(this.begin);
                var length = this.direction.length();
                this.direction.normalize();
                var middle = new mathis.XYZ(0, 0, 0);
                middle.add(this.begin).add(this.end).scale(0.5);
                this.modelMesh.scaling = new mathis.XYZ(this.lateralScaling, length, this.lateralScaling);
                this.modelMesh.position = middle;
                var anOrtho = new mathis.XYZ(0, 0, 0);
                var copyOfLateralDirection = new mathis.XYZ(0, 0, 0);
                mathis.geo.cross(this.direction, this.lateralDirection, this.nothing);
                if (this.nothing.lengthSquared() < mathis.geo.epsilon)
                    copyOfLateralDirection.copyFromFloats(Math.random(), Math.random(), Math.random());
                else
                    copyOfLateralDirection.copyFrom(this.lateralDirection);
                mathis.geo.orthonormalizeKeepingFirstDirection(this.direction, copyOfLateralDirection, this.nothing, anOrtho);
                var quat = new mathis.XYZW(0, 0, 0, 0);
                mathis.geo.aQuaternionMovingABtoCD(this.yAxis, this.zAxis, this.direction, anOrtho, quat, true);
                this.modelMesh.rotationQuaternion = quat;
                return this.modelMesh;
            };
            return ElongateAMeshFromBeginToEnd;
        }());
        visu3d.ElongateAMeshFromBeginToEnd = ElongateAMeshFromBeginToEnd;
    })(visu3d = mathis.visu3d || (mathis.visu3d = {}));
})(mathis || (mathis = {}));
/**
 * Created by vigon on 08/12/2015.
 */
/**for dev only*/
var cc;
var showDevMessages = true;
if (showDevMessages) {
    cc = console.log.bind(window.console);
}
else
    cc = function () { };
var mathis;
(function (mathis) {
    /**some object are created from the very begining*/
    mathis.geo = new mathis.Geo();
    mathis.logger = new mathis.Logger();
})(mathis || (mathis = {}));
/**
 * Created by vigon on 08/11/2016.
 */
var mathis;
(function (mathis) {
    var differentialSystem;
    (function (differentialSystem) {
        var TwoDim = (function () {
            function TwoDim(vectorField, mathisFrame) {
                this.originMath = new mathis.XYZ(0, 0, 0);
                this.endMath = new mathis.XYZ(1, 1, 0);
                this.originView = new mathis.XYZ(-1, -1, 0);
                this.endView = new mathis.XYZ(1, 1, 0);
                this.nbI = 20;
                this.nbJ = 20;
                this.departure = new mathis.XYZ(0, 0, 0);
                this.deltaT = 0.1;
                this.vectorsAreArrowsVersusCone = true;
                this.scaleVectorsAccordingToTheirNorm = false;
                this.makeLightAndCamera = true;
                this.generator = new mathis.reseau.BasisForRegularReseau();
                this.stochasticVariation = new mathis.XYZ(0, 0, 0);
                this.dW = new mathis.XYZ(0, 0, 0);
                this.scaler = null;
                this.functionToSortvertex = function (v1, v2) { return v1.customerObject.squareLengthOfTangent - v2.customerObject.squareLengthOfTangent; };
                this.vectorField = vectorField;
                this.mathisFrame = mathisFrame;
            }
            TwoDim.prototype.go = function () {
                if (this.randomExitation == null)
                    this.randomExitation = function () { return new mathis.XYZ(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5); };
                this.generator.nbI = this.nbI;
                this.generator.nbJ = this.nbJ;
                this.generator.origin = this.originView;
                this.generator.end = this.endView;
                this.makePlanForClick();
                if (this.makeLightAndCamera)
                    this.lightAndCamera();
                this.arrowModel = this.createArrowModel();
                this.scaler = mathis.geo.affineTransformGenerator(this.originView, this.endView, this.originMath, this.endMath);
                /**can be fired at any moment when we want to change vector fields*/
                this.loadVectorFields();
                this.mameshAndPositioning();
                if (this.scaleVectorsAccordingToTheirNorm)
                    this.prepareRescaling();
                this.start();
            };
            // restartWithNewVectorField(vectorField:(t:number, p:XYZ,res:XYZ)=>void){
            //     this.vectorField=vectorField
            //     this.mameshAndPositioning()
            //     this.start()
            // }
            TwoDim.prototype.makePlanForClick = function () {
                this.planForClick = BABYLON.Mesh.CreatePlane('', 1, this.mathisFrame.scene);
                var amplitude = mathis.XYZ.newFrom(this.generator.end).substract(this.generator.origin);
                var middle = mathis.XYZ.newFrom(this.generator.origin).add(this.generator.end).scale(0.5);
                this.planForClick.scaling = new mathis.XYZ(amplitude.x, amplitude.y, 0);
                /**doit tre derriere le grabber, sinon il masque ce dernier
                 * doit tre devant les flches*/
                this.planForClick.position = new mathis.XYZ(middle.x, middle.y, 0.06);
                this.planForClick.bakeCurrentTransformIntoVertices();
                this.planForClick.visibility = 0;
            };
            TwoDim.prototype.lightAndCamera = function () {
                var amplitude = mathis.XYZ.newFrom(this.generator.end).substract(this.generator.origin);
                var grabber = new mathis.macamera.PlanarGrabber(this.mathisFrame.scene, new mathis.XYZ(amplitude.x, amplitude.y, 0.061));
                grabber.mesh.visibility = 0;
                var macam = new mathis.macamera.GrabberCamera(this.mathisFrame, grabber);
                macam.checkCollisions = false;
                macam.useFreeModeWhenCursorOutOfGrabber = false;
                macam.changePosition(new mathis.XYZ(0, 0, -2), false);
                macam.attachControl(this.mathisFrame.canvas);
                //let bacam=new BABYLON.FreeCamera("",new BABYLON.Vector3(0,0,-2),this.mathisFrame.scene)
                //bacam.attachControl(this.mathisFrame.canvas)
                var light0 = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(-1, 1, -1), this.mathisFrame.scene);
                light0.diffuse = new BABYLON.Color3(0.5, 0.5, 0.5);
                light0.specular = new BABYLON.Color3(0.7, 0.7, 0.7);
                light0.groundColor = new BABYLON.Color3(1, 1, 1);
            };
            TwoDim.prototype.computeNewPathPoint = function (previousPoint, t, res) {
                this.vectorFieldScaled(t, previousPoint, res);
                res.scale(this.deltaT);
                if (this.vectorFieldForNoiseScaled != null) {
                    this.vectorFieldForNoiseScaled(t, previousPoint, this.stochasticVariation);
                    //this.dW.copyFromFloats(gaussian.goChanging(),gaussian.goChanging(),gaussian.goChanging())
                    this.stochasticVariation.multiply(this.randomExitation()).scale(Math.sqrt(this.deltaT));
                    res.add(this.stochasticVariation);
                }
                res.add(previousPoint);
            };
            TwoDim.prototype.mameshAndPositioning = function () {
                var regCrea = new mathis.reseau.Regular(this.generator);
                regCrea.squareVersusTriangleMaille = false;
                this.mamesh = regCrea.go();
                var posiComp = new mathis.mameshAroundComputations.PositioningComputerForMameshVertices(this.mamesh);
                /**tangents are given by the vector field*/
                posiComp.computeTangent = false;
                posiComp.sizesProp = new mathis.XYZ(0.15, 0.15, 0.15);
                this.positionings = posiComp.go();
                this.vectorReferencesize = this.positionings.getValue(this.mamesh.vertices[0]).scaling.x;
            };
            TwoDim.prototype.createArrowModel = function () {
                var arrowModel;
                var qua = new mathis.XYZW(0, 0, 0, 0);
                mathis.geo.axisAngleToQuaternion(new mathis.XYZ(0, 0, 1), -Math.PI / 2, qua);
                if (this.vectorsAreArrowsVersusCone) {
                    var arrowCreator = new mathis.creation3D.ArrowCreator(this.mathisFrame.scene);
                    arrowCreator.quaternion = qua;
                    arrowCreator.arrowFootAtOrigin = false;
                    arrowCreator.totalHeight = 3;
                    arrowCreator.bodyDiameterProp = 0.2;
                    arrowCreator.headDiameterProp = 0.4;
                    arrowModel = arrowCreator.go();
                }
                else {
                    arrowModel = BABYLON.Mesh.CreateCylinder('', 2, 0, 1, 6, null, this.mathisFrame.scene);
                    arrowModel.rotationQuaternion = qua;
                    arrowModel.bakeCurrentTransformIntoVertices();
                }
                var mat = new BABYLON.StandardMaterial('', this.mathisFrame.scene);
                mat.diffuseColor = new BABYLON.Color3(0, 0, 1);
                arrowModel.material = mat;
                return arrowModel;
            };
            TwoDim.prototype.loadVectorFields = function () {
                var _this = this;
                var pScaled = new mathis.XYZ(0, 0, 0);
                /**  p is a point of the view rectangle, we have to scale it into the math rectangle before the find the corresponding vector */
                this.vectorFieldScaled = function (t, p, res) {
                    _this.scaler(p, pScaled);
                    _this.vectorField(t, pScaled, res);
                };
                if (this.vectorFieldForNoise != null) {
                    var p2Scaled_1 = new mathis.XYZ(0, 0, 0);
                    this.vectorFieldForNoiseScaled = function (t, p, res) {
                        _this.scaler(p, p2Scaled_1);
                        _this.vectorFieldForNoise(t, p2Scaled_1, res);
                    };
                }
            };
            TwoDim.prototype.start = function () {
                var _this = this;
                var snake = new mathis.creation3D.Snake(this.mathisFrame);
                snake.initialPosition = this.departure;
                snake.serpentRadius = 0.01;
                snake.go();
                /**field init*/
                this.mamesh.vertices.forEach(function (v) {
                    _this.vectorFieldScaled(0, v.position, _this.positionings.getValue(v).frontDir);
                });
                var vertexVisu = new mathis.visu3d.VerticesViewer(this.mamesh, this.mathisFrame.scene, this.positionings);
                vertexVisu.meshModel = this.arrowModel;
                vertexVisu.go();
                var curentTime = 0;
                var mainAction = new mathis.PeriodicAction(function () {
                    curentTime += _this.deltaT;
                    var point = new mathis.XYZ(0, 0, 0);
                    _this.computeNewPathPoint(snake.getHeadPosition(), curentTime, point);
                    snake.elongateTo(point);
                    _this.mamesh.vertices.forEach(function (v) {
                        var pos = _this.positionings.getValue(v);
                        _this.vectorFieldScaled(curentTime, v.position, pos.frontDir);
                    });
                    if (_this.scaleVectorsAccordingToTheirNorm)
                        _this.rescaleVectors(_this.vectorReferencesize);
                    vertexVisu.updatePositionings();
                });
                mainAction.id = "main action";
                mainAction.frameInterval = 1;
                this.mathisFrame.pushPeriodicAction(mainAction);
                /**onClick, we restart the snake*/
                this.planForClick.onClick = function (dep) {
                    var action = new mathis.PeriodicAction(function () {
                        snake.contractInOnePoint(dep);
                    });
                    action.frameInterval = 1;
                    action.nbTimesThisActionMustBeFired = 1;
                    action.id = "click action";
                    action.passageOrderIndex = 2;
                    _this.mathisFrame.pushPeriodicAction(action);
                };
            };
            TwoDim.prototype.prepareRescaling = function () {
                var _this = this;
                this.verticeSorted = [];
                this.mamesh.vertices.forEach(function (v) { return _this.verticeSorted.push(v); });
            };
            TwoDim.prototype.rescaleVectors = function (vertexRefSize) {
                var _this = this;
                this.mamesh.vertices.forEach(function (v) {
                    v.customerObject.squareLengthOfTangent = _this.positionings.getValue(v).frontDir.lengthSquared();
                });
                this.verticeSorted.sort(this.functionToSortvertex);
                for (var i = 0; i < this.verticeSorted.length; i++)
                    this.verticeSorted[i].customerObject.scaleFromOrder = (i / this.verticeSorted.length);
                this.mamesh.vertices.forEach(function (v) {
                    var pos = _this.positionings.getValue(v);
                    pos.scaling.x = 2 * vertexRefSize * (v.customerObject.scaleFromOrder + 1 / 4);
                    var epaisseur = vertexRefSize * Math.max(1, v.customerObject.scaleFromOrder + 1 / 2);
                    pos.scaling.y = epaisseur;
                    pos.scaling.z = epaisseur;
                });
            };
            return TwoDim;
        }());
        differentialSystem.TwoDim = TwoDim;
    })(differentialSystem = mathis.differentialSystem || (mathis.differentialSystem = {}));
})(mathis || (mathis = {}));
/**
 * Created by vigon on 07/11/2016.
 */
var mathis;
(function (mathis) {
    var infiniteWorlds;
    (function (infiniteWorlds) {
        (function (NameOfReseau3D) {
            NameOfReseau3D[NameOfReseau3D["cube"] = 0] = "cube";
            NameOfReseau3D[NameOfReseau3D["hexagone"] = 1] = "hexagone";
            NameOfReseau3D[NameOfReseau3D["doubleHexagone"] = 2] = "doubleHexagone";
        })(infiniteWorlds.NameOfReseau3D || (infiniteWorlds.NameOfReseau3D = {}));
        var NameOfReseau3D = infiniteWorlds.NameOfReseau3D;
        var InfiniteCartesian = (function () {
            function InfiniteCartesian(mathisFrame) {
                /**reseau characterization*/
                this.nameOfResau3d = NameOfReseau3D.cube;
                this.nbVerticalDecays = 0;
                this.nbHorizontalDecays = 0;
                this.fondamentalDomainSize = 9;
                this.nbSubdivision = 3;
                this.nbRepetition = 8;
                /**bien rgler ce paramtre pour que l'on ne voit pas le bout du monde.
                 *  fondamentalDomainSize petit &&  nbRepetition petit => fogDensity grand */
                this.fogDensity = 0.05;
                this.drawFondamentalDomain = false;
                /**when creating the world, to see it from outside, put the  next fields to false */
                this.recenterCamera = true;
                this.notDrawMeshesAtFarCorners = true;
                //addFog=true
                this.population = [];
                this.collisionOnLinks = false;
                this.collisionOnVertices = false;
                this.collisionForCamera = false;
                /**if null, no links*/
                this.nbSidesOfLinks = 4;
                this.pathFromHtmlToAssets = '../../assets/';
                this.buildLightCameraSkyboxAndFog = true;
                this.mathisFrame = mathisFrame;
            }
            InfiniteCartesian.prototype.go = function () {
                if (this.buildLightCameraSkyboxAndFog)
                    this.cameraLight();
                this.creationOfReseau();
                var wallDiffuseTexture = new BABYLON.Texture(this.pathFromHtmlToAssets + 'texture/escher.jpg', this.mathisFrame.scene);
                this.vertexVisualization(this.mamesh, wallDiffuseTexture);
                this.linksVisualization(this.mamesh, wallDiffuseTexture);
                this.addAndMultiplyPopulation();
                if (this.buildLightCameraSkyboxAndFog) {
                    this.seeWorldFromInside();
                    this.fogAndSkybox();
                }
            };
            InfiniteCartesian.prototype.addAndMultiplyPopulation = function () {
                var maxDist = (this.notDrawMeshesAtFarCorners) ? this.getTotalSize() * 0.6 : this.getTotalSize();
                var multiply = new mathis.periodicWorld.Multiply(this.fd, maxDist, this.nbRepetition);
                for (var _i = 0, _a = this.population; _i < _a.length; _i++) {
                    var mesh = _a[_i];
                    multiply.addAbstractMesh(mesh);
                }
            };
            InfiniteCartesian.prototype.seeWorldFromOutside = function () {
                //this.nbRepetition=nbRepetition
                var totalSize = this.getTotalSize();
                this.getCamera().changePosition(new mathis.XYZ(0, 0, -totalSize * 2), false);
                this.getCamera().changeFrontDir(new mathis.XYZ(0, 0, 1), false);
                //TODO cela bug si je fais cela : this.cam.changeUpVector(new XYZ(0,1,0))
                this.recenterCamera = false;
                this.getGrabber().mesh.visibility = 1;
                this.getCamera().useOnlyFreeMode = false;
                this.mathisFrame.scene.fogMode = BABYLON.Scene.FOGMODE_NONE;
                //if (this.addFog&&suppressFog) this.toggleFogAndSkyBox(false)
            };
            InfiniteCartesian.prototype.seeWorldFromInside = function () {
                this.recenterCamera = true;
                //this.addFog=true
                this.getCamera().changePosition(new mathis.XYZ(0, 0, 0), false);
                this.getCamera().changeFrontDir(new mathis.XYZ(-0.5, -0.5, -1), false);
                this.getGrabber().mesh.visibility = 0;
                this.getCamera().useOnlyFreeMode = true;
                this.mathisFrame.scene.fogMode = BABYLON.Scene.FOGMODE_EXP2;
                //if(this.addFog) this.toggleFogAndSkyBox(true)
            };
            //cam:macamera.GrabberCamera
            //grabber0:macamera.SphericalGrabber
            InfiniteCartesian.prototype.getCamera = function () {
                return this.mathisFrame.scene.activeCamera;
            };
            InfiniteCartesian.prototype.getGrabber = function () {
                return this.getCamera().currentGrabber;
            };
            InfiniteCartesian.prototype.cameraLight = function () {
                var _this = this;
                var grabberRadius = this.getTotalSize() * 0.6;
                var grabber0 = new mathis.macamera.SphericalGrabber(this.mathisFrame.scene, new mathis.XYZ(grabberRadius, grabberRadius, grabberRadius));
                grabber0.focusOnMyCenterWhenCameraGoDownWard = false;
                grabber0.mesh.visibility = 0; //TODO faire un grabber sans forcement de mesh
                //this.mathisFrame.camera=this.cam
                var camera = new mathis.macamera.GrabberCamera(this.mathisFrame, grabber0);
                camera.translationSpeed = this.fondamentalDomainSize * 0.5;
                camera.checkCollisions = this.collisionForCamera;
                //cam.useOnlyFreeMode=true
                //this.cam.changePosition(this.cameraInitialPosition)
                //this.cam.changeFrontDir(this.cameraFrontDir)//new XYZ(-0.5,-1,1.5)
                camera.keysFrontward = [66, 78];
                camera.keysBackward = [32];
                camera.attachControl(this.mathisFrame.canvas);
                this.mathisFrame.scene.activeCamera = camera;
                // Ajout d'une lumire
                var light0 = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(-1, 1, -1), this.mathisFrame.scene);
                light0.diffuse = new BABYLON.Color3(1, 1, 1);
                light0.specular = new BABYLON.Color3(0., 0., 0.);
                light0.groundColor = new BABYLON.Color3(0, 0, 0.3);
                var camPosInWebCoor = new mathis.XYZ(0, 0, 0);
                var camDomain = new mathis.periodicWorld.Domain(0, 0, 0);
                var camDomainCenter = new mathis.XYZ(0, 0, 0);
                this.fd = new mathis.periodicWorld.CartesianFundamentalDomain(new mathis.XYZ(this.fondamentalDomainSize, 0, 0), new mathis.XYZ(0, this.fondamentalDomainSize, 0), new mathis.XYZ(0, 0, this.fondamentalDomainSize));
                if (this.drawFondamentalDomain) {
                    this.fd.drawMe(this.mathisFrame.scene);
                    this.fd.getArretes(this.mathisFrame.scene);
                }
                camera.onTranslate = function () {
                    if (_this.recenterCamera) {
                        _this.fd.pointToWebCoordinate(camera.trueCamPos.position, camPosInWebCoor);
                        camDomain.whichContains(camPosInWebCoor);
                        camDomain.getCenter(_this.fd, camDomainCenter);
                        /**attention, il faut changer simultanment la truePosition et la wished position. Donc mettre le smoothing  false*/
                        camera.changePosition(camera.whishedCamPos.getPosition().substract(camDomainCenter), false);
                    }
                };
            };
            InfiniteCartesian.prototype.creationOfReseau = function () {
                var basis = new mathis.reseau.BasisForRegularReseau();
                basis.end = new mathis.XYZ(this.fondamentalDomainSize, this.fondamentalDomainSize, 0);
                basis.nbI = this.nbSubdivision;
                basis.nbJ = this.nbSubdivision;
                basis.origin = new mathis.XYZ(0, 0, 0);
                basis.nbVerticalDecays = this.nbVerticalDecays;
                basis.nbHorizontalDecays = this.nbHorizontalDecays;
                var VV = basis.go();
                var crea = new mathis.reseau.Regular3D();
                crea.nbI = this.nbSubdivision * this.nbRepetition;
                crea.nbJ = this.nbSubdivision * this.nbRepetition;
                crea.nbK = this.nbSubdivision * this.nbRepetition;
                crea.Vi = VV.Vi;
                crea.Vj = VV.Vj;
                crea.Vk = new mathis.XYZ(0, 0, this.fondamentalDomainSize / (this.nbSubdivision - 1));
                crea.makeTriangleOrSquare = false;
                crea.createIKSquaresOrTriangles = false;
                crea.createJKSquares = false;
                if (this.nameOfResau3d == NameOfReseau3D.hexagone || this.nameOfResau3d == NameOfReseau3D.doubleHexagone) {
                    crea.strateHaveSquareMailleVersusTriangleMaille = false;
                }
                if (this.nameOfResau3d == NameOfReseau3D.doubleHexagone) {
                    crea.interStrateMailleAreSquareVersusTriangle = false;
                    crea.decayOddStrates = true;
                }
                //let totalSize=this.nbSubdivision*this.nbRepetition*VV.Vi.length()
                var totalSize = this.getTotalSize();
                crea.origine = new mathis.XYZ(-totalSize / 2, -totalSize / 2, -totalSize / 2);
                if (this.notDrawMeshesAtFarCorners)
                    crea.putAVertexOnlyAtXYZCheckingThisCondition = function (xyz) { return xyz.length() < (totalSize * 0.6); };
                this.mamesh = crea.go();
                this.mamesh.fillLineCatalogue();
            };
            InfiniteCartesian.prototype.getTotalSize = function () {
                return this.nbRepetition * this.fondamentalDomainSize;
            };
            InfiniteCartesian.prototype.vertexVisualization = function (mamesh2, wallDiffuseTexture) {
                var model = BABYLON.Mesh.CreateBox('', 0.5, this.mathisFrame.scene);
                var material = new BABYLON.StandardMaterial('', this.mathisFrame.scene);
                material.diffuseTexture = wallDiffuseTexture;
                model.material = material;
                model.convertToFlatShadedMesh();
                var verticesVisuMaker = new mathis.visu3d.VerticesViewer(mamesh2, this.mathisFrame.scene);
                verticesVisuMaker.meshModel = model;
                verticesVisuMaker.checkCollision = this.collisionOnVertices;
                var positioning = new mathis.Positioning();
                positioning.upVector = new mathis.XYZ(1, 0, 0);
                positioning.frontDir = new mathis.XYZ(0, 1, 0);
                verticesVisuMaker.positionings = new mathis.HashMap();
                for (var _i = 0, _a = mamesh2.vertices; _i < _a.length; _i++) {
                    var v = _a[_i];
                    verticesVisuMaker.positionings.putValue(v, positioning);
                }
                verticesVisuMaker.go();
            };
            InfiniteCartesian.prototype.linksVisualization = function (ma, wallDiffuseTexture) {
                var model;
                if (this.nbSidesOfLinks == 4)
                    model = BABYLON.Mesh.CreateBox('', 1, this.mathisFrame.scene);
                else
                    model = BABYLON.Mesh.CreateCylinder('', 1, 1, 1, this.nbSidesOfLinks, null, this.mathisFrame.scene);
                var material = new BABYLON.StandardMaterial('', this.mathisFrame.scene);
                material.diffuseColor = new BABYLON.Color3(0.6, 0.6, 0.6);
                material.diffuseTexture = wallDiffuseTexture;
                model.material = material;
                model.convertToFlatShadedMesh();
                var linksViewer = new mathis.visu3d.LinksViewer(ma, this.mathisFrame.scene);
                linksViewer.lateralScalingConstant = 0.2;
                /**collision sur les poutres pas terrible*/
                linksViewer.checkCollision = this.collisionOnLinks;
                linksViewer.meshModel = model;
                var vec100 = new mathis.XYZ(1, 0, 0);
                var vec010 = new mathis.XYZ(0, 1, 0);
                linksViewer.pairVertexToLateralDirection = function (v1, v2) {
                    if (Math.abs(mathis.geo.dot(mathis.XYZ.newFrom(v1.position).substract(v2.position), vec100)) < 0.0001)
                        return vec100;
                    else
                        return vec010;
                };
                linksViewer.go();
            };
            InfiniteCartesian.prototype.fogAndSkybox = function () {
                var skybox = BABYLON.Mesh.CreateBox("skyBox", 50. * this.fondamentalDomainSize, this.mathisFrame.scene);
                this.mathisFrame.skybox = skybox;
                //skybox.checkCollisions=true
                skybox.visibility = 1;
                /**je ne comprend pas pourquoi le brouillar ne parche pas quand on ne met pas de sky box...*/
                var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", this.mathisFrame.scene);
                skyboxMaterial.backFaceCulling = false;
                skybox.material = skyboxMaterial;
                skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
                skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
                skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture(this.pathFromHtmlToAssets + "skybox/skybox", this.mathisFrame.scene, ['_px.jpg', '_py.jpg', '_pz.jpg', '_nx.jpg', '_ny.jpg', '_nz.jpg']);
                skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
                //this.mathisFrame.scene.fogMode = BABYLON.Scene.FOGMODE_EXP2;
                this.mathisFrame.scene.fogDensity = this.fogDensity; //this.fondamentalDomainSize;
                this.mathisFrame.scene.fogColor = new BABYLON.Color3(1, 1, 1);
            };
            return InfiniteCartesian;
        }());
        infiniteWorlds.InfiniteCartesian = InfiniteCartesian;
    })(infiniteWorlds = mathis.infiniteWorlds || (mathis.infiniteWorlds = {}));
})(mathis || (mathis = {}));
/**
 * Created by vigon on 08/11/2016.
 */
var mathis;
(function (mathis) {
    var mecaStat;
    (function (mecaStat) {
        var IsingOnMesh = (function () {
            function IsingOnMesh(mathisFrame) {
                this.q = 1.1;
                this.beta = 0.5;
                this.sphereRadius = 1;
                this.frameInterval = 5;
                this.nbActionsPerIteration = 100;
                this.defineLightAndCamera = true;
                this.nbDicho = 4;
                this.mathisFrame = mathisFrame;
            }
            IsingOnMesh.prototype.go = function () {
                if (this.defineLightAndCamera)
                    this.lightAndCam();
                this.meshAndIsing();
            };
            IsingOnMesh.prototype.lightAndCam = function () {
                var light0 = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(-1, 1, -1), this.mathisFrame.scene);
                light0.diffuse = new BABYLON.Color3(1, 1, 1);
                light0.specular = new BABYLON.Color3(1, 1, 1);
                light0.groundColor = new BABYLON.Color3(0.5, 0.5, 0.5);
                var center = new mathis.XYZ(0, 0, 0);
                //BABYLON.Mesh.CreateSphere('',20,2,scene)
                var grabber = new mathis.macamera.SphericalGrabber(this.mathisFrame.scene, new mathis.XYZ(this.sphereRadius, this.sphereRadius, this.sphereRadius), center);
                grabber.mesh.material.alpha = 0.6;
                grabber.showGrabberOnlyWhenGrabbing = false;
                grabber.endOfZone1 = 0;
                grabber.endOfZone2 = 0;
                var macam = new mathis.macamera.GrabberCamera(this.mathisFrame, grabber);
                macam.useFreeModeWhenCursorOutOfGrabber = false;
                macam.changePosition(new mathis.XYZ(0, 0, -4 * this.sphereRadius), false);
                //macam.camera.viewport=new BABYLON.Viewport(index/nbCam,0,1/nbCam,1)
                macam.attachControl(this.mathisFrame.canvas);
                //mathisFrame.scene.activeCameras.push(macam.camera)
            };
            IsingOnMesh.prototype.meshAndIsing = function () {
                var _this = this;
                var sphereMaker = new mathis.creation3D.Polyhedron(mathis.creation3D.PolyhedronType.Dodecahedron);
                var mamesh = sphereMaker.go();
                for (var i = 0; i < this.nbDicho; i++) {
                    var dicho = new mathis.mameshModification.TriangleDichotomer(mamesh);
                    dicho.makeLinks = true;
                    dicho.go();
                }
                mamesh.vertices.forEach(function (v) {
                    v.position.normalize().scale(_this.sphereRadius);
                });
                var ising = new mathis.metropolis.IsingModel(mamesh.vertices);
                ising.beta = this.beta;
                ising.q = this.q;
                ising.nbActionsPerIteration = this.nbActionsPerIteration;
                ising.go();
                var model1 = this.sphereModel(new BABYLON.Color3(1, 0, 0));
                var model2 = this.sphereModel(new BABYLON.Color3(0, 0, 1));
                var positionner = new mathis.mameshAroundComputations.PositioningComputerForMameshVertices(mamesh);
                positionner.sizesProp = new mathis.XYZ(1, 1, 1);
                var positioning = positionner.go();
                var positioning1 = new mathis.HashMap();
                mamesh.vertices.forEach(function (v) {
                    var po = new mathis.Positioning();
                    po.copyFrom(positioning.getValue(v));
                    po.scaling.copyFromFloats(0, 0, 0);
                    positioning1.putValue(v, po);
                });
                var positioning2 = new mathis.HashMap();
                mamesh.vertices.forEach(function (v) {
                    var po = new mathis.Positioning();
                    po.copyFrom(positioning.getValue(v));
                    po.scaling.copyFromFloats(0, 0, 0);
                    positioning2.putValue(v, po);
                });
                var vertVisu1 = new mathis.visu3d.VerticesViewer(mamesh, this.mathisFrame.scene);
                vertVisu1.positionings = positioning1;
                vertVisu1.meshModel = model1;
                vertVisu1.go();
                var vertVisu2 = new mathis.visu3d.VerticesViewer(mamesh, this.mathisFrame.scene);
                vertVisu2.positionings = positioning2;
                vertVisu2.meshModel = model2;
                vertVisu2.go();
                var commonSizes = positioning.getValue(mamesh.vertices[0]).scaling;
                var action = new mathis.PeriodicAction(function () {
                    var changed = ising.iterateAndGetChangedVertices();
                    changed.allKeys().forEach(function (v) {
                        if (v.customerObject.value == 0) {
                            positioning1.getValue(v).scaling.copyFromFloats(0, 0, 0); //.getValue(v).scaling.copyFrom(0,0,0)
                            positioning2.getValue(v).scaling.copyFromFloats(0, 0, 0);
                        }
                        else if (v.customerObject.value == 1) {
                            positioning1.getValue(v).scaling.copyFrom(commonSizes);
                            positioning2.getValue(v).scaling.copyFromFloats(0, 0, 0);
                        }
                        else if (v.customerObject.value == -1) {
                            positioning2.getValue(v).scaling.copyFrom(commonSizes);
                            positioning1.getValue(v).scaling.copyFromFloats(0, 0, 0);
                        }
                    });
                    vertVisu1.updatePositionings();
                    vertVisu2.updatePositionings();
                });
                action.frameInterval = this.frameInterval;
                this.mathisFrame.pushPeriodicAction(action);
            };
            IsingOnMesh.prototype.sphereModel = function (color) {
                var model = BABYLON.Mesh.CreateSphere('', 6, 1, this.mathisFrame.scene);
                var mat1 = new BABYLON.StandardMaterial('', this.mathisFrame.scene);
                mat1.diffuseColor = color;
                model.material = mat1;
                var qua = new mathis.XYZW(0, 0, 0, 0);
                mathis.geo.axisAngleToQuaternion(new mathis.XYZ(1, 0, 0), Math.PI / 2, qua);
                model.rotationQuaternion = qua;
                return model;
            };
            return IsingOnMesh;
        }());
        mecaStat.IsingOnMesh = IsingOnMesh;
    })(mecaStat = mathis.mecaStat || (mathis.mecaStat = {}));
})(mathis || (mathis = {}));
var mathis;
(function (mathis) {
    var fractal;
    (function (fractal) {
        var StableRandomFractal = (function () {
            function StableRandomFractal(mamesh) {
                this.referenceDistanceBetweenVertexWithZeroDichoLevel = 0.1;
                this.deformationFromCenterVersusFromDirection = true;
                this.center = new mathis.XYZ(0, 0, 0);
                this.direction = new mathis.XYZ(0, 0, 1);
                this.alpha = 1.7;
                this.beta = 0.7;
                this.seed = 22345;
                this.mamesh = mamesh;
            }
            StableRandomFractal.prototype.go = function () {
                this.simuStable = new mathis.proba.StableLaw();
                this.simuStable.alpha = this.alpha;
                this.simuStable.beta = this.beta;
                this.simuStable.nbSimu = this.mamesh.vertices.length;
                var generator = new mathis.proba.Random(this.seed);
                this.simuStable.basicGenerator = function () { return generator.pseudoRand(); };
                var X = this.simuStable.go();
                var someThinerDichoLevels = true;
                var randomCount = 0;
                var currentDichoLevel = 0;
                var newPosition = new mathis.XYZ(0, 0, 0);
                var temp = new mathis.XYZ(0, 0, 0);
                while (someThinerDichoLevels) {
                    someThinerDichoLevels = false;
                    for (var key in this.mamesh.cutSegmentsDico) {
                        var segment = this.mamesh.cutSegmentsDico[key];
                        if (Math.max(segment.a.dichoLevel, segment.b.dichoLevel) == currentDichoLevel) {
                            someThinerDichoLevels = true;
                            var modif = X[randomCount++] * Math.pow(this.referenceDistanceBetweenVertexWithZeroDichoLevel / Math.pow(2, currentDichoLevel), 1 / this.simuStable.alpha);
                            mathis.geo.between(segment.a.position, segment.b.position, 1 / 2, newPosition);
                            if (this.deformationFromCenterVersusFromDirection) {
                                newPosition.substract(this.center);
                                newPosition.scale(1 + modif);
                            }
                            else {
                                temp.copyFrom(this.direction).scale(modif);
                                newPosition.add(temp);
                            }
                            segment.middle.position.copyFrom(newPosition);
                        }
                    }
                    currentDichoLevel++;
                }
            };
            return StableRandomFractal;
        }());
        fractal.StableRandomFractal = StableRandomFractal;
    })(fractal = mathis.fractal || (mathis.fractal = {}));
})(mathis || (mathis = {}));
/**
 * Created by vigon on 01/04/2016.
 */
var mathis;
(function (mathis) {
    var metropolis;
    (function (metropolis) {
        var IsingModel = (function () {
            function IsingModel(graph) {
                this.nbActionsPerIteration = 1000;
                this.q = Number.POSITIVE_INFINITY;
                this.beta = 0.01;
                this.graph = graph;
            }
            IsingModel.prototype.checkArgs = function () {
                if (this.q == null || this.beta == null)
                    throw 'q or beta is null';
                if (this.q <= 0)
                    throw 'q must be positive';
            };
            IsingModel.prototype.go = function () {
                this.checkArgs();
                if (this.q == Number.POSITIVE_INFINITY)
                    this.possibleValues = [-1, 1];
                else
                    this.possibleValues = [-1, 0, 1];
                this.initialisation();
                //this.iterateAndGetChangedVertices()
            };
            IsingModel.prototype.iterateAndGetChangedVertices = function () {
                var res = new mathis.HashMap(true);
                for (var i = 0; i < this.nbActionsPerIteration; i++) {
                    var valuedVertex = void 0;
                    var possibleNewValue = void 0;
                    if (this.beta != Number.POSITIVE_INFINITY) {
                        var randomIndex = Math.floor(Math.random() * this.graph.length);
                        valuedVertex = this.graph[randomIndex];
                        possibleNewValue = this.newValue();
                    }
                    else {
                        /**when beta=infinity, we do not accept that +1 and -1 are neighbor */
                        var ok = false;
                        while (!ok) {
                            var randomIndex = Math.floor(Math.random() * this.graph.length);
                            valuedVertex = this.graph[randomIndex];
                            possibleNewValue = this.newValue();
                            var voi = null;
                            var ok_1 = true;
                            for (var _i = 0, _a = valuedVertex.links; _i < _a.length; _i++) {
                                voi = _a[_i];
                                if (voi.to.customerObject.value * possibleNewValue == -1) {
                                    ok_1 = false;
                                    break;
                                }
                            }
                        }
                    }
                    var ratioEnergy = this.energyRatio(valuedVertex, possibleNewValue);
                    if (ratioEnergy >= 1 || Math.random() < ratioEnergy) {
                        valuedVertex.customerObject.value = possibleNewValue;
                        res.putValue(valuedVertex, possibleNewValue);
                    }
                }
                return res;
            };
            IsingModel.prototype.newValue = function () {
                var randomIndex = Math.floor(Math.random() * this.possibleValues.length);
                return this.possibleValues[randomIndex];
            };
            IsingModel.prototype.energyRatio = function (ver, possibleNewValue) {
                var res = 1;
                if (this.q != 1 && this.q != Number.POSITIVE_INFINITY) {
                    res = Math.pow(this.q, Math.abs(possibleNewValue) - Math.abs(ver.customerObject.value));
                }
                if (this.beta != 0 && this.beta != Number.POSITIVE_INFINITY) {
                    var diff_1 = possibleNewValue - ver.customerObject.value;
                    if (this.beta != 0 && this.beta != Number.POSITIVE_INFINITY) {
                        var sac_1 = 0;
                        ver.links.forEach(function (li) {
                            sac_1 += diff_1 * li.to.customerObject.value;
                        });
                        res *= Math.exp(this.beta * sac_1);
                    }
                }
                return res;
            };
            IsingModel.prototype.initialisation = function () {
                this.graph.forEach(function (v) {
                    v.customerObject.value = 0;
                });
            };
            return IsingModel;
        }());
        metropolis.IsingModel = IsingModel;
    })(metropolis = mathis.metropolis || (mathis.metropolis = {}));
})(mathis || (mathis = {}));
var mathis;
(function (mathis) {
    var proba;
    (function (proba) {
        /** pour avoir toujours la mme squence alatoire d' un client  l' autre */
        var Random = (function () {
            function Random(seed) {
                if (seed === void 0) { seed = 1234567; }
                this.seed = seed;
            }
            //Webkit2's crazy invertible mapping SUB_generator
            // Theory is here: http://dl.acm.org/citation.cfm?id=752741
            Random.prototype.pseudoRand = function () {
                var max = Math.pow(2, 32);
                // creates randomness...somehow...
                this.seed += (this.seed * this.seed) | 5;
                // Shift off bits, discarding the sign. Discarding the sign is
                // important because OR w/ 5 can give us + or - numbers.
                return (this.seed >>> 32) / max;
            };
            Random.prototype.pseudoRandInt = function (size) {
                var res = Math.floor(size * this.pseudoRand());
                if (res == size)
                    res--; // pour le cas trs improbable o pseudoRand() revnoit 1
                return res;
            };
            return Random;
        }());
        proba.Random = Random;
        var Gaussian = (function () {
            function Gaussian() {
                this.mean = 0;
                this.stdev = 1;
                this.knuthVersusBowMuller = true;
                this.use_last = false;
            }
            Gaussian.prototype.go = function () {
                if (this.knuthVersusBowMuller)
                    return this.knuth();
                else
                    return this.bowMuller();
            };
            Gaussian.prototype.bowMuller = function () {
                var u = 1 - Math.random(); // Subtraction to flip [0, 1) to (0, 1].
                var v = 1 - Math.random();
                return this.mean + this.stdev * Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
            };
            Gaussian.prototype.knuth = function () {
                var y1;
                if (this.use_last) {
                    y1 = this.y2;
                    this.use_last = false;
                }
                else {
                    var x1, x2, w;
                    do {
                        x1 = 2.0 * Math.random() - 1.0;
                        x2 = 2.0 * Math.random() - 1.0;
                        w = x1 * x1 + x2 * x2;
                    } while (w >= 1.0);
                    w = Math.sqrt((-2.0 * Math.log(w)) / w);
                    y1 = x1 * w;
                    this.y2 = x2 * w;
                    this.use_last = true;
                }
                var retval = this.mean + this.stdev * y1;
                if (retval > 0)
                    return retval;
                return -retval;
            };
            return Gaussian;
        }());
        proba.Gaussian = Gaussian;
        // returns a gaussian random function with the given mean and stdev.
        function gaussian(mean, stdev) {
            var y2;
            var use_last = false;
            return function () {
                var y1;
                if (use_last) {
                    y1 = y2;
                    use_last = false;
                }
                else {
                    var x1, x2, w;
                    do {
                        x1 = 2.0 * Math.random() - 1.0;
                        x2 = 2.0 * Math.random() - 1.0;
                        w = x1 * x1 + x2 * x2;
                    } while (w >= 1.0);
                    w = Math.sqrt((-2.0 * Math.log(w)) / w);
                    y1 = x1 * w;
                    y2 = x2 * w;
                    use_last = true;
                }
                var retval = mean + stdev * y1;
                if (retval > 0)
                    return retval;
                return -retval;
            };
        }
        proba.gaussian = gaussian;
        var StableLaw = (function () {
            function StableLaw() {
                /**
                 alpha is the stability parameter in (0,2]
                 beta  is the skewness parameter in [-1,+1]
                 sigma is the scale parameter in ]0,infinity[
                 mu is the translation parameter in ]-infinity,+infinity[
                 when alpha<1 and beta==1, then the simulations are positive
                 */
                this.nbSimu = 1;
                this.alpha = 1.5;
                this.beta = 0;
                this.sigma = 1;
                this.mu = 0;
                this.basicGenerator = Math.random;
            }
            StableLaw.prototype.checkArgs = function () {
                if (this.alpha > 2 || this.alpha <= 0)
                    throw 'alpha must be in (0,2]';
                if (this.beta < -1 || this.beta > 1)
                    throw 'beta must be in [-1,1]';
            };
            StableLaw.prototype.go = function () {
                this.checkArgs();
                var X = [];
                for (var i = 0; i < this.nbSimu; i++) {
                    var V = this.basicGenerator() * Math.PI - Math.PI / 2; //angle alatoire
                    var W = -Math.log(this.basicGenerator()); //v.a. de loi exponentielle(1)
                    if (this.alpha != 1) {
                        // some constantes
                        var ta = Math.tan(Math.PI * this.alpha / 2);
                        var B = Math.atan(this.beta * ta) / this.alpha;
                        var S = (1 + this.beta ^ 2 * ta ^ 2) ^ (1 / 2 / this.alpha);
                        //  simulations
                        X[i] = S * Math.sin(this.alpha * (V + B)) / (Math.pow((Math.cos(V)), (1 / this.alpha)))
                            * Math.pow((Math.cos(V - this.alpha * (V + B)) / W), ((1 - this.alpha) / this.alpha));
                        X[i] = this.sigma * X[i] + this.mu;
                    }
                    else if (this.alpha == 1) {
                        X[i] = 2 / Math.PI * ((Math.PI / 2 + this.beta * V) * Math.tan(V) - this.beta * Math.log(W * Math.cos(V) / (Math.PI / 2 + this.beta * V)));
                        X[i] = this.sigma * X[i] + 2 / Math.PI * this.beta * this.sigma * Math.log(this.sigma) + this.mu;
                    }
                }
                return X;
            };
            return StableLaw;
        }());
        proba.StableLaw = StableLaw;
    })(proba = mathis.proba || (mathis.proba = {}));
})(mathis || (mathis = {}));
/**
 * Created by vigon on 06/05/2016.
 */
var mathis;
(function (mathis) {
    var usualFunction;
    (function (usualFunction) {
        usualFunction.sinh = function (x) { return (Math.exp(x) - Math.exp(-x)) / 2; };
        usualFunction.tanh = function (x) { return (Math.exp(x) - Math.exp(-x)) / (Math.exp(x) + Math.exp(-x)); };
        usualFunction.sech = function (x) { return 2 / (Math.exp(x) + Math.exp(-x)); };
        usualFunction.sechP = function (x) { return -usualFunction.tanh(x) * usualFunction.sech(x); };
        usualFunction.sechPP = function (x) { return -usualFunction.tanhP(x) * usualFunction.sech(x) - usualFunction.tanh(x) * usualFunction.sechP(x); };
        usualFunction.tanhP = function (x) {
            var ta = usualFunction.tanh(x);
            return 1 - ta * ta;
        };
        usualFunction.tanhPP = function (x) { return -2 * usualFunction.tanh(x) * usualFunction.tanhP(x); };
        usualFunction.tractrice = function (x) { return new mathis.XYZ(usualFunction.sech(x), x - usualFunction.tanh(x), 0); };
        usualFunction.tractriceP = function (x) { return new mathis.XYZ(usualFunction.sechP(x), 1 - usualFunction.tanhP(x), 0); };
        usualFunction.tractricePP = function (x) { return new mathis.XYZ(usualFunction.sechPP(x), -usualFunction.tanhPP(x), 0); };
        usualFunction.rotationYAxis = function (theta) {
            var res = new mathis.MM();
            var cos = Math.cos(theta);
            var sin = Math.sin(theta);
            mathis.geo.numbersToMM(cos, 0, sin, 0, 0, 1, 0, 0, -sin, 0, cos, 0, 0, 0, 0, 1, res);
            return res;
        };
        usualFunction.rotationYAxisP = function (theta) {
            var res = new mathis.MM();
            var cos = Math.cos(theta);
            var sin = Math.sin(theta);
            mathis.geo.numbersToMM(-sin, 0, cos, 0, 0, 0, 0, 0, -cos, 0, -sin, 0, 0, 0, 0, 1, res);
            return res;
        };
        usualFunction.rotationYAxisPP = function (theta) {
            var res = new mathis.MM();
            var cos = Math.cos(theta);
            var sin = Math.sin(theta);
            mathis.geo.numbersToMM(-cos, 0, -sin, 0, 0, 0, 0, 0, sin, 0, -cos, 0, 0, 0, 0, 1, res);
            return res;
        };
    })(usualFunction = mathis.usualFunction || (mathis.usualFunction = {}));
    var riemann;
    (function (riemann) {
        var Carte = (function () {
            function Carte() {
                /** -1 to inverse orientation*/
                this.orientationCoef = +1;
                this.unit = 1;
                this.point = new mathis.XYZ(0, 0, 0);
                this._meanLinkLengthAtArrival = null;
            }
            Carte.prototype.xyzToUV = function (xyz, recomputeStandartDevialtion) {
                if (recomputeStandartDevialtion === void 0) { recomputeStandartDevialtion = false; }
                if (this.maillage == null)
                    throw 'you must give a maillage to use xyzToUV ';
                var uv = new mathis.UV(0, 0);
                var shortestDist = Number.MAX_VALUE;
                var minDistToBorder = Number.MAX_VALUE;
                var vertex = null;
                for (var _i = 0, _a = this.maillage.vertices; _i < _a.length; _i++) {
                    vertex = _a[_i];
                    var u = vertex.position.x;
                    var v = vertex.position.y;
                    this.point.copyFrom(this.X(u, v));
                    var dist = mathis.geo.distance(this.point, xyz);
                    if (dist < shortestDist) {
                        shortestDist = dist;
                        uv.u = u;
                        uv.v = v;
                    }
                    /**the distance to border is computed from the clicked xyz (and not from the choosen point) but that is without importance
                     * this distance can be used to chose the right cart among several*/
                    if (vertex.hasMark(mathis.Vertex.Markers.border)) {
                        var distToBorder = mathis.geo.distance(xyz, this.point);
                        if (distToBorder < minDistToBorder)
                            minDistToBorder = distToBorder;
                    }
                }
                if (recomputeStandartDevialtion || this._meanLinkLengthAtArrival == null)
                    this._meanLinkLengthAtArrival = this.meanLinkLengthAtArrival();
                if (shortestDist < 1.1 * this._meanLinkLengthAtArrival)
                    return { uv: uv, distToBorder: minDistToBorder, distToNearestArrivalMesh: shortestDist };
                else {
                    //cc('in xyzTouV',this.name,xyz,shortestDist,this._meanLinkLengthAtArrival)
                    return null;
                }
            };
            Carte.prototype.e = function (u, v) {
                return mathis.geo.dot(this.newN(u, v), this.Xuu(u, v));
            };
            Carte.prototype.f = function (u, v) {
                return mathis.geo.dot(this.newN(u, v), this.Xuv(u, v));
            };
            Carte.prototype.g = function (u, v) {
                return mathis.geo.dot(this.newN(u, v), this.Xvv(u, v));
            };
            Carte.prototype.E = function (u, v) {
                return mathis.geo.dot(this.Xu(u, v), this.Xu(u, v));
            };
            Carte.prototype.F = function (u, v) {
                return mathis.geo.dot(this.Xu(u, v), this.Xv(u, v));
            };
            Carte.prototype.G = function (u, v) {
                return mathis.geo.dot(this.Xv(u, v), this.Xv(u, v));
            };
            Carte.prototype.createArrivalMeshFromMaillage = function () {
                var _this = this;
                var mameshDeepCopier = new mathis.mameshModification.MameshDeepCopier(this.maillage);
                mameshDeepCopier.copyCutSegmentsDico = false;
                this.arrivalOpenMesh = mameshDeepCopier.go();
                this.arrivalOpenMesh.vertices.forEach(function (vertex) {
                    var u = vertex.position.x;
                    var v = vertex.position.y;
                    vertex.position = _this.X(u, v);
                });
            };
            Carte.prototype.dNinTangentBasis = function (u, v) {
                var res = new mathis.M22();
                var e = this.e(u, v);
                var f = this.f(u, v);
                var g = this.g(u, v);
                var E = this.E(u, v);
                var F = this.F(u, v);
                var G = this.G(u, v);
                var det = E * G - F * F;
                res.m11 = (f * F - e * G) / det;
                res.m12 = (g * F - f * G) / det;
                res.m21 = (e * F - f * E) / det;
                res.m22 = (f * F - g * E) / det;
                return res;
            };
            Carte.prototype.dNaction = function (u, v, vect) {
                var a = this.dNinTangentBasis(u, v);
                var vectUV = this.canonicalToTangentBasis(u, v, vect);
                var trans = a.multiplyUV(vectUV);
                return this.tagentToCanonicalBasis(u, v, trans);
            };
            Carte.prototype.canonicalToTangentBasis = function (u, v, vect) {
                var Xu = this.Xu(u, v);
                var Xv = this.Xv(u, v);
                var mat = new mathis.M22();
                mat.m11 = Xu.x;
                mat.m21 = Xu.y;
                mat.m21 = Xv.x;
                mat.m22 = Xv.y;
                var inv = mat.inverse();
                cc(inv.determinant());
                var vect2 = new mathis.UV(vect.x, vect.y);
                return inv.multiplyUV(vect2);
            };
            Carte.prototype.tagentToCanonicalBasis = function (u, v, vect) {
                var Xu = this.Xu(u, v);
                var Xv = this.Xv(u, v);
                Xu.scale(vect.u);
                Xv.scale(vect.v);
                return Xu.add(Xv);
            };
            Carte.prototype.newN = function (u, v) {
                var res = new mathis.XYZ(0, 0, 0);
                mathis.geo.cross(this.Xu(u, v), this.Xv(u, v), res);
                res.normalize().scale(this.unit * this.orientationCoef);
                return res;
            };
            Carte.prototype.meanLinkLengthAtArrival = function () {
                var _this = this;
                var res = 0;
                var nb = 0;
                this.maillage.vertices.forEach(function (v) {
                    v.links.forEach(function (l) {
                        nb++;
                        res += mathis.geo.distance(_this.X(v.position.x, v.position.y), _this.X(l.to.position.x, l.to.position.y));
                    });
                });
                return res / nb;
            };
            return Carte;
        }());
        riemann.Carte = Carte;
        var Surface = (function () {
            function Surface() {
                this.cartes = [];
            }
            Surface.prototype.drawTheWholeSurface = function (scene) {
                this.drawOneMesh(this.wholeSurfaceMesh, scene);
            };
            Surface.prototype.drawOneCarte = function (carteIndex, scene) {
                this.drawOneMesh(this.cartes[carteIndex].arrivalOpenMesh, scene);
            };
            Surface.prototype.drawOneMesh = function (mesh, scene) {
                function lineIsChosen(line, space) {
                    var vertOk = true;
                    for (var _i = 0, line_2 = line; _i < line_2.length; _i++) {
                        var vert = line_2[_i];
                        if (vert.param.x % space != 0) {
                            vertOk = false;
                            break;
                        }
                    }
                    var horOk = true;
                    for (var _a = 0, line_3 = line; _a < line_3.length; _a++) {
                        var vert = line_3[_a];
                        if (vert.param.y % space != 0) {
                            horOk = false;
                            break;
                        }
                    }
                    return vertOk || horOk;
                }
                var lin = new mathis.visu3d.LinesViewer(mesh, scene);
                lin.constantRadius = 0.01;
                var linesOnSurf = lin.go();
                linesOnSurf.forEach(function (mesh) { return mesh.isPickable = false; });
                var surf = new mathis.visu3d.SurfaceViewer(mesh, scene);
                surf.alpha = 0.5;
                //surf.normalDuplication=visu3d.SurfaceVisuStatic.NormalDuplication.none
                //surf.sideOrientation=BABYLON.Mesh.BACKSIDE
                var meshSurf = surf.go();
                // let mat=new BABYLON.StandardMaterial('',this.surfaceMathisFrame.scene)
                // mat.diffuseColor=new Color3(0,1,1)
                // mat.backFaceCulling=true
                // mat.sideOrientation=BABYLON.Mesh.BACKSIDE
                // this.meshSurf.material=mat
            };
            Surface.prototype.findBestCarte = function (xyz) {
                var maxDistToBorder = -1;
                var chosenCarte = null;
                var chosenUV = null;
                this.cartes.forEach(function (carte) {
                    //cc('in find',carte.name)
                    var uvAndDist = carte.xyzToUV(xyz);
                    //cc('in find',uvAndDist,uvAndDist.distToBorder,'maxDistToBorder',maxDistToBorder)
                    /** we chose the carte for which the point is the most central (the further from the border)*/
                    if (uvAndDist != null && uvAndDist.distToBorder > maxDistToBorder) {
                        maxDistToBorder = uvAndDist.distToBorder;
                        chosenCarte = carte;
                        chosenUV = uvAndDist.uv;
                    }
                });
                /**do not change at all the following error  message, it is tested in riemann-test*/
                if (chosenUV == null) {
                    cc('the point which is not in any cart arrival is:', xyz.toString());
                    throw 'strange, the xyz do not belong to any carte-arrival';
                }
                return { uv: chosenUV, carte: chosenCarte };
            };
            return Surface;
        }());
        riemann.Surface = Surface;
        (function (SurfaceName) {
            SurfaceName[SurfaceName["selle"] = 0] = "selle";
            SurfaceName[SurfaceName["cylinder"] = 1] = "cylinder";
            SurfaceName[SurfaceName["torus"] = 2] = "torus";
            SurfaceName[SurfaceName["pseudoSphere"] = 3] = "pseudoSphere";
        })(riemann.SurfaceName || (riemann.SurfaceName = {}));
        var SurfaceName = riemann.SurfaceName; //ellipsoide
        var SurfaceMaker = (function () {
            function SurfaceMaker(surfaceName) {
                this.vertexToCarte = new mathis.HashMap();
                this.carteIndexToMinimalArrivalMesh = [];
                this.surfaceName = surfaceName;
            }
            SurfaceMaker.prototype.go = function () {
                this.surface = new Surface();
                this.surface.cartes = [];
                if (this.surfaceName == SurfaceName.torus) {
                    var oneCarte = function (origin, end) {
                        var gene = new mathis.reseau.BasisForRegularReseau();
                        gene.origin = origin;
                        gene.end = end;
                        gene.nbI = 32;
                        gene.nbJ = 64;
                        var departureMesh = new mathis.reseau.Regular(gene).go();
                        var arrivalMesh = new mathis.reseau.Regular(gene).go();
                        var r = 0.3;
                        var a = 0.7;
                        var carte0 = new Carte();
                        carte0.maillage = departureMesh;
                        carte0.arrivalOpenMesh = arrivalMesh;
                        carte0.X = function (u, v) { return new mathis.XYZ((r * Math.cos(u) + a) * Math.cos(v), (r * Math.cos(u) + a) * Math.sin(v), r * Math.sin(u)); };
                        carte0.Xu = function (u, v) { return new mathis.XYZ(-r * Math.sin(u) * Math.cos(v), -r * Math.sin(u) * Math.sin(v), r * Math.cos(u)); };
                        carte0.Xv = function (u, v) { return new mathis.XYZ(-(r * Math.cos(u) + a) * Math.sin(v), (r * Math.cos(u) + a) * Math.cos(v), 0); };
                        carte0.Xuu = function (u, v) { return new mathis.XYZ(-r * Math.cos(u) * Math.cos(v), -r * Math.cos(u) * Math.sin(v), -r * Math.sin(u)); };
                        carte0.Xuv = function (u, v) { return new mathis.XYZ(r * Math.sin(u) * Math.sin(v), -r * Math.sin(u) * Math.cos(v), 0); };
                        carte0.Xvv = function (u, v) { return new mathis.XYZ(-(r * Math.cos(u) + a) * Math.cos(v), -(r * Math.cos(u) + a) * Math.sin(v), 0); };
                        arrivalMesh.vertices.forEach(function (vert) {
                            var u = vert.position.x;
                            var v = vert.position.y;
                            vert.position = carte0.X(u, v);
                        });
                        return carte0;
                    };
                    var delta = 0.1;
                    this.surface.cartes.push(oneCarte(new mathis.XYZ(delta, delta, 0), new mathis.XYZ(2 * Math.PI - delta, 2 * Math.PI - delta, 0)));
                    this.surface.cartes.push(oneCarte(new mathis.XYZ(-Math.PI + delta, -Math.PI + delta, 0), new mathis.XYZ(Math.PI - delta, Math.PI - delta, 0)));
                    this.surface.wholeSurfaceMesh = oneCarte(new mathis.XYZ(0, 0, 0), new mathis.XYZ(2 * Math.PI, 2 * Math.PI, 0)).arrivalOpenMesh;
                }
                else if (this.surfaceName == SurfaceName.cylinder) {
                    var nb_1 = 40;
                    var oneCarte = function (origin, end) {
                        var gene = new mathis.reseau.BasisForRegularReseau();
                        gene.origin = origin;
                        gene.end = end;
                        gene.nbI = nb_1 + 1;
                        gene.nbJ = nb_1 + 1;
                        var departureMesh = new mathis.reseau.Regular(gene).go();
                        var arrivalMesh = new mathis.reseau.Regular(gene).go();
                        var rad = 0.5;
                        var carte0 = new Carte();
                        carte0.maillage = departureMesh;
                        carte0.arrivalOpenMesh = arrivalMesh;
                        carte0.X = function (u, v) { return new mathis.XYZ(rad * Math.cos(u), v, rad * Math.sin(u)); };
                        carte0.Xu = function (u, v) { return new mathis.XYZ(-rad * Math.sin(u), 0, rad * Math.cos(u)); };
                        carte0.Xv = function (u, v) { return new mathis.XYZ(0, 1, 0); };
                        carte0.Xuu = function (u, v) { return new mathis.XYZ(-rad * Math.cos(u), 0, -rad * Math.sin(u)); };
                        carte0.Xuv = function (u, v) { return new mathis.XYZ(0, 0, 0); };
                        carte0.Xvv = function (u, v) { return new mathis.XYZ(0, 0, 0); };
                        arrivalMesh.vertices.forEach(function (vert) {
                            var u = vert.position.x;
                            var v = vert.position.y;
                            vert.position = carte0.X(u, v);
                        });
                        return carte0;
                    };
                    var delta = 0.3;
                    this.surface.cartes.push(oneCarte(new mathis.XYZ(delta, -1 / 2, 0), new mathis.XYZ(2 * Math.PI - delta, 1 / 2, 0)));
                    this.surface.cartes.push(oneCarte(new mathis.XYZ(delta - Math.PI, -1 / 2, 0), new mathis.XYZ(Math.PI - delta, 1 / 2, 0)));
                    // delta=0.8
                    // let ma1=oneCarte(new XYZ(delta,-1/2, 0),new XYZ(2*Math.PI -delta, 1/2 , 0)).arrivalOpenMesh
                    // let ma2=oneCarte(new XYZ(delta-Math.PI,-1/2, 0),new XYZ(Math.PI-delta , 1/2 , 0)).arrivalOpenMesh
                    // let concurenter=new mameshModification.ConcurrentMameshesGraterAndSticker([ma1,ma2])
                    // concurenter.duringGratingSeedAreComputedFromBarycentersVersusFromAllPossibleCells=false
                    // concurenter.toleranceToBeOneOfTheClosest=0
                    this.surface.wholeSurfaceMesh = oneCarte(new mathis.XYZ(0, -1 / 2, 0), new mathis.XYZ(2 * Math.PI, 1 / 2, 0)).arrivalOpenMesh;
                }
                else if (this.surfaceName == SurfaceName.pseudoSphere) {
                    var oneCarte = function (origin, end) {
                        var gene = new mathis.reseau.BasisForRegularReseau();
                        gene.origin = origin;
                        gene.end = end;
                        gene.nbI = 32 + 1;
                        gene.nbJ = 20 + 1;
                        var departureMesh = new mathis.reseau.Regular(gene).go();
                        var arrivalMesh = new mathis.reseau.Regular(gene).go();
                        var rotationCarteMaker = new riemann.RotationCarteMaker(usualFunction.tractrice);
                        rotationCarteMaker.translation = new mathis.XYZ(0, -1, 0);
                        var sc = 1;
                        rotationCarteMaker.scaling = new mathis.XYZ(sc, sc, sc);
                        rotationCarteMaker.curveP = usualFunction.tractriceP;
                        rotationCarteMaker.curvePP = usualFunction.tractricePP;
                        var carte0 = rotationCarteMaker.go();
                        carte0.maillage = departureMesh;
                        carte0.arrivalOpenMesh = arrivalMesh;
                        arrivalMesh.vertices.forEach(function (vert) {
                            var u = vert.position.x;
                            var v = vert.position.y;
                            vert.position = carte0.X(u, v);
                        });
                        return carte0;
                    };
                    var delta = 0.3;
                    this.surface.cartes.push(oneCarte(new mathis.XYZ(delta, 0.1, 0), new mathis.XYZ(2 * Math.PI - delta, 3.5, 0)));
                    this.surface.cartes.push(oneCarte(new mathis.XYZ(-Math.PI + delta, 0.1, 0), new mathis.XYZ(Math.PI - delta, 3.5, 0)));
                    this.surface.wholeSurfaceMesh = oneCarte(new mathis.XYZ(0, 0.1, 0), new mathis.XYZ(2 * Math.PI, 3.5, 0)).arrivalOpenMesh;
                }
                else if (this.surfaceName == SurfaceName.selle) {
                    var oneCarte = function (origin, end) {
                        var gene = new mathis.reseau.BasisForRegularReseau();
                        gene.origin = origin;
                        gene.end = end;
                        gene.nbI = 40 + 1;
                        gene.nbJ = 40 + 1;
                        var departureMesh = new mathis.reseau.Regular(gene).go();
                        var arrivalMesh = new mathis.reseau.Regular(gene).go();
                        var carte0 = new Carte();
                        carte0.maillage = departureMesh;
                        carte0.arrivalOpenMesh = arrivalMesh;
                        carte0.X = function (u, v) { return new mathis.XYZ(u, v, v * v - u * u); };
                        carte0.Xu = function (u, v) { return new mathis.XYZ(1, 0, -2 * u); };
                        carte0.Xv = function (u, v) { return new mathis.XYZ(0, 1, 2 * v); };
                        carte0.Xuu = function (u, v) { return new mathis.XYZ(0, 0, -2); };
                        carte0.Xuv = function (u, v) { return new mathis.XYZ(0, 0, 0); };
                        carte0.Xvv = function (u, v) { return new mathis.XYZ(0, 0, 2); };
                        //     carte0.X = (u, v)=>new XYZ(u, v, v * v - u * u)
                        //     carte0.Xu = (u, v)=>new XYZ(1, 0, -2 * u)
                        //     carte0.Xv = (u, v)=>new XYZ(0, 1, 2 * v)
                        //
                        //     carte0.Xuu = (u, v)=>new XYZ(0, 0, -2)
                        //     carte0.Xuv = (u, v)=>new XYZ(0, 0, 0)
                        //     carte0.Xvv = (u, v)=>new XYZ(0, 0, 2)
                        arrivalMesh.vertices.forEach(function (vert) {
                            var u = vert.position.x;
                            var v = vert.position.y;
                            vert.position = carte0.X(u, v);
                        });
                        return carte0;
                    };
                    //let delta=0.1
                    //this.surface.cartes.push(oneCarte(new XYZ(delta,-1/2, 0),new XYZ(2*Math.PI -delta, 1/2 , 0)))
                    //this.surface.cartes.push(oneCarte(new XYZ(delta-Math.PI,-1/2, 0),new XYZ(Math.PI-delta , 1/2 , 0)))
                    var coef = 0.7;
                    this.surface.cartes.push(oneCarte(new mathis.XYZ(-coef, -coef, 0), new mathis.XYZ(coef, coef, 0)));
                    this.surface.wholeSurfaceMesh = oneCarte(new mathis.XYZ(-coef, -coef, 0), new mathis.XYZ(coef, coef, 0)).arrivalOpenMesh;
                }
                else
                    throw 'not yet';
                this.makeMinimalMeshesForEachCarte();
                return this.surface;
            };
            SurfaceMaker.prototype.makeMinimalMeshesForEachCarte = function () {
                //let selectedVertices:Vertex[]=[]
                var _this = this;
                var _loop_3 = function(carteIndex) {
                    var carte = this_2.surface.cartes[carteIndex];
                    var selectedVerticesForOneCart = [];
                    carte.arrivalOpenMesh.vertices.forEach(function (vert) {
                        var uvAndCarte = _this.surface.findBestCarte(vert.position);
                        if (uvAndCarte.carte == carte) {
                            //selectedVertices.push(vert)
                            _this.vertexToCarte.putValue(vert, carte);
                            selectedVerticesForOneCart.push(vert);
                        }
                    });
                    //cc('carte:',carte.name, carte.arrivalOpenMesh.vertices.length,'restricte',selectedVerticesForOneCart.length)
                    var subMamesh = new mathis.grateAndGlue.SubMameshExtractor(carte.arrivalOpenMesh, selectedVerticesForOneCart).go();
                    this_2.carteIndexToMinimalArrivalMesh[carteIndex] = subMamesh;
                };
                var this_2 = this;
                for (var carteIndex = 0; carteIndex < this.surface.cartes.length; carteIndex++) {
                    _loop_3(carteIndex);
                }
            };
            return SurfaceMaker;
        }());
        riemann.SurfaceMaker = SurfaceMaker;
        var RotationCarteMaker = (function () {
            function RotationCarteMaker(curve) {
                this.translation = new mathis.XYZ(0, 0, 0);
                this.scaling = new mathis.XYZ(1, 1, 1);
                this.curve = curve;
            }
            RotationCarteMaker.prototype.go = function () {
                var _this = this;
                var res = new Carte();
                res.X = function (u, v) {
                    var r = new mathis.XYZ(0, 0, 0);
                    mathis.geo.multiplicationMatrixVector(usualFunction.rotationYAxis(u), _this.curve(v), r);
                    r.resizes(_this.scaling).add(_this.translation);
                    return r;
                };
                res.Xu = function (u, v) {
                    var r = new mathis.XYZ(0, 0, 0);
                    mathis.geo.multiplicationMatrixVector(usualFunction.rotationYAxisP(u), _this.curve(v), r);
                    r.resizes(_this.scaling);
                    return r;
                };
                res.Xuu = function (u, v) {
                    var r = new mathis.XYZ(0, 0, 0);
                    mathis.geo.multiplicationMatrixVector(usualFunction.rotationYAxisPP(u), _this.curve(v), r);
                    r.resizes(_this.scaling);
                    return r;
                };
                res.Xv = function (u, v) {
                    var r = new mathis.XYZ(0, 0, 0);
                    mathis.geo.multiplicationMatrixVector(usualFunction.rotationYAxis(u), _this.curveP(v), r);
                    r.resizes(_this.scaling);
                    return r;
                };
                res.Xvv = function (u, v) {
                    var r = new mathis.XYZ(0, 0, 0);
                    mathis.geo.multiplicationMatrixVector(usualFunction.rotationYAxis(u), _this.curvePP(v), r);
                    r.resizes(_this.scaling);
                    return r;
                };
                res.Xuv = function (u, v) {
                    var r = new mathis.XYZ(0, 0, 0);
                    mathis.geo.multiplicationMatrixVector(usualFunction.rotationYAxisP(u), _this.curveP(v), r);
                    r.resizes(_this.scaling);
                    return r;
                };
                return res;
            };
            return RotationCarteMaker;
        }());
        riemann.RotationCarteMaker = RotationCarteMaker;
    })(riemann = mathis.riemann || (mathis.riemann = {}));
})(mathis || (mathis = {}));
/**
 * Created by vigon on 23/12/2016.
 */
var mathis;
(function (mathis) {
    var documentation;
    (function (documentation) {
        var conv;
        (function (conv) {
            conv.idForAttributeSelect = function (key, pieceOfCodeName) { return key + '_of_' + pieceOfCodeName; };
            conv.$$$ = '$$$';
            conv.spacesToSuppress = '                ';
            conv.toIncludeAtTheBeginOfTheFirstHiddenPiece = ["var mathisFrame=new mathis.MathisFrame()"];
            conv.traitementsForEachLine = [
                function (line) {
                    return line.replace(/this.mathisFrame\./g, "mathisFrame\.");
                    //return line.replace(/mathis\./g,"")
                }
            ];
            conv.begin = ["$$$begin", "$$$b"];
            conv.beginHidden = ["$$$beginHidden", "$$$bh"];
            conv.end = ["$$$end", "$$$e"];
            conv.endHidden = ["$$$endHidden", "$$$eh"];
        })(conv = documentation.conv || (documentation.conv = {}));
        /**create one select for each $$$attributes for a piece of code
         * when select change, the action is fired (usualy action is the goChanging method of piece of code.
         * selects are add inside a $placesToPutSelects, usually the  pieceOfCode html-lised
         * */
        var Binder = (function () {
            function Binder(pieceOfCode, allChoices, $placesToPutSelects) {
                this.selectAndAroundClassName = null;
                this.$placesToPutSelects = $placesToPutSelects;
                //this.action=action
                this.allChoices = allChoices;
                this.pieceOfCode = pieceOfCode;
                // if (containerId!=null){
                //     this.$containerForSelects=document.getElementById(containerId)
                //     this.$containerForSelects.innerHTML=""
                // }
                for (var _i = 0, _a = this.allChoices.allValues(); _i < _a.length; _i++) {
                    var choices = _a[_i];
                    choices.initializeSelectedValue();
                }
            }
            Binder.prototype.selectObjectAttribute = function () {
                for (var _i = 0, _a = this.allChoices.allValues(); _i < _a.length; _i++) {
                    var choices = _a[_i];
                    this.pieceOfCode[choices.key] = choices.selectedValue;
                }
                /**ne pas lancer l'action ici, cela ne sert  rien*/
                //this.action()
            };
            Binder.prototype.go = function () {
                var _this = this;
                var $res = null;
                if (this.$placesToPutSelects == null)
                    $res = $('<div></div>');
                var defaultIndex = 0;
                var _loop_4 = function(key) {
                    var choices = this_3.allChoices.getValue(key);
                    var $textAndSelect = document.createElement("span");
                    if (this_3.selectAndAroundClassName != null)
                        $textAndSelect.className = this_3.selectAndAroundClassName;
                    var $text = document.createElement("span");
                    if (choices.options.before != null)
                        $text.innerText = choices.options.before;
                    var $select = document.createElement("select");
                    $textAndSelect.appendChild($text);
                    $textAndSelect.appendChild($select);
                    for (var i = 0; i < choices.values.length; i++) {
                        var option = document.createElement("option");
                        option.value = choices.values[i];
                        if (choices.options.visualValues != null) {
                            option.label = choices.options.visualValues[i];
                            option.text = choices.options.visualValues[i];
                        }
                        /**TODO :  on compare les objets via toString, pas terrible */
                        if (choices.initialValue === null || choices.values[i] === null) {
                            if (choices.values[i] === null && choices.initialValue === null)
                                defaultIndex = i;
                        }
                        else {
                            if (choices.values[i].toString() == choices.initialValue.toString())
                                defaultIndex = i;
                        }
                        option.text = choices.values[i];
                        $select.appendChild(option);
                    }
                    $select.selectedIndex = defaultIndex;
                    $select.onchange = function () {
                        choices.selectedValue = choices.values[$select.selectedIndex];
                        _this.selectObjectAttribute();
                        if (choices.options.onchange != null)
                            choices.options.onchange();
                        else
                            _this.pieceOfCode.go();
                    };
                    /**if a $placesToPutSelects is given, then we put the select inside, at the right place
                     * if not, a div is create and all the select are sticked inside*/
                    if (this_3.$placesToPutSelects != null) {
                        this_3.$placesToPutSelects.find('#' + conv.idForAttributeSelect(key, this_3.pieceOfCode.NAME)).empty().append($textAndSelect);
                    }
                    else {
                        $res.append($textAndSelect);
                    }
                };
                var this_3 = this;
                for (var _i = 0, _a = this.allChoices.allKeys(); _i < _a.length; _i++) {
                    var key = _a[_i];
                    _loop_4(key);
                }
                this.selectObjectAttribute();
                if ($res != null)
                    return $res;
                else if (this.$placesToPutSelects != null)
                    return this.$placesToPutSelects;
                else
                    throw 'hoj';
            };
            return Binder;
        }());
        documentation.Binder = Binder;
        var Choices = (function () {
            function Choices(choices, options) {
                if (options === void 0) { options = null; }
                this.choices = choices;
                if (options != null)
                    this.options = options;
                else
                    this.options = {};
            }
            Choices.prototype.initializeSelectedValue = function () {
                /**attention ici, peut-tre se serait plus prudent de stocker une selectedKey ??? */
                this.selectedValue = this.initialValue;
            };
            Choices.prototype.getInitialValueAsString = function () {
                if (this.initialValue === null)
                    return 'null';
                else
                    return this.initialValue.toString();
            };
            return Choices;
        }());
        documentation.Choices = Choices;
        function findChoicesFromPieceOfCode(pieceOfCode) {
            var res = new mathis.StringMap();
            for (var $$$key in pieceOfCode) {
                if (pieceOfCode.hasOwnProperty($$$key) && $$$key.slice(0, 3) == conv.$$$) {
                    var key = $$$key.slice(3);
                    if (key != 'name' && key != 'title') {
                        var choicesOb = pieceOfCode[$$$key];
                        if ($.isArray(choicesOb))
                            choicesOb = new Choices(choicesOb);
                        else if (!(choicesOb instanceof Choices))
                            throw "a $$$attribute must be an array or of Type Choices";
                        choicesOb.key = key;
                        res.putValue(key, choicesOb);
                    }
                }
            }
            for (var _i = 0, _a = res.allKeys(); _i < _a.length; _i++) {
                var key = _a[_i];
                /**pieceOfCode[key] doit tre dfini (il peut cependant avoir la valeur null )  */
                if (pieceOfCode[key] === undefined)
                    throw 'no attribute associate to  $$$' + key;
                res.getValue(key).initialValue = pieceOfCode[key];
            }
            return res;
        }
        documentation.findChoicesFromPieceOfCode = findChoicesFromPieceOfCode;
        var PieceOfCodeTransformer = (function () {
            //stringsToSuppress=["mathis."]
            function PieceOfCodeTransformer(pieceOfCode) {
                this.allChoices = new mathis.StringMap();
                this.pieceOfCode = pieceOfCode;
            }
            PieceOfCodeTransformer.prototype.go = function () {
                this.allChoices = findChoicesFromPieceOfCode(this.pieceOfCode);
                var pieces = this.extractPiecesToShow();
                var res = $('<div></div>');
                for (var i = 0; i < pieces.length; i++) {
                    var piece = pieces[i];
                    /**including a chain at the begin*/
                    if (i == 0) {
                        var toInclude = this.pieceOfCode.toIncludeAtTheBeginOfTheFirstHiddenPiece;
                        if (toInclude == null)
                            toInclude = conv.toIncludeAtTheBeginOfTheFirstHiddenPiece;
                        if (toInclude != null) {
                            if (!(toInclude instanceof Array) || (typeof toInclude[0] != 'string'))
                                throw 'must be an array of string';
                            var toIncludeWithSpaces = [];
                            for (var i_2 = 0; i_2 < toInclude.length; i_2++) {
                                toIncludeWithSpaces[i_2] = conv.spacesToSuppress + toInclude[i_2];
                            }
                            if (piece.type == 'hidden') {
                                piece.piece = toIncludeWithSpaces.concat(piece.piece);
                            }
                            else {
                                var squiz = new SquizBox(false, "");
                                squiz.$squizable.append(this.transformOnePiece(toIncludeWithSpaces));
                                res.append(squiz.$visual);
                            }
                        }
                    }
                    if (piece.type == 'show')
                        res.append(this.transformOnePiece(piece.piece));
                    else {
                        var squiz = new SquizBox(false, piece.title);
                        squiz.$squizable.append(this.transformOnePiece(piece.piece));
                        res.append(squiz.$visual);
                    }
                }
                return res;
            };
            PieceOfCodeTransformer.prototype.transformOnePiece = function (lines) {
                var newLines = [];
                for (var _i = 0, lines_2 = lines; _i < lines_2.length; _i++) {
                    var line = lines_2[_i];
                    newLines.push(line.slice(16));
                }
                for (var i = 0; i < newLines.length; i++) {
                    if (newLines[i].slice(0, 3) == "//n") {
                        newLines[i] = " ";
                    }
                    for (var _a = 0, _b = conv.traitementsForEachLine; _a < _b.length; _a++) {
                        var traitement = _b[_a];
                        newLines[i] = traitement(newLines[i]);
                    }
                }
                var newtext = newLines.join('\n');
                /**important d'ordonner : dans le cas o un attribut est prfixe d'un autre */
                //function sortAccordingToLength(a:string,b:string){return -a.length+b.length}
                for (var _c = 0, _d = this.allChoices.allKeys(); _c < _d.length; _c++) {
                    var key = _d[_c];
                    /**a regex for this.attribute*/
                    var re = new RegExp('\\bthis.' + key + '\\b', "g");
                    var newtextSplited = newtext.split(re);
                    //if (newtextSplited.length==1) logger.c('the attribute:'+key+' do not appears in the piece of code')
                    //TODO: chand id into class to allow several apparition. + synchronize selects
                    if (newtextSplited.length > 2)
                        throw 'the attribute:' + key + ' appears more than one time in the piece of code';
                    newtext = newtextSplited.join('<div class="selectableAttribute" id="' + conv.idForAttributeSelect(key, this.pieceOfCode.NAME) + '">' + this.allChoices.getValue(key).getInitialValueAsString() + '</div>');
                }
                return $('<pre class="prettyprint">' + newtext + '</pre>');
            };
            PieceOfCodeTransformer.prototype.extractPiecesToShow = function () {
                /**on rcupre le contenu de la mthode goChanging*/
                var wholeText = this.pieceOfCode.go.toString();
                var lines = wholeText.split('\n');
                var indexOfBegin = [];
                var indexOfEnd = [];
                // function matchToBegin(line:string):boolean{
                //     let regex=new RegExp('^                \/\/\$\$\$(begin|b)( |\n).*')
                //     return regex.test(line)
                // }
                for (var i = 0; i < lines.length; i++) {
                    var line = lines[i];
                    var isTitle = /^                \/\/\$\$\$(beginHidden|bh) *./g.test(line);
                    if (/^                \/\/\$\$\$(begin|b)$/g.test(line))
                        indexOfBegin.push({ 'index': i, 'type': 'show' });
                    if (isTitle || /^                \/\/\$\$\$(beginHidden|bh)$/g.test(line)) {
                        var title = "";
                        if (isTitle) {
                            var reg = /^                \/\/\$\$\$(beginHidden|bh) *./g;
                            reg.exec(line);
                            title = line.slice(reg.lastIndex - 1);
                        }
                        indexOfBegin.push({ 'index': i, 'type': 'hidden', 'title': title });
                    }
                    if (/^                \/\/\$\$\$(end|e)$/g.test(line))
                        indexOfEnd.push({ 'index': i, 'type': 'show' });
                    if (/^                \/\/\$\$\$(endHidden|eh)$/g.test(line))
                        indexOfEnd.push({ 'index': i, 'type': 'hidden' });
                }
                if (indexOfBegin.length != indexOfEnd.length)
                    throw 'not the same number of $$$begin and $$$end';
                var res = [];
                for (var i = 0; i < indexOfBegin.length; i++) {
                    var indexBegin = indexOfBegin[i].index;
                    var typeBegin = indexOfBegin[i].type;
                    var title = indexOfBegin[i].title;
                    var indexEnd = indexOfEnd[i].index;
                    var typeEnd = indexOfEnd[i].type;
                    if (indexEnd <= indexBegin)
                        throw "an end before a begin";
                    if (typeBegin != typeEnd)
                        throw "$$$begin and $$$end have not the same type";
                    var piece = lines.slice(indexBegin + 1, indexEnd);
                    res.push({ 'piece': piece, 'type': typeBegin, 'title': title });
                }
                return res;
                // let beginIndex=lines.indexOf('                //$$$begin')
                // let endIndex=lines.indexOf('                //$$$end')
                // lines=lines.slice(beginIndex+1,endIndex)
            };
            return PieceOfCodeTransformer;
        }());
        documentation.PieceOfCodeTransformer = PieceOfCodeTransformer;
        var SquizBox = (function () {
            function SquizBox(isOpen, $title) {
                var _this = this;
                this.isOpen = isOpen;
                this.$visual = $('<div></div>');
                this.$squizable = $('<div class="squizable"></div>').appendTo(this.$visual);
                this.$title = $('<div class="ocGrey" style="display:inline-block"></div>').append($title);
                this.$squizButton = $('<div class="fa squizButton ocGrey"></div>');
                this.$allTheHead = $('<div class="docuPink"></div>');
                var $clickablePartOfTheHead = $('<div class="clickable inline"></div>')
                    .on('click touch', function () { _this.toggle(); })
                    .append(this.$squizButton)
                    .append(this.$title);
                this.$allTheHead.append($clickablePartOfTheHead).prependTo(this.$visual);
                if (this.isOpen)
                    this.open(false);
                else
                    this.close(false);
            }
            SquizBox.prototype.getVisual = function () { return this.$visual; };
            SquizBox.prototype.close = function (slide) {
                if (slide)
                    this.$squizable.slideUp();
                else
                    this.$squizable.hide();
                this.isOpen = false;
                this.$squizButton.removeClass('fa-compress').addClass('fa-expand');
            };
            SquizBox.prototype.open = function (slide) {
                if (slide)
                    this.$squizable.slideDown();
                else
                    this.$squizable.show();
                this.isOpen = true;
                this.$squizButton.removeClass('fa-expand').addClass('fa-compress');
            };
            SquizBox.prototype.toggle = function () {
                if (this.isOpen)
                    this.close(true);
                else
                    this.open(true);
            };
            return SquizBox;
        }());
        var APieceOfCodeForTest = (function () {
            function APieceOfCodeForTest() {
                this.$$$name = "part1";
                this.$$$title = "Bonjour ici c'est a";
                this.a = 0;
                this.$$$a = new Choices([0, 1, 2, 3, 4]);
                this.aaa = new mathis.XYZ(12, 2, 3);
                this.$$$aaa = new Choices([new mathis.XYZ(12, 2, 3), new mathis.XYZ(0, 0, 3)]);
                this.mlkajert = "toto";
                this.$$$mlkajert = new Choices(["a", "b", "c", "b", "toto"]);
            }
            APieceOfCodeForTest.prototype.goForTheFirstTime = function () {
                console.log("we goChanging for the first time");
                this.go();
            };
            APieceOfCodeForTest.prototype.go = function () {
                var n = 1234;
                //$$$begin
                /**AAAAAAAAAAAAAAA*/
                var a = this.a;
                var aze = this.mlkajert;
                var roro = this.aaa;
                var b = 0;
                var azeaze = "mathis.";
                var r = new mathis.Bilan();
                for (var k = 0; k < 4; k++) {
                    b += k;
                }
                function qsd() {
                    return 4;
                }
                //$$$end
                console.log(a, aze, roro);
            };
            return APieceOfCodeForTest;
        }());
        documentation.APieceOfCodeForTest = APieceOfCodeForTest;
    })(documentation = mathis.documentation || (mathis.documentation = {}));
})(mathis || (mathis = {}));
/**
 * Created by vigon on 19/11/2016.
 */
var mathis;
(function (mathis) {
    var documentation;
    (function (documentation) {
        var Enlarger = (function () {
            function Enlarger($leftButton, $rightButton, $left, $right) {
                var _this = this;
                this.$leftButton = $leftButton;
                this.$rightButton = $rightButton;
                this.$left = $left;
                this.$right = $right;
                this.state = 0;
                this.max = 4;
                this.min = -4;
                this.leftIsFullPage = false;
                this.$leftButton.on('click touch', function () { _this.onclickLeft(); });
                this.$rightButton.on('click touch', function () { _this.onclickRight(); });
            }
            Enlarger.prototype.onclickLeft = function () {
                if (this.state > this.min) {
                    this.state--;
                    this.onStateChange();
                }
            };
            Enlarger.prototype.onclickRight = function () {
                if (this.state < this.max) {
                    this.state++;
                    this.onStateChange();
                }
            };
            Enlarger.prototype.equilibrate = function () {
                if (this.state != 0) {
                    this.state = 0;
                    this.onStateChange();
                }
            };
            Enlarger.prototype.leftToFullPageTemporarily = function () {
                if (!this.leftIsFullPage) {
                    this.$left.css({ width: "100%" });
                    this.$right.css({ width: 0, left: "100%" });
                    this.leftIsFullPage = true;
                }
            };
            Enlarger.prototype.endOfTemporarily = function () {
                if (this.leftIsFullPage) {
                    this.leftIsFullPage = false;
                    this.onStateChange();
                }
            };
            Enlarger.prototype.onStateChange = function () {
                var leftWidth = Math.round(this.state - this.min) / (this.max - this.min) * 100;
                var rightWidth = 100 - leftWidth;
                this.$left.css({ width: leftWidth + "%" });
                this.$right.css({ width: rightWidth + "%", left: leftWidth + "%" });
                this.$leftButton.css({ right: rightWidth + "%" });
                this.$rightButton.css({ left: leftWidth + "%" });
            };
            return Enlarger;
        }());
        documentation.Enlarger = Enlarger;
        //
        // export function quitAndReloadSite(){
        //         $('#pageContent').fadeOut("fast",()=>{
        //         window.location.reload()
        //     })
        // }
        var IndexPage = (function () {
            function IndexPage(mathisFrame) {
                var _this = this;
                this.navigator = new documentation.Navigator();
                this.severalPages = new documentation.SeveralPages();
                this.mathisFrame = mathisFrame;
                this.enlarger = new Enlarger($('#enlargeLeft'), $('#enlargeRight'), $('#mainLeftCol'), $('#mainRightCol'));
                this.build();
                this.navigator.registerAndIndividualAction("index", function () { _this.show(true); });
                this.navigator.registerPagesAndParts(this.severalPages);
                // setTimeout(()=>{
                //     this.navigator.makeAction(encodeURI("DeformedReseau"))
                // },1000)
                //let allKeys=this.navigator.idToAction.allKeys().
                // setTimeout(()=>{
                //     this.navigator.makeAction(encodeURI("CornerBorderCenterForPolygone"))
                //     setTimeout(()=>{
                //         this.navigator.makeAction(encodeURI("mathis, what ?"))
                //         setTimeout(()=>{
                //             this.navigator.makeAction(encodeURI("CornerBorderCenterForPolygone"))
                //         },1000)
                //     },1000)
                // },2000)
                window.onpopstate = function (event) {
                    _this.navigator.makeAction(event.state);
                };
            }
            IndexPage.prototype.build = function () {
                this.severalPages.addPage(new documentation.WhyBlabla(this.mathisFrame));
                this.severalPages.addPage(new documentation.PureJavascriptTuto());
                this.severalPages.addPage(new documentation.TypescriptTuto());
                this.severalPages.addPage(new documentation.MathisFrameDocu(this.mathisFrame));
                this.severalPages.addPage(new documentation.BasicDocu(this.mathisFrame));
                this.severalPages.addPage(new documentation.ReseauDocu(this.mathisFrame));
                this.severalPages.addPage(new documentation.SurfaceDocu(this.mathisFrame));
                this.severalPages.addPage(new documentation.LinksDocu(this.mathisFrame));
                this.severalPages.addPage(new documentation.MacamDocu(this.mathisFrame));
                this.severalPages.addPage(new documentation.VerticesViewingDocu(this.mathisFrame));
                this.severalPages.addPage(new documentation.LinesViewingDocu(this.mathisFrame));
                this.severalPages.addPage(new documentation.LinksViewingDocu(this.mathisFrame));
                this.severalPages.addPage(new documentation.SurfaceViewerDocu(this.mathisFrame));
                this.severalPages.addPage(new documentation.GraphDistance(this.mathisFrame));
                this.severalPages.addPage(new documentation.GrateMergeStick(this.mathisFrame));
                this.severalPages.addPage(new documentation.DichoDocu(this.mathisFrame));
                this.severalPages.addPage(new documentation.TorusPlatonicDocu(this.mathisFrame));
            };
            IndexPage.prototype.show = function (fromNavigator) {
                $('#pageTitle').empty().text("Main menu");
                this.enlarger.endOfTemporarily();
                var $pageContent = $("#pageContent");
                documentation.startDemo(this.mathisFrame);
                $pageContent.empty().append(this.severalPages.$visual);
                this.severalPages.remakeHandlers();
                if (!fromNavigator)
                    history.pushState("index", "index", "#index");
            };
            return IndexPage;
        }());
        function startSite2() {
            var mathisFrame = new mathis.MathisFrame('placeForMathis');
            documentation.indexPage = new IndexPage(mathisFrame);
            documentation.indexPage.show(false);
            $('#logoMathis').on('click touch', function () { documentation.indexPage.show(false); });
        }
        documentation.startSite2 = startSite2;
    })(documentation = mathis.documentation || (mathis.documentation = {}));
})(mathis || (mathis = {}));
/**
 * Created by vigon on 08/02/2017.
 */
var mathis;
(function (mathis) {
    var documentation;
    (function (documentation) {
        var OnePart = (function () {
            function OnePart() {
                this.isVariant = false;
            }
            OnePart.prototype.fromComment = function ($comment, name) {
                this.$comment = $comment;
                this.name = name;
                return this;
            };
            OnePart.prototype.fromPieceOfCode = function (pieceOfCode, isVariant) {
                if (isVariant === void 0) { isVariant = false; }
                this.pieceOfCode = pieceOfCode;
                this.isVariant = isVariant;
                this.name = pieceOfCode.NAME;
                return this;
            };
            return OnePart;
        }());
        var SeveralPages = (function () {
            function SeveralPages() {
                this.nbPages = 0;
                this.idToPage = new mathis.StringMap();
                this.idToLine = new mathis.StringMap();
                this.$visual = $('<div></div>');
            }
            SeveralPages.prototype.addPage = function (onePage) {
                this.nbPages++;
                var line = $('<div class="mainMenuLine"></div>');
                line.text(this.nbPages + ' : ' + onePage.pageIdAndTitle);
                this.$visual.append(line);
                if (this.idToPage.getValue(onePage.pageIdAndTitle) != null)
                    throw 'two OnePage have the same title';
                this.idToPage.putValue(onePage.pageIdAndTitle, onePage);
                this.idToLine.putValue(onePage.pageIdAndTitle, line);
            };
            SeveralPages.prototype.goToPage = function (onePage, fromNavigator) {
                $('#pageTitle').empty().text(onePage.pageIdAndTitle);
                $('#divForDemoSelects').empty();
                $('#demoChoice').empty();
                var content = onePage.go();
                $('#pageContent').empty().append(content); //.hide().fadeIn()
                prettyPrint();
                if (!fromNavigator) {
                    var name_2 = encodeURI(onePage.pageIdAndTitle);
                    history.pushState(name_2, name_2, "#" + name_2);
                }
            };
            //
            // addIFrame(text:string,src:string,linkBefore=null){
            //
            //     this.nbPages++
            //
            //     let line=$('<div class="mainMenuLine"></div>')
            //     line.text(this.nbPages+' : '+text)
            //
            //     //TODO indexPage.enlarger.leftToFullPageTemporarily()
            //
            //
            //     line.on('click touch',()=>{
            //
            //
            //         $('#pageIdAndTitle').empty().text(text)
            //         $('#divForDemoSelects').empty()
            //         $('#demoChoice').empty()
            //
            //         // let $pageContent=$('#pageContent')
            //         // $pageContent.height('100%').empty()
            //         //
            //         // if (linkBefore!=null) $pageContent.append(linkBefore)
            //         // let $iframe=$('<iframe src='+src+' style="overflow:hidden;height:100%;width:100%" height="100%" width="100%"></iframe>')
            //         // $pageContent.append($iframe)
            //
            //     } )
            //
            //     this.$visual.append(line)
            //
            // }
            //
            SeveralPages.prototype.remakeHandlers = function () {
                var _this = this;
                var _loop_5 = function(id) {
                    this_4.idToLine.getValue(id).on('click touch', function () {
                        _this.goToPage(_this.idToPage.getValue(id), false);
                    });
                };
                var this_4 = this;
                for (var _i = 0, _a = this.idToPage.allKeys(); _i < _a.length; _i++) {
                    var id = _a[_i];
                    _loop_5(id);
                }
            };
            return SeveralPages;
        }());
        documentation.SeveralPages = SeveralPages;
        var SeveralParts = (function () {
            function SeveralParts() {
                this.allParts = [];
                this.numberOrParts = 0;
            }
            SeveralParts.prototype.go = function () {
                var $visual = $('<div></div>');
                $visual.empty();
                for (var _i = 0, _a = this.allParts; _i < _a.length; _i++) {
                    var onePart = _a[_i];
                    if (onePart.pieceOfCode != null)
                        $visual.append(this.createPartWithPieceOfCode(onePart));
                    else
                        $visual.append(onePart.$comment);
                }
                /**la permire partie qui n'est pas un commentaire est active*/
                for (var _b = 0, _c = this.allParts; _b < _c.length; _b++) {
                    var onePart = _c[_b];
                    if (onePart.pieceOfCode != null) {
                        this.clickInOnePlayButton(onePart, true);
                        break;
                    }
                }
                // /**automatically, the first part is activated*/
                // for (let key of this.order.allKeys()){
                //     if (this.order.getValue(key)==1) {
                //         this.clickInOnePlayButton(key)
                //         break
                //     }
                // }
                //
                // for (let name of this.allPieceOfCodes.allKeys()){
                //     this.createPart(this.allPieceOfCodes.getValue(name),this.areVariant.getValue(name))
                // }
                return $visual;
            };
            /**just to register*/
            SeveralParts.prototype.addPart = function (pieceOfCode, isVariante) {
                if (isVariante === void 0) { isVariante = false; }
                this.allParts.push(new OnePart().fromPieceOfCode(pieceOfCode, isVariante));
            };
            SeveralParts.prototype.createPartWithPieceOfCode = function (onePart) {
                var _this = this;
                this.numberOrParts++;
                var $part = (onePart.isVariant) ? $('<div class="ChoicesPartVariante"></div>') : $('<div class="ChoicesPart"></div>');
                var $partHead = $('<div class="ChoicesPartHead"></div>');
                var $partContent = $('<div class="ChoicesPartContent"></div>');
                $part.append($partHead).append($partContent);
                onePart.$playButton = $('<div class="fa fa-play playButton"></div>')
                    .on('click touch', function () { _this.clickInOnePlayButton(onePart, false); });
                $partHead.html(onePart.pieceOfCode.TITLE);
                $partHead.append(onePart.$playButton);
                var pieceOfCodeTransformer = new documentation.PieceOfCodeTransformer(onePart.pieceOfCode);
                onePart.$transformedPieceOfCode = pieceOfCodeTransformer.go();
                var binder = new documentation.Binder(onePart.pieceOfCode, pieceOfCodeTransformer.allChoices, onePart.$transformedPieceOfCode);
                $partContent.append(binder.go());
                if (onePart.isVariant)
                    onePart.$transformedPieceOfCode.hide();
                onePart.$action = function () { onePart.pieceOfCode.goForTheFirstTime(); };
                return $part;
            };
            SeveralParts.prototype.addComment = function ($content, name) {
                var $part = $('<div class="commentBetweenParts"></div>').append($content);
                this.allParts.push(new OnePart().fromComment($content, name));
            };
            // private findOnePartByName(name:string):OnePart{
            //     for (let onePart of this.allParts){
            //         if (onePart.name==name) return onePart
            //     }
            //     throw 'no part associated to this name'
            // }
            SeveralParts.prototype.clickInOnePlayButton = function (clickPart, fromNavigator) {
                for (var _i = 0, _a = this.allParts; _i < _a.length; _i++) {
                    var onePart = _a[_i];
                    if (onePart.pieceOfCode != null) {
                        onePart.$transformedPieceOfCode.find('select').prop('disabled', true);
                        onePart.$playButton.removeClass("activePlayButton");
                    }
                }
                documentation.indexPage.mathisFrame.messageDiv.empty();
                // for (let key of this.$allPlayButtons.allKeys()){
                //     this.$allTransformedPieceOfCode.getValue(key).find('select').prop('disabled', true);
                //     this.$allPlayButtons.getValue(key).removeClass("activePlayButton")
                // }
                clickPart.$playButton.addClass("activePlayButton");
                clickPart.$transformedPieceOfCode.find('select').prop('disabled', false);
                if (clickPart.isVariant)
                    clickPart.$transformedPieceOfCode.show();
                clickPart.$action();
                if (!fromNavigator) {
                    var name_3 = encodeURI(clickPart.name);
                    history.pushState(name_3, name_3, "#" + name_3);
                }
                // else{
                //     let $toAnimate
                //     if (clickPart.pieceOfCode!=null) $toAnimate=clickPart.$transformedPieceOfCode
                //     else $toAnimate=clickPart.$comment
                //     $('html, body').animate({
                //         scrollTop: $toAnimate.offset().top //Math.max($toAnimate.offset().top - 50,0)
                //     }, 1000);
                // }
                //this.$allPlayButtons.getValue(partName)
                // this.$allTransformedPieceOfCode.getValue(partName).find('select').prop('disabled', false);
                // this.$allTransformedPieceOfCode.getValue(partName).show()
                // if (this.additionnalActionToDoBeforPlaying!=null) this.additionnalActionToDoBeforPlaying()
                // this.$allActions.getValue(partName)()
                // if (this.additionnalActionToDoAfterPlaying!=null) this.additionnalActionToDoAfterPlaying()
            };
            return SeveralParts;
        }());
        documentation.SeveralParts = SeveralParts;
        // export class SeveralParts{
        //
        //     $visual:any
        //     $allTransformedPieceOfCode=new StringMap<any>()
        //     $allPlayButtons=new StringMap<any>()
        //     $allActions=new StringMap<()=>void>()
        //     order=new StringMap<number>()
        //
        //     additionnalActionToDoBeforPlaying:()=>void=null
        //     additionnalActionToDoAfterPlaying:()=>void=null
        //
        //     numberOrParts=0
        //
        //     constructor(){
        //         this.$visual=$('<div></div>')
        //
        //     }
        //
        //     go(){
        //         /**automatically, the first part is activated*/
        //         for (let key of this.order.allKeys()){
        //             if (this.order.getValue(key)==1) {
        //                 this.clickInOnePlayButton(key)
        //                 break
        //             }
        //         }
        //         return this.$visual
        //
        //
        //
        //     }
        //
        //
        //     addPart(pieceOfCode:PieceOfCode,isVariante=false){
        //
        //         if (this.$allTransformedPieceOfCode.getValue(pieceOfCode.$$$name)!=null) throw "two pieces of code have the same name:"+pieceOfCode.$$$name
        //
        //         this.numberOrParts++
        //
        //         let $part=(isVariante) ? $('<div class="ChoicesPartVariante"></div>') : $('<div class="ChoicesPart"></div>')
        //
        //         let $partHead=$('<div class="ChoicesPartHead"></div>')
        //         let $partContent=$('<div class="ChoicesPartContent"></div>')
        //
        //         $part.append($partHead).append($partContent)
        //
        //         let $button=$('<div class="fa fa-play playButton"></div>')
        //         $button.on('click touch',()=>{this.clickInOnePlayButton(pieceOfCode.$$$name)})
        //         $partHead.html(pieceOfCode.$$$title)
        //         $partHead.append($button)
        //
        //         this.$visual.append($part)
        //
        //         let pieceOfCodeTransformer=new PieceOfCodeTransformer(pieceOfCode)
        //         let $pieceOfCodeTransformed=pieceOfCodeTransformer.go()
        //         let binder=new Binder(pieceOfCode,pieceOfCodeTransformer.allChoices,$pieceOfCodeTransformed)
        //         $partContent.append(binder.go())
        //
        //         this.$allPlayButtons.putValue(pieceOfCode.$$$name,$button)
        //         this.$allTransformedPieceOfCode.putValue(pieceOfCode.$$$name,$pieceOfCodeTransformed)
        //         if (isVariante) $pieceOfCodeTransformed.hide()
        //         this.$allActions.putValue(pieceOfCode.$$$name,()=>{pieceOfCode.goForTheFirstTime()})
        //         this.order.putValue(pieceOfCode.$$$name,this.numberOrParts)
        //     }
        //
        //
        //     addComment($content):void{
        //         let $part= $('<div class="commentBetweenParts"></div>').append($content)
        //         this.$visual.append($part)
        //     }
        //
        //
        //     clickInOnePlayButton(partName:string):void{
        //
        //         for (let key of this.$allPlayButtons.allKeys()){
        //             this.$allTransformedPieceOfCode.getValue(key).find('select').prop('disabled', true);
        //             this.$allPlayButtons.getValue(key).removeClass("activePlayButton")
        //         }
        //
        //         this.$allPlayButtons.getValue(partName).addClass("activePlayButton")
        //         this.$allTransformedPieceOfCode.getValue(partName).find('select').prop('disabled', false);
        //         this.$allTransformedPieceOfCode.getValue(partName).show()
        //         if (this.additionnalActionToDoBeforPlaying!=null) this.additionnalActionToDoBeforPlaying()
        //         this.$allActions.getValue(partName)()
        //         if (this.additionnalActionToDoAfterPlaying!=null) this.additionnalActionToDoAfterPlaying()
        //     }
        //
        //
        //
        //     slideAndActivateOnePart(partName:string):void{
        //         if (this.$allPlayButtons.getValue(partName)==null) throw "this partName is not register in this severalParts"
        //         this.clickInOnePlayButton(partName)
        //     }
        //
        // }
        var Navigator = (function () {
            function Navigator() {
                this.idToAction = new mathis.StringMap();
            }
            Navigator.prototype.registerPagesAndParts = function (severalPages) {
                var _loop_6 = function(onePage) {
                    this_5.registerAndIndividualAction(onePage.pageIdAndTitle, function () { severalPages.goToPage(onePage, true); });
                    var severalParts = onePage.severalParts;
                    if (onePage.severalParts != null) {
                        var _loop_7 = function(onePart) {
                            this_5.registerAndIndividualAction(onePart.name, function () {
                                severalPages.goToPage(onePage, true);
                                severalParts.clickInOnePlayButton(onePart, true);
                            });
                        };
                        for (var _i = 0, _a = severalParts.allParts; _i < _a.length; _i++) {
                            var onePart = _a[_i];
                            _loop_7(onePart);
                        }
                    }
                };
                var this_5 = this;
                for (var _b = 0, _c = severalPages.idToPage.allValues(); _b < _c.length; _b++) {
                    var onePage = _c[_b];
                    _loop_6(onePage);
                }
                //console.log(this.idToAction)
                // severalPages.idToPage.allValues().forEach((onePage:OnePage)=>{
                //     this.registerAndIndividualAction(onePage.pageIdAndTitle,()=>{severalPages.goToPage(onePage)})
                //
                //     if (onePage.severalParts!=null){
                //
                //         for (let onePart of onePage.severalParts.allParts){
                //             if (onePart.name==)
                //         }
                //
                //         for (let $$$name in onePage.severalParts.$allPlayButtons.allKeys()){
                //             this.registerAndIndividualAction(onePage.pageIdAndTitle,()=>{
                //                 severalPages.goToPage(onePage)
                //                 onePage.severalParts.slideAndActivateOnePart($$$name)
                //                 //onePage.severalParts.
                //
                //             })
                //         }
                //
                //     }
                // })
            };
            Navigator.prototype.registerAndIndividualAction = function (id, action) {
                id = encodeURI(id);
                if (this.idToAction.getValue(id) != null)
                    throw "two similars ids";
                this.idToAction.putValue(id, action);
            };
            Navigator.prototype.makeAction = function (name) {
                var action = this.idToAction.getValue(name);
                if (action == null)
                    throw "no action associated with the keyword:" + name;
                action();
            };
            return Navigator;
        }());
        documentation.Navigator = Navigator;
    })(documentation = mathis.documentation || (mathis.documentation = {}));
})(mathis || (mathis = {}));
/**
 * Created by vigon on 30/11/2016.
 */
var mathis;
(function (mathis) {
    var documentation;
    (function (documentation) {
        var InfiniteWordOnIndex = (function () {
            function InfiniteWordOnIndex(mathisFrame) {
                var _this = this;
                this.mathisFrame = mathisFrame;
                this.$$$name = "InfiniteWordOnIndex";
                this.nameOfResau3d = mathis.infiniteWorlds.NameOfReseau3D.cube;
                this.$$$nameOfResau3d = new documentation.Choices(mathis.allIntegerValueOfEnume(mathis.infiniteWorlds.NameOfReseau3D), { 'visualValues': mathis.allStringValueOfEnume(mathis.infiniteWorlds.NameOfReseau3D) });
                this.seeFromInside = true;
                this.$$$seeFromInside = new documentation.Choices([true, false], { 'before': 'view from:', 'visualValues': ['inside', 'outside'], 'onchange': function () { _this.go2(); } });
            }
            InfiniteWordOnIndex.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.infinite = new mathis.infiniteWorlds.InfiniteCartesian(this.mathisFrame);
                this.infinite.buildLightCameraSkyboxAndFog = true;
                this.common();
            };
            InfiniteWordOnIndex.prototype.go = function () {
                this.mathisFrame.clearScene(false, false, false);
                //this.infinite=new infiniteWorlds.InfiniteCartesian(this.mathisFrame)
                this.infinite.buildLightCameraSkyboxAndFog = false;
                this.common();
            };
            InfiniteWordOnIndex.prototype.common = function () {
                this.infinite.pathFromHtmlToAssets = '../assets/';
                this.infinite.nameOfResau3d = this.nameOfResau3d;
                this.infinite.go();
            };
            //private weAreInside=true
            InfiniteWordOnIndex.prototype.go2 = function () {
                if (this.seeFromInside)
                    this.infinite.seeWorldFromInside();
                else
                    this.infinite.seeWorldFromOutside();
            };
            return InfiniteWordOnIndex;
        }());
        documentation.InfiniteWordOnIndex = InfiniteWordOnIndex;
        var IsingOnIndex = (function () {
            function IsingOnIndex(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "IsingOnIndex";
                this.beta = 0.5;
                this.$$$beta = new documentation.Choices([0, 0.5, 1, 3], { 'before': "repulsion force:" });
                this.q = 1.1;
                this.$$$q = new documentation.Choices([0.1, 0.5, 1, 3], { 'before': "density:" });
                this.nbDicho = 4;
                this.$$$nbDicho = new documentation.Choices([2, 3, 4], { 'before': "nb particles:" });
            }
            IsingOnIndex.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                var ising = new mathis.mecaStat.IsingOnMesh(this.mathisFrame);
                ising.defineLightAndCamera = true;
                this.common(ising);
            };
            IsingOnIndex.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                var ising = new mathis.mecaStat.IsingOnMesh(this.mathisFrame);
                ising.defineLightAndCamera = false;
                this.common(ising);
            };
            IsingOnIndex.prototype.common = function (ising) {
                ising.beta = this.beta;
                ising.q = this.q;
                ising.nbDicho = this.nbDicho;
                ising.go();
            };
            return IsingOnIndex;
        }());
        documentation.IsingOnIndex = IsingOnIndex;
        var DifferentialOnIndex = (function () {
            function DifferentialOnIndex(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "DifferentialOnIndex";
                this.vectorField = 2; //Math.floor(Math.random()*3)
                this.$$$vectorField = new documentation.Choices([0, 1, 2], { 'before': 'vector field:' });
                this.noiseIntensity = 0;
                this.$$$noiseIntensity = new documentation.Choices([0, 0.01, 0.02, 0.05, 0.1], { 'onchange': this.changeNoise, 'before': 'noise' });
            }
            DifferentialOnIndex.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.common(true);
            };
            DifferentialOnIndex.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                this.common(false);
            };
            DifferentialOnIndex.prototype.changeNoise = function () {
                var _this = this;
                if (this.diffsyst != null) {
                    this.diffsyst.vectorFieldForNoise = function (t, p, res) { res.copyFromFloats(_this.noiseIntensity, _this.noiseIntensity, 0); };
                    this.diffsyst.loadVectorFields();
                }
            };
            DifferentialOnIndex.prototype.common = function (makeCam) {
                var _this = this;
                /**vecter field priodique*/
                var vectorField0;
                {
                    //let scaled = new XYZ(0, 0, 0)
                    var A1_1 = function (t) { return 0.4 * Math.sin(0.5 * t); };
                    var A2_1 = function (t) { return 0.2 * Math.sin(0.5 * t); };
                    var a11_1 = function (t) { return 0; };
                    var a12_1 = function (t) { return 0; };
                    var a21_1 = function (t) { return 0; };
                    var a22_1 = function (t) { return 0; };
                    vectorField0 = function (t, p, res) {
                        //to01(p, scaled)
                        /**potential part*/
                        var raX = (p.x - 0.5) * 2;
                        var raY = (p.y - 0.5) * 4;
                        res.x = -raX * raY * raY;
                        res.y = -raX * raX * raY;
                        /**excitation part*/
                        res.x += p.x * (A1_1(t) + a11_1(t) * p.x + a12_1(t) * p.y);
                        res.y += p.y * (A2_1(t) + a21_1(t) * p.x + a22_1(t) * p.y);
                    };
                }
                var vectorField1;
                {
                    var A1_2 = function (t) { return 0.4 * Math.sin(t); };
                    var A2_2 = function (t) { return 0.2 * Math.sin(0.5 * t); };
                    var a11_2 = function (t) { return 0.1 * Math.sin(t); };
                    var a12_2 = function (t) { return -0.1 * Math.sin(t); };
                    var a21_2 = function (t) { return -0.1 * Math.sin(t); };
                    var a22_2 = function (t) { return 0.1 * Math.sin(t); };
                    vectorField1 = function (t, p, res) {
                        /**potential part*/
                        var raX = (p.x - 0.5) * 2;
                        var raY = (p.y - 0.5) * 4;
                        res.x = -raX * raY * raY;
                        res.y = -raX * raX * raY;
                        /**exitation part*/
                        res.x += p.x * (A1_2(t) + a11_2(t) * p.x + a12_2(t) * p.y);
                        res.y += p.y * (A2_2(t) + a21_2(t) * p.x + a22_2(t) * p.y);
                    };
                }
                var vectorField2;
                {
                    var A1_3 = function (t) { return 0.4 * Math.sin(0.5 * t); };
                    var A2_3 = function (t) { return 0.2 * Math.sin(0.3 * t); };
                    var a11_3 = function (t) { return 0; };
                    var a12_3 = function (t) { return 0; };
                    var a21_3 = function (t) { return 0; };
                    var a22_3 = function (t) { return 0.1 * Math.sin(t); };
                    vectorField2 = function (t, p, res) {
                        /**potential part*/
                        var raX = (p.x - 0.5) * 2;
                        var raY = (p.y - 0.5) * 4;
                        res.x = -raX * raY * raY;
                        res.y = -raX * raX * raY;
                        /**exitation part*/
                        res.x += p.x * (A1_3(t) + a11_3(t) * p.x + a12_3(t) * p.y);
                        res.y += p.y * (A2_3(t) + a21_3(t) * p.x + a22_3(t) * p.y);
                    };
                }
                var vectorField;
                if (this.vectorField == 0)
                    vectorField = vectorField0;
                else if (this.vectorField == 1)
                    vectorField = vectorField1;
                else if (this.vectorField == 2)
                    vectorField = vectorField2;
                var vectorFieldForNoise = function (t, p, res) { res.copyFromFloats(_this.noiseIntensity, _this.noiseIntensity, 0); };
                this.diffsyst = new mathis.differentialSystem.TwoDim(vectorField, this.mathisFrame);
                this.diffsyst.originView = new mathis.XYZ(-1, -1, 0);
                this.diffsyst.endView = new mathis.XYZ(1, 1, 0);
                this.diffsyst.vectorFieldForNoise = vectorFieldForNoise;
                this.diffsyst.makeLightAndCamera = makeCam;
                this.diffsyst.go();
            };
            return DifferentialOnIndex;
        }());
        documentation.DifferentialOnIndex = DifferentialOnIndex;
        var FractalOnIndex = (function () {
            function FractalOnIndex(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "FractalOnIndex";
                this.alpha = 1.2;
                this.$$$alpha = new documentation.Choices([0.8, 1, 1.2, 1.5, 1.7, 1.9], { 'before': 'alpha' });
                this.beta = 0.;
                this.$$$beta = new documentation.Choices([-1, -0.7, -0.5, -0.2, 0, 0.2, 0.5, 0.7, 1], { 'before': 'beta' });
                this.nbDicho = 4;
                this.$$$nbDicho = new documentation.Choices([2, 3, 4, 5], { 'before': 'nb dichotomy' });
                this.showLine = false;
                this.$$$showLine = new documentation.Choices([true, false], { 'before': "showLines:" });
                this.shape = 'plan';
                this.$$$shape = new documentation.Choices(['sphere', 'plan'], { 'before': 'shape:' });
            }
            FractalOnIndex.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                this.mathisFrame.getGrabberCamera().changePosition(new mathis.XYZ(0, 0, -7));
                this.go();
            };
            FractalOnIndex.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                var mamesh;
                if (this.shape == 'sphere') {
                    var creator = new mathis.creation3D.Polyhedron(mathis.creation3D.PolyhedronType.Dodecahedron);
                    mamesh = creator.go();
                }
                else {
                    var basis = new mathis.reseau.BasisForRegularReseau();
                    basis.squareMailleInsteadOfTriangle = false;
                    basis.origin = new mathis.XYZ(-1, -1, 0);
                    basis.end = new mathis.XYZ(1, 1, 0);
                    basis.nbI = 4;
                    basis.nbJ = 4;
                    var creator = new mathis.reseau.Regular(basis);
                    mamesh = creator.go();
                }
                for (var i = 0; i < this.nbDicho; i++)
                    new mathis.mameshModification.TriangleDichotomer(mamesh).go();
                if (this.shape == 'sphere')
                    for (var _i = 0, _a = mamesh.vertices; _i < _a.length; _i++) {
                        var vertex = _a[_i];
                        vertex.position.normalize();
                    }
                var fractalModifier = new mathis.fractal.StableRandomFractal(mamesh);
                fractalModifier.referenceDistanceBetweenVertexWithZeroDichoLevel = 0.005;
                fractalModifier.alpha = this.alpha;
                fractalModifier.beta = this.beta;
                fractalModifier.deformationFromCenterVersusFromDirection = (this.shape == 'sphere');
                fractalModifier.go();
                if (this.shape == 'plan') {
                    var positioning = new mathis.Positioning();
                    positioning.upVector = new mathis.XYZ(0, 0, 1);
                    positioning.applyToVertices(mamesh.vertices);
                }
                var surfaceViewer = new mathis.visu3d.SurfaceViewer(mamesh, this.mathisFrame.scene);
                surfaceViewer.alpha = 1;
                //surfaceViewer.normalDuplication=visu3d.NormalDuplication.none
                surfaceViewer.sideOrientation = BABYLON.Mesh.DOUBLESIDE;
                surfaceViewer.go();
                if (this.showLine) {
                    var lineViewer = new mathis.visu3d.LinesViewer(mamesh, this.mathisFrame.scene);
                    lineViewer.interpolationOption.interpolationStyle = mathis.geometry.InterpolationStyle.none;
                    lineViewer.isThin = true;
                    lineViewer.color = mathis.color.thema.defaultLinkColor;
                    lineViewer.go();
                }
            };
            return FractalOnIndex;
        }());
        documentation.FractalOnIndex = FractalOnIndex;
        var SeveralDemo = (function () {
            function SeveralDemo(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "SeveralDemo";
                this.demoChoice = Math.floor(Math.random() * 4);
                this.$$$demoChoice = new documentation.Choices([0, 1, 2, 3], { 'visualValues': ["infinite world", "ising model", '2d differential', 'alpha fractal'] });
            }
            SeveralDemo.prototype.goForTheFirstTime = function () {
                this.go();
            };
            SeveralDemo.prototype.go = function () {
                var pieceOfCode;
                if (this.demoChoice == 0)
                    pieceOfCode = new InfiniteWordOnIndex(this.mathisFrame);
                else if (this.demoChoice == 1)
                    pieceOfCode = new IsingOnIndex(this.mathisFrame);
                else if (this.demoChoice == 2)
                    pieceOfCode = new DifferentialOnIndex(this.mathisFrame);
                else if (this.demoChoice == 3)
                    pieceOfCode = new FractalOnIndex(this.mathisFrame);
                else
                    throw "boum";
                var attributeChoices = documentation.findChoicesFromPieceOfCode(pieceOfCode);
                var binder = new documentation.Binder(pieceOfCode, attributeChoices, null);
                binder.selectAndAroundClassName = "spanForDemoSelects";
                var $selects = binder.go();
                pieceOfCode.goForTheFirstTime();
                $('#divForDemoSelects').empty().append($selects);
                //$('#mainCanvasDiv').append($placeForSelects)
            };
            return SeveralDemo;
        }());
        documentation.SeveralDemo = SeveralDemo;
        function startDemo(mathisFrame) {
            var pieceOfCode = new SeveralDemo(mathisFrame);
            var attributeChoices = documentation.findChoicesFromPieceOfCode(pieceOfCode);
            var binder = new documentation.Binder(pieceOfCode, attributeChoices, null);
            var $selects = binder.go();
            $('#demoChoice').append($selects);
            pieceOfCode.goForTheFirstTime();
        }
        documentation.startDemo = startDemo;
    })(documentation = mathis.documentation || (mathis.documentation = {}));
})(mathis || (mathis = {}));
/**
 * Created by vigon on 19/11/2016.
 */
var mathis;
(function (mathis) {
    var documentation;
    (function (documentation) {
        var BasicDocu = (function () {
            function BasicDocu(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.pageIdAndTitle = "Mameshes, vertices, links and lines";
                var several = new documentation.SeveralParts();
                several.addPart(new SimpleMamesh(this.mathisFrame));
                several.addPart(new SimpleMameshLine(this.mathisFrame));
                several.addPart(new LineDocu(this.mathisFrame));
                this.severalParts = several;
            }
            BasicDocu.prototype.go = function () {
                //several.addPart(new APieceOfCodeForTest())
                return this.severalParts.go();
            };
            return BasicDocu;
        }());
        documentation.BasicDocu = BasicDocu;
        var SimpleMamesh = (function () {
            function SimpleMamesh(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "SimpleMamesh";
                this.$$$title = "A simple Mamesh with polygons and links";
                this.link = true;
                this.$$$link = new documentation.Choices([true, false]);
                this.mathisFrame = mathisFrame;
            }
            SimpleMamesh.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                var camera = this.mathisFrame.scene.activeCamera;
                camera.changePosition(new mathis.XYZ(0, 0, -5));
                this.go();
            };
            SimpleMamesh.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$begin
                var addLinks = this.link;
                /**let's create vertices*/
                var vertex0 = new mathis.Vertex().setPosition(-1, -1, 0);
                var vertex1 = new mathis.Vertex().setPosition(-1, 1, 0);
                var vertex2 = new mathis.Vertex().setPosition(0, 1.5, 0);
                var vertex3 = new mathis.Vertex().setPosition(0, -0.5, 0);
                var vertex4 = new mathis.Vertex().setPosition(1, -1, 0);
                var vertex5 = new mathis.Vertex().setPosition(1, 1, 0);
                //n
                /**let's make a mamesh with 2 triangles, 1 rectangle*/
                var mamesh = new mathis.Mamesh();
                mamesh.vertices.push(vertex0, vertex1, vertex2, vertex3, vertex4, vertex5);
                mamesh.addATriangle(vertex0, vertex2, vertex1).addATriangle(vertex0, vertex3, vertex2);
                mamesh.addASquare(vertex2, vertex3, vertex4, vertex5);
                //n
                /**automatic creation of links between vertex */
                if (addLinks) {
                    mamesh.addSimpleLinksAroundPolygons();
                }
                //$$$end
                //$$$bh visualization
                var verticesViewer = new mathis.visu3d.VerticesViewer(mamesh, this.mathisFrame.scene);
                verticesViewer.go();
                var linksViewer = new mathis.visu3d.LinksViewer(mamesh, this.mathisFrame.scene);
                linksViewer.go();
                var surfaceViewer = new mathis.visu3d.SurfaceViewer(mamesh, this.mathisFrame.scene);
                surfaceViewer.go();
                //$$$eh
            };
            return SimpleMamesh;
        }());
        var SimpleMameshLine = (function () {
            function SimpleMameshLine(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "SimpleMameshLine";
                this.$$$title = "the same mamesh, but we also add lines";
                this.link = true;
                this.$$$link = new documentation.Choices([true, false]);
                this.mathisFrame = mathisFrame;
            }
            SimpleMameshLine.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                var camera = this.mathisFrame.scene.activeCamera;
                camera.changePosition(new mathis.XYZ(0, 0, -5));
                this.go();
            };
            SimpleMameshLine.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$bh mamesh creation
                /**let's create vertices*/
                var vertex0 = new mathis.Vertex().setPosition(-1, -1, 0);
                var vertex1 = new mathis.Vertex().setPosition(-1, 1, 0);
                var vertex2 = new mathis.Vertex().setPosition(0, 1.5, 0);
                var vertex3 = new mathis.Vertex().setPosition(0, -0.5, 0);
                var vertex4 = new mathis.Vertex().setPosition(1, -1, 0);
                var vertex5 = new mathis.Vertex().setPosition(1, 1, 0);
                //n
                /**let's make a mamesh with 2 triangles, 1 rectangle*/
                var mamesh = new mathis.Mamesh();
                mamesh.vertices.push(vertex0, vertex1, vertex2, vertex3, vertex4, vertex5);
                mamesh.addATriangle(vertex0, vertex2, vertex1).addATriangle(vertex0, vertex3, vertex2);
                mamesh.addASquare(vertex2, vertex3, vertex4, vertex5);
                //$$$eh
                //$$$begin
                /**automatic creation of links between vertex */
                var addOppositeLinks = this.link;
                if (addOppositeLinks) {
                    /**some natural opposition are made between links.
                     * Line are constructed following links in oppositions. */
                    mamesh.addOppositeLinksAroundPolygons();
                }
                else {
                    mamesh.addSimpleLinksAroundPolygons();
                }
                //$$$end
                //$$$bh visualization
                var verticesViewer = new mathis.visu3d.VerticesViewer(mamesh, this.mathisFrame.scene);
                verticesViewer.go();
                if (addOppositeLinks) {
                    /**to hide the famous bug*/
                    new mathis.spacialTransformations.Similitude(mamesh.vertices, 0.001).goChanging();
                    var lineViewer = new mathis.visu3d.LinesViewer(mamesh, this.mathisFrame.scene);
                    //lineViewer.interpolationOption.interpolationStyle=geometry.InterpolationStyle.none
                    lineViewer.go();
                }
                else {
                    var linksViewer = new mathis.visu3d.LinksViewer(mamesh, this.mathisFrame.scene);
                    linksViewer.go();
                }
                var surfaceViewer = new mathis.visu3d.SurfaceViewer(mamesh, this.mathisFrame.scene);
                surfaceViewer.go();
                //$$$eh
            };
            return SimpleMameshLine;
        }());
        var LineDocu = (function () {
            function LineDocu(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "LineDocu";
                this.$$$title = "Defining lines joining vertices";
                this.makeLoop = false;
                this.$$$makeLoop = new documentation.Choices([true, false]);
                this.nb = 9;
                this.$$$nb = new documentation.Choices([5, 7, 9, 15]);
                this.interpolationStyle = mathis.geometry.InterpolationStyle.octavioStyle;
                this.$$$interpolationStyle = new documentation.Choices(mathis.allIntegerValueOfEnume(mathis.geometry.InterpolationStyle), { "before": "geometry.InterpolationStyle.", "visualValues": mathis.allStringValueOfEnume(mathis.geometry.InterpolationStyle) });
            }
            LineDocu.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                this.go();
            };
            LineDocu.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$begin
                var makeLoop = this.makeLoop;
                var interpolationStyle = this.interpolationStyle;
                var nb = this.nb;
                var mamesh = new mathis.Mamesh();
                for (var i = 0; i < nb; i++) {
                    var vertex = new mathis.Vertex();
                    var angle = 2 * Math.PI * i / (nb);
                    vertex.position = new mathis.XYZ(Math.cos(angle), Math.sin(angle), 0);
                    mamesh.vertices.push(vertex);
                }
                for (var i = 1; i < nb - 1; i++) {
                    /**create two links and and inform both of them that they are opposite */
                    mamesh.vertices[i].setTwoOppositeLinks(mamesh.vertices[i - 1], mamesh.vertices[i + 1]);
                }
                if (makeLoop) {
                    mamesh.vertices[0].setTwoOppositeLinks(mamesh.vertices[1], mamesh.vertices[nb - 1]);
                    mamesh.vertices[nb - 1].setTwoOppositeLinks(mamesh.vertices[nb - 2], mamesh.vertices[0]);
                }
                else {
                    mamesh.vertices[0].setOneLink(mamesh.vertices[1]);
                    mamesh.vertices[nb - 1].setOneLink(mamesh.vertices[nb - 2]);
                }
                //$$$end
                //$$$bh visualization
                var linesViewer = new mathis.visu3d.LinesViewer(mamesh, this.mathisFrame.scene);
                linesViewer.interpolationOption.interpolationStyle = interpolationStyle;
                linesViewer.interpolationOption.loopLine = makeLoop;
                linesViewer.go();
                new mathis.visu3d.VerticesViewer(mamesh, this.mathisFrame.scene).go();
                //$$$eh
            };
            return LineDocu;
        }());
    })(documentation = mathis.documentation || (mathis.documentation = {}));
})(mathis || (mathis = {}));
/**
* Created by vigon on 05/12/2016.
*/
var mathis;
(function (mathis) {
    var documentation;
    (function (documentation) {
        var DichoDocu = (function () {
            function DichoDocu(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.pageIdAndTitle = "Dichotomy";
                var several = new documentation.SeveralParts();
                several.addPart(new ReseauDicho(this.mathisFrame));
                several.addPart(new SolideDicho(this.mathisFrame));
                this.severalParts = several;
            }
            DichoDocu.prototype.go = function () {
                return this.severalParts.go();
            };
            return DichoDocu;
        }());
        documentation.DichoDocu = DichoDocu;
        var ReseauDicho = (function () {
            function ReseauDicho(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "ReseauDicho";
                this.$$$title = "we do dichotomy on some square or triangle net";
                this.nbTrianglesCut = 2;
                this.$$$nbTrianglesCut = [1, 2, 3, 4, 5, 10, 16, 32, 50];
                this.squareVersusTriangle = true;
                this.$$$squareVersusTriangle = [true, false];
                this.nbInitialDicho = 1;
                this.$$$nbInitialDicho = [0, 1, 2, 3, 4];
                this.mathisFrame = mathisFrame;
            }
            ReseauDicho.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                this.go();
            };
            ReseauDicho.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$begin
                var squareVersusTriangle = this.squareVersusTriangle;
                var creator = new mathis.reseau.Regular();
                creator.nbI = 3;
                creator.nbJ = 3;
                creator.origine = new mathis.XYZ(-1, -1, 0);
                creator.squareVersusTriangleMaille = squareVersusTriangle;
                var mamesh = creator.go();
                //n
                /**we do triangle-dichotomies several times*/
                var nbInitialDicho = this.nbInitialDicho;
                for (var i = 0; i < nbInitialDicho; i++) {
                    var dichotomer = void 0;
                    if (squareVersusTriangle)
                        dichotomer = new mathis.mameshModification.SquareDichotomer(mamesh);
                    else
                        dichotomer = new mathis.mameshModification.TriangleDichotomer(mamesh);
                    dichotomer.go();
                }
                /**again a dichotomy, but not for all triangles: we choose the first triangle in the list*/
                var nbPolygonsToCutAgain = this.nbTrianglesCut;
                var partialDichotomer;
                if (squareVersusTriangle) {
                    partialDichotomer = new mathis.mameshModification.SquareDichotomer(mamesh);
                    partialDichotomer.squareToCut = mamesh.smallestSquares.slice(0, 4 * nbPolygonsToCutAgain);
                }
                else {
                    partialDichotomer = new mathis.mameshModification.TriangleDichotomer(mamesh);
                    partialDichotomer.trianglesToCut = mamesh.smallestTriangles.slice(0, 3 * nbPolygonsToCutAgain);
                }
                partialDichotomer.go();
                //$$$end
                //$$$bh visualization
                /**we collect vertices according to their dichotomy level*/
                var verticesByDichoLevel = [];
                for (var i = 0; i < mamesh.vertices.length; i++) {
                    var vertex = mamesh.vertices[i];
                    var level = vertex.dichoLevel;
                    if (verticesByDichoLevel[level] == null)
                        verticesByDichoLevel[level] = [];
                    verticesByDichoLevel[level].push(vertex);
                }
                /**we create the visualisation, changing color according according to dichotomy level*/
                var nbLevel = verticesByDichoLevel.length;
                var colorList = [mathis.Color.names.black, mathis.Color.names.whitesmoke, mathis.Color.names.blue, mathis.Color.names.red, mathis.Color.names.orange, mathis.Color.names.violet, mathis.Color.names.beige];
                for (var level = 0; level < nbLevel; level++) {
                    var viewer = new mathis.visu3d.VerticesViewer(mamesh, this.mathisFrame.scene);
                    viewer.color = new mathis.Color(colorList[level]); //new Color(new HSV_01((level+1)/nbLevel,1,1))
                    viewer.vertices = verticesByDichoLevel[level];
                    viewer.go();
                }
                new mathis.visu3d.LinksViewer(mamesh, this.mathisFrame.scene).go();
                new mathis.visu3d.SurfaceViewer(mamesh, this.mathisFrame.scene).go();
                //$$$eh
            };
            return ReseauDicho;
        }());
        var SolideDicho = (function () {
            function SolideDicho(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "SolideDicho";
                this.$$$title = "we do dichotomy on some solid";
                this.polyhedronType = mathis.creation3D.PolyhedronType.Dodecahedron;
                this.$$$polyhedronType = new documentation.Choices(mathis.allIntegerValueOfEnume(mathis.creation3D.PolyhedronType), { visualValues: mathis.allStringValueOfEnume(mathis.creation3D.PolyhedronType) });
                this.nbInitialDicho = 1;
                this.$$$nbInitialDicho = [0, 1, 2, 3, 4];
                this.mathisFrame = mathisFrame;
            }
            SolideDicho.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                this.go();
            };
            SolideDicho.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$begin
                var creator = new mathis.creation3D.Polyhedron(this.polyhedronType);
                var mamesh = creator.go();
                //n
                var nbInitialDicho = this.nbInitialDicho;
                /**we do triangle-dichotomies several times*/
                for (var i = 0; i < nbInitialDicho; i++) {
                    if (mamesh.smallestTriangles.length > 0)
                        new mathis.mameshModification.TriangleDichotomer(mamesh).go();
                }
                //$$$end
                //$$$bh visualization
                /**we collect vertices according to their dichotomy level*/
                var verticesByDichoLevel = [];
                for (var i = 0; i < mamesh.vertices.length; i++) {
                    var vertex = mamesh.vertices[i];
                    var level = vertex.dichoLevel;
                    if (verticesByDichoLevel[level] == null)
                        verticesByDichoLevel[level] = [];
                    verticesByDichoLevel[level].push(vertex);
                }
                /**we create the visualisation, changing color according according to dichotomy level*/
                var nbLevel = verticesByDichoLevel.length;
                var colorList = [mathis.Color.names.black, mathis.Color.names.whitesmoke, mathis.Color.names.blue, mathis.Color.names.red, mathis.Color.names.orange, mathis.Color.names.violet, mathis.Color.names.beige];
                for (var level = 0; level < nbLevel; level++) {
                    var viewer = new mathis.visu3d.VerticesViewer(mamesh, this.mathisFrame.scene);
                    viewer.color = new mathis.Color(colorList[level]);
                    viewer.vertices = verticesByDichoLevel[level];
                    viewer.go();
                }
                new mathis.visu3d.LinksViewer(mamesh, this.mathisFrame.scene).go();
                new mathis.visu3d.SurfaceViewer(mamesh, this.mathisFrame.scene).go();
                //$$$eh
            };
            return SolideDicho;
        }());
    })(documentation = mathis.documentation || (mathis.documentation = {}));
})(mathis || (mathis = {}));
/**
 * Created by vigon on 05/12/2016.
 */
var mathis;
(function (mathis) {
    var documentation;
    (function (documentation) {
        var GraphDistance = (function () {
            function GraphDistance(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.pageIdAndTitle = "finding vertices using connexity";
                var several = new documentation.SeveralParts();
                several.addPart(new GeodesicDocu(this.mathisFrame));
                several.addPart(new GeodesicGroupDocu(this.mathisFrame));
                several.addPart(new CornerBorderCenterForPolygone(this.mathisFrame));
                //several.addPart(new CornerBorderCenterForReseau(this.mathisFrame),true)
                several.addPart(new TwoGraphDistances(this.mathisFrame));
                several.addPart(new DiameterDocu(this.mathisFrame));
                several.addPart(new PercoForReseau(this.mathisFrame));
                this.severalParts = several;
            }
            GraphDistance.prototype.go = function () {
                return this.severalParts.go();
            };
            return GraphDistance;
        }());
        documentation.GraphDistance = GraphDistance;
        var GeodesicDocu = (function () {
            function GeodesicDocu(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "GeodesicDocu";
                this.$$$title = "Compute distances and geodesics between vertices";
                this.nbSides = 4;
                this.$$$nbSides = [4, 6, 8, 10];
                this.nbSubdivisionInARadius = 7;
                this.$$$nbSubdivisionInARadius = [3, 5, 7, 9, 11];
                // marker=Vertex.Markers.border
                // $$$marker=new Choices([Vertex.Markers.border,Vertex.Markers.corner,Vertex.Markers.center],{"before":"Vertex.Markers.",visualValues:["border","corner","center"]})
                this.randomSeed = 38434;
                this.$$$randomSeed = [38434, 984651, 3481, 9846513, 684123];
                this.onlyOneGeodesic = false;
                this.$$$onlyOneGeodesic = [true, false];
                this.useGraphDistanceVersusDistanceVersusLinkWeights = 0;
                this.$$$useGraphDistanceVersusDistanceVersusLinkWeights = [0, 1, 2];
                this.mathisFrame = mathisFrame;
            }
            GeodesicDocu.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                this.go();
            };
            GeodesicDocu.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                var mathisFrame = this.mathisFrame;
                //$$$begin
                var creator = new mathis.reseau.TriangulatedPolygone(this.nbSides);
                creator.origin = new mathis.XYZ(-1, -1, 0);
                creator.end = new mathis.XYZ(1, 1, 0);
                creator.nbSubdivisionInARadius = this.nbSubdivisionInARadius;
                var mamesh = creator.go();
                var distances = new mathis.graph.DistancesBetweenAllVertices(mamesh.vertices);
                distances.go();
                var random = new mathis.proba.Random(this.randomSeed);
                var vertex0 = mamesh.vertices[random.pseudoRandInt(mamesh.vertices.length)];
                var vertex1 = mamesh.vertices[random.pseudoRandInt(mamesh.vertices.length)];
                mathisFrame.messageDiv.append("distance between vertex0 and vertex1:" + distances.OUT_distance(vertex0, vertex1));
                mathisFrame.messageDiv.append("graph diameter:" + distances.OUT_diameter);
                var onlyOneGeodesic = this.onlyOneGeodesic;
                var geodesics = distances.OUT_allGeodesics(vertex0, vertex1, onlyOneGeodesic);
                //n
                //$$$end
                //$$$bh visualization
                for (var i = 0; i < geodesics.length; i++) {
                    var verticesViewer = new mathis.visu3d.VerticesViewer(mamesh, this.mathisFrame.scene);
                    verticesViewer.vertices = geodesics[i];
                    verticesViewer.color = new mathis.Color(new mathis.HSV_01(i / geodesics.length * 0.7, 1, 1));
                    verticesViewer.go();
                }
                new mathis.visu3d.LinksViewer(mamesh, this.mathisFrame.scene).go();
                //$$$eh
            };
            return GeodesicDocu;
        }());
        var GeodesicGroupDocu = (function () {
            function GeodesicGroupDocu(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "GeodesicGroupDocu";
                this.$$$title = "Compute distances and geodesics from a set of vertices";
                this.nbSides = 4;
                this.$$$nbSides = [4, 6, 8, 10];
                this.nbSubdivisionInARadius = 7;
                this.$$$nbSubdivisionInARadius = [3, 5, 7, 9, 11];
                // marker=Vertex.Markers.border
                // $$$marker=new Choices([Vertex.Markers.border,Vertex.Markers.corner,Vertex.Markers.center],{"before":"Vertex.Markers.",visualValues:["border","corner","center"]})
                this.randomSeed = 38434;
                this.$$$randomSeed = [38434, 984651, 3481, 9846513, 684123];
                this.onlyOneGeodesic = false;
                this.$$$onlyOneGeodesic = [true, false];
                this.left = -0.3;
                this.$$$left = [-0.9, -0.7, -0.5, -0.3, -0.1];
                this.right = 0.3;
                this.$$$right = [0.1, 0.3, 0.5, 0.7, 0.9];
                this.mathisFrame = mathisFrame;
            }
            GeodesicGroupDocu.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                this.go();
            };
            GeodesicGroupDocu.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                var mathisFrame = this.mathisFrame;
                //$$$begin
                var creator = new mathis.reseau.TriangulatedPolygone(this.nbSides);
                creator.origin = new mathis.XYZ(-1, -1, 0);
                creator.end = new mathis.XYZ(1, 1, 0);
                creator.nbSubdivisionInARadius = this.nbSubdivisionInARadius;
                var mamesh = creator.go();
                var group = [];
                var singleVertex;
                for (var i = 0; i < mamesh.vertices.length; i++) {
                    var vertex = mamesh.vertices[i];
                    if (vertex.position.x < this.left)
                        group.push(vertex);
                    if (vertex.position.x > this.right)
                        singleVertex = vertex;
                }
                var distances = new mathis.graph.DistancesFromAGroup(group);
                distances.go();
                mathisFrame.messageDiv.append("distance between vertex and group:" + distances.OUT_distance(singleVertex));
                var onlyOneGeodesic = this.onlyOneGeodesic;
                var geodesics = distances.OUT_allGeodesics(singleVertex, onlyOneGeodesic);
                //n
                //$$$end
                //$$$bh visualization
                for (var i = 0; i < geodesics.length; i++) {
                    var verticesViewer = new mathis.visu3d.VerticesViewer(mamesh, this.mathisFrame.scene);
                    verticesViewer.vertices = geodesics[i];
                    verticesViewer.color = new mathis.Color(new mathis.HSV_01(i / geodesics.length * 0.7, 1, 1));
                    verticesViewer.go();
                }
                var linksViewer = new mathis.visu3d.LinksViewer(mamesh, this.mathisFrame.scene);
                linksViewer.segmentOrientationFunction = function (vertex0, vertex1) {
                    if (group.indexOf(vertex0) != -1 && group.indexOf(vertex1) != -1)
                        return 1;
                    else
                        return 0;
                };
                linksViewer.color = new mathis.Color(mathis.Color.names.red);
                linksViewer.lateralScalingProp = 0.08;
                linksViewer.go();
                new mathis.visu3d.LinksViewer(mamesh, this.mathisFrame.scene).go();
                //$$$eh
            };
            return GeodesicGroupDocu;
        }());
        var DiameterDocu = (function () {
            function DiameterDocu(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "DiameterDocu";
                this.$$$title = "Two methods to find the diameter of polygones. 1/ compute all distances between vertices which is long.\n            2/ an heuristic iterative method. Be aware : If the graph is non-connected, this second method only look at the component of the first vertex.\n            But if the graph is connected, it is hard to find a counter-example where the second method fails. \n            You can see such counter-example by fitting 4/9/0.3 as the three first parameters. ";
                this.nbSides = 4;
                this.$$$nbSides = [4, 6, 8, 10];
                this.nbSubdivisionInARadius = 2;
                this.$$$nbSubdivisionInARadius = [3, 5, 7, 9, 11];
                this.marker = mathis.Vertex.Markers.border;
                this.$$$marker = new documentation.Choices([mathis.Vertex.Markers.border, mathis.Vertex.Markers.corner, mathis.Vertex.Markers.center], { "before": "Vertex.Markers.", visualValues: ["border", "corner", "center"] });
                this.percolationProba = 0.5;
                this.$$$percolationProba = [0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8];
                this.methodChoice = true;
                this.$$$methodChoice = [true, false];
                this.mathisFrame = mathisFrame;
            }
            DiameterDocu.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                this.go();
            };
            DiameterDocu.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                var mathisFrame = this.mathisFrame;
                //$$$begin
                var creator = new mathis.reseau.TriangulatedPolygone(this.nbSides);
                creator.origin = new mathis.XYZ(-1, -1, 0);
                creator.end = new mathis.XYZ(1, 1, 0);
                creator.nbSubdivisionInARadius = this.nbSubdivisionInARadius;
                var mamesh = creator.go();
                var random = new mathis.proba.Random();
                for (var i = 0; i < mamesh.vertices.length; i++) {
                    var vertex = mamesh.vertices[i];
                    for (var j = 0; j < vertex.links.length; j++) {
                        if (random.pseudoRand() < this.percolationProba)
                            mathis.Vertex.separateTwoVoisins(vertex, vertex.links[j].to);
                    }
                }
                var diameter;
                var someExtremeVertices;
                var startingTime = window.performance.now();
                var duration;
                if (this.methodChoice) {
                    var distances = new mathis.graph.DistancesBetweenAllVertices(mamesh.vertices);
                    distances.go();
                    duration = window.performance.now() - startingTime;
                    diameter = distances.OUT_diameter;
                    someExtremeVertices = distances.OUT_allExtremeVertex;
                }
                else {
                    var diameterComputer = new mathis.graph.HeuristicDiameter(mamesh.vertices);
                    diameter = diameterComputer.go();
                    duration = window.performance.now() - startingTime;
                    someExtremeVertices = diameterComputer.OUT_twoChosenExtremeVertices;
                }
                mathisFrame.messageDiv.append("diameter:" + diameter + ", computed in:" + duration + " ms");
                //n
                //$$$end
                //$$$bh visualization
                var verticesViewer0 = new mathis.visu3d.VerticesViewer(mamesh, this.mathisFrame.scene);
                verticesViewer0.vertices = someExtremeVertices;
                verticesViewer0.color = new mathis.Color(mathis.Color.names.indianred);
                verticesViewer0.go();
                //n
                new mathis.visu3d.LinksViewer(mamesh, this.mathisFrame.scene).go();
                //$$$eh
            };
            return DiameterDocu;
        }());
        var CornerBorderCenterForPolygone = (function () {
            function CornerBorderCenterForPolygone(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "CornerBorderCenterForPolygone";
                this.$$$title = "find some marked vertices and their Neighbors ";
                this.nbSides = 6;
                this.$$$nbSides = [4, 6, 8, 10];
                this.nbSubdivisionInARadius = 5;
                this.$$$nbSubdivisionInARadius = [3, 5, 7, 9, 11];
                this.marker = mathis.Vertex.Markers.border;
                this.$$$marker = new documentation.Choices([mathis.Vertex.Markers.border, mathis.Vertex.Markers.corner, mathis.Vertex.Markers.center], { "before": "Vertex.Markers.", visualValues: ["border", "corner", "center"] });
                this.justOneTime = true;
                this.$$$justOneTime = [true, false];
                this.polygoneVersusReseau = true;
                this.$$$polygoneVersusReseau = [true, false];
                this.squareVersusTriangleMaille = false;
                this.$$$squareVersusTriangleMaille = [true, false];
                this.nbI = 7;
                this.$$$nbI = [3, 7, 15, 30];
                this.mathisFrame = mathisFrame;
            }
            CornerBorderCenterForPolygone.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                this.go();
            };
            CornerBorderCenterForPolygone.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$bh
                var creator;
                if (this.polygoneVersusReseau) {
                    creator = new mathis.reseau.TriangulatedPolygone(this.nbSides);
                    creator.origin = new mathis.XYZ(-1, -1, 0);
                    creator.end = new mathis.XYZ(1, 1, 0);
                    creator.nbSubdivisionInARadius = this.nbSubdivisionInARadius;
                }
                else {
                    var basisComputer = new mathis.reseau.BasisForRegularReseau();
                    basisComputer.origin = new mathis.XYZ(-1, -1, 0);
                    basisComputer.end = new mathis.XYZ(1, 1, 0);
                    basisComputer.nbI = this.nbI;
                    basisComputer.set_nbJ_toHaveRegularReseau = true;
                    basisComputer.squareMailleInsteadOfTriangle = this.squareVersusTriangleMaille;
                    creator = new mathis.reseau.Regular(basisComputer);
                }
                //$$$eh
                //$$$begin
                var mamesh = creator.go();
                var markedVertex = [];
                for (var i = 0; i < mamesh.vertices.length; i++) {
                    var vertex = mamesh.vertices[i];
                    if (vertex.hasMark(this.marker))
                        markedVertex.push(vertex);
                }
                var strates = [];
                strates.push(markedVertex);
                if (this.justOneTime) {
                    strates.push(mathis.graph.getEdge(markedVertex));
                }
                else {
                    var alreadySeen = new mathis.HashMap();
                    var curentEdge = markedVertex;
                    while (curentEdge.length > 0) {
                        curentEdge = mathis.graph.getEdge(curentEdge, alreadySeen);
                        strates.push(curentEdge);
                    }
                }
                //$$$end
                //$$$bh visualization
                for (var i = 0; i < strates.length; i++) {
                    var verticesViewer0 = new mathis.visu3d.VerticesViewer(mamesh, this.mathisFrame.scene);
                    verticesViewer0.vertices = strates[i];
                    verticesViewer0.color = new mathis.Color(i);
                    verticesViewer0.go();
                }
                new mathis.visu3d.LinksViewer(mamesh, this.mathisFrame.scene).go();
                //$$$eh
            };
            return CornerBorderCenterForPolygone;
        }());
        //
        // class CornerBorderCenterForReseau implements PieceOfCode {
        //
        //     $$$name = "CornerBorderCenterForReseau"
        //     $$$title = "variant with a regular reseau "
        //
        //     marker=Vertex.Markers.border
        //   $$$marker=new Choices([Vertex.Markers.border,Vertex.Markers.corner,Vertex.Markers.center],{"before":"Vertex.Markers.",visualValues:["border","corner","center"]})
        //
        //     squareVersusTriangleMaille=false
        //     $$$squareVersusTriangleMaille=[true,false]
        //
        //     nbI=7
        //     $$$nbI=[3,7,15,30]
        //
        //     constructor(private mathisFrame:MathisFrame) {
        //         this.mathisFrame = mathisFrame
        //
        //     }
        //
        //     goForTheFirstTime() {
        //
        //         this.mathisFrame.clearScene()
        //         this.mathisFrame.addDefaultCamera()
        //         this.mathisFrame.addDefaultLight()
        //         this.go()
        //     }
        //
        //     go(){
        //
        //
        //         this.mathisFrame.clearScene(false, false)
        //
        //         //$$$begin
        //         let basisComputer = new reseau.BasisForRegularReseau()
        //         basisComputer.origin = new XYZ(-1, -1, 0)
        //         basisComputer.end = new XYZ(1, 1, 0)
        //         basisComputer.nbI = this.nbI
        //         basisComputer.set_nbJ_toHaveRegularReseau=true
        //         basisComputer.squareMailleInsteadOfTriangle = this.squareVersusTriangleMaille
        //         let creator = new reseau.Regular(basisComputer)
        //
        //         let mamesh = creator.go()
        //
        //
        //         //n
        //         let markedVertex = []
        //         mamesh.vertices.forEach((vertex:Vertex)=> {
        //             if (vertex.hasMark(this.marker)) markedVertex.push(vertex)
        //         })
        //
        //         let border = graph.getEdge(markedVertex)
        //
        //         //$$$end
        //
        //
        //         //$$$bh visualization
        //         let verticesViewer0 = new visu3d.VerticesViewer(mamesh, this.mathisFrame.scene)
        //         verticesViewer0.selectedVertices = markedVertex
        //         verticesViewer0.color = new Color(Color.names.indianred)
        //         verticesViewer0.go()
        //
        //         //n
        //         let verticesViewer1 = new visu3d.VerticesViewer(mamesh, this.mathisFrame.scene)
        //         verticesViewer1.selectedVertices = border
        //         verticesViewer1.color = new Color(Color.names.aqua)
        //         verticesViewer1.go()
        //         //n
        //
        //         new visu3d.LinksViewer(mamesh, this.mathisFrame.scene).go()
        //         //$$$eh
        //     }
        // }
        var TwoGraphDistances = (function () {
            function TwoGraphDistances(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "TwoGraphDistances";
                this.$$$title = "For reseaux with squares, considering or not considering the diagonals lead to two different notions of distances : ";
                this.useDiago = true;
                this.$$$useDiago = [true, false];
                this.marker = mathis.Vertex.Markers.center;
                this.$$$marker = new documentation.Choices([mathis.Vertex.Markers.border, mathis.Vertex.Markers.corner, mathis.Vertex.Markers.center], { "before": "Vertex.Markers.", visualValues: ["border", "corner", "center"] });
                this.nbI = 7;
                this.$$$nbI = [3, 7, 15, 30];
                this.justOneTime = true;
                this.$$$justOneTime = [true, false];
                this.mathisFrame = mathisFrame;
            }
            TwoGraphDistances.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                this.go();
            };
            TwoGraphDistances.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$bh creation of a squared mesh
                var basisComputer = new mathis.reseau.BasisForRegularReseau();
                basisComputer.origin = new mathis.XYZ(-1, -1, 0);
                basisComputer.end = new mathis.XYZ(1, 1, 0);
                basisComputer.nbI = this.nbI;
                basisComputer.set_nbJ_toHaveRegularReseau = true;
                var creator = new mathis.reseau.Regular(basisComputer);
                var mamesh = creator.go();
                //$$$eh
                //$$$begin
                var considerDiagonals = this.useDiago;
                var markedVertex = [];
                for (var i = 0; i < mamesh.vertices.length; i++) {
                    var vertex = mamesh.vertices[i];
                    if (vertex.hasMark(this.marker))
                        markedVertex.push(vertex);
                }
                var strates = [];
                strates.push(markedVertex);
                if (this.justOneTime) {
                    if (considerDiagonals)
                        strates.push(mathis.graph.getEdgeConsideringAlsoDiagonalVoisin(markedVertex));
                    else
                        strates.push(mathis.graph.getEdge(markedVertex));
                }
                else {
                    var alreadySeen = new mathis.HashMap();
                    var curentEdge = markedVertex;
                    while (curentEdge.length > 0) {
                        if (considerDiagonals)
                            curentEdge = mathis.graph.getEdgeConsideringAlsoDiagonalVoisin(curentEdge, alreadySeen);
                        else
                            curentEdge = mathis.graph.getEdge(curentEdge, alreadySeen);
                        strates.push(curentEdge);
                    }
                }
                //
                //
                // let strates=[]
                // if (ringifyTheWholeReseau){
                //     if (considerDiagonals) strates=graph.ringifyConsideringAlsoDiagonalVoisin(markedVertex )
                //     else strates=graph.ringify(markedVertex)
                // }
                // else{
                //     strates.push(markedVertex)
                //     if (considerDiagonals) strates.push(graph.getEdgeConsideringAlsoDiagonalVoisin(markedVertex))
                //     else strates.push(graph.getEdge(markedVertex))
                // }
                //$$$end
                //$$$bh visualization
                for (var i = 0; i < strates.length; i++) {
                    var verticesViewer0 = new mathis.visu3d.VerticesViewer(mamesh, this.mathisFrame.scene);
                    verticesViewer0.vertices = strates[i];
                    verticesViewer0.color = new mathis.Color(i);
                    verticesViewer0.go();
                }
                new mathis.visu3d.LinksViewer(mamesh, this.mathisFrame.scene).go();
                //$$$eh
            };
            return TwoGraphDistances;
        }());
        var PercoForReseau = (function () {
            function PercoForReseau(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "PercoForReseau";
                this.$$$title = "get a connected component ";
                this.marker = mathis.Vertex.Markers.border;
                this.$$$marker = new documentation.Choices([mathis.Vertex.Markers.border, mathis.Vertex.Markers.corner, mathis.Vertex.Markers.center], { "before": "Vertex.Markers.", visualValues: ["border", "corner", "center"] });
                this.squareVersusTriangleMaille = false;
                this.$$$squareVersusTriangleMaille = [true, false];
                this.nbI = 7;
                this.$$$nbI = [3, 7, 15, 30];
                this.probaToKeep = 0.5;
                this.$$$probaToKeep = [0, 0.4, 0.45, 0.5, 0.55, 0.6, 0.8, 1];
                this.mathisFrame = mathisFrame;
            }
            PercoForReseau.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                this.go();
            };
            PercoForReseau.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$begin
                var basisComputer = new mathis.reseau.BasisForRegularReseau();
                basisComputer.origin = new mathis.XYZ(-1, -1, 0);
                basisComputer.end = new mathis.XYZ(1, 1, 0);
                basisComputer.nbI = this.nbI;
                basisComputer.set_nbJ_toHaveRegularReseau = true;
                basisComputer.squareMailleInsteadOfTriangle = this.squareVersusTriangleMaille;
                var creator = new mathis.reseau.Regular(basisComputer);
                var mamesh = creator.go();
                var probaToKeep = this.probaToKeep;
                var admissibleForGroup = new mathis.HashMap(true);
                var centerVertices = [];
                for (var i = 0; i < mamesh.vertices.length; i++) {
                    var vertex = mamesh.vertices[i];
                    if (Math.random() < probaToKeep)
                        admissibleForGroup.putValue(vertex, true);
                    if (vertex.hasMark(mathis.Vertex.Markers.center)) {
                        centerVertices.push(vertex);
                        admissibleForGroup.putValue(vertex, true);
                    }
                }
                var centralComponent = mathis.graph.getGroup(centerVertices, admissibleForGroup);
                //$$$end
                //$$$bh visualization
                var verticesViewer = new mathis.visu3d.VerticesViewer(mamesh, this.mathisFrame.scene);
                verticesViewer.vertices = centralComponent;
                verticesViewer.radiusProp = 0.5;
                verticesViewer.go();
                //$$$eh
            };
            return PercoForReseau;
        }());
    })(documentation = mathis.documentation || (mathis.documentation = {}));
})(mathis || (mathis = {}));
/**
 * Created by vigon on 01/02/2017.
 */
/**
 * Created by vigon on 05/12/2016.
 */
var mathis;
(function (mathis) {
    var documentation;
    (function (documentation) {
        var GrateMergeStick = (function () {
            function GrateMergeStick(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.pageIdAndTitle = "Grating and gluing";
                var several = new documentation.SeveralParts();
                several.addPart(new GrateGluedMamesh(this.mathisFrame));
                several.addPart(new GrateMamesh(this.mathisFrame));
                several.addPart(new GrateMameshConcentric(this.mathisFrame), true);
                several.addPart(new MergeVersusStick(this.mathisFrame));
                this.severalParts = several;
            }
            GrateMergeStick.prototype.go = function () {
                return this.severalParts.go();
            };
            return GrateMergeStick;
        }());
        documentation.GrateMergeStick = GrateMergeStick;
        var GrateMamesh = (function () {
            function GrateMamesh(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "GrateMamesh";
                this.$$$title = "When two mameshes overlap (they are concurrent), we could want to grate them to suppress overlapping.  \n            Grating process starts from seeds: each concurrent have some given (or computed) seeds which are keep (and represented here as red bullet). \n            Around these seeds, we compute strates, and we keep their cell, until strates of concurrent overlap";
                this.nbSides0 = 6;
                this.$$$nbSides0 = [4, 6, 8, 10];
                this.nbSides1 = 6;
                this.$$$nbSides1 = [4, 6, 8, 10];
                this.nbSubdivisionInARadius0 = 9;
                this.$$$nbSubdivisionInARadius0 = [3, 5, 7, 9, 11];
                this.nbSubdivisionInARadius1 = 5;
                this.$$$nbSubdivisionInARadius1 = [3, 5, 7, 9, 11];
                this.grate = true;
                this.$$$grate = [true, false];
                this.neighborhoodCoefficient0 = 0.7;
                this.$$$neighborhoodCoefficient0 = [0.5, 0.7, 1, 2];
                this.neighborhoodCoefficient1 = 0.7;
                this.$$$neighborhoodCoefficient1 = [0.5, 0.7, 1, 2];
                this.proportionOfSeed0 = 0.1;
                this.$$$proportionOfSeed0 = [0.1, 0.3, 0.5, 0.7];
                this.proportionOfSeed1 = 0.1;
                this.$$$proportionOfSeed1 = [0.1, 0.3, 0.5, 0.7];
                this.seedComputedFromBarycentersVersusFromAllPossibleCells = true;
                this.$$$seedComputedFromBarycentersVersusFromAllPossibleCells = [true, false];
                this.mathisFrame = mathisFrame;
            }
            GrateMamesh.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                this.go();
            };
            GrateMamesh.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$begin
                var creator0 = new mathis.reseau.TriangulatedPolygone(this.nbSides0);
                creator0.origin = new mathis.XYZ(-1, -1, 0);
                creator0.end = new mathis.XYZ(0.5, 0.5, 0);
                creator0.nbSubdivisionInARadius = this.nbSubdivisionInARadius0;
                var mamesh0 = creator0.go();
                var creator1 = new mathis.reseau.TriangulatedPolygone(this.nbSides1);
                creator1.origin = new mathis.XYZ(-0.5, -0.5, 0);
                creator1.end = new mathis.XYZ(1, 1, 0);
                creator1.nbSubdivisionInARadius = this.nbSubdivisionInARadius1;
                var mamesh1 = creator1.go();
                var grater = null;
                if (this.grate) {
                    grater = new mathis.grateAndGlue.GraphGrater();
                    grater.IN_graphFamily.push(mamesh0.vertices, mamesh1.vertices);
                    //n
                    /** this params determine the neighborhood of each graph (this param are proportions)
                     * If too small, cells could penetrate each others.
                     * E.g keep all the defaults, and set the first number to 0.5*/
                    grater.proximityCoefToGrate = [this.neighborhoodCoefficient0, this.neighborhoodCoefficient1];
                    /** There are two ways to select seeds :
                     * --- if seedComputedFromBarycenters : seeds are vertices the farthest of barycenter of concurrents.
                     * --- is seedComputedFromAllPossibleCell : seeds are all vertices which is not to close to a concurrent.*/
                    grater.seedComputedFromBarycentersVersusFromAllPossibleCells = this.seedComputedFromBarycentersVersusFromAllPossibleCells;
                    /**Determine the proportion of seeds of each concurrent: only useful is previous attribute is true*/
                    grater.proportionOfSeeds = [this.proportionOfSeed0, this.proportionOfSeed1];
                    var remainingVertices = grater.go();
                    //n
                    mamesh0 = new mathis.grateAndGlue.SubMameshExtractor(mamesh0, remainingVertices[0]).go();
                    mamesh0.isolateMameshVerticesFromExteriorVertices();
                    mamesh1 = new mathis.grateAndGlue.SubMameshExtractor(mamesh1, remainingVertices[1]).go();
                    mamesh1.isolateMameshVerticesFromExteriorVertices();
                }
                //$$$end
                //$$$bh visualization
                if (grater != null) {
                    var verticesViewer0 = new mathis.visu3d.VerticesViewer(mamesh0, this.mathisFrame.scene);
                    verticesViewer0.vertices = grater.OUT_allSeeds[0];
                    verticesViewer0.color = new mathis.Color(mathis.Color.names.red);
                    verticesViewer0.go();
                    var verticesViewer1 = new mathis.visu3d.VerticesViewer(mamesh1, this.mathisFrame.scene);
                    verticesViewer1.vertices = grater.OUT_allSeeds[1];
                    verticesViewer1.color = new mathis.Color(mathis.Color.names.red);
                    verticesViewer1.go();
                }
                //n
                var linkViewer0 = new mathis.visu3d.LinksViewer(mamesh0, this.mathisFrame.scene);
                linkViewer0.color = new mathis.Color(mathis.Color.names.darkseagreen);
                linkViewer0.go();
                var linkViewer1 = new mathis.visu3d.LinksViewer(mamesh1, this.mathisFrame.scene);
                linkViewer1.color = new mathis.Color(mathis.Color.names.blueviolet);
                linkViewer1.go();
                //$$$eh
            };
            return GrateMamesh;
        }());
        var GrateMameshConcentric = (function () {
            function GrateMameshConcentric(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "GrateMameshConcentric";
                this.$$$title = "Variant with two concentric mameshes";
                this.nbSides0 = 6;
                this.$$$nbSides0 = [4, 6, 8, 10];
                this.nbSides1 = 6;
                this.$$$nbSides1 = [4, 6, 8, 10];
                this.nbSubdivisionInARadius0 = 9;
                this.$$$nbSubdivisionInARadius0 = [3, 5, 7, 9, 11];
                this.nbSubdivisionInARadius1 = 5;
                this.$$$nbSubdivisionInARadius1 = [3, 5, 7, 9, 11];
                this.grate = true;
                this.$$$grate = [true, false];
                this.neighborhoodCoefficient0 = 0.7;
                this.$$$neighborhoodCoefficient0 = [0.5, 0.7, 1, 2];
                this.neighborhoodCoefficient1 = 0.7;
                this.$$$neighborhoodCoefficient1 = [0.5, 0.7, 1, 2];
                this.proportionOfSeed0 = 0.1;
                this.$$$proportionOfSeed0 = [0.1, 0.3, 0.5, 0.7];
                this.proportionOfSeed1 = 0.1;
                this.$$$proportionOfSeed1 = [0.1, 0.3, 0.5, 0.7];
                this.seedComputedFromBarycentersVersusFromAllPossibleCells = true;
                this.$$$seedComputedFromBarycentersVersusFromAllPossibleCells = [true, false];
                this.mathisFrame = mathisFrame;
            }
            GrateMameshConcentric.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                this.go();
            };
            GrateMameshConcentric.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$begin
                var creator0 = new mathis.reseau.TriangulatedPolygone(this.nbSides0);
                creator0.origin = new mathis.XYZ(-1, -1, 0);
                creator0.end = new mathis.XYZ(1, 1, 0);
                creator0.nbSubdivisionInARadius = this.nbSubdivisionInARadius0;
                var mamesh0 = creator0.go();
                var creator1 = new mathis.reseau.TriangulatedPolygone(this.nbSides1);
                creator1.origin = new mathis.XYZ(-0.5, -0.5, 0);
                creator1.end = new mathis.XYZ(0.5, 0.5, 0);
                creator1.nbSubdivisionInARadius = this.nbSubdivisionInARadius1;
                var mamesh1 = creator1.go();
                var grater = null;
                if (this.grate) {
                    grater = new mathis.grateAndGlue.GraphGrater();
                    grater.IN_graphFamily.push(mamesh0.vertices, mamesh1.vertices);
                    //n
                    grater.proximityCoefToGrate = [this.neighborhoodCoefficient0, this.neighborhoodCoefficient1];
                    /** When a mamesh cover the other, the false option make disappear the covered one*/
                    grater.seedComputedFromBarycentersVersusFromAllPossibleCells = this.seedComputedFromBarycentersVersusFromAllPossibleCells;
                    /**Determine the proportion of seeds of each concurrent: only useful is previous attribute is true*/
                    grater.proportionOfSeeds = [this.proportionOfSeed0, this.proportionOfSeed1];
                    var remainingVertices = grater.go();
                    //n
                    mamesh0 = new mathis.grateAndGlue.SubMameshExtractor(mamesh0, remainingVertices[0]).go();
                    mamesh0.isolateMameshVerticesFromExteriorVertices();
                    mamesh1 = new mathis.grateAndGlue.SubMameshExtractor(mamesh1, remainingVertices[1]).go();
                    mamesh1.isolateMameshVerticesFromExteriorVertices();
                }
                //$$$end
                //$$$bh visualization
                if (grater != null) {
                    var verticesViewer0 = new mathis.visu3d.VerticesViewer(mamesh0, this.mathisFrame.scene);
                    verticesViewer0.vertices = grater.OUT_allSeeds[0];
                    verticesViewer0.color = new mathis.Color(mathis.Color.names.red);
                    verticesViewer0.go();
                    var verticesViewer1 = new mathis.visu3d.VerticesViewer(mamesh1, this.mathisFrame.scene);
                    verticesViewer1.vertices = grater.OUT_allSeeds[1];
                    verticesViewer1.color = new mathis.Color(mathis.Color.names.red);
                    verticesViewer1.go();
                }
                //n
                var linkViewer0 = new mathis.visu3d.LinksViewer(mamesh0, this.mathisFrame.scene);
                linkViewer0.color = new mathis.Color(mathis.Color.names.darkseagreen);
                linkViewer0.go();
                var linkViewer1 = new mathis.visu3d.LinksViewer(mamesh1, this.mathisFrame.scene);
                linkViewer1.color = new mathis.Color(mathis.Color.names.blueviolet);
                linkViewer1.go();
                //$$$eh
            };
            return GrateMameshConcentric;
        }());
        var GrateGluedMamesh = (function () {
            function GrateGluedMamesh(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "GrateGluedMamesh";
                this.$$$title = "When two mameshes overlap (they are concurrent), we could want to grate them and to stick them.  \n            Techniques for grating and Sticking are detail further on.";
                this.nbSides0 = 6;
                this.$$$nbSides0 = [4, 6, 8, 10];
                this.nbSides1 = 6;
                this.$$$nbSides1 = [4, 6, 8, 10];
                this.nbSubdivisionInARadius0 = 9;
                this.$$$nbSubdivisionInARadius0 = [3, 5, 7, 9, 11];
                this.nbSubdivisionInARadius1 = 5;
                this.$$$nbSubdivisionInARadius1 = [3, 5, 7, 9, 11];
                this.toleranceToBeOneOfTheClosest = 0.5;
                this.$$$toleranceToBeOneOfTheClosest = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7];
                this.proportionOfSeed0 = 0.1;
                this.$$$proportionOfSeed0 = [0.1, 0.3, 0.5, 0.7];
                this.proportionOfSeed1 = 0.1;
                this.$$$proportionOfSeed1 = [0.1, 0.3, 0.5, 0.7];
                this.proximityCoefToStick = 2;
                this.$$$proximityCoefToStick = [1, 1.5, 2, 3];
                this.suppressLinksAngularlyTooClose = false;
                this.$$$suppressLinksAngularlyTooClose = [true, false];
                this.propAngle = 0.1;
                this.$$$propAngle = [0.01, 0.05, 0.1, 0.2, 0.3];
                this.justGrateDoNotStick = false;
                this.$$$justGrateDoNotStick = [true, false];
                this.mathisFrame = mathisFrame;
            }
            GrateGluedMamesh.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                this.go();
            };
            GrateGluedMamesh.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$bh mameshes creation
                var creator0 = new mathis.reseau.TriangulatedPolygone(this.nbSides0);
                creator0.origin = new mathis.XYZ(-1, -1, 0);
                creator0.end = new mathis.XYZ(0.5, 0.5, 0);
                creator0.nbSubdivisionInARadius = this.nbSubdivisionInARadius0;
                var mamesh0 = creator0.go();
                var creator1 = new mathis.reseau.TriangulatedPolygone(this.nbSides1);
                creator1.origin = new mathis.XYZ(-0.5, -0.5, 0);
                creator1.end = new mathis.XYZ(1, 1, 0);
                creator1.nbSubdivisionInARadius = this.nbSubdivisionInARadius1;
                var mamesh1 = creator1.go();
                //$$$eh
                //$$$begin
                var graterAndSticker = new mathis.grateAndGlue.ConcurrentMameshesGraterAndSticker();
                graterAndSticker.IN_mameshes.push(mamesh0, mamesh1);
                graterAndSticker.justGrateDoNotStick = this.justGrateDoNotStick;
                /**all attributes of the grating process (see above) could be ruled via this SUB_object. Here we just change one.*/
                graterAndSticker.SUB_grater.proportionOfSeeds = [this.proportionOfSeed0, this.proportionOfSeed1];
                /** Coef ruling the neighborhood zone of vertices.
                 *  More big is this coef, more we accept far neighbors,  and so more we stick far vertices */
                graterAndSticker.proximityCoefToStick = [this.proximityCoefToStick];
                /**if 0    -->  only the closest neighbor is stick
                 * if 0.10 -->  all vertices which are positioned up to 10% further than the closest are stick
                 * if 0.1  -->  ...
                 * be careful, if too big links can cross themselves:
                 * which can be solve by clearing links making too small angles each others.
                 * */
                graterAndSticker.toleranceToBeOneOfTheClosest = this.toleranceToBeOneOfTheClosest;
                //n
                graterAndSticker.suppressLinksAngularlyTooClose = this.suppressLinksAngularlyTooClose;
                /**links cleaning is made by a SUB object that we can parametrize: */
                graterAndSticker.SUB_linkCleanerByAngle.suppressLinksAngularParam = 2 * Math.PI * this.propAngle;
                var mamesh = graterAndSticker.goChanging();
                //$$$end
                //$$$bh visualization
                var linkViewer0 = new mathis.visu3d.LinksViewer(mamesh, this.mathisFrame.scene);
                linkViewer0.go();
                /**source vertices in blue*/
                var verticesViewerSource = new mathis.visu3d.VerticesViewer(mamesh, this.mathisFrame.scene);
                verticesViewerSource.vertices = graterAndSticker.OUT_stickingMap.allKeys();
                verticesViewerSource.color = new mathis.Color(mathis.Color.names.blueviolet);
                verticesViewerSource.go();
                /**receiver vertices in red*/
                var verticesViewer = new mathis.visu3d.VerticesViewer(mamesh, this.mathisFrame.scene);
                verticesViewer.vertices = [];
                for (var _i = 0, _a = graterAndSticker.OUT_stickingMap.allValues(); _i < _a.length; _i++) {
                    var vertices = _a[_i];
                    verticesViewer.vertices = verticesViewer.vertices.concat(vertices);
                }
                verticesViewer.go();
                //$$$eh
            };
            return GrateGluedMamesh;
        }());
        var MergeVersusStick = (function () {
            function MergeVersusStick(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "MergeVersusStick";
                this.$$$title = "Merging or Sticking mameshes";
                this.oneVersusTwoMameshes = false;
                this.$$$oneVersusTwoMameshes = [true, false];
                this.toleranceToBeOneOfTheClosest = 0.05;
                this.$$$toleranceToBeOneOfTheClosest = [0, 0.05, 0.1, 0.2, 0.5, 1, 1.5, 2];
                this.suppressLinksAngularlyTooClose = false;
                this.$$$suppressLinksAngularlyTooClose = [true, false];
                this.stickOrMerge = true;
                this.$$$stickOrMerge = [true, false];
                this.proximityCoef = 1.2;
                this.$$$proximityCoef = [0.2, 0.5, 0.8, 1, 1.2, 1.5, 2, 3];
                this.angle = 0.01;
                this.$$$angle = [0, 0.005, 0.01, 0.02, 0.05];
                this.slow = true;
                this.$$$slow = [true, false];
                this.resolution = 10;
                this.$$$resolution = [5, 10, 15, 20];
                this.hole = 0.97;
                this.$$$hole = [0.8, 0.9, 0.95, 0.97, 0.99, 1];
                this.mathisFrame = mathisFrame;
            }
            MergeVersusStick.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                this.go();
            };
            MergeVersusStick.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$b
                var oneVersusTwoMameshes = this.oneVersusTwoMameshes;
                //$$$e
                //$$$bh mameshes creation
                var vertices0 = [];
                var vertices1 = [];
                var mamesh0;
                var mamesh1;
                if (oneVersusTwoMameshes) {
                    var basis = new mathis.reseau.BasisForRegularReseau();
                    basis.origin = new mathis.XYZ(0, -0.7, 0);
                    basis.end = new mathis.XYZ(2 * Math.PI, 0.7, 0);
                    basis.nbI = 20;
                    basis.nbJ = 10;
                    basis.nbHorizontalDecays = 2;
                    mamesh0 = new mathis.reseau.Regular(basis).go();
                    mamesh1 = mamesh0;
                    for (var _i = 0, _a = mamesh0.vertices; _i < _a.length; _i++) {
                        var v = _a[_i];
                        if (v.param.x == 0)
                            vertices0.push(v);
                        else if (v.param.x == basis.nbI - 1)
                            vertices1.push(v);
                    }
                    for (var i = 0; i < mamesh0.vertices.length; i++) {
                        var position = mamesh0.vertices[i].position;
                        var theta = position.x * this.hole;
                        position.x = Math.cos(theta - Math.PI / 2);
                        position.z = Math.sin(theta - Math.PI / 2);
                    }
                }
                else {
                    var basis0 = new mathis.reseau.BasisForRegularReseau();
                    basis0.origin = new mathis.XYZ(-1, -0.9, 0);
                    basis0.end = new mathis.XYZ(-0.05, 1.1, 0);
                    basis0.nbI = 5;
                    basis0.nbJ = 10;
                    mamesh0 = new mathis.reseau.Regular(basis0).go();
                    var basis1 = new mathis.reseau.BasisForRegularReseau();
                    basis1.origin = new mathis.XYZ(0.05, -1, 0);
                    basis1.end = new mathis.XYZ(1, 1, 0);
                    basis1.nbI = 5;
                    basis1.nbJ = 10;
                    mamesh1 = new mathis.reseau.Regular(basis1).go();
                    vertices0 = mamesh0.vertices;
                    vertices1 = mamesh1.vertices;
                    /**with big angle, the two mameshes overlap, and the result is not nice
                     * -> we need to grate mameshes before (see further on)*/
                    new mathis.spacialTransformations.Similitude(mamesh1.vertices, 2 * Math.PI * this.angle).goChanging();
                }
                //$$$eh
                //$$$begin
                /**two ways for creating a map vertex->Vertex[] (source->receivers) to say which vertices are stick or merge with other */
                var map;
                if (this.slow) {
                    var mapFinder = new mathis.grateAndGlue.FindSickingMapFromVertices(vertices0, vertices1);
                    /**if e.g. equal to 2, then two vertices are declared to be close when their distance is at most 2 times the mean distance of their link */
                    mapFinder.proximityCoef = this.proximityCoef;
                    /**if equal to 0, in the map vertex->Vertex[] (source->receivers), receivers is a list of only one vertex : the closest one to the source.
                     * If equal to 2 (e.g.),receivers contain the closest vertices from source (let's say the distance is d)
                     * and also all the vertices at distance less that 2*d  */
                    mapFinder.toleranceToBeOneOfTheClosest = this.toleranceToBeOneOfTheClosest;
                    map = mapFinder.go();
                }
                else {
                    /** A fast method: it creates a dictionary or approximative vertex-positions, which avoid a double loop over
                     * the two vertex-list. The proximity is parametrized by {@link FindCloseVerticesFast#nbDistinctPoint}
                     * which indicate how many different positions are allowed between the two extreme points (typically 1000).
                     * (imagine that it creates a sort of grid, as in classical drawing software). With very small values (e.g. 5)
                     * the behaviour is weird.
                     * */
                    var mapFinder = new mathis.grateAndGlue.FindCloseVerticesFast(vertices0, vertices1);
                    mapFinder.nbDistinctPoint = this.resolution;
                    map = mapFinder.go();
                }
                //$$$e
                //$$$bh  Warning : vertices0 and vertices1 might be disjoint...
                /** Sources and Receiver must be disjoint for sticking or merging.
                 * In the present code, we have construct two lists vertices0 and vertices1 which are disjoints.
                 * You can give non-disjoint lists to {@link FindCloseVerticesFast} which make a choice to
                 * separate sources and receiver.
                 * You can also give non-disjoint list to {@link FindSickingMapFromVertices} but in this case
                 * you must set {@link FindSickingMapFromVertices#acceptOnlyDisjointReceiverAndSource} to false;
                 * and after you have to make yourself the separation between source and receiver*/
                //$$$eh
                //$$$b
                //n
                /**compare merging and sticking*/
                if (this.stickOrMerge) {
                    /**sticking : links are added from source to all its receivers*/
                    var sticker = new mathis.grateAndGlue.Sticker(mamesh0, mamesh1, map);
                    sticker.goChanging();
                }
                else {
                    /**merging : the source is sent to the first receiver (the closest) */
                    var merger = new mathis.grateAndGlue.Merger(mamesh0, mamesh1, map);
                    merger.goChanging();
                }
                //n
                if (this.suppressLinksAngularlyTooClose) {
                    new mathis.linkModule.LinksSorterAndCleanerByAngles(mamesh0).goChanging();
                }
                //$$$end
                //$$$bh visualization
                var linkViewer0 = new mathis.visu3d.LinksViewer(mamesh0, this.mathisFrame.scene);
                linkViewer0.go();
                new mathis.visu3d.SurfaceViewer(mamesh0, this.mathisFrame.scene).go();
                //$$$eh
            };
            return MergeVersusStick;
        }());
    })(documentation = mathis.documentation || (mathis.documentation = {}));
})(mathis || (mathis = {}));
/**
 * Created by vigon on 26/12/2016.
 */
/**
 * Created by vigon on 22/12/2016.
 */
/**
 * Created by vigon on 21/11/2016.
 */
var mathis;
(function (mathis) {
    var documentation;
    (function (documentation) {
        var LinesViewingDocu = (function () {
            function LinesViewingDocu(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.pageIdAndTitle = "Lines viewing";
                var severalParts = new documentation.SeveralParts();
                severalParts.addPart(new ChoseColorOfLinesAccordingToLevel(this.mathisFrame));
                severalParts.addPart(new JustTheSizeOfLines(this.mathisFrame));
                severalParts.addPart(new ChoseColorOfLinesAccordingToSymmetries(this.mathisFrame));
                severalParts.addPart(new ChoseColorOfLinesBifurcation(this.mathisFrame));
                severalParts.addComment("The lineViewer call the method mamesh.fillLineCatalogue() which compute\n                   all lines passing throw vertices of the mamesh. But you can decide to fill the catalogue before\n                   to call the viewer, and to not add all the lines. Here is some examples.", "The lineViewer call the method mamesh");
                severalParts.addPart(new DoNotDrawAllTheLines(this.mathisFrame));
                severalParts.addPart(new DoNotDrawAllTheLines3d(this.mathisFrame), true);
                severalParts.addPart(new DrawOnlyLinePassingInside(this.mathisFrame));
                this.severalParts = severalParts;
            }
            LinesViewingDocu.prototype.go = function () {
                return this.severalParts.go();
            };
            return LinesViewingDocu;
        }());
        documentation.LinesViewingDocu = LinesViewingDocu;
        var JustTheSizeOfLines = (function () {
            function JustTheSizeOfLines(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "JustTheSizeOfLines";
                this.$$$title = "We change radius and interpolation style";
                this.nbSides = 4;
                this.$$$nbSides = [4, 7, 10];
                this.nbSubdivisionInARadius = 3;
                this.$$$nbSubdivisionInARadius = [2, 3, 5];
                this.color = mathis.Color.names.rebeccapurple;
                this.$$$color = new documentation.Choices([mathis.Color.names.rebeccapurple, mathis.Color.names.rosybrown, mathis.Color.names.darkorange], { 'before': 'Color.names.', 'visualValues': ['rebeccapurple', 'rosybrown', 'darkorange'] });
                this.radiusProp = 0.05;
                this.$$$radiusProp = [0.01, 0.05, 0.1];
                this.constantRadius = null;
                this.$$$constantRadius = [null, 0.01, 0.02, 0.05];
                this.isThin = false;
                this.$$$isThin = [true, false];
                this.radiusFunction = null;
                this.$$$radiusFunction = [null, function (i, alpha) { return 0.02 * Math.sin(2 * Math.PI * alpha); }];
                this.interpolationStyle = mathis.geometry.InterpolationStyle.octavioStyle;
                this.$$$interpolationStyle = new documentation.Choices(mathis.allIntegerValueOfEnume(mathis.geometry.InterpolationStyle), { "before": "geometry.InterpolationStyle.", "visualValues": mathis.allStringValueOfEnume(mathis.geometry.InterpolationStyle) });
            }
            JustTheSizeOfLines.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                this.go();
            };
            JustTheSizeOfLines.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$b
                var creator = new mathis.reseau.TriangulatedPolygone(this.nbSides);
                creator.nbSubdivisionInARadius = this.nbSubdivisionInARadius;
                var mamesh = creator.go();
                //n
                var linesViewer = new mathis.visu3d.LinesViewer(mamesh, this.mathisFrame.scene);
                linesViewer.interpolationOption.interpolationStyle = this.interpolationStyle;
                //n
                /**to have line of one pixel*/
                linesViewer.isThin = this.isThin;
                /**useless is previous is not false :
                 * argument 'i' is the index of the line in the lineCatalogue of the mamesh (see further)
                 * argument 'alpha' in range [0,1] is the position in the line
                 * return the radius of the i-th lines at the position alpha*/
                linesViewer.radiusFunction = this.radiusFunction;
                /**useless if one of the previous is not null/false*/
                linesViewer.constantRadius = this.constantRadius;
                /**useless if one of the previous is not null/false*/
                linesViewer.radiusProp = this.radiusProp;
                linesViewer.go();
                //$$$e
                //$$$bh vertices viewing
                var verticesViewer = new mathis.visu3d.VerticesViewer(mamesh, this.mathisFrame.scene);
                verticesViewer.radiusProp = 0.1;
                verticesViewer.go();
                //$$$eh
            };
            return JustTheSizeOfLines;
        }());
        var DoNotDrawAllTheLines = (function () {
            function DoNotDrawAllTheLines(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "DoNotDrawAllTheLines";
                this.$$$title = "We construct only the lines starting from selected vertices.";
                this.nbI = 10;
                this.$$$nbI = [5, 10, 12, 15, 20];
                this.selectionChoice = 0;
                this.$$$selectionChoice = [0, 1, 2];
            }
            DoNotDrawAllTheLines.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                this.go();
            };
            DoNotDrawAllTheLines.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$b
                var basis = new mathis.reseau.BasisForRegularReseau();
                basis.nbI = this.nbI;
                basis.nbJ = basis.nbI;
                basis.origin = new mathis.XYZ(-0.7, -0.7, 0);
                basis.end = new mathis.XYZ(+0.7, +0.7, 0);
                var creator = new mathis.reseau.Regular(basis);
                var mamesh = creator.go();
                var lineBuilder = new mathis.lineModule.LineComputer(mamesh);
                lineBuilder.startingVertices = [];
                var selectionChoice = this.selectionChoice;
                for (var i = 0; i < mamesh.vertices.length; i++) {
                    var vertex = mamesh.vertices[i];
                    if (selectionChoice == 0) {
                        if (vertex.param.x % 3 == 0 && vertex.param.y == 0)
                            lineBuilder.startingVertices.push(vertex);
                    }
                    else if (selectionChoice == 1) {
                        if (vertex.param.x % 3 == 0 && vertex.param.y == 0)
                            lineBuilder.startingVertices.push(vertex);
                        if (vertex.param.x == 0 && vertex.param.y % 3 == 0)
                            lineBuilder.startingVertices.push(vertex);
                    }
                    else if (selectionChoice == 2) {
                        if (vertex.position.length() < 0.25)
                            lineBuilder.startingVertices.push(vertex);
                    }
                }
                mamesh.lines = lineBuilder.go();
                //n
                var linesViewer = new mathis.visu3d.LinesViewer(mamesh, this.mathisFrame.scene);
                linesViewer.go();
                //$$$e
                //$$$bh vertices viewing
                var verticesViewer = new mathis.visu3d.VerticesViewer(mamesh, this.mathisFrame.scene);
                verticesViewer.radiusProp = 0.1;
                verticesViewer.go();
                //$$$eh
            };
            return DoNotDrawAllTheLines;
        }());
        var DoNotDrawAllTheLines3d = (function () {
            function DoNotDrawAllTheLines3d(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "DoNotDrawAllTheLines3d";
                this.$$$title = "variant with 3d cartesian reseau";
                this.nbI = 10;
                this.$$$nbI = [5, 10, 12, 15, 20];
                this.selectionChoice = 0;
                this.$$$selectionChoice = [0, 1, 2];
            }
            DoNotDrawAllTheLines3d.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                this.go();
            };
            DoNotDrawAllTheLines3d.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$b
                var creator = new mathis.reseau.Regular3D();
                creator.nbI = this.nbI;
                creator.nbJ = creator.nbI;
                creator.nbK = creator.nbI;
                creator.Vi = new mathis.XYZ(0.1, 0, 0);
                creator.Vj = new mathis.XYZ(0, 0.1, 0);
                creator.Vk = new mathis.XYZ(0, 0, 0.1);
                var mamesh = creator.go();
                var lineBuilder = new mathis.lineModule.LineComputer(mamesh);
                lineBuilder.startingVertices = [];
                var selectionChoice = this.selectionChoice;
                for (var i = 0; i < mamesh.vertices.length; i++) {
                    var vertex = mamesh.vertices[i];
                    if (selectionChoice == 0) {
                        if (vertex.param.x % 3 == 0 && vertex.param.y == 0)
                            lineBuilder.startingVertices.push(vertex);
                    }
                    else if (selectionChoice == 1) {
                        if (vertex.param.x % 3 == 0 && vertex.param.y == 0 && vertex.param.z == 0)
                            lineBuilder.startingVertices.push(vertex);
                        if (vertex.param.x == 0 && vertex.param.y % 3 == 0 && vertex.param.z == 0)
                            lineBuilder.startingVertices.push(vertex);
                        if (vertex.param.x == 0 && vertex.param.y == 0 && vertex.param.z % 3 == 0)
                            lineBuilder.startingVertices.push(vertex);
                    }
                    else if (selectionChoice == 2) {
                        if (vertex.position.length() < 0.25)
                            lineBuilder.startingVertices.push(vertex);
                    }
                }
                mamesh.lines = lineBuilder.go();
                //n
                var linesViewer = new mathis.visu3d.LinesViewer(mamesh, this.mathisFrame.scene);
                linesViewer.go();
                //$$$e
                //$$$bh vertices viewing
                var verticesViewer = new mathis.visu3d.VerticesViewer(mamesh, this.mathisFrame.scene);
                verticesViewer.radiusProp = 0.1;
                verticesViewer.go();
                //$$$eh
            };
            return DoNotDrawAllTheLines3d;
        }());
        var DrawOnlyLinePassingInside = (function () {
            function DrawOnlyLinePassingInside(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "DrawOnlyLinePassingInside";
                this.$$$title = "We draw lines only passing inside selected vertices";
                this.nbI = 10;
                this.$$$nbI = [5, 10, 12, 15, 20];
                this.selectionChoice = 0;
                this.$$$selectionChoice = [0, 1, 2];
            }
            DrawOnlyLinePassingInside.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                this.go();
            };
            DrawOnlyLinePassingInside.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$b
                var basis = new mathis.reseau.BasisForRegularReseau();
                basis.nbI = this.nbI;
                basis.nbJ = basis.nbI;
                basis.origin = new mathis.XYZ(-0.7, -0.7, 0);
                basis.end = new mathis.XYZ(+0.7, +0.7, 0);
                var creator = new mathis.reseau.Regular(basis);
                var mamesh = creator.go();
                var lineBuilder = new mathis.lineModule.LineComputer(mamesh);
                lineBuilder.restrictLinesToTheseVertices = [];
                var selectionChoice = this.selectionChoice;
                for (var i = 0; i < mamesh.vertices.length; i++) {
                    var vertex = mamesh.vertices[i];
                    if (selectionChoice == 0) {
                        if (vertex.param.x <= 3 && (vertex.param.y <= 3 || vertex.param.y > 5))
                            lineBuilder.restrictLinesToTheseVertices.push(vertex);
                    }
                    else if (selectionChoice == 1) {
                        if (vertex.position.length() > 0.5)
                            lineBuilder.restrictLinesToTheseVertices.push(vertex);
                    }
                    else if (selectionChoice == 2) {
                        if (vertex.position.length() < 0.5)
                            lineBuilder.restrictLinesToTheseVertices.push(vertex);
                    }
                }
                mamesh.lines = lineBuilder.go();
                //$$$e
                //$$$bh visualization
                var linesViewer = new mathis.visu3d.LinesViewer(mamesh, this.mathisFrame.scene);
                linesViewer.go();
                var verticesViewer = new mathis.visu3d.VerticesViewer(mamesh, this.mathisFrame.scene);
                verticesViewer.radiusProp = 0.1;
                verticesViewer.go();
                //$$$eh
            };
            return DrawOnlyLinePassingInside;
        }());
        var ChoseColorOfLinesAccordingToLevel = (function () {
            function ChoseColorOfLinesAccordingToLevel(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "ChoseColorOfLinesAccordingToLevel";
                this.$$$title = "colors of vertical lines are chosen via lineToColor. color of horizontal lines are chosen via a lineToLevel";
                this.nbI = 11;
                this.$$$nbI = new documentation.Choices([11, 5, 15]);
            }
            ChoseColorOfLinesAccordingToLevel.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                this.go();
            };
            ChoseColorOfLinesAccordingToLevel.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$bh mamesh creation
                var basis = new mathis.reseau.BasisForRegularReseau();
                basis.nbI = this.nbI;
                basis.nbJ = 11;
                basis.origin = new mathis.XYZ(-1, -1, 0);
                basis.end = new mathis.XYZ(1, 1, 0);
                var creator = new mathis.reseau.Regular(basis);
                var mamesh = creator.go();
                //$$$eh
                //$$$b
                mamesh.fillLineCatalogue();
                //n
                var lineViewerHorizontal = new mathis.visu3d.LinesViewer(mamesh, this.mathisFrame.scene);
                lineViewerHorizontal.lineToLevel = new mathis.HashMap();
                var lineViewerVertical = new mathis.visu3d.LinesViewer(mamesh, this.mathisFrame.scene);
                lineViewerVertical.lineToColor = new mathis.HashMap();
                for (var i = 0; i < mamesh.lines.length; i++) {
                    var line = mamesh.lines[i];
                    var isHorizontal = (line.getVertex(0).param.y == line.getVertex(1).param.y);
                    if (isHorizontal) {
                        lineViewerHorizontal.lineToLevel.putValue(line, line.getVertex(0).param.y);
                    }
                    else {
                        if (line.getVertex(0).param.x % 2 == 0)
                            lineViewerVertical.lineToColor.putValue(line, new mathis.Color(mathis.Color.names.black));
                        else
                            lineViewerVertical.lineToColor.putValue(line, new mathis.Color(mathis.Color.names.whitesmoke));
                    }
                }
                /**Levels are transformed into  colors via the default color map*/
                lineViewerHorizontal.go();
                lineViewerVertical.go();
                //$$$e
                //$$$bh vertices visualization
                var verticesViewer = new mathis.visu3d.VerticesViewer(mamesh, this.mathisFrame.scene);
                verticesViewer.radiusProp = 0.1;
                verticesViewer.go();
                //$$$eh
            };
            return ChoseColorOfLinesAccordingToLevel;
        }());
        var ChoseColorOfLinesAccordingToSymmetries = (function () {
            function ChoseColorOfLinesAccordingToSymmetries(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "ChoseColorOfLinesAccordingToSymmetries";
                this.$$$title = "We color symmetric lines with the same color";
                this.nbI = 11;
                this.$$$nbI = new documentation.Choices([11, 5, 15]);
                this.oneMoreVertexForOddLine = false;
                this.$$$oneMoreVertexForOddLine = new documentation.Choices([true, false]);
                this.squareMaille = true;
                this.$$$squareMaille = new documentation.Choices([true, false]);
                this.Vj = new mathis.XYZ(0, 0.1, 0);
                this.$$$Vj = new documentation.Choices([new mathis.XYZ(0, 0.1, 0), new mathis.XYZ(0.05, 0.1, 0)], { "before": "new XYZ" });
                this.selectionChoice = 0;
                this.$$$selectionChoice = [0, 1, 2];
            }
            ChoseColorOfLinesAccordingToSymmetries.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                this.go();
            };
            ChoseColorOfLinesAccordingToSymmetries.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$b
                var basis = new mathis.reseau.BasisForRegularReseau();
                basis.nbI = this.nbI;
                basis.nbJ = 11;
                basis.origin = new mathis.XYZ(0, 0, 0);
                basis.end = new mathis.XYZ(1, 1, 0);
                basis.squareMailleInsteadOfTriangle = this.squareMaille;
                /**true-> square net, false->triangular net*/
                var creator = new mathis.reseau.Regular(basis);
                creator.oneMoreVertexForOddLine = this.oneMoreVertexForOddLine;
                var mamesh = creator.go();
                mamesh.fillLineCatalogue();
                var lineColorIndexer = new mathis.lineModule.CreateAColorIndexRespectingBifurcationsAndSymmetries(mamesh);
                var symmetriesChoice = this.selectionChoice;
                if (symmetriesChoice == 0) {
                    lineColorIndexer.symmetries = [function (a) { return new mathis.XYZ(1 - a.x, a.y, a.z); }, function (a) { return new mathis.XYZ(a.x, 1 - a.y, a.z); }, function (a) { return new mathis.XYZ(1 - a.x, 1 - a.y, a.z); }];
                }
                else if (symmetriesChoice == 1) {
                    lineColorIndexer.symmetries = [function (a) { return new mathis.XYZ(a.x, 1 - a.y, a.z); }, function (a) { return new mathis.XYZ(1 - a.x, 1 - a.y, a.z); }];
                }
                else if (symmetriesChoice == 2) {
                    lineColorIndexer.symmetries = [function (a) { return new mathis.XYZ(1 - a.x, 1 - a.y, a.z); }];
                }
                var linesViewer = new mathis.visu3d.LinesViewer(mamesh, this.mathisFrame.scene);
                linesViewer.lineToLevel = lineColorIndexer.go();
                linesViewer.go();
                //$$$e
                //$$$bh vertices visualization
                var verticesViewer = new mathis.visu3d.VerticesViewer(mamesh, this.mathisFrame.scene);
                verticesViewer.radiusProp = 0.1;
                verticesViewer.go();
                //$$$eh
            };
            return ChoseColorOfLinesAccordingToSymmetries;
        }());
        var ChoseColorOfLinesBifurcation = (function () {
            function ChoseColorOfLinesBifurcation(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "ChoseColorOfLinesBifurcation";
                this.$$$title = "We color bifurcation with the same color";
                this.nbSides = 7;
                this.$$$nbSides = [4, 7, 10];
                this.nbSubdivisionInARadius = 3;
                this.$$$nbSubdivisionInARadius = [2, 3, 5];
                this.selectionChoice = 0;
                this.$$$selectionChoice = [0, 1, 2];
            }
            ChoseColorOfLinesBifurcation.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                this.go();
            };
            ChoseColorOfLinesBifurcation.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$b
                var creator = new mathis.reseau.TriangulatedPolygone(this.nbSides);
                creator.nbSubdivisionInARadius = this.nbSubdivisionInARadius;
                var mamesh = creator.go();
                /**random suppression of some links*/
                var random = new mathis.proba.Random(6537);
                for (var i = 0; i < mamesh.vertices.length; i++) {
                    var vertex = mamesh.vertices[i];
                    for (var j = 0; j < vertex.links.length; j++) {
                        if (random.pseudoRand() < 0.4) {
                            mathis.Vertex.separateTwoVoisins(vertex, vertex.links[j].to);
                        }
                    }
                }
                /**we suppress all opposite and recreate them using angles.
                 * This will naturally create bifurcations*/
                mamesh.clearOppositeInLinks();
                var associer = new mathis.linkModule.OppositeLinkAssocierByAngles(mamesh.vertices);
                associer.canCreateBifurcations = true; //(default value)
                associer.goChanging();
                /** we compute lines. Can also be done via mamesh.fillLineCatalogue */
                var lineBuilder = new mathis.lineModule.LineComputer(mamesh);
                lineBuilder.lookAtBifurcation = true; //(default value)
                mamesh.lines = lineBuilder.go();
                //n
                /** here we create  line-index : two lines issue of a bifurcation have a same index.
                 * This will lead to a same color */
                var linesViewer = new mathis.visu3d.LinesViewer(mamesh, this.mathisFrame.scene);
                var lineColorIndexer = new mathis.lineModule.CreateAColorIndexRespectingBifurcationsAndSymmetries(mamesh);
                linesViewer.lineToLevel = lineColorIndexer.go();
                linesViewer.go();
                //$$$e
                //$$$bh vertices visualization
                var verticesViewer = new mathis.visu3d.VerticesViewer(mamesh, this.mathisFrame.scene);
                verticesViewer.radiusProp = 0.1;
                verticesViewer.go();
                //$$$eh
            };
            return ChoseColorOfLinesBifurcation;
        }());
    })(documentation = mathis.documentation || (mathis.documentation = {}));
})(mathis || (mathis = {}));
/**
 * Created by vigon on 15/12/2016.
 */
var mathis;
(function (mathis) {
    var documentation;
    (function (documentation) {
        var LinksDocu = (function () {
            function LinksDocu(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.pageIdAndTitle = "Simple links and opposite links";
                var several = new documentation.SeveralParts();
                several.addPart(new AutomaticLink(this.mathisFrame));
                several.addPart(new AutomaticPolygonLink(this.mathisFrame));
                several.addPart(new WhatAreLinks(this.mathisFrame));
                several.addPart(new WhatAreOppositeLinks(this.mathisFrame));
                this.severalParts = several;
            }
            LinksDocu.prototype.go = function () {
                return this.severalParts.go();
            };
            return LinksDocu;
        }());
        documentation.LinksDocu = LinksDocu;
        var WhatAreLinks = (function () {
            function WhatAreLinks(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "WhatAreLinks";
                this.$$$title = "Several ways to create manually links (without association of opposite)";
                this.technicChoice = 0;
                this.$$$technicChoice = [0, 1, 2];
                this.mathisFrame = mathisFrame;
            }
            WhatAreLinks.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                var camera = this.mathisFrame.scene.activeCamera;
                camera.changePosition(new mathis.XYZ(0, 0, -5));
                this.go();
            };
            WhatAreLinks.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$bh vertices creation
                /**let's create vertices*/
                var vertex0 = new mathis.Vertex().setPosition(-1, -1, 0);
                var vertex1 = new mathis.Vertex().setPosition(-1, 1, 0);
                var vertex2 = new mathis.Vertex().setPosition(0, 1.5, 0);
                var vertex3 = new mathis.Vertex().setPosition(0, -0.5, 0);
                var vertex4 = new mathis.Vertex().setPosition(1, -1, 0);
                var vertex5 = new mathis.Vertex().setPosition(1, 1, 0);
                //$$$eh
                //$$$begin
                /**let's make a mamesh with 2 triangles, 1 rectangle*/
                var mamesh = new mathis.Mamesh();
                mamesh.vertices.push(vertex0, vertex1, vertex2, vertex3, vertex4, vertex5);
                mamesh.addATriangle(vertex0, vertex2, vertex1).addATriangle(vertex0, vertex3, vertex2);
                mamesh.addASquare(vertex2, vertex3, vertex4, vertex5);
                //n
                var technicChoice = this.technicChoice;
                if (technicChoice == 0) {
                    /**automatic creation using polygons */
                    mamesh.addSimpleLinksAroundPolygons();
                }
                else if (technicChoice == 1) {
                    /**we only create 2 links
                     * To create a link between two vertices, you have to inform both of them that they are linked  */
                    vertex2.setOneLink(vertex1).setOneLink(vertex5);
                    vertex1.setOneLink(vertex2);
                    vertex5.setOneLink(vertex2);
                }
                else if (technicChoice == 2) {
                    /**quick and direct technique :  no verification is done.  */
                    vertex0.links.push(new mathis.Link(vertex1), new mathis.Link(vertex2));
                    vertex1.links.push(new mathis.Link(vertex0));
                    vertex2.links.push(new mathis.Link(vertex0));
                }
                //$$$end
                //$$$bh visualization
                var verticesViewer = new mathis.visu3d.VerticesViewer(mamesh, this.mathisFrame.scene);
                verticesViewer.go();
                var linksViewer = new mathis.visu3d.LinksViewer(mamesh, this.mathisFrame.scene);
                linksViewer.go();
                var surfaceViewer = new mathis.visu3d.SurfaceViewer(mamesh, this.mathisFrame.scene);
                surfaceViewer.go();
                //$$$eh
            };
            return WhatAreLinks;
        }());
        var WhatAreOppositeLinks = (function () {
            function WhatAreOppositeLinks(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "WhatAreOppositeLinks";
                this.$$$title = "several ways to associate manually opposite links";
                this.technicChoice = 0;
                this.$$$technicChoice = [0, 1, 2];
                this.mathisFrame = mathisFrame;
            }
            WhatAreOppositeLinks.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                var camera = this.mathisFrame.scene.activeCamera;
                camera.changePosition(new mathis.XYZ(0, 0, -5));
                this.go();
            };
            WhatAreOppositeLinks.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$bh vertices creation
                /**let's create vertices*/
                var vertex0 = new mathis.Vertex().setPosition(-1, -1, 0);
                var vertex1 = new mathis.Vertex().setPosition(-1, 1, 0);
                var vertex2 = new mathis.Vertex().setPosition(0, 1.5, 0);
                var vertex3 = new mathis.Vertex().setPosition(0, -0.5, 0);
                var vertex4 = new mathis.Vertex().setPosition(1, -1, 0);
                var vertex5 = new mathis.Vertex().setPosition(1, 1, 0);
                //$$$eh
                //$$$begin
                /**let's make a mamesh with 2 triangles, 1 rectangle*/
                var mamesh = new mathis.Mamesh();
                mamesh.vertices.push(vertex0, vertex1, vertex2, vertex3, vertex4, vertex5);
                mamesh.addATriangle(vertex0, vertex2, vertex1).addATriangle(vertex0, vertex3, vertex2);
                mamesh.addASquare(vertex2, vertex3, vertex4, vertex5);
                //n
                var technicChoice = this.technicChoice;
                if (technicChoice == 0) {
                    /**automatic creation using polygons (see further, for more details)*/
                    mamesh.addOppositeLinksAroundPolygons();
                }
                else if (technicChoice == 1) {
                    /**we only create 2 links
                     * To create a link between two vertices, you have to inform both of them that they are linked  */
                    vertex3.setTwoOppositeLinks(vertex0, vertex4);
                    vertex0.setOneLink(vertex3);
                    vertex4.setOneLink(vertex3);
                }
                else if (technicChoice == 2) {
                    /**direct technique (to understand the underlying data structure)*/
                    var link2_1 = new mathis.Link(vertex1);
                    var link2_5 = new mathis.Link(vertex5);
                    link2_1.opposites = [link2_5];
                    link2_5.opposites = [link2_1];
                    vertex2.links.push(link2_1, link2_5);
                    vertex1.links.push(new mathis.Link(vertex2));
                    vertex5.links.push(new mathis.Link(vertex2));
                }
                mamesh.fillLineCatalogue();
                console.log(mamesh.toString());
                //$$$end
                //$$$bh visualization
                var verticesViewer = new mathis.visu3d.VerticesViewer(mamesh, this.mathisFrame.scene);
                verticesViewer.go();
                var linksViewer = new mathis.visu3d.LinesViewer(mamesh, this.mathisFrame.scene);
                linksViewer.go();
                var surfaceViewer = new mathis.visu3d.SurfaceViewer(mamesh, this.mathisFrame.scene);
                surfaceViewer.go();
                //$$$eh
            };
            return WhatAreOppositeLinks;
        }());
        var AutomaticLink = (function () {
            function AutomaticLink(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "AutomaticLink";
                this.$$$title = "We create some random links. Then we associate opposite-links using an automatic process based on angles. " +
                    "This can create bifurcation";
                this.technicChoice = 0;
                this.$$$technicChoice = [0, 1, 2];
                this.createBifurcation = true;
                this.$$$createBifurcation = [true, false];
                this.nbLinks = 30;
                this.$$$nbLinks = [20, 30, 50, 100];
                this.maxAngleToAssociateLinks = Math.PI * 0.3;
                this.$$$maxAngleToAssociateLinks = new documentation.Choices([Math.PI * 0.1, Math.PI * 0.3, Math.PI * 0.5, Math.PI * 0.8], { visualValues: ['PI*0.1', 'PI*0.3', 'PI*0.5', 'PI*0.8'] });
                this.mathisFrame = mathisFrame;
            }
            AutomaticLink.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                var camera = this.mathisFrame.scene.activeCamera;
                camera.changePosition(new mathis.XYZ(0, 0, -5));
                this.go();
            };
            AutomaticLink.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$begin
                /**let's create vertices*/
                var basis = new mathis.reseau.BasisForRegularReseau();
                basis.nbI = 8;
                basis.nbJ = 8;
                var creator = new mathis.reseau.Regular(basis);
                creator.makeLinks = false;
                creator.makeTriangleOrSquare = false;
                var mamesh = creator.go();
                var nbLinks = this.nbLinks;
                /** pseudo random generator. The seed is fixed to have
                 * always the same sequence */
                var seed = 46765474657;
                var random = new mathis.proba.Random(seed);
                var count = 0;
                while (count < nbLinks) {
                    var vertex0 = mamesh.vertices[random.pseudoRandInt(mamesh.vertices.length)];
                    var vertex1 = mamesh.vertices[random.pseudoRandInt(mamesh.vertices.length)];
                    if (Math.abs(vertex0.param.x - vertex1.param.x) == 1 && Math.abs(vertex0.param.y - vertex1.param.y) < 3) {
                        vertex0.setOneLink(vertex1);
                        vertex1.setOneLink(vertex0);
                        count++;
                    }
                }
                var maxAngleToAssociateLinks = this.maxAngleToAssociateLinks;
                var associer = new mathis.linkModule.OppositeLinkAssocierByAngles(mamesh.vertices);
                associer.canCreateBifurcations = this.createBifurcation;
                associer.maxAngleToAssociateLinks = maxAngleToAssociateLinks;
                associer.goChanging();
                //$$$end
                //$$$bh visualization
                /**if we made bifurcation, we make a colorIndex in order that two bifurcating lines have the same color*/
                var linesViewer = new mathis.visu3d.LinesViewer(mamesh, this.mathisFrame.scene);
                if (associer.canCreateBifurcations) {
                    mamesh.fillLineCatalogue();
                    var lineIndexer = new mathis.lineModule.CreateAColorIndexRespectingBifurcationsAndSymmetries(mamesh);
                    linesViewer.lineToLevel = lineIndexer.go();
                }
                linesViewer.constantRadius = 0.01;
                linesViewer.go();
                var verticesViewer = new mathis.visu3d.VerticesViewer(mamesh, this.mathisFrame.scene);
                verticesViewer.constantRadius = 0.03;
                verticesViewer.go();
                //$$$eh
                // let surfaceViewer=new visu3d.SurfaceViewer(mamesh,this.mathisFrame.scene)
                // surfaceViewer.go()
            };
            return AutomaticLink;
        }());
        var AutomaticPolygonLink = (function () {
            function AutomaticPolygonLink(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "AutomaticPolygonLink";
                this.$$$title = "We associate opposite-links using an automatic process based on polygons.";
                this.seed = 3534;
                this.$$$seed = [3534, 7654, 909123, 58912307];
                this.squareMailleInsteadOfTriangle = true;
                this.$$$squareMailleInsteadOfTriangle = [true, false];
                this.mathisFrame = mathisFrame;
            }
            AutomaticPolygonLink.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                var camera = this.mathisFrame.scene.activeCamera;
                camera.changePosition(new mathis.XYZ(0, 0, -5));
                this.go();
            };
            AutomaticPolygonLink.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$begin
                /**let's create vertices*/
                var basis = new mathis.reseau.BasisForRegularReseau();
                basis.nbI = 5;
                basis.nbJ = 5;
                basis.squareMailleInsteadOfTriangle = this.squareMailleInsteadOfTriangle;
                var creator = new mathis.reseau.Regular(basis);
                /**we intentionally forget to create links*/
                creator.makeLinks = false;
                var mamesh = creator.go();
                /**we perturbate a lot the reseau*/
                var seed = this.seed;
                var random = new mathis.proba.Random(seed);
                for (var i = 0; i < mamesh.vertices.length; i++) {
                    mamesh.vertices[i].position.add(new mathis.XYZ(random.pseudoRand(), random.pseudoRand(), random.pseudoRand()).scale(0.25));
                }
                /**first we add simple links. Easy work*/
                mamesh.addSimpleLinksAroundPolygons();
                /**now we associate opposite links (more complex algorithm)*/
                var process = new mathis.linkModule.LinkCreaterSorterAndBorderDetecterByPolygons(mamesh);
                process.goChanging();
                //$$$end
                //$$$bh visualization
                var verticesViewer = new mathis.visu3d.VerticesViewer(mamesh, this.mathisFrame.scene);
                verticesViewer.constantRadius = 0.05;
                verticesViewer.go();
                var linesViewer = new mathis.visu3d.LinesViewer(mamesh, this.mathisFrame.scene);
                linesViewer.constantRadius = 0.02;
                linesViewer.go();
                new mathis.visu3d.SurfaceViewer(mamesh, this.mathisFrame.scene).go();
                //$$$eh
                // let surfaceViewer=new visu3d.SurfaceViewer(mamesh,this.mathisFrame.scene)
                // surfaceViewer.go()
            };
            return AutomaticPolygonLink;
        }());
    })(documentation = mathis.documentation || (mathis.documentation = {}));
})(mathis || (mathis = {}));
/**
 * Created by vigon on 26/12/2016.
 */
/**
 * Created by vigon on 22/12/2016.
 */
/**
 * Created by vigon on 21/11/2016.
 */
var mathis;
(function (mathis) {
    var documentation;
    (function (documentation) {
        var LinksViewingDocu = (function () {
            function LinksViewingDocu(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.pageIdAndTitle = "Links viewing";
                var severalParts = new documentation.SeveralParts();
                severalParts.addPart(new JustTheSizeOfLinks(this.mathisFrame));
                severalParts.addPart(new OrientationLinksViewing(this.mathisFrame));
                severalParts.addComment("In the sequel we explain how to finely adjust the links-representation.", "In the sequel we explain how to finely adjust the links-representation");
                severalParts.addPart(new Elongate(this.mathisFrame));
                severalParts.addPart(new DefaultLinksViewing(this.mathisFrame));
                severalParts.addPart(new CustomLinksViewing(this.mathisFrame));
                this.severalParts = severalParts;
            }
            LinksViewingDocu.prototype.go = function () {
                return this.severalParts.go();
            };
            return LinksViewingDocu;
        }());
        documentation.LinksViewingDocu = LinksViewingDocu;
        var JustTheSizeOfLinks = (function () {
            function JustTheSizeOfLinks(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "JustTheSizeOfLinks";
                this.$$$title = "As a simple usage, you can specified  the color and the lateral-size of links. This size can be relative or absolute.";
                this.nbSides = 4;
                this.$$$nbSides = [4, 7, 10];
                this.nbSubdivisionInARadius = 3;
                this.$$$nbSubdivisionInARadius = [2, 3, 5];
                this.color = mathis.Color.names.rebeccapurple;
                this.$$$color = new documentation.Choices([mathis.Color.names.rebeccapurple, mathis.Color.names.rosybrown, mathis.Color.names.darkorange], { 'before': 'Color.names.', 'visualValues': ['rebeccapurple', 'rosybrown', 'darkorange'] });
                this.lateralScalingProp = 0.05;
                this.$$$lateralScalingProp = [0.01, 0.05, 0.1];
                this.lateralScalingConstant = null;
                this.$$$lateralScalingConstant = [null, 0.05, 0.1, 0.2];
            }
            JustTheSizeOfLinks.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                this.go();
            };
            JustTheSizeOfLinks.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$b
                var creator = new mathis.reseau.TriangulatedPolygone(this.nbSides);
                creator.nbSubdivisionInARadius = this.nbSubdivisionInARadius;
                var mamesh = creator.go();
                //n
                var linksViewer = new mathis.visu3d.LinksViewer(mamesh, this.mathisFrame.scene);
                linksViewer.color = new mathis.Color(this.color);
                /**if null, the lateral scaling is proportional to the mean distance between linked vertices*/
                linksViewer.lateralScalingConstant = this.lateralScalingConstant;
                /**useless if previous is not null,*/
                linksViewer.lateralScalingProp = this.lateralScalingProp;
                linksViewer.go();
                //$$$e
            };
            return JustTheSizeOfLinks;
        }());
        var OrientationLinksViewing = (function () {
            function OrientationLinksViewing(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "OrientationLinksViewing";
                this.$$$title = "Now we specify a model (here an arrow), and indicate which links must be drawn and in which direction.";
                this.polyhedronType = mathis.creation3D.PolyhedronType.Cube;
                this.$$$polyhedronType = new documentation.Choices([mathis.creation3D.PolyhedronType.Tetrahedron, mathis.creation3D.PolyhedronType.Cube, mathis.creation3D.PolyhedronType.Dodecahedron], { 'before': 'creation3D.PolyhedronType.', 'visualValues': ['Tetrahedron', 'Cube', 'Dodecahedron'] });
                this.showLateralDirection = false;
                this.$$$showLateralDirection = [true, false];
                this.methodChoice = -1;
                this.$$$methodChoice = [-1, 0, 1, 2, 3];
            }
            OrientationLinksViewing.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                this.go();
            };
            OrientationLinksViewing.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$b
                var creator = new mathis.creation3D.Polyhedron(this.polyhedronType);
                var mamesh = creator.go();
                //$$$e
                //$$$bh the model is an arrow
                var modelsCreator = new mathis.creation3D.ArrowCreator(this.mathisFrame.scene);
                modelsCreator.arrowFootAtOrigin = false;
                modelsCreator.bodyDiameterProp = 1;
                modelsCreator.headDiameterProp = 2;
                var model = modelsCreator.go();
                var material = new BABYLON.StandardMaterial("", this.mathisFrame.scene);
                material.diffuseColor = new BABYLON.Color3(0, 0, 1);
                model.material = material;
                /**to avoid smoothing */
                model.convertToFlatShadedMesh();
                //$$$eh
                //$$$b
                var segmentOrientationFunction;
                var methodChoice = this.methodChoice;
                if (methodChoice == -1) {
                    /**no function : so all the link are drawn with a random orientation*/
                    segmentOrientationFunction = null;
                }
                else if (methodChoice == 0) {
                    /**if the function return 0 : no links are drawn
                     * else : orientation is chosen according to the sign of the return values*/
                    segmentOrientationFunction = function (v0, v1) {
                        if (mathis.geo.almostEquality(v0.position.y, v1.position.y))
                            return 0;
                        return v0.position.y - v1.position.y;
                    };
                }
                else if (methodChoice == 1) {
                    /**the opposite method*/
                    segmentOrientationFunction = function (v0, v1) {
                        if (mathis.geo.almostEquality(v0.position.y, v1.position.y))
                            return 0;
                        return -v0.position.y + v1.position.y;
                    };
                }
                else if (methodChoice == 2) {
                    segmentOrientationFunction = function (v0, v1) {
                        if (mathis.geo.almostEquality(v0.position.z, v1.position.z))
                            return 0;
                        return v0.position.z - v1.position.z;
                    };
                }
                else if (methodChoice == 3) {
                    /**please, try this method on the Dodecahedron*/
                    segmentOrientationFunction = function (v0, v1) {
                        if (v0.hasMark(mathis.Vertex.Markers.polygonCenter) || v1.hasMark(mathis.Vertex.Markers.polygonCenter))
                            return 0;
                        return v0.position.z - v1.position.z;
                    };
                }
                var linksViewer = new mathis.visu3d.LinksViewer(mamesh, this.mathisFrame.scene);
                linksViewer.meshModel = model;
                linksViewer.segmentOrientationFunction = segmentOrientationFunction;
                linksViewer.go();
                //$$$e
            };
            return OrientationLinksViewing;
        }());
        var Elongate = (function () {
            function Elongate(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "Elongate";
                this.$$$title = "Links viewing is made via an 'elongator'. This elongator take a vertical mesh (eg cylinder, arrow...) " +
                    "and place its between two positions. Lateral-direction and lateral-scaling can be given.";
                this.upVector = new mathis.XYZ(0, 0, 1);
                this.$$$upVector = new documentation.Choices([new mathis.XYZ(0, 0, 1), new mathis.XYZ(0, 1, 1), new mathis.XYZ(0, 0.5, 1)], { 'before': 'new XYZ' });
                this.endPos = new mathis.XYZ(1, 0, 0);
                this.$$$endPos = new documentation.Choices([new mathis.XYZ(1, 0, 0), new mathis.XYZ(-1, 0.5, 0), new mathis.XYZ(1, 1, 0)], { 'before': 'new XYZ' });
                this.modelChoice = 0;
                this.$$$modelChoice = [0, 1, 2];
                this.lateralScaling = 0.1;
                this.$$$lateralScaling = [0.05, 0.1, 0.5];
                this.justSeeModels = false;
                this.$$$justSeeModels = [true, false];
                this.showLateralDirection = true;
                this.$$$showLateralDirection = [true, false];
            }
            Elongate.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                this.go();
            };
            Elongate.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$b
                var modelChoice = this.modelChoice;
                var model;
                if (modelChoice == 0) {
                    model = BABYLON.Mesh.CreateBox("", 1, this.mathisFrame.scene);
                }
                else if (modelChoice == 1) {
                    model = BABYLON.Mesh.CreateCylinder("", 1, 1, 1, 3, 3, this.mathisFrame.scene);
                }
                else if (modelChoice == 2) {
                    var modelsCreator = new mathis.creation3D.ArrowCreator(this.mathisFrame.scene);
                    modelsCreator.arrowFootAtOrigin = false;
                    modelsCreator.bodyDiameterProp = 1;
                    modelsCreator.headDiameterProp = 2;
                    model = modelsCreator.go();
                }
                var material = new BABYLON.StandardMaterial("", this.mathisFrame.scene);
                material.diffuseColor = new BABYLON.Color3(0, 0, 1);
                model.material = material;
                /**to avoid smoothing */
                model.convertToFlatShadedMesh();
                var justSeeModels = this.justSeeModels;
                var endPos = this.endPos;
                var lateralDirection = this.upVector;
                if (!justSeeModels) {
                    var elongator = new mathis.visu3d.ElongateAMeshFromBeginToEnd(new mathis.XYZ(-1, 0, 0), endPos, model);
                    elongator.lateralDirection = lateralDirection;
                    elongator.lateralScaling = this.lateralScaling;
                    elongator.goChanging();
                }
                //n
                var showLateralDirection = this.showLateralDirection;
                //$$$e
                //$$$bh the code to show the lateral direction
                if (showLateralDirection) {
                    var lateralVector = new mathis.creation3D.ArrowCreator(this.mathisFrame.scene).go();
                    var quaternion = new mathis.XYZW(0, 0, 0, 0);
                    mathis.geo.axisAngleToQuaternion(new mathis.XYZ(0, 0, 1), -Math.PI / 2, quaternion);
                    lateralVector.rotationQuaternion = quaternion;
                    lateralVector.bakeCurrentTransformIntoVertices();
                    if (!justSeeModels) {
                        var elongator2 = new mathis.visu3d.ElongateAMeshFromBeginToEnd(new mathis.XYZ(-1, 0, 0), endPos, lateralVector);
                        elongator2.lateralDirection = lateralDirection;
                        elongator2.lateralScaling = 1;
                        elongator2.goChanging();
                    }
                }
                //$$$eh
            };
            return Elongate;
        }());
        var DefaultLinksViewing = (function () {
            function DefaultLinksViewing(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "DefaultLinksViewing";
                this.$$$title = "The links are drawn using the default method to compute lateral directions (these direction are illustrated by the white arrows)";
                this.modelChoice = 0;
                this.$$$modelChoice = [-1, 0, 1, 2];
                this.lateralScalingProp = 0.05;
                this.$$$lateralScalingProp = [0.01, 0.05, 0.1];
                this.lateralScalingConstant = null;
                this.$$$lateralScalingConstant = [null, 0.05, 0.1, 0.2];
                this.justSeeModels = false;
                this.$$$justSeeModels = [true, false];
                this.polyhedronType = mathis.creation3D.PolyhedronType.Cube;
                this.$$$polyhedronType = new documentation.Choices([mathis.creation3D.PolyhedronType.Tetrahedron, mathis.creation3D.PolyhedronType.Cube, mathis.creation3D.PolyhedronType.Dodecahedron], { 'before': 'creation3D.PolyhedronType.', 'visualValues': ['Tetrahedron', 'Cube', 'Dodecahedron'] });
                this.showLateralDirection = true;
                this.$$$showLateralDirection = [true, false];
            }
            DefaultLinksViewing.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                this.go();
            };
            DefaultLinksViewing.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$b
                var creator = new mathis.creation3D.Polyhedron(this.polyhedronType);
                var mamesh = creator.go();
                var modelChoice = this.modelChoice;
                //$$$e
                //$$$bh model construction (-1 for default cylinder)
                var model;
                if (modelChoice == -1) {
                    /**default:no model*/
                    model = null;
                }
                else if (modelChoice == 0) {
                    model = BABYLON.Mesh.CreateBox("", 1, this.mathisFrame.scene);
                }
                else if (modelChoice == 1) {
                    model = BABYLON.Mesh.CreateCylinder("", 1, 1, 1, 3, 3, this.mathisFrame.scene);
                }
                else if (modelChoice == 2) {
                    var modelsCreator = new mathis.creation3D.ArrowCreator(this.mathisFrame.scene);
                    modelsCreator.arrowFootAtOrigin = false;
                    modelsCreator.bodyDiameterProp = 1;
                    modelsCreator.headDiameterProp = 2;
                    model = modelsCreator.go();
                }
                if (model != null) {
                    var material = new BABYLON.StandardMaterial("", this.mathisFrame.scene);
                    material.diffuseColor = new BABYLON.Color3(0, 0, 1);
                    model.material = material;
                    /**to avoid smoothing */
                    model.convertToFlatShadedMesh();
                }
                //$$$eh
                //$$$b
                var justSeeModels = this.justSeeModels;
                if (!justSeeModels) {
                    var linksViewer = new mathis.visu3d.LinksViewer(mamesh, this.mathisFrame.scene);
                    linksViewer.meshModel = model;
                    /**if null, the lateral scaling is proportional to the mean distance between linked vertices*/
                    linksViewer.lateralScalingConstant = this.lateralScalingConstant;
                    /**useless if previous is not null,*/
                    linksViewer.lateralScalingProp = this.lateralScalingProp;
                    linksViewer.go();
                }
                //n
                var showLateralDirection = this.showLateralDirection;
                //$$$e
                //$$$bh the code to show the lateral directions
                if (showLateralDirection) {
                    var lateralVector = new mathis.creation3D.ArrowCreator(this.mathisFrame.scene).go();
                    var quaternion = new mathis.XYZW(0, 0, 0, 0);
                    mathis.geo.axisAngleToQuaternion(new mathis.XYZ(0, 0, 1), -Math.PI / 2, quaternion);
                    lateralVector.rotationQuaternion = quaternion;
                    lateralVector.bakeCurrentTransformIntoVertices();
                    if (!justSeeModels) {
                        var linksViewer = new mathis.visu3d.LinksViewer(mamesh, this.mathisFrame.scene);
                        linksViewer.meshModel = lateralVector;
                        linksViewer.lateralScalingConstant = 0.3;
                        linksViewer.go();
                    }
                }
                //$$$eh
            };
            return DefaultLinksViewing;
        }());
        var CustomLinksViewing = (function () {
            function CustomLinksViewing(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "CustomLinksViewing";
                this.$$$title = "The links are drawn using some methods to compute lateral directions (these direction are illustrated by the white arrows)";
                this.modelChoice = 0;
                this.$$$modelChoice = [-1, 0, 1, 2];
                this.lateralScalingProp = 0.05;
                this.$$$lateralScalingProp = [0.01, 0.05, 0.1];
                this.lateralScalingConstant = null;
                this.$$$lateralScalingConstant = [null, 0.05, 0.1, 0.2];
                this.justSeeModels = false;
                this.$$$justSeeModels = [true, false];
                this.polyhedronType = mathis.creation3D.PolyhedronType.Cube;
                this.$$$polyhedronType = new documentation.Choices([mathis.creation3D.PolyhedronType.Tetrahedron, mathis.creation3D.PolyhedronType.Cube, mathis.creation3D.PolyhedronType.Dodecahedron], { 'before': 'creation3D.PolyhedronType.', 'visualValues': ['Tetrahedron', 'Cube', 'Dodecahedron'] });
                this.showLateralDirection = true;
                this.$$$showLateralDirection = [true, false];
                this.methodChoice = 0;
                this.$$$methodChoice = [-1, 0, 1];
            }
            CustomLinksViewing.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                this.go();
            };
            CustomLinksViewing.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$b
                var creator = new mathis.creation3D.Polyhedron(this.polyhedronType);
                var mamesh = creator.go();
                var modelChoice = this.modelChoice;
                //$$$e
                //$$$bh model construction (-1 for the default green cylinder)
                var model;
                if (modelChoice == -1) {
                    /**default:no model*/
                    model = null;
                }
                else if (modelChoice == 0) {
                    model = BABYLON.Mesh.CreateBox("", 1, this.mathisFrame.scene);
                }
                else if (modelChoice == 1) {
                    model = BABYLON.Mesh.CreateCylinder("", 1, 1, 1, 3, 3, this.mathisFrame.scene);
                }
                else if (modelChoice == 2) {
                    var modelsCreator = new mathis.creation3D.ArrowCreator(this.mathisFrame.scene);
                    modelsCreator.arrowFootAtOrigin = false;
                    modelsCreator.bodyDiameterProp = 1;
                    modelsCreator.headDiameterProp = 2;
                    model = modelsCreator.go();
                }
                if (model != null) {
                    var material = new BABYLON.StandardMaterial("", this.mathisFrame.scene);
                    material.diffuseColor = new BABYLON.Color3(0, 0, 1);
                    model.material = material;
                    /**to avoid smoothing */
                    model.convertToFlatShadedMesh();
                }
                //$$$eh
                //$$$b
                var justSeeModels = this.justSeeModels;
                var pairVertexToLateralDirection;
                var methodChoice = this.methodChoice;
                if (methodChoice == -1) {
                    /**so the default method will be used*/
                    pairVertexToLateralDirection = null;
                }
                if (methodChoice == 0) {
                    /**a method ad hoc for the cube with straight-links*/
                    var linkDirection_1 = new mathis.XYZ(0, 0, 0);
                    var lateralDir1_1 = new mathis.XYZ(0, 1, 0);
                    var lateralDir2_1 = new mathis.XYZ(1, 0, 0);
                    pairVertexToLateralDirection = function (v0, v1) {
                        linkDirection_1.copyFrom(v0.position).substract(v1.position);
                        if (mathis.geo.almostParallel(linkDirection_1, lateralDir1_1))
                            return lateralDir2_1;
                        else
                            return lateralDir1_1;
                    };
                }
                else {
                    /**a method which use the normal vector of vertices
                     * Perhaps you already have computed this normal vector,
                     * and perhaps you saved them as mamesh.vertexToPositioning (see vertex viewing)*/
                    var normalComputing = new mathis.mameshAroundComputations.PositioningComputerForMameshVertices(mamesh);
                    normalComputing.computeTangent = false; //we just want normals
                    normalComputing.computeSizes = false;
                    normalComputing.computeNormal = true;
                    var positionings_1 = normalComputing.go();
                    /**this method return the sum of the two  normals*/
                    pairVertexToLateralDirection = function (v0, v1) {
                        var res = new mathis.XYZ(0, 0, 0);
                        return res.copyFrom(positionings_1.getValue(v0).upVector).add(positionings_1.getValue(v1).upVector);
                    };
                }
                if (!justSeeModels) {
                    var linksViewer = new mathis.visu3d.LinksViewer(mamesh, this.mathisFrame.scene);
                    linksViewer.meshModel = model;
                    linksViewer.pairVertexToLateralDirection = pairVertexToLateralDirection;
                    linksViewer.go();
                }
                //n
                var showLateralDirection = this.showLateralDirection;
                //$$$e
                //$$$bh the code to show the lateral directions
                if (showLateralDirection) {
                    var lateralVector = new mathis.creation3D.ArrowCreator(this.mathisFrame.scene).go();
                    var quaternion = new mathis.XYZW(0, 0, 0, 0);
                    mathis.geo.axisAngleToQuaternion(new mathis.XYZ(0, 0, 1), -Math.PI / 2, quaternion);
                    lateralVector.rotationQuaternion = quaternion;
                    lateralVector.bakeCurrentTransformIntoVertices();
                    if (!justSeeModels) {
                        var linksViewer = new mathis.visu3d.LinksViewer(mamesh, this.mathisFrame.scene);
                        linksViewer.meshModel = lateralVector;
                        linksViewer.lateralScalingConstant = 0.3;
                        linksViewer.pairVertexToLateralDirection = pairVertexToLateralDirection;
                        linksViewer.go();
                    }
                }
                //$$$eh
            };
            return CustomLinksViewing;
        }());
    })(documentation = mathis.documentation || (mathis.documentation = {}));
})(mathis || (mathis = {}));
/**
 * Created by vigon on 28/12/2016.
 */
/**
 * Created by vigon on 05/12/2016.
 */
var mathis;
(function (mathis) {
    var documentation;
    (function (documentation) {
        var MacamDocu = (function () {
            function MacamDocu(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.pageIdAndTitle = "Camera";
                var several = new documentation.SeveralParts();
                several.addComment($("<div>The default mathis-camera is called the GrabberCamera. For real 3d viewing of single object the ideal grabber is a sphere " +
                    "(it is the white sphere which appear then you grab with your mouse). With the first piece of code, observe that :  <br>" +
                    "- outside the grabber when you grab, the grabber seems to turn on itself ; but actually, it is the camera (so yourself) that turning around.  <br>" +
                    "- inside the grabber  your are in a 'free mode rotation'<br> " +
                    " - close to the surface of the grabber, the movement is an interpolation between the two previous movement ; which give the impression to roll on the grabber surface.<br> " +
                    "Observe also that, by default, when it go back, the camera recenter on the grabber center. All these behaviour can be parametrized (see further pieces of code) </div>"), "The default mathis-camera is called the GrabberCamera");
                several.addPart(new SphericalGrabberCameraDocu(this.mathisFrame));
                several.addPart(new PlanarGrabberCameraDocu(this.mathisFrame));
                several.addPart(new TwoGrabberCameraDocu(this.mathisFrame));
                this.severalParts = several;
            }
            MacamDocu.prototype.go = function () {
                return this.severalParts.go();
            };
            return MacamDocu;
        }());
        documentation.MacamDocu = MacamDocu;
        //         //
        //         // function testMultGrabber(mathisFrame:MathisFrame):void{
        //         //
        //         //
        //         //     let macam = new macamera.GrabberCamera(mathisFrame.scene)
        //         //     macam.changePosition(new XYZ(0,0,-4))
        //         //
        //         //     let grabber0=new macamera.Grabber(macam)
        //         //     grabber0.center=new XYZ(0,0,0)
        //         //     grabber0.constantRadius=1
        //         //     grabber0.grabberIsVisible=true
        //         //     grabber0.name='green'
        //         //
        //         //     let grabber1=new macamera.Grabber(macam)
        //         //     grabber1.center=new XYZ(2,0,0)
        //         //     grabber1.constantRadius=1
        //         //     grabber1.grabberIsVisible=true
        //         //     grabber1.name='red'
        //         //
        //         //     let grabber2=new macamera.Grabber(macam)
        //         //     grabber2.center=new XYZ(-2,0,0)
        //         //     grabber2.constantRadius=1
        //         //     grabber2.grabberIsVisible=true
        //         //     grabber2.name='blue'
        //         //
        //         //
        //         //     macam.grabbers.push(grabber0,grabber1,grabber2)
        //         //
        //         //     macam.attachControl(mathisFrame.canvas)
        //         //
        //         //
        //         //
        //         //
        //         //
        //         //     // Ajout d'une lumire
        //         //     var light0 = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(-1, 1, -1), mathisFrame.scene);
        //         //     light0.diffuse = new BABYLON.Color3(1, 1, 1);
        //         //     light0.specular = new BABYLON.Color3(1, 1, 1);
        //         //     light0.groundColor = new BABYLON.Color3(0, 0, 0);
        //         //
        //         //
        //         //
        //         //
        //         //
        //         //
        //         //
        //         //
        //         // }
        var TwoGrabberCameraDocu = (function () {
            function TwoGrabberCameraDocu(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "TwoGrabberCameraDocu";
                this.$$$title = "Several grabbers. Usually used  for several for several meshes of interest. Here, two better show the process, we add only on mesh of" +
                    "interest in the middle of two grabbers that we never hide.";
                this.cameraOptionChoice = 0;
                this.$$$cameraOptionChoice = [0, 1, 2];
                this.toIncludeAtTheBeginOfTheFirstHiddenPiece = ["var mathisFrame=new MathisFrame(false) // false so no default light and camera"];
                this.useFreeModeWhenCursorOutOfGrabber = false;
                this.$$$useFreeModeWhenCursorOutOfGrabber = [true, false];
                this.useOnlyFreeMode = false;
                this.$$$useOnlyFreeMode = [true, false];
                this.mathisFrame = mathisFrame;
            }
            TwoGrabberCameraDocu.prototype.goForTheFirstTime = function () {
                this.go();
            };
            TwoGrabberCameraDocu.prototype.go = function () {
                this.mathisFrame.clearScene();
                //$$$begin
                this.mathisFrame.addDefaultLight();
                var grabberChoice = this.cameraOptionChoice;
                var grabber0 = new mathis.macamera.SphericalGrabber(this.mathisFrame.scene);
                grabber0.mesh.position = new mathis.XYZ(2, 0, 0);
                grabber0.referenceCenter = new mathis.XYZ(2, 0, 0);
                grabber0.material.diffuseColor = new BABYLON.Color3(1, 0, 0);
                grabber0.showGrabberOnlyWhenGrabbing = false;
                grabber0.focusOnMyCenterWhenCameraGoDownWard = false;
                //n
                var grabber1 = new mathis.macamera.SphericalGrabber(this.mathisFrame.scene);
                grabber1.mesh.position = new mathis.XYZ(-2, 0, 0);
                grabber1.referenceCenter = new mathis.XYZ(-2, 0, 0);
                grabber1.material.diffuseColor = new BABYLON.Color3(0, 1, 0);
                grabber1.showGrabberOnlyWhenGrabbing = false;
                grabber1.focusOnMyCenterWhenCameraGoDownWard = false;
                //n
                var grabberCamera = new mathis.macamera.GrabberCamera(this.mathisFrame, grabber0);
                grabberCamera.grabbers = [grabber0, grabber1];
                grabberCamera.useFreeModeWhenCursorOutOfGrabber = this.useFreeModeWhenCursorOutOfGrabber;
                grabberCamera.useOnlyFreeMode = this.useOnlyFreeMode;
                grabberCamera.attachControl(this.mathisFrame.canvas);
                grabberCamera.changePosition(new mathis.XYZ(0, 0, -10));
                //n
                var creator = new mathis.creation3D.Polyhedron(mathis.creation3D.PolyhedronType.Cube);
                var mamesh = creator.go();
                new mathis.visu3d.LinksViewer(mamesh, this.mathisFrame.scene).go();
                //$$$end
            };
            return TwoGrabberCameraDocu;
        }());
        var SphericalGrabberCameraDocu = (function () {
            function SphericalGrabberCameraDocu(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "SphericalGrabberCameraDocu";
                this.$$$title = "Mathis camera with spherical grabber";
                this.cameraOptionChoice = 0;
                this.$$$cameraOptionChoice = [0, 1, 2];
                this.toIncludeAtTheBeginOfTheFirstHiddenPiece = ["var mathisFrame=new MathisFrame(false) // false so no default light and camera"];
                this.useFreeModeWhenCursorOutOfGrabber = false;
                this.$$$useFreeModeWhenCursorOutOfGrabber = [true, false];
                this.useOnlyFreeMode = false;
                this.$$$useOnlyFreeMode = [true, false];
                this.mathisFrame = mathisFrame;
            }
            SphericalGrabberCameraDocu.prototype.goForTheFirstTime = function () {
                this.go();
            };
            SphericalGrabberCameraDocu.prototype.go = function () {
                this.mathisFrame.clearScene();
                //$$$begin
                this.mathisFrame.addDefaultLight();
                var grabberChoice = this.cameraOptionChoice;
                var grabber;
                if (grabberChoice == 0) {
                    /**default camera*/
                    grabber = new mathis.macamera.SphericalGrabber(this.mathisFrame.scene);
                }
                else if (grabberChoice == 1) {
                    /**We deform the grabber. */
                    grabber = new mathis.macamera.SphericalGrabber(this.mathisFrame.scene);
                    grabber.mesh.scaling.x = 1.5;
                    /**see later on to understand the usage of this radius*/
                    grabber.radius = 1.5;
                }
                var grabberCamera = new mathis.macamera.GrabberCamera(this.mathisFrame, grabber);
                grabberCamera.useFreeModeWhenCursorOutOfGrabber = this.useFreeModeWhenCursorOutOfGrabber;
                grabberCamera.useOnlyFreeMode = this.useOnlyFreeMode;
                grabberCamera.attachControl(this.mathisFrame.canvas);
                //n
                var creator = new mathis.creation3D.Polyhedron(mathis.creation3D.PolyhedronType.Cube);
                var mamesh = creator.go();
                new mathis.visu3d.LinksViewer(mamesh, this.mathisFrame.scene).go();
                //$$$end
            };
            return SphericalGrabberCameraDocu;
        }());
        var PlanarGrabberCameraDocu = (function () {
            function PlanarGrabberCameraDocu(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "PlanarGrabberCameraDocu";
                this.$$$title = "Mathis camera with planar grabber";
                this.cameraOptionChoice = 0;
                this.$$$cameraOptionChoice = [0, 1];
                this.toIncludeAtTheBeginOfTheFirstHiddenPiece = ["var mathisFrame=new MathisFrame(false) // false so no default light and camera"];
                this.useFreeModeWhenCursorOutOfGrabber = false;
                this.$$$useFreeModeWhenCursorOutOfGrabber = [true, false];
                this.useOnlyFreeMode = false;
                this.$$$useOnlyFreeMode = [true, false];
                this.changeMaterial = true;
                this.$$$changeMaterial = [true, false];
                this.mathisFrame = mathisFrame;
            }
            PlanarGrabberCameraDocu.prototype.goForTheFirstTime = function () {
                this.go();
            };
            PlanarGrabberCameraDocu.prototype.go = function () {
                this.mathisFrame.clearScene();
                //$$$begin
                this.mathisFrame.addDefaultLight();
                var grabberChoice = this.cameraOptionChoice;
                var grabber = new mathis.macamera.PlanarGrabber(this.mathisFrame.scene);
                if (grabberChoice == 0) {
                    grabber.mesh.scaling.x = 2;
                }
                else if (grabberChoice == 1) {
                    /**we change the default mesh,keeping the default material*/
                    grabber.mesh.dispose();
                    grabber.mesh = BABYLON.Mesh.CreateDisc('', 1, 20, this.mathisFrame.scene);
                    grabber.mesh.material = grabber.material;
                }
                /**perhaps change some material properties*/
                if (this.changeMaterial) {
                    grabber.material.diffuseColor = new BABYLON.Color3(1, 0, 0);
                    grabber.material.alpha = 0.5;
                }
                var grabberCamera = new mathis.macamera.GrabberCamera(this.mathisFrame, grabber);
                grabberCamera.useFreeModeWhenCursorOutOfGrabber = this.useFreeModeWhenCursorOutOfGrabber;
                grabberCamera.useOnlyFreeMode = this.useOnlyFreeMode;
                grabberCamera.attachControl(this.mathisFrame.canvas);
                console.log(this.mathisFrame.scene.activeCamera);
                console.log(this.mathisFrame.scene.activeCameras);
                //n
                var creator = new mathis.creation3D.Polyhedron(mathis.creation3D.PolyhedronType.Cube);
                var mamesh = creator.go();
                new mathis.visu3d.LinksViewer(mamesh, this.mathisFrame.scene).go();
                //$$$end
            };
            return PlanarGrabberCameraDocu;
        }());
        var SeveralGrabber = (function () {
            function SeveralGrabber(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "SeveralGrabber";
                this.$$$title = " ";
                this.mathisFrame = mathisFrame;
            }
            SeveralGrabber.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                this.go();
            };
            SeveralGrabber.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$begin
                var creator = new mathis.creation3D.Polyhedron(mathis.creation3D.PolyhedronType.Rhombicuboctahedron);
                var mamesh = creator.go();
                //$$$end
            };
            return SeveralGrabber;
        }());
    })(documentation = mathis.documentation || (mathis.documentation = {}));
})(mathis || (mathis = {}));
/**
 * Created by vigon on 23/12/2016.
 */
var mathis;
(function (mathis) {
    var documentation;
    (function (documentation) {
        var MathisFrameDocu = (function () {
            function MathisFrameDocu(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.pageIdAndTitle = "Positioning objects";
                var severalParts = new documentation.SeveralParts();
                severalParts.addPart(new AxisAndSomeMesh(this.mathisFrame));
                this.severalParts = severalParts;
            }
            MathisFrameDocu.prototype.go = function () {
                return this.severalParts.go();
            };
            return MathisFrameDocu;
        }());
        documentation.MathisFrameDocu = MathisFrameDocu;
        var AxisAndSomeMesh = (function () {
            function AxisAndSomeMesh(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "AxisAndSomeMesh";
                this.$$$title = "We position some mesh on space";
                this.order = 0;
                this.$$$order = [0, 1, 2];
                this.move = true;
                this.$$$move = [true, false];
                this.upTranslation = true;
                this.$$$upTranslation = [true, false];
            }
            AxisAndSomeMesh.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                this.go();
            };
            AxisAndSomeMesh.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$begin
                /**BabylonJS use a left-hand axis system*/
                var axisCreator = new mathis.creation3D.TwoOrTreeAxis(this.mathisFrame.scene);
                axisCreator.addLabelsXYZ = true;
                axisCreator.go();
                //n
                /**we put a small cube*/
                var cube = BABYLON.Mesh.CreateBox('', 0.1, this.mathisFrame.scene);
                cube.position = new mathis.XYZ(0.5, 0.5, 0.5);
                //n
                /** we add a second axis-system   */
                var axisToMove = new mathis.creation3D.TwoOrTreeAxis(this.mathisFrame.scene).go();
                /** we add a cone*/
                var coneToMove = BABYLON.Mesh.CreateCylinder("", 0.5, 0, 0.5, 20, 3, this.mathisFrame.scene);
                axisToMove.push(coneToMove);
                if (this.upTranslation) {
                    /**a translation that we bake (if not, this translation will be forget when we will move again the cone)*/
                    coneToMove.position.y = 0.5;
                    coneToMove.bakeCurrentTransformIntoVertices();
                }
                if (this.move) {
                    var positioning = new mathis.Positioning();
                    /**we indicate where must goChanging the x-axis and where must goChanging the y-axis*/
                    positioning.setOrientation(new mathis.XYZ(-1, 1, 0), new mathis.XYZ(1, 1, 0));
                    positioning.scaling = new mathis.XYZ(0.2, 0.2, 0.2);
                    positioning.position = new mathis.XYZ(-0.5, 0.5, 0);
                    positioning.applyToMeshes(axisToMove);
                }
                /**NB : transformation are always applied in the following order:
                 * 1/  scaling, 2/  rotating 3/ translating */
                //$$$end
                // threeArrows.scaling = new XYZ(0.2, 0.2, 0.2)
                // threeArrows.rotationQuaternion = new XYZW(0, 0, 0, 0)
                // geo.axisAngleToQuaternion(new XYZ(1, 0, 0), Math.PI / 4, threeArrows.rotationQuaternion)
                // threeArrows.position = new XYZ(-0.5, 0, 0)
                // let order=this.order
                // if (order==0) {
                //     threeArrows.scaling = new XYZ(0.2, 0.2, 0.2)
                //     threeArrows.rotationQuaternion = new XYZW(0, 0, 0, 0)
                //     geo.axisAngleToQuaternion(new XYZ(1, 0, 0), Math.PI / 4, threeArrows.rotationQuaternion)
                //     threeArrows.position = new XYZ(-0.5, 0, 0)
                // }
                // else if (order==1){
                //     /**to start with the translation, we have to force the transformation*/
                //     threeArrows.position = new XYZ(-0.5, 0, 0)
                //     threeArrows.bakeCurrentTransformIntoVertices()
                //     //n
                //     threeArrows.scaling = new XYZ(0.2, 0.2, 0.2)
                //     threeArrows.rotationQuaternion = new XYZW(0, 0, 0, 0)
                //     geo.axisAngleToQuaternion(new XYZ(1, 0, 0), Math.PI / 4, threeArrows.rotationQuaternion)
                // }
                // else if (order==2){
                //     threeArrows.position = new XYZ(-0.5, 0, 0)
                //     threeArrows.bakeCurrentTransformIntoVertices()
                //
                //     //n
                //     threeArrows.scaling = new XYZ(0.2, 0.2, 0.2)
                //     threeArrows.bakeCurrentTransformIntoVertices()
                //
                //     //n
                //     threeArrows.rotationQuaternion = new XYZW(0, 0, 0, 0)
                //     geo.axisAngleToQuaternion(new XYZ(1, 0, 0), Math.PI / 4, threeArrows.rotationQuaternion)
                // }
                //new visu3d.VerticesViewer(mamesh, this.mathisFrame.scene).goChanging()
            };
            return AxisAndSomeMesh;
        }());
    })(documentation = mathis.documentation || (mathis.documentation = {}));
})(mathis || (mathis = {}));
/**
 * Created by vigon on 21/11/2016.
 */
var mathis;
(function (mathis) {
    var documentation;
    (function (documentation) {
        var ReseauDocu = (function () {
            function ReseauDocu(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.pageIdAndTitle = "Reseaux (=nets)";
                var severalParts = new documentation.SeveralParts();
                severalParts.addPart(new RegularReseauDocu(this.mathisFrame));
                severalParts.addPart(new RegularBasisDocu(this.mathisFrame));
                severalParts.addPart(new PolygonalResauDocu(this.mathisFrame));
                severalParts.addPart(new Regular3dReseauDocu(this.mathisFrame));
                this.severalParts = severalParts;
            }
            ReseauDocu.prototype.go = function () {
                return this.severalParts.go();
            };
            return ReseauDocu;
        }());
        documentation.ReseauDocu = ReseauDocu;
        var RegularReseauDocu = (function () {
            function RegularReseauDocu(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "RegularReseauDocu";
                this.$$$title = "Regular Reseau (=net)";
                this.nbI = 3;
                this.$$$nbI = new documentation.Choices([3, 5, 7]);
                this.oneMoreVertexForOddLine = false;
                this.$$$oneMoreVertexForOddLine = new documentation.Choices([true, false]);
                this.squareMaille = true;
                this.$$$squareMaille = new documentation.Choices([true, false]);
                this.Vj = new mathis.XYZ(0, 0.2, 0);
                this.$$$Vj = new documentation.Choices([new mathis.XYZ(0, 0.2, 0), new mathis.XYZ(0.05, 0.2, 0)], { "before": "new XYZ" });
            }
            RegularReseauDocu.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                this.go();
            };
            RegularReseauDocu.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$begin
                var creator = new mathis.reseau.Regular();
                /** Vi and Vj form the basis of the reseau.
                 * For square net, points are i*Vi + j*Vj
                 * For triangular net, points are :
                 *  i*Vi + (j+decay)*Vj where decay=0.5 when j is odd*/
                creator.nbI = this.nbI;
                creator.nbJ = 4;
                creator.Vi = new mathis.XYZ(0.2, 0, 0);
                creator.Vj = this.Vj;
                creator.origine = new mathis.XYZ(-0.7, -0.7, 0);
                //n
                creator.squareVersusTriangleMaille = this.squareMaille;
                /**true-> square net, false->triangular net*/
                creator.oneMoreVertexForOddLine = this.oneMoreVertexForOddLine;
                //n
                var mamesh = creator.go();
                //$$$end
                //$$$bh visualization
                new mathis.visu3d.VerticesViewer(mamesh, this.mathisFrame.scene).go();
                new mathis.visu3d.LinksViewer(mamesh, this.mathisFrame.scene).go();
                new mathis.visu3d.SurfaceViewer(mamesh, this.mathisFrame.scene).go();
                //$$$eh
            };
            return RegularReseauDocu;
        }());
        var RegularBasisDocu = (function () {
            function RegularBasisDocu(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "RegularBasisDocu";
                this.$$$title = "Basis generation for regular reseau ";
                this.nbI = 3;
                this.$$$nbI = new documentation.Choices([3, 5, 7]);
                this.squareMaille = true;
                this.$$$squareMaille = new documentation.Choices([true, false]);
                this.Vj = new mathis.XYZ(0, 0.2, 0);
                this.$$$Vj = new documentation.Choices([new mathis.XYZ(0, 0.2, 0), new mathis.XYZ(0.05, 0.2, 0)], { "before": "new XYZ" });
                this.end = new mathis.XYZ(0.7, 0.7, 0);
                this.$$$end = new documentation.Choices([new mathis.XYZ(0.7, 0.7, 0), new mathis.XYZ(0, 0, 0), new mathis.XYZ(0.5, 1, 0)], { "before": "new XYZ" });
                this.setNBJ = true;
                this.$$$setNBJ = [true, false];
            }
            RegularBasisDocu.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                this.go();
            };
            RegularBasisDocu.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$begin
                var basis = new mathis.reseau.BasisForRegularReseau();
                basis.nbI = this.nbI;
                /**if true: nbJ is computed to obtain regular triangle/square*/
                basis.set_nbJ_toHaveRegularReseau = this.setNBJ;
                /**if previous is true, the next affectation is useless*/
                basis.nbJ = 4;
                basis.origin = new mathis.XYZ(-0.7, -0.7, 0);
                basis.end = this.end;
                basis.squareMailleInsteadOfTriangle = this.squareMaille;
                //n
                var creator = new mathis.reseau.Regular(basis);
                //n
                var mamesh = creator.go();
                //$$$end
                //$$$bh visualization
                new mathis.visu3d.VerticesViewer(mamesh, this.mathisFrame.scene).go();
                new mathis.visu3d.LinksViewer(mamesh, this.mathisFrame.scene).go();
                new mathis.visu3d.SurfaceViewer(mamesh, this.mathisFrame.scene).go();
                //$$$eh
            };
            return RegularBasisDocu;
        }());
        var PolygonalResauDocu = (function () {
            function PolygonalResauDocu(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.nbSides = 7;
                this.$$$nbSides = new documentation.Choices([3, 4, 5, 6, 7, 9, 11]);
                this.nbSubdivisionsInARadius = 3;
                this.$$$nbSubdivisionsInARadius = new documentation.Choices([1, 2, 3, 4, 5]);
                this.$$$name = "PolygonalResauDocu";
                this.$$$title = "Polygonal reseau";
            }
            PolygonalResauDocu.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                this.go();
            };
            PolygonalResauDocu.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$begin
                /**for triangles, with no vertex at the center, use "reseau.TriangulatedTriangle"*/
                var creator = new mathis.reseau.TriangulatedPolygone(this.nbSides);
                creator.nbSubdivisionInARadius = this.nbSubdivisionsInARadius;
                creator.origin = new mathis.XYZ(-1, -1, 0);
                creator.end = new mathis.XYZ(1, 1, 0);
                var mamesh = creator.go();
                //$$$end
                //$$$bh visualization
                new mathis.visu3d.VerticesViewer(mamesh, this.mathisFrame.scene).go();
                new mathis.visu3d.LinksViewer(mamesh, this.mathisFrame.scene).go();
                new mathis.visu3d.SurfaceViewer(mamesh, this.mathisFrame.scene).go();
                //$$$eh
            };
            return PolygonalResauDocu;
        }());
        var Regular3dReseauDocu = (function () {
            function Regular3dReseauDocu(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "Regular3dReseauDocu";
                this.$$$title = "A 3d reseau now";
                this.Vj = new mathis.XYZ(0, 0.2, 0);
                this.$$$Vj = new documentation.Choices([new mathis.XYZ(0, 0.2, 0), new mathis.XYZ(0.05, 0.2, 0)], { "before": "new XYZ" });
                this.nbI = 4;
                this.$$$nbI = new documentation.Choices([4, 6, 8]);
                this.decayOddStrates = false;
                this.$$$decayOddStrates = new documentation.Choices([true, false]);
                this.interStrateMailleAreSquareVersusTriangle = true;
                this.$$$interStrateMailleAreSquareVersusTriangle = new documentation.Choices([true, false]);
                this.strateHaveSquareMailleVersusTriangleMaille = true;
                this.$$$strateHaveSquareMailleVersusTriangleMaille = new documentation.Choices([true, false]);
            }
            Regular3dReseauDocu.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                this.go();
            };
            Regular3dReseauDocu.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$begin
                var creator = new mathis.reseau.Regular3D();
                creator.nbI = this.nbI;
                creator.nbJ = 4;
                creator.nbK = 5;
                creator.Vi = new mathis.XYZ(0.2, 0, 0);
                creator.Vj = this.Vj;
                creator.Vk = new mathis.XYZ(0, 0, 0.2);
                creator.origine = new mathis.XYZ(-0.7, -0.7, -0.7);
                //n
                creator.decayOddStrates = this.decayOddStrates;
                creator.interStrateMailleAreSquareVersusTriangle = this.interStrateMailleAreSquareVersusTriangle;
                creator.strateHaveSquareMailleVersusTriangleMaille = this.strateHaveSquareMailleVersusTriangleMaille;
                //n
                var mamesh = creator.go();
                //$$$end
                //$$$bh visualization
                new mathis.visu3d.VerticesViewer(mamesh, this.mathisFrame.scene).go();
                new mathis.visu3d.LinksViewer(mamesh, this.mathisFrame.scene).go();
                new mathis.visu3d.SurfaceViewer(mamesh, this.mathisFrame.scene).go();
                //$$$eh
            };
            return Regular3dReseauDocu;
        }());
    })(documentation = mathis.documentation || (mathis.documentation = {}));
})(mathis || (mathis = {}));
/**
 * Created by vigon on 22/12/2016.
 */
/**
 * Created by vigon on 21/11/2016.
 */
var mathis;
(function (mathis) {
    var documentation;
    (function (documentation) {
        var SurfaceDocu = (function () {
            function SurfaceDocu(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.pageIdAndTitle = "Surfaces from reseaux";
                var severalParts = new documentation.SeveralParts();
                severalParts.addPart(new HelicoidDocu(this.mathisFrame));
                severalParts.addPart(new DeformedReseau(this.mathisFrame));
                this.severalParts = severalParts;
            }
            SurfaceDocu.prototype.go = function () {
                return this.severalParts.go();
            };
            return SurfaceDocu;
        }());
        documentation.SurfaceDocu = SurfaceDocu;
        var DeformedReseau = (function () {
            function DeformedReseau(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "DeformedReseau";
                this.$$$title = "Pushing up a reseau to make a surface";
                this.linesVersusLinks = true;
                this.$$$linesVersusLinks = [true, false];
                this.func = function (v) { return new mathis.XYZ(v.x, v.x * v.y, v.y); };
                this.$$$func = new documentation.Choices([
                    function (v) { return new mathis.XYZ(v.x, v.x * v.y, v.y); },
                    function (v) { return new mathis.XYZ(v.x, 0.5 * Math.sin(5 * v.x), v.y); }
                ]);
            }
            DeformedReseau.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                this.go();
            };
            DeformedReseau.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$begin
                var creator = new mathis.reseau.TriangulatedPolygone(10);
                creator.nbSubdivisionInARadius = 5;
                creator.origin = new mathis.XYZ(-1, -1, 0);
                creator.end = new mathis.XYZ(1, 1, 0);
                var mamesh = creator.go();
                var func = this.func;
                for (var i = 0; i < mamesh.vertices.length; i++) {
                    var vertex = mamesh.vertices[i];
                    vertex.position = func(vertex.position);
                }
                var lineVersusLinks = this.linesVersusLinks;
                if (lineVersusLinks) {
                    /**coloring can be improve (e.g. using symmetries, and better hue variations. see further)*/
                    new mathis.visu3d.LinesViewer(mamesh, this.mathisFrame.scene).go();
                }
                else {
                    new mathis.visu3d.LinksViewer(mamesh, this.mathisFrame.scene).go();
                }
                new mathis.visu3d.SurfaceViewer(mamesh, this.mathisFrame.scene).go();
                //$$$end
            };
            return DeformedReseau;
        }());
        var HelicoidDocu = (function () {
            function HelicoidDocu(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "HelicoidDocu";
                this.$$$title = "We create an hellicoid. Best respresentation can de done with more vertex, but in this cas, " +
                    "you have to not draw all the line (see section in line visualization for line selection)";
                this.a = 0.2;
                this.$$$a = [0.1, 0.2, 1];
                this.nbI = 10;
                this.$$$nbI = [5, 10, 20];
                this.nbJ = 20;
                this.$$$nbJ = [10, 20, 40];
            }
            HelicoidDocu.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                this.go();
            };
            HelicoidDocu.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$begin
                var basis = new mathis.reseau.BasisForRegularReseau();
                basis.nbI = this.nbI;
                basis.nbJ = this.nbJ;
                basis.origin = new mathis.XYZ(-Math.PI, -1, 0);
                basis.end = new mathis.XYZ(Math.PI, 1, 0);
                var creator = new mathis.reseau.Regular(basis);
                var mamesh = creator.go();
                var a = this.a;
                for (var _i = 0, _a = mamesh.vertices; _i < _a.length; _i++) {
                    var vertex = _a[_i];
                    var u = vertex.position.x;
                    var v = vertex.position.y;
                    vertex.position.x = v * Math.cos(u);
                    vertex.position.y = a * u;
                    vertex.position.z = v * Math.sin(u);
                }
                new mathis.visu3d.LinesViewer(mamesh, this.mathisFrame.scene).go();
                new mathis.visu3d.SurfaceViewer(mamesh, this.mathisFrame.scene).go();
                //$$$end
            };
            return HelicoidDocu;
        }());
    })(documentation = mathis.documentation || (mathis.documentation = {}));
})(mathis || (mathis = {}));
/**
 * Created by vigon on 05/01/2017.
 */
/**
 * Created by vigon on 22/12/2016.
 */
/**
 * Created by vigon on 21/11/2016.
 */
var mathis;
(function (mathis) {
    var documentation;
    (function (documentation) {
        var SurfaceViewerDocu = (function () {
            function SurfaceViewerDocu(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.pageIdAndTitle = "Surface viewing";
                var severalParts = new documentation.SeveralParts();
                severalParts.addPart(new BackFaceCullingDocu(this.mathisFrame));
                severalParts.addPart(new DuplicateNormalDocu(this.mathisFrame));
                severalParts.addPart(new MoebiusBandDocu(this.mathisFrame));
                this.severalParts = severalParts;
            }
            SurfaceViewerDocu.prototype.go = function () {
                return this.severalParts.go();
            };
            return SurfaceViewerDocu;
        }());
        documentation.SurfaceViewerDocu = SurfaceViewerDocu;
        var BackFaceCullingDocu = (function () {
            function BackFaceCullingDocu(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "BackFaceCullingDocu";
                this.$$$title = "We observe the effect of the side orientation and the back-face-culling";
                this.alpha = 0.5;
                this.$$$alpha = [0.1, 0.3, 0.5, 0.8, 1];
                this.color = mathis.Color.names.rebeccapurple;
                this.$$$color = new documentation.Choices([mathis.Color.names.rebeccapurple, mathis.Color.names.rosybrown, mathis.Color.names.darkorange], { 'before': 'Color.names.', 'visualValues': ['rebeccapurple', 'rosybrown', 'darkorange'] });
                this.backFaceCulling = true;
                this.$$$backFaceCulling = [true, false];
                this.sideOrientation = BABYLON.Mesh.FRONTSIDE;
                this.$$$sideOrientation = new documentation.Choices([BABYLON.Mesh.DOUBLESIDE, BABYLON.Mesh.BACKSIDE, BABYLON.Mesh.FRONTSIDE], { 'visualValues': ['DOUBLESIDE', 'BACKSIDE', 'FRONTSIDE'], 'before': 'BABYLON.Mesh.' });
                this.toIncludeAtTheBeginOfTheFirstHiddenPiece = ["var mathisFrame=new mathis.MathisFrame()", "/**back the camera*/", "this.mathisFrame.getGrabberCamera().changePosition(new XYZ(0,0,-7))"];
            }
            BackFaceCullingDocu.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                this.mathisFrame.getGrabberCamera().changePosition(new mathis.XYZ(0, 0, -7));
                this.go();
            };
            BackFaceCullingDocu.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$begin
                var creator = new mathis.reseau.TriangulatedPolygone(10);
                creator.nbSubdivisionInARadius = 5;
                creator.origin = new mathis.XYZ(-Math.PI * 0.8, -1, 0);
                creator.end = new mathis.XYZ(+Math.PI * 0.8, 1, 0);
                var mamesh = creator.go();
                for (var _i = 0, _a = mamesh.vertices; _i < _a.length; _i++) {
                    var vertex = _a[_i];
                    var u = vertex.position.x;
                    var v = vertex.position.y;
                    vertex.position.x = Math.cos(u);
                    vertex.position.y = Math.sin(u);
                    vertex.position.z = v;
                }
                var positioning = new mathis.Positioning();
                positioning.frontDir.copyFromFloats(1, 0, 1);
                positioning.applyToVertices(mamesh.vertices);
                new mathis.visu3d.LinksViewer(mamesh, this.mathisFrame.scene).go();
                var surfaceViewer = new mathis.visu3d.SurfaceViewer(mamesh, this.mathisFrame.scene);
                surfaceViewer.alpha = this.alpha;
                surfaceViewer.color = new mathis.Color(this.color);
                /**best choice is : backFaceCulling=true and sideOrientation=DOUBLESIDE (if you want to see both-sides of your surface).
                 * When backFaceCulling=false, the transparency of your surface depend of the sideOrientation. If it is DOUBLESIDE, you see in the same time both faces,
                 * so transparency is degraded*/
                surfaceViewer.backFaceCulling = this.backFaceCulling;
                surfaceViewer.sideOrientation = this.sideOrientation;
                surfaceViewer.go();
                //$$$end
            };
            return BackFaceCullingDocu;
        }());
        var DuplicateNormalDocu = (function () {
            function DuplicateNormalDocu(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "DuplicateNormalDocu";
                this.$$$title = "WebGL need normals to reflect light. But, what a pity, normal was positioned at points (while mathematically, a better choice would be to put one normal per triangle)." +
                    "So if you want to see sharp angle, you have du duplicate points in order to duplicate normals. ";
                this.alpha = 1;
                this.$$$alpha = [0.1, 0.3, 0.5, 0.8, 1];
                this.color = mathis.Color.names.rebeccapurple;
                this.$$$color = new documentation.Choices([mathis.Color.names.rebeccapurple, mathis.Color.names.rosybrown, mathis.Color.names.darkorange], { 'before': 'Color.names.', 'visualValues': ['rebeccapurple', 'rosybrown', 'darkorange'] });
                this.backFaceCulling = true;
                this.$$$backFaceCulling = [true, false];
                this.sideOrientation = BABYLON.Mesh.DOUBLESIDE;
                this.$$$sideOrientation = new documentation.Choices([BABYLON.Mesh.DOUBLESIDE, BABYLON.Mesh.BACKSIDE, BABYLON.Mesh.FRONTSIDE], { 'visualValues': ['DOUBLESIDE', 'BACKSIDE', 'FRONTSIDE'], 'before': 'BABYLON.Mesh.' });
                this.toIncludeAtTheBeginOfTheFirstHiddenPiece = ["var mathisFrame=new mathis.MathisFrame()", "/**back the camera*/", "this.mathisFrame.getGrabberCamera().changePosition(new XYZ(0,0,-7))"];
                this.letBabylonDoTheJob = false;
                this.$$$letBabylonDoTheJob = [true, false];
                this.normalDuplication = mathis.visu3d.NormalDuplication.duplicateVertex;
                this.$$$normalDuplication = new documentation.Choices(mathis.allIntegerValueOfEnume(mathis.visu3d.NormalDuplication), { 'visualValues': mathis.allStringValueOfEnume(mathis.visu3d.NormalDuplication), 'before': 'visu3d.NormalDuplication.' });
            }
            DuplicateNormalDocu.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                this.mathisFrame.getGrabberCamera().changePosition(new mathis.XYZ(0, 0, -7));
                this.go();
            };
            DuplicateNormalDocu.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$begin
                var creator = new mathis.creation3D.Polyhedron(mathis.creation3D.PolyhedronType.PentagonalDipyramid);
                var mamesh = creator.go();
                var surfaceViewer = new mathis.visu3d.SurfaceViewer(mamesh, this.mathisFrame.scene);
                /** with none : the diPyramid seem smooth.*/
                surfaceViewer.normalDuplication = this.normalDuplication;
                /**only useful for the option duplicateOnlyWhenNormalsAreTooFarr*/
                surfaceViewer.maxAngleBetweenNormals = Math.PI / 6;
                surfaceViewer.backFaceCulling = this.backFaceCulling;
                surfaceViewer.sideOrientation = this.sideOrientation;
                surfaceViewer.alpha = this.alpha;
                var babylonMesh = surfaceViewer.go();
                /** we can ask to BABYLON to duplicate normals. But in this case put surfaceViewer.normalDuplication to 'none'
                 * (if not you multiply by 4 the number of normals!).
                 * As far I now, in BABYLON, there is no option : duplicateOnlyWhenNormalsAreTooFarr, which is the default option of our mathis.SurfaceViewer*/
                var letBabylonDoTheJob = this.letBabylonDoTheJob;
                if (letBabylonDoTheJob)
                    babylonMesh.convertToFlatShadedMesh();
                //$$$end
            };
            return DuplicateNormalDocu;
        }());
        var MoebiusBandDocu = (function () {
            function MoebiusBandDocu(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "MoebiusBandDocu";
                this.$$$title = "Here is the moebius band, this is a non orientable surface. In this case, to duplicate  normal-vectors have a bad effect at the place where the band is glued ! " +
                    "To see this bad effect, look at the white triangle alternating with red-triangles this is due to the reflection of the specular light";
                this.alpha = 1;
                this.$$$alpha = [0.1, 0.3, 0.5, 0.8, 1];
                this.color = mathis.Color.names.rebeccapurple;
                this.$$$color = new documentation.Choices([mathis.Color.names.rebeccapurple, mathis.Color.names.rosybrown, mathis.Color.names.darkorange], { 'before': 'Color.names.', 'visualValues': ['rebeccapurple', 'rosybrown', 'darkorange'] });
                this.backFaceCulling = true;
                this.$$$backFaceCulling = [true, false];
                this.sideOrientation = BABYLON.Mesh.DOUBLESIDE;
                this.$$$sideOrientation = new documentation.Choices([BABYLON.Mesh.DOUBLESIDE, BABYLON.Mesh.BACKSIDE, BABYLON.Mesh.FRONTSIDE], { 'visualValues': ['DOUBLESIDE', 'BACKSIDE', 'FRONTSIDE'], 'before': 'BABYLON.Mesh.' });
                this.toIncludeAtTheBeginOfTheFirstHiddenPiece = ["var mathisFrame=new mathis.MathisFrame()", "/**back the camera*/", "this.mathisFrame.getGrabberCamera().changePosition(new XYZ(0,0,-7))"];
                this.vertexDuplication = mathis.visu3d.NormalDuplication.duplicateVertex;
                this.$$$vertexDuplication = new documentation.Choices(mathis.allIntegerValueOfEnume(mathis.visu3d.NormalDuplication), { 'visualValues': mathis.allStringValueOfEnume(mathis.visu3d.NormalDuplication), 'before': 'visu3d.NormalDuplication.' });
            }
            MoebiusBandDocu.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                this.mathisFrame.getGrabberCamera().changePosition(new mathis.XYZ(0, 0, -7));
                this.go();
            };
            MoebiusBandDocu.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$begin
                var basis = new mathis.reseau.BasisForRegularReseau();
                basis.origin = new mathis.XYZ(0, -1, 0);
                basis.end = new mathis.XYZ(2 * Math.PI, 1, 0);
                basis.nbI = 20;
                basis.nbJ = 10;
                var creator = new mathis.reseau.Regular(basis);
                var mamesh = creator.go();
                for (var _i = 0, _a = mamesh.vertices; _i < _a.length; _i++) {
                    var vertex = _a[_i];
                    var u = vertex.position.x;
                    var v = vertex.position.y;
                    vertex.position.x = (2 - v * Math.sin(u / 2)) * Math.sin(u);
                    vertex.position.y = (2 - v * Math.sin(u / 2)) * Math.cos(u);
                    vertex.position.z = v * Math.cos(u / 2);
                }
                var positioning = new mathis.Positioning();
                positioning.frontDir.copyFromFloats(1, 0, 1);
                positioning.applyToVertices(mamesh.vertices);
                new mathis.visu3d.LinksViewer(mamesh, this.mathisFrame.scene).go();
                var surfaceViewer = new mathis.visu3d.SurfaceViewer(mamesh, this.mathisFrame.scene);
                /**put normalDuplication to none, to suppress the bad effect */
                surfaceViewer.normalDuplication = this.vertexDuplication;
                surfaceViewer.backFaceCulling = this.backFaceCulling;
                surfaceViewer.sideOrientation = this.sideOrientation;
                surfaceViewer.alpha = this.alpha;
                surfaceViewer.go();
                //$$$end
            };
            return MoebiusBandDocu;
        }());
    })(documentation = mathis.documentation || (mathis.documentation = {}));
})(mathis || (mathis = {}));
var mathis;
(function (mathis) {
    var documentation;
    (function (documentation) {
        var TorusPlatonicDocu = (function () {
            function TorusPlatonicDocu(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.pageIdAndTitle = "Torus";
                var severalParts = new documentation.SeveralParts();
                severalParts.addPart(new TorusPart(this.mathisFrame));
                severalParts.addPart(new TorusPartLines(this.mathisFrame));
                this.severalParts = severalParts;
            }
            TorusPlatonicDocu.prototype.go = function () {
                return this.severalParts.go();
            };
            return TorusPlatonicDocu;
        }());
        documentation.TorusPlatonicDocu = TorusPlatonicDocu;
        var TorusPart = (function () {
            function TorusPart(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "TorusPart";
                this.$$$title = "A twisted torus from a skewed reseau";
                this.nbVerticalDecays = 2;
                this.$$$nbVerticalDecays = [0, 1, 2, 3, 4];
                this.nbHorizontalDecays = 1;
                this.$$$nbHorizontalDecays = [0, 1, 2, 3, 4];
                this.bent = false;
                this.$$$bent = [true, false];
                this.nbI = 5;
                this.$$$nbI = [4, 5, 6, 7, 8];
                this.nbJ = 20;
                this.$$$nbJ = [15, 16, 20, 30];
            }
            TorusPart.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                this.go();
            };
            TorusPart.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$begin
                /**SUB_generator allow to compute basis (Vi,Vj) of a planar reseau. If no decays,
                 * Vi and Vj are simply computed so that the reseau start at "origine" [default (0,0,0)]
                 * and finish at "end". To see effect of decays, observe ! */
                var generator = new mathis.reseau.BasisForRegularReseau();
                generator.nbI = this.nbI;
                generator.nbJ = this.nbJ;
                generator.origin = new mathis.XYZ(0, 0, 0);
                generator.end = new mathis.XYZ(2 * Math.PI, 2 * Math.PI, 0).scale(0.1);
                generator.nbVerticalDecays = this.nbVerticalDecays;
                generator.nbHorizontalDecays = this.nbHorizontalDecays;
                //n
                var creator = new mathis.reseau.Regular(generator);
                var mamesh = creator.go();
                //n
                var bent = this.bent;
                if (bent) {
                    var r_1 = 0.3;
                    var a_1 = 0.75;
                    mamesh.vertices.forEach(function (vertex) {
                        var u = vertex.position.x * 10;
                        var v = vertex.position.y * 10;
                        vertex.position.x = (r_1 * Math.cos(u) + a_1) * Math.cos((v));
                        vertex.position.y = (r_1 * Math.cos(u) + a_1) * Math.sin((v));
                        vertex.position.z = r_1 * Math.sin(u);
                    });
                }
                //$$$end
                var linksViewer = new mathis.visu3d.LinksViewer(mamesh, this.mathisFrame.scene);
                linksViewer.lateralScalingConstant = 0.02;
                linksViewer.go();
                var surfaceViewer = new mathis.visu3d.SurfaceViewer(mamesh, this.mathisFrame.scene);
                surfaceViewer.alpha = 0.7;
                surfaceViewer.go();
                // let merger=new mameshModification.Merger(mamesh)
                // merger.mergeLink=true
                // merger.goChanging()
                //
                // let oppositeAssocier=new linkModule.OppositeLinkAssocierByAngles(IN_mamesh.vertices)
                // oppositeAssocier.maxAngleToAssociateLinks=Math.PI
                // oppositeAssocier.goChanging()
            };
            return TorusPart;
        }());
        var TorusPartLines = (function () {
            function TorusPartLines(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "TorusPartLines";
                this.$$$title = "Problem : lines of the flat reseau behave badly on the torus. \nSolution : merge the vertices and remake links";
                this.nbVerticalDecays = 2;
                this.$$$nbVerticalDecays = [0, 1, 2, 3, 4];
                this.nbHorizontalDecays = 1;
                this.$$$nbHorizontalDecays = [0, 1, 2, 3, 4];
                this.bent = true;
                this.$$$bent = [true, false];
                this.merge = false;
                this.$$$merge = [true, false];
                this.nbI = 5;
                this.$$$nbI = [4, 5, 6, 7, 8];
                this.nbJ = 20;
                this.$$$nbJ = [15, 16, 20, 30];
                this.interpolationStyle = mathis.geometry.InterpolationStyle.hermite;
                this.$$$interpolationStyle = new documentation.Choices([mathis.geometry.InterpolationStyle.none, mathis.geometry.InterpolationStyle.octavioStyle, mathis.geometry.InterpolationStyle.hermite], { 'before': 'geometry.InterpolationStyle.', 'visualValues': ['none', 'octavioStyle', 'hermite'] });
            }
            TorusPartLines.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                this.go();
            };
            TorusPartLines.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$begin
                var generator = new mathis.reseau.BasisForRegularReseau();
                generator.nbI = this.nbI;
                generator.nbJ = this.nbJ;
                generator.origin = new mathis.XYZ(0, 0, 0);
                generator.end = new mathis.XYZ(2 * Math.PI, 2 * Math.PI, 0).scale(0.1);
                generator.nbVerticalDecays = this.nbVerticalDecays;
                generator.nbHorizontalDecays = this.nbHorizontalDecays;
                var creator = new mathis.reseau.Regular(generator);
                var mamesh = creator.go();
                //n
                var bent = this.bent;
                if (bent) {
                    var r_2 = 0.3;
                    var a_2 = 0.75;
                    mamesh.vertices.forEach(function (vertex) {
                        var u = vertex.position.x * 10;
                        var v = vertex.position.y * 10;
                        vertex.position.x = (r_2 * Math.cos(u) + a_2) * Math.cos((v));
                        vertex.position.y = (r_2 * Math.cos(u) + a_2) * Math.sin((v));
                        vertex.position.z = r_2 * Math.sin(u);
                    });
                    var merge = this.merge;
                    if (merge) {
                        var merger = new mathis.grateAndGlue.Merger(mamesh, null, null);
                        merger.mergeLink = true;
                        merger.goChanging();
                        var oppositeAssocier = new mathis.linkModule.OppositeLinkAssocierByAngles(mamesh.vertices);
                        oppositeAssocier.maxAngleToAssociateLinks = Math.PI;
                        oppositeAssocier.goChanging();
                    }
                }
                var interpolationStyle = this.interpolationStyle;
                //$$$end
                //$$$bh visualization
                var lineViewer = new mathis.visu3d.LinesViewer(mamesh, this.mathisFrame.scene);
                lineViewer.interpolationOption.interpolationStyle = interpolationStyle;
                lineViewer.go();
                //$$$eh
                // let surfaceViewer=new visu3d.SurfaceViewer(mamesh, this.mathisFrame.scene)
                // surfaceViewer.alpha=0.7
                //     surfaceViewer.goChanging()
            };
            return TorusPartLines;
        }());
    })(documentation = mathis.documentation || (mathis.documentation = {}));
})(mathis || (mathis = {}));
/**
 * Created by vigon on 08/02/2017.
 */
var mathis;
(function (mathis) {
    var documentation;
    (function (documentation) {
        var PureJavascriptTuto = (function () {
            function PureJavascriptTuto() {
                this.pageIdAndTitle = "hello world in pure javascript";
                this.severalParts = null;
            }
            PureJavascriptTuto.prototype.go = function () {
                /**oblig d'agir sur le parent car l'iframe sinon n'a pas de hauteur*/
                $('#pageContent').height('100%').empty();
                var $res = $('<div class="aWholeDiv"></div>');
                $res.append('<a target="_blank" href="https://drive.google.com/open?id=0B5ZYbxojmGIaMVFvdkZSVVFDY3M">Codes for this tuto and for the next one</a>');
                var $iframe = $('<iframe src="https://docs.google.com/document/d/1tqyLj66D4xKTPKeXS81GCZJwV_WHKH9PNywTrozmfM0/pub?embedded=true" style="overflow:hidden;height:100%;width:100%" height="100%" width="100%"></iframe>');
                $res.append($iframe);
                return $res;
            };
            return PureJavascriptTuto;
        }());
        documentation.PureJavascriptTuto = PureJavascriptTuto;
        var TypescriptTuto = (function () {
            function TypescriptTuto() {
                this.pageIdAndTitle = "hello typescript";
                this.severalParts = null;
            }
            TypescriptTuto.prototype.go = function () {
                /**oblig d'agir sur le parent car l'iframe sinon n'a pas de hauteur*/
                $('#pageContent').height('100%').empty();
                var $res = $('<div class="aWholeDiv"></div>');
                $res.append('<a target="_blank" href="https://drive.google.com/open?id=0B5ZYbxojmGIaMVFvdkZSVVFDY3M">Codes for this tuto and for the next one</a>');
                var $iframe = $('<iframe src="https://docs.google.com/document/d/1p6Ch4wyT9qVzLzdRSVumNRRB6CcpfrtNcJ_wbRku_94/pub?embedded=true" style="overflow:hidden;height:100%;width:100%" height="100%" width="100%"></iframe>');
                $res.append($iframe);
                return $res;
            };
            return TypescriptTuto;
        }());
        documentation.TypescriptTuto = TypescriptTuto;
    })(documentation = mathis.documentation || (mathis.documentation = {}));
})(mathis || (mathis = {}));
/**
 * Created by vigon on 22/12/2016.
 */
/**
 * Created by vigon on 21/11/2016.
 */
var mathis;
(function (mathis) {
    var documentation;
    (function (documentation) {
        var VerticesViewingDocu = (function () {
            function VerticesViewingDocu(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.pageIdAndTitle = "Vertices viewing";
                var severalParts = new documentation.SeveralParts();
                severalParts.addPart(new DefaultVerticesViewing(this.mathisFrame));
                severalParts.addPart(new ModelVerticesViewing(this.mathisFrame));
                severalParts.addPart(new ModelPositioning(this.mathisFrame));
                severalParts.addPart(new ModelAutoPositioning(this.mathisFrame));
                this.severalParts = severalParts;
            }
            VerticesViewingDocu.prototype.go = function () {
                return this.severalParts.go();
            };
            return VerticesViewingDocu;
        }());
        documentation.VerticesViewingDocu = VerticesViewingDocu;
        var DefaultVerticesViewing = (function () {
            function DefaultVerticesViewing(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "DefaultVerticesViewing";
                this.$$$title = "By default : Each vertices is represented by a sphere. " +
                    "Sizes can be given or computed according to distances between vertices.";
                this.radiusProportion = 0.1;
                this.$$$radiusProportion = [0.1, 0.25, 0.5, 1];
                this.squareMailleInsteadOfTriangle = true;
                this.$$$squareMailleInsteadOfTriangle = [true, false];
                this.constantRadius = null;
                this.$$$constantRadius = [null, 0.05, 0.1, 0.2];
                this.useAModel = false;
                this.$$$useAModel = [true, false];
            }
            DefaultVerticesViewing.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                this.go();
            };
            DefaultVerticesViewing.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$bh mamesh creation
                var basis = new mathis.reseau.BasisForRegularReseau();
                basis.nbI = 3;
                basis.set_nbJ_toHaveRegularReseau = true;
                basis.squareMailleInsteadOfTriangle = this.squareMailleInsteadOfTriangle;
                basis.origin = new mathis.XYZ(-0.7, -0.7, 0);
                basis.end = new mathis.XYZ(0.7, 0.7, 0);
                var creator = new mathis.reseau.Regular(basis);
                var mamesh = creator.go();
                //$$$eh
                //$$$begin
                var verticesViewer = new mathis.visu3d.VerticesViewer(mamesh, this.mathisFrame.scene);
                /**by default, this attribute is null. So radius of vertices are computed
                 * according to the distances between neighbor vertices*/
                verticesViewer.constantRadius = this.constantRadius;
                /**this affectation is useless if previous is not null*/
                verticesViewer.radiusProp = this.radiusProportion;
                /**you can change the color (or the material via verticesViewer.material)*/
                verticesViewer.color = new mathis.Color(mathis.Color.names.indianred);
                verticesViewer.go();
                //n
                new mathis.visu3d.LinksViewer(mamesh, this.mathisFrame.scene).go();
                //$$$end
            };
            return DefaultVerticesViewing;
        }());
        var ModelVerticesViewing = (function () {
            function ModelVerticesViewing(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "ModelVerticesViewing";
                this.$$$title = "we use  babylonJS meshes as model for vertices";
                this.radiusProportion = 0.25;
                this.$$$radiusProportion = [0.1, 0.25, 0.5, 1];
                this.squareMailleInsteadOfTriangle = false;
                this.$$$squareMailleInsteadOfTriangle = [true, false];
                this.constantRadius = null;
                this.$$$constantRadius = [null, 0.1, 0.2, 0.3];
                this.modelChoice = 0;
                this.$$$modelChoice = [0, 1, 2, 3];
                this.justShowTheModel = false;
                this.$$$justShowTheModel = [true, false];
                this.scaleTheModel = true;
                this.$$$scaleTheModel = [true, false];
                this.backFaceCulling = true;
                this.$$$backFaceCulling = [true, false];
            }
            ModelVerticesViewing.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                this.go();
            };
            ModelVerticesViewing.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$bh mamesh creation
                var basis = new mathis.reseau.BasisForRegularReseau();
                basis.nbI = 3;
                basis.set_nbJ_toHaveRegularReseau = true;
                basis.squareMailleInsteadOfTriangle = this.squareMailleInsteadOfTriangle;
                basis.origin = new mathis.XYZ(-0.7, -0.7, 0);
                basis.end = new mathis.XYZ(0.7, 0.7, 0);
                var creator = new mathis.reseau.Regular(basis);
                var mamesh = creator.go();
                //$$$eh
                //$$$begin
                var verticesViewer = new mathis.visu3d.VerticesViewer(mamesh, this.mathisFrame.scene);
                verticesViewer.constantRadius = this.constantRadius;
                verticesViewer.radiusProp = this.radiusProportion;
                /**model mush have a bounding "radius" of 1. It will be re-sized by the vertices-viewer */
                var modelChoice = this.modelChoice;
                if (modelChoice == 0) {
                    verticesViewer.meshModel = BABYLON.Mesh.CreateCylinder("", 2, 0, 2, 20, 2, this.mathisFrame.scene);
                }
                else if (modelChoice == 1) {
                    /**we can put several models, and change the red-default color*/
                    verticesViewer.meshModels = [BABYLON.Mesh.CreateBox("", 1, this.mathisFrame.scene), BABYLON.Mesh.CreateCylinder("", 1, 0, 1, 20, 2, this.mathisFrame.scene)];
                    verticesViewer.meshModels[0].position.y = -0.5;
                    verticesViewer.meshModels[1].position.y = +0.5;
                    verticesViewer.color = new mathis.Color(mathis.Color.names.deeppink);
                }
                else if (modelChoice == 2) {
                    verticesViewer.meshModel = BABYLON.Mesh.CreateDisc("", 1, 20, this.mathisFrame.scene);
                    /**if a material is specified, default material is not used*/
                    var material = new BABYLON.StandardMaterial("", this.mathisFrame.scene);
                    material.backFaceCulling = false; //better for a disk
                    material.diffuseColor = new BABYLON.Color3(0, 0, 1); //blue
                    verticesViewer.meshModel.material = material;
                }
                else if (modelChoice == 3) {
                    /**the x-axis (red) is sent to the normal vectors*/
                    verticesViewer.meshModels = new mathis.creation3D.TwoOrTreeAxis(this.mathisFrame.scene).go();
                }
                //n
                var justShowTheModel = this.justShowTheModel;
                if (!justShowTheModel) {
                    /**if you do not fire "verticesViewer.goChanging()", we just see the model.*/
                    verticesViewer.go();
                    new mathis.visu3d.LinksViewer(mamesh, this.mathisFrame.scene).go();
                }
                //$$$end
            };
            return ModelVerticesViewing;
        }());
        var ModelPositioning = (function () {
            function ModelPositioning(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "ModelPositioning";
                this.$$$title = "we specify the positioning of the models";
                this.radiusProportion = 0.25;
                this.$$$radiusProportion = [0.1, 0.25, 0.5, 1];
                this.squareMailleInsteadOfTriangle = false;
                this.$$$squareMailleInsteadOfTriangle = [true, false];
                this.constantRadius = null;
                this.$$$constantRadius = [null, 0.1, 0.2, 0.3];
                this.modelChoice = 3;
                this.$$$modelChoice = [0, 1, 2, 3];
                this.justShowTheModel = false;
                this.$$$justShowTheModel = [true, false];
                this.scaleTheModel = true;
                this.$$$scaleTheModel = [true, false];
                this.backFaceCulling = true;
                this.$$$backFaceCulling = [true, false];
            }
            ModelPositioning.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                this.go();
            };
            ModelPositioning.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$bh mamesh creation as previously
                var basis = new mathis.reseau.BasisForRegularReseau();
                basis.nbI = 5;
                basis.set_nbJ_toHaveRegularReseau = true;
                basis.squareMailleInsteadOfTriangle = this.squareMailleInsteadOfTriangle;
                basis.origin = new mathis.XYZ(-0.7, -0.7, 0);
                basis.end = new mathis.XYZ(0.7, 0.7, 0);
                var creator = new mathis.reseau.Regular(basis);
                var mamesh = creator.go();
                var verticesViewer = new mathis.visu3d.VerticesViewer(mamesh, this.mathisFrame.scene);
                /**model mush have a bounding "radius" of 1. It will be re-sized by the vertices-viewer */
                var modelChoice = this.modelChoice;
                if (modelChoice == 0) {
                    verticesViewer.meshModel = BABYLON.Mesh.CreateCylinder("", 2, 0, 2, 20, 2, this.mathisFrame.scene);
                }
                else if (modelChoice == 1) {
                    /**we can put several models, and change the red-default color*/
                    verticesViewer.meshModels = [BABYLON.Mesh.CreateBox("", 1, this.mathisFrame.scene), BABYLON.Mesh.CreateCylinder("", 1, 0, 1, 20, 2, this.mathisFrame.scene)];
                    verticesViewer.meshModels[0].position.y = -0.5;
                    verticesViewer.meshModels[1].position.y = +0.5;
                    verticesViewer.color = new mathis.Color(mathis.Color.names.deeppink);
                }
                else if (modelChoice == 2) {
                    verticesViewer.meshModel = BABYLON.Mesh.CreateDisc("", 1, 20, this.mathisFrame.scene);
                    /**if a material is specified, default material is not used*/
                    var material = new BABYLON.StandardMaterial("", this.mathisFrame.scene);
                    material.backFaceCulling = false; //better for a disk
                    material.diffuseColor = new BABYLON.Color3(0, 0, 1); //blue
                    verticesViewer.meshModel.material = material;
                }
                else if (modelChoice == 3) {
                    /**the x-axis (red) is sent to the normal vectors*/
                    var twoAxisCreator = new mathis.creation3D.TwoOrTreeAxis(this.mathisFrame.scene);
                    twoAxisCreator.threeVersusTwoAxis = false;
                    verticesViewer.meshModels = twoAxisCreator.go();
                }
                //$$$eh
                //$$$begin
                var positionings = new mathis.HashMap();
                for (var i = 0; i < mamesh.vertices.length; i++) {
                    var positioning = new mathis.Positioning();
                    var angle = Math.random() * Math.PI * 2;
                    positioning.setOrientation(new mathis.XYZ(0, 0, -1), new mathis.XYZ(Math.cos(angle), Math.sin(angle), 0));
                    positioning.scaling = new mathis.XYZ(0.2, 0.2, 0.2);
                    positionings.putValue(mamesh.vertices[i], positioning);
                }
                verticesViewer.positionings = positionings;
                //n
                var justShowTheModel = this.justShowTheModel;
                if (!justShowTheModel) {
                    /**if you do not fire "verticesViewer.goChanging()", we just see the model.*/
                    verticesViewer.go();
                    new mathis.visu3d.LinksViewer(mamesh, this.mathisFrame.scene).go();
                }
                //$$$end
            };
            return ModelPositioning;
        }());
        var ModelAutoPositioning = (function () {
            function ModelAutoPositioning(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.$$$name = "ModelAutoPositioning";
                this.$$$title = "Positionings are computed from mamesh : " +
                    "FrontDir is the link. Which links ? the link the more  " +
                    "UpVector is the normal of the surface, which is computed either with a polygon or this vertices ";
                this.squareMailleInsteadOfTriangle = false;
                this.$$$squareMailleInsteadOfTriangle = [true, false];
                this.constantRadius = null;
                this.$$$constantRadius = [null, 0.1, 0.2, 0.3];
                this.modelChoice = 3;
                this.$$$modelChoice = [0, 1, 2, 3];
                this.justShowTheModel = false;
                this.$$$justShowTheModel = [true, false];
                this.scaleTheModel = true;
                this.$$$scaleTheModel = [true, false];
                this.backFaceCulling = true;
                this.$$$backFaceCulling = [true, false];
                this.attractionForTangent = new mathis.XYZ(100, 10, 0);
                this.$$$attractionForTangent = new documentation.Choices([new mathis.XYZ(100, 0, 0), new mathis.XYZ(-100, 0, 0), new mathis.XYZ(0, 100, 0), new mathis.XYZ(0, 0, 100)], { 'before': "new XYZ" });
                this.cylinderVersusSphere = true;
                this.$$$cylinderVersusSphere = [true, false];
                this.randomFrontDir = false;
                this.$$$randomFrontDir = [true, false];
            }
            ModelAutoPositioning.prototype.goForTheFirstTime = function () {
                this.mathisFrame.clearScene();
                this.mathisFrame.addDefaultCamera();
                this.mathisFrame.addDefaultLight();
                this.go();
            };
            ModelAutoPositioning.prototype.go = function () {
                this.mathisFrame.clearScene(false, false);
                //$$$b
                var cylinderVersusSphere = this.cylinderVersusSphere;
                //$$$e
                //$$$bh cylinder or sphere creation
                var mamesh;
                if (cylinderVersusSphere) {
                    var basis = new mathis.reseau.BasisForRegularReseau();
                    basis.origin = new mathis.XYZ(0, -1, 0);
                    basis.end = new mathis.XYZ(Math.PI, +1, 0);
                    basis.nbI = 5;
                    basis.nbJ = 7;
                    mamesh = new mathis.reseau.Regular(basis).go();
                    for (var i = 0; i < mamesh.vertices.length; i++) {
                        var oldPosition = mathis.XYZ.newFrom(mamesh.vertices[i].position);
                        mamesh.vertices[i].position.x = Math.cos(oldPosition.x);
                        mamesh.vertices[i].position.z = Math.sin(oldPosition.x);
                    }
                }
                else {
                    var creator = new mathis.creation3D.Polyhedron(mathis.creation3D.PolyhedronType.Dodecahedron);
                    mamesh = creator.go();
                    new mathis.mameshModification.TriangleDichotomer(mamesh).go();
                    for (var i = 0; i < mamesh.vertices.length; i++) {
                        mamesh.vertices[i].position.normalize();
                    }
                }
                var verticesViewer = new mathis.visu3d.VerticesViewer(mamesh, this.mathisFrame.scene);
                //$$$eh
                //$$$b
                var modelChoice = this.modelChoice;
                //$$$e
                //$$$bh model creation
                if (modelChoice == 0) {
                    verticesViewer.meshModel = BABYLON.Mesh.CreateCylinder("", 2, 0, 2, 20, 2, this.mathisFrame.scene);
                }
                else if (modelChoice == 1) {
                    /**we can put several models, and change the red-default color*/
                    verticesViewer.meshModels = [BABYLON.Mesh.CreateBox("", 1, this.mathisFrame.scene), BABYLON.Mesh.CreateCylinder("", 1, 0, 1, 20, 2, this.mathisFrame.scene)];
                    verticesViewer.meshModels[0].position.y = -0.5;
                    verticesViewer.meshModels[1].position.y = +0.5;
                    verticesViewer.color = new mathis.Color(mathis.Color.names.deeppink);
                }
                else if (modelChoice == 2) {
                    verticesViewer.meshModel = BABYLON.Mesh.CreateDisc("", 1, 20, this.mathisFrame.scene);
                    /**if a material is specified, default material is not used*/
                    var material = new BABYLON.StandardMaterial("", this.mathisFrame.scene);
                    material.backFaceCulling = false; //better for a disk
                    material.diffuseColor = new BABYLON.Color3(0, 0, 1); //blue
                    verticesViewer.meshModel.material = material;
                }
                else if (modelChoice == 3) {
                    var twoAxisCreator = new mathis.creation3D.TwoOrTreeAxis(this.mathisFrame.scene);
                    twoAxisCreator.threeVersusTwoAxis = false;
                    verticesViewer.meshModels = twoAxisCreator.go();
                }
                //$$$eh
                //$$$begin
                var positioningComputer = new mathis.mameshAroundComputations.PositioningComputerForMameshVertices(mamesh);
                positioningComputer.attractionOfTangent = this.attractionForTangent;
                /**to compute normal (= upVector) is quite a heavy job : first we must compute a normal by polygon, and
                 * then, for each vertex, we have to take the barycenter of the normal of polygons around.
                 * Moreover these normals can be use by several guys e.g. by other verticesViewers or by a linksViewer (see further on).
                 * So it is a good think to memorize  vertexToPositioning inside the mamesh*/
                mamesh.vertexToPositioning = positioningComputer.go();
                /**then we have to say to the verticesViewer  to use this vertexToPositioning*/
                verticesViewer.positionings = mamesh.positionings;
                /**you can also decide to no use the frontDir previously computed, or to not use the sizes. Ex*/
                if (this.randomFrontDir) {
                    for (var i = 0; i < mamesh.vertices.length; i++) {
                        var positioning = mamesh.positionings.getValue(mamesh.vertices[i]);
                        mathis.geo.getOneOrthonormal(positioning.upVector, positioning.frontDir);
                    }
                }
                //n
                var justShowTheModel = this.justShowTheModel;
                if (!justShowTheModel) {
                    /**if you do not fire "verticesViewer.goChanging()", we just see the model.*/
                    verticesViewer.go();
                    var linksViewer = new mathis.visu3d.LinksViewer(mamesh, this.mathisFrame.scene);
                    linksViewer.lateralScalingConstant = 0.01;
                    linksViewer.go();
                }
                //$$$end
            };
            return ModelAutoPositioning;
        }());
    })(documentation = mathis.documentation || (mathis.documentation = {}));
})(mathis || (mathis = {}));
/**
 * Created by vigon on 31/01/2017.
 */
var mathis;
(function (mathis) {
    var documentation;
    (function (documentation) {
        var WhyBlabla = (function () {
            function WhyBlabla(mathisFrame) {
                this.mathisFrame = mathisFrame;
                this.pageIdAndTitle = "mathis, what ?";
                this.severalParts = null;
            }
            WhyBlabla.prototype.go = function () {
                var localAddress = "../../MATHIS/finalized/gauss/gauss.html";
                var serverAddress = "http://92.222.18.63/MATHIS/finalized/gauss/gauss.html";
                var blabla = "<div style=\"padding:2em\">A young library to easily construct math objets inside browser. \n                Targeted: teachers (pedagogic tools), researchers (simulations, portfolio), and all math lovers (amazing). \n                For any comments: vincent #point vigon #hatte math #point unistra #point fr </div>";
                var links = "<div style=\"padding:2em\">As example, <a target=\"_blank\" href=\"http://92.222.18.63/MATHIS/finalized/gauss/gauss.html\">here is a mathis-application</a>,\n                illustrating the Gauss-map and the Gauss-curvature.</div>";
                return $("<div></div>").append(blabla).append(links);
            };
            return WhyBlabla;
        }());
        documentation.WhyBlabla = WhyBlabla;
    })(documentation = mathis.documentation || (mathis.documentation = {}));
})(mathis || (mathis = {}));
/**
 * Created by vigon on 05/05/2016.
 */
var mathis;
(function (mathis) {
    var Color3 = BABYLON.Color3;
    var gauss;
    (function (gauss) {
        var StandardMaterial = BABYLON.StandardMaterial;
        var SurfaceName = mathis.riemann.SurfaceName;
        function start() {
            var mainDiv = document.getElementById("mainDiv");
            //let canvass = mathis.nCanvasInOneLine(2, mainDiv)
            var frame = new mathis.MathisFrame("surfaceMathisFrame", false);
            var frame2 = new mathis.MathisFrame("sphereMathisFrame", false);
            var buttonPlace = mathis.legend('30px', mainDiv, false);
            new GaussCurvature(frame, frame2, buttonPlace);
        }
        gauss.start = start;
        var DrawNormalAndTangentVector = (function () {
            function DrawNormalAndTangentVector(
                //IN_mamesh:Mamesh,
                cartes, scene, sphereScene, cam, surface) {
                this.sizes = new mathis.XYZ(1, 1, 1);
                // findAndDraw(point:XYZ):void{
                //     let clickedVertex=this.findClosestVertex(point,this.vertices)
                //     let u=clickedVertex.mathUV.x
                //     let v=clickedVertex.mathUV.y
                //     this.draw(u,v)
                // }
                this.arrowColor = new Color3(1, 0, 0);
                this.planeColor = new Color3(0, 0, 1);
                this.planeRadius = 0.2;
                this.tangentDiameter = 0.1;
                //this.IN_mamesh=IN_mamesh
                this.cartes = cartes;
                this.surfaceScene = scene;
                this.cam = cam;
                this.sphereScene = sphereScene;
                this.surface = surface;
            }
            // findClosestVertex(point:XYZ):Vertex{
            //     let res:Vertex=null
            //     let minDist=Number.MAX_VALUE
            //
            //     this.IN_mamesh.vertices.forEach(v=>{
            //         let dist=geo.distance(v.position,point)
            //         if (dist<minDist) {
            //             minDist=dist
            //             res=v
            //         }
            //     })
            //     return  res
            // }
            // findUvAndCarte(xyz:XYZ):{uv:UV;carte:Carte}{
            //
            //
            //     let maxDistToBorder=0
            //     let chosenCarte:Carte=null
            //     let chosenUV:UV=null
            //
            //     this.cartes.forEach(carte=>{
            //         let uvAndDist= carte.xyzToUV(xyz)
            //         chosenCarte=carte
            //         chosenUV=uvAndDist.uv
            //         /** we chose the carte for which the point is the most central (the further from the border)*/
            //         if (uvAndDist.distToBorder>maxDistToBorder) {
            //             maxDistToBorder=uvAndDist.distToBorder
            //             chosenCarte=carte
            //             chosenUV=uvAndDist.uv
            //         }
            //
            //     })
            //
            //     return {uv:chosenUV,carte:chosenCarte}
            // }
            // findUV(point:XYZ,vertices:Vertex[]):XYZ{
            //     let res:Vertex=null
            //     let minDist=Number.MAX_VALUE
            //
            //     vertices.forEach(v=>{
            //         let dist=geo.distance(v.position,point)
            //         if (dist<minDist) {
            //             minDist=dist
            //             res=v
            //         }
            //     })
            //     return  {u:res.}
            // }
            DrawNormalAndTangentVector.prototype.checkOrientation = function (u, v, carte) {
                var pointToCam = mathis.XYZ.newFrom(this.cam.trueCamPos.position).substract(carte.X(u, v));
                if (mathis.geo.dot(pointToCam, carte.newN(u, v)) < 0)
                    carte.orientationCoef *= -1;
            };
            DrawNormalAndTangentVector.prototype.oneArrowOnOneScene = function (point, quaternion, scene, sizes) {
                var creatorArrowMesh = new mathis.creation3D.ArrowCreator(scene);
                //creatorArrowMesh.headUp=this.naturalOrientationComesToCam
                var arrow = creatorArrowMesh.go();
                arrow.position = point;
                arrow.rotationQuaternion = quaternion;
                var mat = new BABYLON.StandardMaterial('', scene);
                mat.diffuseColor = this.arrowColor;
                arrow.material = mat;
                arrow.scaling = sizes;
                return arrow;
            };
            DrawNormalAndTangentVector.prototype.drawNormalVectors = function (u, v, carte) {
                this.checkOrientation(u, v, carte);
                var positionning = new mathis.Positioning();
                positionning.upVector = carte.newN(u, v);
                var quat = positionning.quaternion();
                var initial = this.oneArrowOnOneScene(carte.X(u, v), quat, this.surfaceScene, this.sizes);
                var onSphere = this.oneArrowOnOneScene(new mathis.XYZ(0, 0, 0), quat.clone(), this.sphereScene, new mathis.XYZ(this.sizes.x, 1, this.sizes.z));
                return { initial: initial, onSphere: onSphere };
            };
            DrawNormalAndTangentVector.prototype.oneTangentPlane = function (normal, tangent, position, scene, onClick) {
                if (onClick === void 0) { onClick = null; }
                var res = BABYLON.Mesh.CreateDisc('', this.planeRadius, 60, scene);
                var qua = new mathis.XYZW(0, 0, 0, 0);
                mathis.geo.aQuaternionMovingABtoCD(new mathis.XYZ(0, 0, 1), new mathis.XYZ(1, 0, 0), normal.scale(-1), tangent, qua, false);
                res.rotationQuaternion = qua;
                res.position = position;
                var biMat = new BABYLON.StandardMaterial('', scene);
                biMat.sideOrientation = BABYLON.Mesh.DOUBLESIDE;
                biMat.diffuseColor = this.planeColor;
                biMat.backFaceCulling = false;
                res.material = biMat;
                if (onClick != null) {
                    ;
                    res.onClick = onClick;
                }
                return res;
            };
            DrawNormalAndTangentVector.prototype.drawOneTangentVector = function (deb, end, scene) {
                if (mathis.geo.distance(deb, end) < 2 * mathis.geo.epsilon)
                    return;
                var arrowCrea = new mathis.creation3D.ArrowCreator(scene);
                //arrowCrea.bodyDiameterProp=
                arrowCrea.arrowFootAtOrigin = false;
                var arrowMesh = arrowCrea.go();
                var mat = new StandardMaterial('', scene);
                mat.diffuseColor = new Color3(1, 0, 0);
                arrowMesh.material = mat;
                var elongate = new mathis.visu3d.ElongateAMeshFromBeginToEnd(deb, end, arrowMesh);
                elongate.lateralScaling = this.tangentDiameter * 2;
                elongate.goChanging();
                return arrowMesh;
            };
            DrawNormalAndTangentVector.prototype.drawTangentPlanes = function (u, v, carte, clickOnPlaneNow, meshesToDispose) {
                var _this = this;
                this.checkOrientation(u, v, carte);
                var onClick = null;
                if (clickOnPlaneNow) {
                    this.surface.isPickable = false;
                    onClick = function (clickXyz) {
                        meshesToDispose.push(_this.drawOneTangentVector(carte.X(u, v), clickXyz, _this.surfaceScene));
                        var tangent = mathis.XYZ.newFrom(clickXyz).substract(carte.X(u, v));
                        var dNtangent = carte.dNaction(u, v, tangent);
                        var begin = carte.newN(u, v);
                        var end = mathis.XYZ.newFrom(begin).add(dNtangent);
                        meshesToDispose.push(_this.drawOneTangentVector(begin, end, _this.sphereScene));
                    };
                }
                meshesToDispose.push(this.oneTangentPlane(carte.newN(u, v), carte.Xu(u, v), carte.X(u, v), this.surfaceScene, onClick));
                meshesToDispose.push(this.oneTangentPlane(carte.newN(u, v), carte.Xu(u, v), carte.newN(u, v), this.sphereScene));
            };
            return DrawNormalAndTangentVector;
        }());
        var PointOfView;
        (function (PointOfView) {
            PointOfView[PointOfView["vue_libre"] = 0] = "vue_libre";
            PointOfView[PointOfView["vue_de_face"] = 1] = "vue_de_face";
            PointOfView[PointOfView["vue_de_dos"] = 2] = "vue_de_dos";
            PointOfView[PointOfView["vue_de_gauche"] = 3] = "vue_de_gauche";
            PointOfView[PointOfView["vue_de_droite"] = 4] = "vue_de_droite";
            PointOfView[PointOfView["vue_du_haut"] = 5] = "vue_du_haut";
            PointOfView[PointOfView["vue_du_bas"] = 6] = "vue_du_bas";
        })(PointOfView || (PointOfView = {}));
        var GaussCurvature = (function () {
            function GaussCurvature(surfaceMathisFrame, sphereMathisFrame, localButtonPlace) {
                var _this = this;
                this.meshesToDispose = [];
                this.normalize = false;
                this.mode = 0;
                this.$tangentSpace = null;
                this.$surfaceName = null;
                this.$pointOfVue = null;
                this.$courbure = null;
                this.recul = -3;
                this.pointOfViewToPos = [null, new mathis.XYZ(0, 0, this.recul), new mathis.XYZ(0, 0, -this.recul), new mathis.XYZ(this.recul, 0, 0), new mathis.XYZ(-this.recul, 0, 0), new mathis.XYZ(0, this.recul, 0), new mathis.XYZ(0, -this.recul, 0)];
                this.pointOfViewToUpVector = [null, new mathis.XYZ(0, 1, 0), new mathis.XYZ(0, 1, 0), new mathis.XYZ(0, 1, 0), new mathis.XYZ(0, 1, 0), new mathis.XYZ(0, 0, 1), new mathis.XYZ(0, 0, 1)];
                this.surfaceScene = surfaceMathisFrame.scene;
                this.sphereScene = sphereMathisFrame.scene;
                this.surfaceMathisFrame = surfaceMathisFrame;
                this.localButtonPlace = localButtonPlace;
                /**camera are create here*/
                this.createGaussSphereScene(sphereMathisFrame);
                this.createSurfaceScene(surfaceMathisFrame);
                this.createSurface(SurfaceName.torus);
                this.drawNormalVector = new DrawNormalAndTangentVector(this.surface.cartes, this.surfaceScene, this.sphereScene, this.surfaceCamera, this.meshSurf);
                this.drawNormalVector.sizes = new mathis.XYZ(0.1, 0.1, 0.1);
                this.resetInitialClick();
                this.addControlButton();
                /**couplage des deux camras
                 * attention, cette venement n'est pas lanc quand on force le positionnement par les mthodes grabberCaera.changeXXX */
                //var setTimeDone=false
                this.surfaceCamera.onPositioningChange = function (positioning) { _this.onPositioningChange(positioning); };
            }
            GaussCurvature.prototype.createSurface = function (surfaceName) {
                var surfaceMaker = new mathis.riemann.SurfaceMaker(surfaceName);
                this.surface = surfaceMaker.go();
                this.drawMesh(this.surface.wholeSurfaceMesh);
            };
            GaussCurvature.prototype.onPositioningChange = function (positioning) {
                {
                    var length_7 = this.sphereCamera.trueCamPos.position.length();
                    positioning.position.normalize().scale(length_7);
                    this.sphereCamera.trueCamPos.copyFrom(positioning);
                    this.sphereCamera.whishedCamPos.copyFrom(positioning);
                    /**when we move the surface by grabbing, the point_of_vue select would be put to "free"*/
                    this.$pointOfVue.selectedIndex = 0;
                }
            };
            GaussCurvature.prototype.setMapMode = function () {
                this.mode = 0;
                this.normalize = false;
            };
            GaussCurvature.prototype.setDifferenceMode = function () {
                this.mode = 1;
                this.normalize = false;
            };
            GaussCurvature.prototype.setNormalisedDifferenceMode = function () {
                this.mode = 2;
                this.normalize = true;
            };
            GaussCurvature.prototype.setDeriveMode = function () {
                this.mode = 3;
                this.normalize = false;
                this.$tangentSpace.selectedIndex = 2;
            };
            GaussCurvature.prototype.addControlButton = function () {
                var _this = this;
                window.onload = function () {
                    /**choix de la surface*/
                    {
                        var surfaceNames = mathis.allStringValueOfEnume(SurfaceName);
                        _this.$surfaceName = document.createElement("select");
                        _this.localButtonPlace.appendChild(_this.$surfaceName);
                        for (var i = 0; i < surfaceNames.length; i++) {
                            var option = document.createElement("option");
                            option.value = surfaceNames[i];
                            option.text = surfaceNames[i];
                            _this.$surfaceName.appendChild(option);
                        }
                        _this.$surfaceName.onchange = function () {
                            _this.clearAll();
                            //this.$carteToDisplay.selectedIndex=0
                            _this.createSurface(_this.$surfaceName.selectedIndex);
                            //this.readdControlToDislayCarte()
                            //TODO utile ???
                            _this.drawNormalVector = new DrawNormalAndTangentVector(_this.surface.cartes, _this.surfaceScene, _this.sphereScene, _this.surfaceCamera, _this.meshSurf);
                            _this.drawNormalVector.sizes = new mathis.XYZ(0.1, 0.1, 0.1);
                        };
                    }
                    /**point de vue*/
                    {
                        var vueNames = mathis.allStringValueOfEnume(PointOfView);
                        _this.$pointOfVue = document.createElement("select");
                        _this.localButtonPlace.appendChild(_this.$pointOfVue);
                        for (var i = 0; i < vueNames.length; i++) {
                            var option = document.createElement("option");
                            option.value = vueNames[i];
                            option.text = vueNames[i];
                            _this.$pointOfVue.appendChild(option);
                        }
                        _this.$pointOfVue.onchange = function (ev) {
                            if (_this.$pointOfVue.selectedIndex > 0) {
                                var position = mathis.XYZ.newFrom(_this.pointOfViewToPos[_this.$pointOfVue.selectedIndex]);
                                var upVector = mathis.XYZ.newFrom(_this.pointOfViewToUpVector[_this.$pointOfVue.selectedIndex]);
                                var positioning = new mathis.Positioning();
                                positioning.position = position;
                                positioning.frontDir = mathis.XYZ.newFrom(position).scale(-1);
                                positioning.upVector = upVector;
                                _this.surfaceCamera.trueCamPos.copyFrom(positioning);
                                _this.surfaceCamera.whishedCamPos.copyFrom(positioning);
                                _this.sphereCamera.trueCamPos.copyFrom(positioning);
                                _this.sphereCamera.whishedCamPos.copyFrom(positioning);
                            }
                        };
                        _this.$pointOfVue.selectedIndex = 1;
                        _this.$pointOfVue.onchange(null);
                    }
                    /**mode*/
                    {
                        var array = ["gauss map", "difference", "diffrence normalis"]; //TODO ,"diffrentielle"
                        var selectList_1 = document.createElement("select");
                        _this.localButtonPlace.appendChild(selectList_1);
                        for (var i = 0; i < array.length; i++) {
                            var option = document.createElement("option");
                            option.value = array[i];
                            option.text = array[i];
                            selectList_1.appendChild(option);
                        }
                        selectList_1.onchange = function () {
                            if (selectList_1.selectedIndex == 0)
                                _this.setMapMode();
                            else if (selectList_1.selectedIndex == 1)
                                _this.setDifferenceMode();
                            else if (selectList_1.selectedIndex == 2)
                                _this.setNormalisedDifferenceMode();
                            else if (selectList_1.selectedIndex == 3)
                                _this.setDeriveMode();
                        };
                    }
                    /**espace tangent*/
                    {
                        var array = ["pas d'espace tangent", "petit espace tangent", "grand espace tangent"];
                        _this.$tangentSpace = document.createElement("select");
                        _this.localButtonPlace.appendChild(_this.$tangentSpace);
                        for (var i = 0; i < array.length; i++) {
                            var option = document.createElement("option");
                            option.value = array[i];
                            option.text = array[i];
                            _this.$tangentSpace.appendChild(option);
                        }
                    }
                    /**whole surface or one carte*/
                    //this.readdControlToDislayCarte()
                    /**bouton clear*/
                    {
                        var buttonClear = document.createElement('button');
                        buttonClear.classList.add("buttonClear");
                        buttonClear.innerHTML = '<i class="fa fa-eraser"></i>';
                        buttonClear.onclick = function () {
                            _this.clearAllSecondaryMeshes();
                        };
                        _this.localButtonPlace.appendChild(buttonClear);
                        _this.$courbure = document.createElement('span');
                        _this.localButtonPlace.appendChild(_this.$courbure);
                        //this.$courbure.textContent="TOTO"
                        /**because we start with torus*/
                        _this.$surfaceName.selectedIndex = SurfaceName.torus;
                    }
                };
            };
            // private readdControlToDislayCarte():void{
            //     if(this.$carteToDisplay!=null) this.$carteToDisplay.remove()
            //     this.$carteToDisplay = document.createElement("select");
            //     this.localButtonPlace.appendChild(this.$carteToDisplay);
            //
            //     for (let i = 0; i <= this.surface.cartes.length; i++) {
            //         let option:HTMLOptionElement = document.createElement("option");
            //         option.value = (i==0)?"toute la surface":"carte n "+i
            //         option.text = option.value
            //         this.$carteToDisplay.appendChild(option);
            //     }
            //
            //     this.$carteToDisplay.onchange = ()=> {
            //         this.clearAll()
            //         if( this.$carteToDisplay.selectedIndex==0) this.surface.drawTheWholeSurface(this.surfaceMathisFrameScene)//this.drawMesh(this.carteForTheWholeSurface.arrivalMesh)
            //         else this.surface.drawOneCarte(this.$carteToDisplay.selectedIndex-1,this.surfaceMathisFrameScene)//this.drawMesh(this.surface.cartes[this.$carteToDisplay.selectedIndex-1].arrivalMesh)
            //     }
            // }
            GaussCurvature.prototype.clearAllSecondaryMeshes = function () {
                this.meshesToDispose.forEach(function (m) {
                    if (m != null)
                        m.dispose();
                });
                this.meshesToDispose = [];
                this.resetInitialClick();
            };
            GaussCurvature.prototype.resetInitialClick = function () {
                var _this = this;
                this.meshSurf.isPickable = true;
                this.meshSurf.onClick = function (clickedPoint) { _this.firstClick(clickedPoint); };
            };
            GaussCurvature.prototype.clearAll = function () {
                this.clearAllSecondaryMeshes();
                this.meshSurf.dispose();
                this.linesOnSurf.forEach(function (m) { return m.dispose(); });
                this.$pointOfVue.selectedIndex = 1;
                this.$pointOfVue.onchange(null);
            };
            GaussCurvature.prototype.firstClick = function (clickedPoint) {
                var _this = this;
                var uvAndCarte = this.surface.findBestCarte(clickedPoint); //this.drawNormalVector.findUvAndCarte(clickedPoint)
                var UV = uvAndCarte.uv;
                var carte = uvAndCarte.carte;
                var color;
                if (this.mode == 0)
                    color = new Color3(Math.random(), Math.random(), Math.random());
                else
                    color = new Color3(0, 1, 0);
                this.drawNormalVector.arrowColor = color;
                var twoMesh = this.drawNormalVector.drawNormalVectors(UV.u, UV.v, carte);
                this.meshesToDispose.push(twoMesh.initial);
                this.meshesToDispose.push(twoMesh.onSphere);
                if (this.$tangentSpace.selectedIndex != 0) {
                    if (this.$tangentSpace.selectedIndex == 1)
                        this.drawNormalVector.planeRadius = 0.03;
                    else if (this.$tangentSpace.selectedIndex == 2)
                        this.drawNormalVector.planeRadius = 0.1;
                    this.drawNormalVector.drawTangentPlanes(UV.u, UV.v, carte, (this.mode == 3), this.meshesToDispose);
                }
                if (this.mode == 1 || this.mode == 2) {
                    ;
                    this.meshSurf.onClick = function (secondClicked) {
                        var secondUvAndCarte = _this.surface.findBestCarte(secondClicked); //this.drawNormalVector.findUvAndCarte(secondClicked)
                        if (secondUvAndCarte.carte != carte) {
                            cc("the second click is too far from the first: they arrived on different cart-image");
                        }
                        else {
                            _this.secondClick(UV, secondUvAndCarte.uv, secondUvAndCarte.carte);
                        }
                        _this.resetInitialClick();
                    };
                }
                var courbure = mathis.roundWithGivenPrecision(carte.dNinTangentBasis(UV.u, UV.v).determinant(), 1);
                this.$courbure.textContent = " Courbure:" + courbure;
            };
            // gaussMapDerivativeClick=(clickedPoint:XYZ)=>{
            //     let clickedVertex=this.drawNormalVector.findClosestVertex(clickedPoint)
            //     let UV=clickedVertex.mathUV
            //
            //     this.drawNormalVector.arrowColor=new Color3(0,1,0)
            //     this.drawNormalVector.drawNormalVectors(UV.x,UV.y)
            //
            //     this.drawNormalVector.planeRadius=0.2
            //     this.drawNormalVector.drawTangentPlanes(UV.x,UV.y,true)
            // }
            GaussCurvature.prototype.secondClick = function (UVcenter, UVclicked, carte) {
                var _this = this;
                var initialLength = mathis.geo.distance(carte.X(UVcenter.u, UVcenter.v), carte.X(UVclicked.u, UVclicked.v));
                var initialLengthOnSphere = mathis.geo.distance(carte.newN(UVcenter.u, UVcenter.v), carte.newN(UVclicked.u, UVclicked.v));
                var alphas = [];
                var pas = 0.01;
                var alpha = 0;
                /**pour lses diffrences normalise, on se rapproche plus du vecteur initial, pour que l'on voit mieux la tangence*/
                var alphaMax = (this.mode == 1) ? 0.8 : 0.95;
                while (alpha < alphaMax) {
                    alphas.push(alpha);
                    alpha += pas;
                }
                var count = 0;
                var pointCenter = carte.X(UVcenter.u, UVcenter.v);
                // let length=geo.distance(pointCenter,coor.X(UVclicked.x,UVclicked.y))
                var currentNormal = null;
                var currentDifference = { initial: null, onSphere: null };
                var action = new mathis.PeriodicAction(function () {
                    var UVinter = new mathis.UV(0, 0);
                    mathis.geo.betweenUV(UVclicked, UVcenter, alphas[count], UVinter);
                    if (currentNormal != null) {
                        currentNormal.initial.dispose();
                        currentNormal.onSphere.dispose();
                    }
                    currentNormal = _this.drawNormalVector.drawNormalVectors(UVinter.u, UVinter.v, carte);
                    count++;
                    if (count != alphas.length + 1) {
                        if (currentDifference.initial != null)
                            currentDifference.initial.dispose();
                        if (currentDifference.onSphere != null)
                            currentDifference.onSphere.dispose();
                    }
                    /**un peu idiot de crer autant de flche : 2 que l'on deplacerait suffirait*/
                    var arrivalOnSurface;
                    var arrivalOnSphere;
                    if (_this.normalize) {
                        var differenceOnSurface = carte.X(UVinter.u, UVinter.v).substract(pointCenter);
                        /** the user can click twice on the same point, so  subtraction can be zero-vector */
                        if (differenceOnSurface.lengthSquared() < mathis.geo.epsilonSquare)
                            return;
                        differenceOnSurface.normalize().scale(initialLength);
                        arrivalOnSurface = mathis.XYZ.newFrom(pointCenter).add(differenceOnSurface);
                        var differenceOnSphere = carte.newN(UVinter.u, UVinter.v).substract(carte.newN(UVcenter.u, UVcenter.v));
                        if (differenceOnSphere.length() > mathis.geo.epsilon)
                            differenceOnSphere.normalize().scale(initialLengthOnSphere);
                        arrivalOnSphere = mathis.XYZ.newFrom(carte.newN(UVcenter.u, UVcenter.v)).add(differenceOnSphere);
                    }
                    else {
                        arrivalOnSurface = carte.X(UVinter.u, UVinter.v);
                        arrivalOnSphere = carte.newN(UVinter.u, UVinter.v);
                    }
                    currentDifference.initial = _this.drawNormalVector.drawOneTangentVector(pointCenter, arrivalOnSurface, _this.surfaceScene);
                    currentDifference.onSphere = _this.drawNormalVector.drawOneTangentVector(carte.newN(UVcenter.u, UVcenter.v), arrivalOnSphere, _this.sphereScene);
                    /**to dispose all the last*/
                    _this.meshesToDispose.push(currentDifference.initial);
                    _this.meshesToDispose.push(currentDifference.onSphere);
                    //currentDifference.onSphere=drawOneDifference(sphereFrame.scene,)
                });
                action.nbTimesThisActionMustBeFired = alphas.length + 1;
                action.timeIntervalMilli = 3000 / alphas.length;
                //this.arrowsToDispose.push(currentNormal.initial)
                //this.arrowsToDispose.push(currentNormal.onSphere)
                this.surfaceMathisFrame.pushPeriodicAction(action);
            };
            GaussCurvature.prototype.createGaussSphereScene = function (sphereFrame) {
                var light0 = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(-1, 1, -1), sphereFrame.scene);
                light0.diffuse = new BABYLON.Color3(1, 1, 1);
                light0.specular = new BABYLON.Color3(1, 1, 1);
                light0.groundColor = new BABYLON.Color3(0, 0, 0);
                var grabber = new mathis.macamera.SphericalGrabber(sphereFrame.scene, new mathis.XYZ(1, 1, 1));
                grabber.endOfZone1 = 0.;
                grabber.endOfZone2 = 0.;
                grabber.mesh.visibility = 1;
                grabber.showGrabberOnlyWhenGrabbing = false;
                var mat = new BABYLON.StandardMaterial('', sphereFrame.scene);
                mat.alpha = 0.3;
                mat.diffuseColor = new Color3(1, 1, 1);
                grabber.mesh.material = mat;
                var cam = new mathis.macamera.GrabberCamera(sphereFrame, grabber);
                cam.useFreeModeWhenCursorOutOfGrabber = false;
                this.sphereCamera = cam;
            };
            GaussCurvature.prototype.createSurfaceScene = function (surfaceFrame) {
                var light0 = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(-1, 1, -1), surfaceFrame.scene);
                light0.diffuse = new BABYLON.Color3(1, 1, 1);
                light0.specular = new BABYLON.Color3(1, 1, 1);
                light0.groundColor = new BABYLON.Color3(0, 0, 0);
                var grabber = new mathis.macamera.SphericalGrabber(surfaceFrame.scene, new mathis.XYZ(1, 1, 1));
                grabber.endOfZone1 = 2;
                grabber.endOfZone2 = 2;
                grabber.showGrabberOnlyWhenGrabbing = true;
                var cam = new mathis.macamera.GrabberCamera(surfaceFrame, grabber);
                //let camPos=new XYZ(-2,-2,-2)
                //let camPos=new XYZ(0,0,-1.5)
                cam.showPredefinedConsoleLog = false;
                cam.useFreeModeWhenCursorOutOfGrabber = false;
                // cam.changePosition(camPos)
                // cam.changeFrontDir(XYZ.newFrom(camPos).scale(-1))
                this.surfaceCamera = cam;
            };
            GaussCurvature.prototype.drawMesh = function (mesh) {
                var lineFiller = new mathis.lineModule.LineComputer(mesh);
                lineFiller.startingVertices = [];
                for (var _i = 0, _a = mesh.vertices; _i < _a.length; _i++) {
                    var vertex = _a[_i];
                    if (vertex.param.x % 4 == 0 && vertex.param.y == 0)
                        lineFiller.startingVertices.push(vertex);
                    if (vertex.param.x == 0 && vertex.param.y % 4 == 0)
                        lineFiller.startingVertices.push(vertex);
                }
                lineFiller.go();
                var lin = new mathis.visu3d.LinesViewer(mesh, this.surfaceScene);
                lin.constantRadius = 0.004;
                this.linesOnSurf = lin.go();
                this.linesOnSurf.forEach(function (mesh) { return mesh.isPickable = false; });
                var surf = new mathis.visu3d.SurfaceViewer(mesh, this.surfaceScene);
                //surf.vertexDuplication=visu3d.SurfaceVisuStatic.VertexDuplication.none
                //surf.sideOrientation=BABYLON.Mesh.BACKSIDE
                this.meshSurf = surf.go();
                this.resetInitialClick();
                // let mat=new BABYLON.StandardMaterial('',this.surfaceMathisFrameScene)
                // mat.diffuseColor=new Color3(0,1,1)
                // mat.backFaceCulling=true
                // mat.sideOrientation=BABYLON.Mesh.BACKSIDE
                // this.meshSurf.material=mat
            };
            return GaussCurvature;
        }());
    })(gauss = mathis.gauss || (mathis.gauss = {}));
})(mathis || (mathis = {}));
// /**
//  * Created by vigon on 10/03/2016.
//  */
//
//
// module mathis{
//
//     export module mathisGame{
//
//         import OneLineOption = mathis.visu3d.LineGameoStatic.LineGameoOption;
//         export function start(){
//             var mathisFrame=new mathis.MathisFrame()
//             mathisFrame.goChanging()
//             sceneCreaFunction(mathisFrame)
//            
//         }
//
//
//
//         export function sceneCrea2(mathisFrame:MathisFrame){
//             let macam = new macamera.GrabberCamera(mathisFrame.scene)
//             macam.trueCamPos.position=new XYZ(0,0,-4)
//             macam.justOneGrabber.center=new XYZ(0,0,0)
//             macam.justOneGrabber.constantRadius=1
//             macam.justOneGrabber.grabberIsVisible=false
//             macam.goChanging()
//             macam.attachControl(mathisFrame.canvas)
//
//            
//
//             // Ajout d'une lumire
//             var light0 = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(-1, 1, -1), mathisFrame.scene);
//             light0.diffuse = new BABYLON.Color3(1, 1, 1);
//             light0.specular = new BABYLON.Color3(1, 1, 1);
//             light0.groundColor = new BABYLON.Color3(0, 0, 0);
//
//
//
//             //createSkybox(scene);
//             //scene.fogMode = BABYLON.Scene.FOGMODE_EXP2;
//             //scene.fogDensity = 0.05;
//             //scene.fogColor = new BABYLON.Color3(0.9, 0.9, 0.85);
//
//
//
//             var origine=BABYLON.Mesh.CreateSphere("origine",50,0.2,scene,false);
//             //origine.material=rose;
//
//             var newInstance = origine.createInstance("i");
//         }
//
//
//         import BabylonGameO = mathis.visu3d.GameoBab;
//
//
//
//         export function sceneCreaFunction(mathisFrame:MathisFrame){
//
//
//             var light0 = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(-1, 0, -0.7), mathisFrame.scene);
//             light0.diffuse = new BABYLON.Color3(1, 1, 1);
//             light0.specular = new BABYLON.Color3(0.5,0.5,0.5);
//             light0.groundColor = new BABYLON.Color3(0, 0, 0);
//
//            
//             let grabber=new macamera.Grabber()
//             grabber.displacementMode=macamera.DisplacementMode.parallele
//             grabber.grabberMesh= BABYLON.Mesh.CreatePlane("",100,scene)
//             grabber.grabberIsVisible=false
//
//
//             let macam = new macamera.GrabberCamera(mathisFrame.scene)
//             macam.trueCamPos.position=new XYZ(0,0,-10)
//             macam.justOneGrabber=grabber
//             macam.useFreeModeWhenCursorOutOfGrabber=false
//
//            
//            
//            
//
//             macam.goChanging()
//             macam.attachControl(mathisFrame.canvas)
//
//
//
//             let mamesh=new Mamesh()
//
//
//             // let polyCrea=new creation3D.Polyhedron(mamesh,creation3D.Polyhedron.Type.Dodecahedron)
//             // polyCrea.goChanging()
//             //
//             // let selectedVertices:Vertex[]=[]
//             // mamesh.vertices.forEach(v=>selectedVertices.push(v))
//             //
//             // new mameshModification.TriangleDichotomer(mamesh).goChanging()
//             // new mameshModification.TriangleDichotomer(mamesh).goChanging()
//             // new mameshModification.TriangleDichotomer(mamesh).goChanging()
//             //
//             //
//             // mamesh.vertices.forEach(v=>{v.position.normalize()})
//             //
//             // mamesh.fillLineCatalogue(selectedVertices)
//
//
//
//             let rootGameo=new GameO()
//
//             let boxGameos:{[key:string]:GameO}={}
//
//             let vectX=new XYZ(2.5,0,0)
//             let vectY=new XYZ(0,2.5,0)
//             let tempX=new XYZ(0,0,0)
//             let tempY=new XYZ(0,0,0)
//
//             for (let i=-1;i<=1;i++){
//                 for (let j=-1;j<=1;j++){
//                     let box=BABYLON.Mesh.CreateBox('',1,scene)
//                     box.visibility=0
//                     let boxGam=new visu3d.GameoFromMesh(box)
//                     boxGam.attachTo(rootGameo)
//                     boxGam.isClickable=true
//                     boxGam.clickMethod=()=>{
//                         cc('lic',i,j)
//                         for (let key in boxGameos){boxGameos[key].locScale=1;boxGameos[key].actualize() }
//                         boxGam.locScale=2
//                         boxGam.actualize()
//                     }
//                     boxGameos[i+','+j]=boxGam
//                     tempX.copyFrom(vectX).scale(i)
//                     tempY.copyFrom(vectY).scale(j)
//                     boxGam.locPos.add(tempX).add(tempY)
//                    
//                     let mamesh=new Mamesh()
//                     let polyhedron=new creation3D.Polyhedron(mamesh,creation3D.PolyhedronStatic.Type.Cube)
//                     polyhedron.rotationAngle=0
//                     polyhedron.goChanging()
//                     mamesh.fillLineCatalogue()
//
//                     let linesGameoMaker=new visu3d.LinesGameoMaker(mamesh,scene)
//                     linesGameoMaker.lineOptionFunction=(i,line)=>{
//                         let res=new OneLineOption()
//                         res.color=favoriteColors.green
//                         res.constantRadius=0.05
//                         return res
//                     }
//                     linesGameoMaker.parentGameo=boxGam
//                     linesGameoMaker.goChanging()
//                    
//                     let bbb=new visu3d.VerticesGameoMaker(mamesh,scene)
//                     bbb.radiusMethod=(v)=>{return 0.05}
//                     bbb.shape=visu3d.VerticesGameoStatic.Shape.sphere
//                     bbb.parentGameo=boxGam
//                     bbb.goChanging()
//                 }
//             }
//
//
//
//
//
//             let skewTorus=new SkewTorus().goChanging()
//             skewTorus.locRadius=0.3
//             skewTorus.attachTo(boxGameos[1+','+0])
//
//             rootGameo.draw()
//             //skewTorus.draw()
//
//
//
//
//
//             //rootGameo.draw()
//
//
//             //skewTorus.scale(2)
//
//
//
//
//         }
//
//
//
//
//
//          class GameoOfTheMainMenu{
//
//         }
//
//
//          class SkewTorus extends GameoOfTheMainMenu{
//
//             goChanging():GameO{
//                 let mamesh = new Mamesh()
//                 let meshMaker = new creationFlat.Cartesian(mamesh)
//                 meshMaker.makeLinks=false
//                 meshMaker.nbX=5
//                 meshMaker.nbY=20
//                 meshMaker.minX=0
//                 meshMaker.maxX=2*Math.PI
//                 meshMaker.minY=0
//                 meshMaker.maxY=2*Math.PI
//                 meshMaker.nbVerticalDecays=2
//                 meshMaker.nbHorizontalDecays=1
//                 meshMaker.goChanging()
//
//
//                 let r=0.8
//                 let a=2
//                 mamesh.vertices.forEach((vertex:Vertex)=>{
//
//                     let u=vertex.position.x
//                     let v=vertex.position.y
//                     vertex.position.x=(r*Math.cos(u)+a)*Math.cos((v))
//                     vertex.position.y=r*Math.sin(u)
//                     vertex.position.z= (r*Math.cos(u)+a)*Math.sin((v))
//                 })
//
//
//                 let merger=new mameshModification.Merger(mamesh)
//                 merger.cleanDoubleLinksKeepingInPriorityThoseWithOpposite=false
//                 merger.mergeLink=false
//                 merger.mergeTrianglesAndSquares=true
//                 merger.goChanging()
//
//
//                 let linkFromPoly=new linker.LinkCreaterSorterAndBorderDetecterByPolygons(mamesh)
//                 linkFromPoly.alsoDoubleLinksAtCorner=true
//                 linkFromPoly.goChanging()
//
//
//                 mamesh.fillLineCatalogue()
//
//
//                 let mainGameo=new GameO()
//                 mainGameo.locRadius=0.35
//
//                 let linesGameoMaker=new visu3d.LinesGameoMaker(mamesh,scene)
//                 linesGameoMaker.parentGameo=mainGameo
//                 linesGameoMaker.lineOptionFunction=(i,index)=>{
//                     let res=new visu3d.LineGameoStatic.LineGameoOption()
//                     res.constantRadius=0.03
//
//                     if (i==0) {
//                         res.color=new BABYLON.Color3(124/255, 252/255, 0)
//
//                     }
//                     //long line
//                     else {
//                         res.color=new BABYLON.Color3(191/255, 62/255, 1)
//                         res.interpolationOption=new geometry.InterpolerStatic.Options()
//                         res.interpolationOption.interpolationStyle=geometry.InterpolerStatic.InterpolationStyle.hermite
//                     }
//
//
//                     return res
//                 }
//                 linesGameoMaker.goChanging()
//
//                 let surfaceGameoMaker=new visu3d.SurfaceVisuMaker(mamesh,scene)
//                 surfaceGameoMaker.parentGameo=mainGameo
//                 let surfaceGameo=surfaceGameoMaker.goChanging()
//                 surfaceGameo.locOpacity=0.7
//
//                 return mainGameo
//
//
//             }
//
//
//         }
//
//
//
//
//     }
//
// }
//
//
/**
 * Created by vigon on 14/03/2016.
 */
var mathis;
(function (mathis) {
    var siteAgreg;
    (function (siteAgreg) {
        function start() {
            var choice = Math.floor(Math.random() * 3);
            if (choice == 0)
                severalVectorField(document.getElementById("platonic"));
            else if (choice == 1)
                severalPolyhedron(document.getElementById("platonic"));
            else if (choice == 2)
                severalIsings(document.getElementById("platonic"));
        }
        siteAgreg.start = start;
        //
        //
        // function platonicBottomLegend(mathisFrame:MathisFrame):void{
        //
        //     let bottomStripe=document.createElement("div")
        //     bottomStripe.id="bottomStripe"
        //
        //
        //     let labelsUnder:HTMLElement[]=[]
        //     for (let i=0;i<5;i++){
        //         let labelUnder=document.createElement("div")
        //         labelUnder.className="labelUnder"
        //         bottomStripe.appendChild(labelUnder)
        //         labelsUnder[i]=labelUnder
        //     }
        //
        //     labelsUnder[0].innerHTML="T  <sub>d</sub>(T)"
        //     let inner2="O<sub>h</sub>(O)"
        //     labelsUnder[1].innerHTML=inner2
        //     labelsUnder[2].innerHTML=inner2
        //     let inner3="I<sub>h</sub>(I)"
        //     labelsUnder[3].innerHTML=inner3
        //     labelsUnder[4].innerHTML=inner3
        //
        //     mathisFrame.canvasContainer.appendChild(bottomStripe)
        //
        // }
        //
        // function scenePlatonic(mathisFrame:MathisFrame):void {
        //
        //
        //     var light0 = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(-1, 0, -0.7), mathisFrame.scene);
        //     light0.diffuse = new BABYLON.Color3(1, 1, 1);
        //     light0.specular = new BABYLON.Color3(0.5, 0.5, 0.5);
        //     light0.groundColor = new BABYLON.Color3(0, 0, 0);
        //
        //
        //     function oneCamInAFamily(decal:number,index:number,nbCam:number):macamera.GrabberCamera{
        //
        //         let grabber=new macamera.SphericalGrabber(mathisFrame.scene,new XYZ(maud,maud,maud),new XYZ(decal,0,0))
        //         grabber.endOfZone1=0
        //         grabber.endOfZone2=0
        //         let macam = new macamera.GrabberCamera(mathisFrame,grabber)
        //         macam.changePosition(new XYZ(decal,0,-4),false)
        //         macam.useFreeModeWhenCursorOutOfGrabber=false
        //         macam.camera.viewport=new BABYLON.Viewport(index/nbCam,0,1/nbCam,1)
        //
        //         macam.attachControl(mathisFrame.canvas)
        //         return macam
        //     }
        //
        //
        //     let decals=[0,1000,2000,3000,4000]
        //     let allCam=[]
        //
        //
        //     for (let i=0;i<decals.length;i++){
        //         let cam=oneCamInAFamily(decals[i],i,decals.length)
        //         allCam.push(cam)
        //         mathisFrame.scene.activeCameras.push(cam.camera)
        //
        //     }
        //
        //
        //
        //     let Tetrahedron =polyhedron(creation3D.PolyhedronStatic.Type.Tetrahedron,mathisFrame.scene)
        //     Tetrahedron.position.x=decals[0]
        //
        //     let Cube =polyhedron(creation3D.PolyhedronStatic.Type.Cube,mathisFrame.scene)
        //     Cube.position.x=decals[1]
        //
        //     let Octahedron =polyhedron(creation3D.PolyhedronStatic.Type.Octahedron,mathisFrame.scene)
        //     Octahedron.position.x=decals[2]
        //
        //     let dodeca =polyhedron(creation3D.PolyhedronStatic.Type.Dodecahedron,mathisFrame.scene)
        //     dodeca.position.x=decals[3]
        //
        //     let Icosahedron =polyhedron(creation3D.PolyhedronStatic.Type.Icosahedron,mathisFrame.scene)
        //     Icosahedron.position.x=decals[4]
        //
        //
        // }
        function upLegend(innerHTML, agregTextName, mainDiv) {
            var $explanation = document.createElement('div');
            mainDiv.appendChild($explanation);
            $explanation.style.display = "inline-block";
            $explanation.style.position = "absolute";
            $explanation.style.left = "0";
            $explanation.style.width = "100%";
            $explanation.style.height = "30px";
            $explanation.style.top = "0";
            $explanation.style.backgroundColor = "indianred";
            $explanation.style.zIndex = "9";
            $explanation.style.textAlign = "center";
            $explanation.innerHTML = innerHTML;
            //$explanation.textContent="plus beta est grand, et plus les particules de mme couleur s'atirent"
            var associatedAgregText = document.createElement('span');
            associatedAgregText.style.height = "30px";
            associatedAgregText.textContent = "(cliquez ici pour voir un texte de modlisation associ)";
            associatedAgregText.classList.add("clickable");
            $explanation.appendChild(associatedAgregText);
            associatedAgregText.onclick = function () {
                window.open('agregAssets/' + agregTextName);
            };
            //let upLegend=legend("30px",mainDiv,false)
            var plus = document.createElement('div');
            mainDiv.appendChild(plus);
            plus.style.display = "inline-block";
            plus.style.position = "absolute";
            plus.style.top = "0";
            plus.style.right = "0";
            plus.style.width = "30px";
            plus.style.height = "30px";
            plus.style.lineHeight = "30px";
            plus.style.backgroundColor = "indianred";
            plus.style.zIndex = "10";
            plus.style.textAlign = "center";
            plus.textContent = "+";
            plus.style.fontSize = "large";
            plus.classList.add("clickable");
            function showExplanations() {
                $explanation.style.visibility = "visible";
                plus.textContent = "-";
                plus.onclick = function () {
                    hideExplanations();
                };
                //mainDiv.onclick=hideExplanations
            }
            function hideExplanations() {
                $explanation.style.visibility = "hidden";
                plus.textContent = "+";
                plus.onclick = function () {
                    showExplanations();
                };
                //mainDiv.onclick=null
            }
            hideExplanations();
        }
        function severalVectorField(mainDiv) {
            function oneVectorField(width, height, origin, vectorField, departure, mathisFrame) {
                var maxPathSegment = 500;
                var deltaT = 0.1;
                /**Camera and plan for click*/
                var planForClick;
                {
                    planForClick = BABYLON.Mesh.CreatePlane('', 1, mathisFrame.scene);
                    planForClick.scaling = new mathis.XYZ(width, height, 0);
                    /**doit tre derriere le grabber, sinon il masque ce dernier
                     * doit tre devant les flches*/
                    planForClick.position = new mathis.XYZ(0, 0, 0.06);
                    planForClick.bakeCurrentTransformIntoVertices();
                    planForClick.visibility = 0;
                    var grabber = new mathis.macamera.PlanarGrabber(mathisFrame.scene, new mathis.XYZ(width, height, 0.061));
                    grabber.mesh.visibility = 0;
                    var macam = new mathis.macamera.GrabberCamera(mathisFrame, grabber);
                    macam.checkCollisions = false;
                    macam.useFreeModeWhenCursorOutOfGrabber = false;
                    macam.changePosition(new mathis.XYZ(0, 0, -2), false);
                    macam.attachControl(mathisFrame.canvas);
                    var light0 = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(-1, 1, -1), mathisFrame.scene);
                    light0.diffuse = new BABYLON.Color3(0.5, 0.5, 0.5);
                    light0.specular = new BABYLON.Color3(0.7, 0.7, 0.7);
                    light0.groundColor = new BABYLON.Color3(1, 1, 1);
                }
                var mamesh;
                var positionings;
                {
                    var generator = new mathis.reseau.BasisForRegularReseau();
                    generator.nbI = 30;
                    generator.nbJ = 10;
                    generator.origin = origin;
                    generator.end = new mathis.XYZ(width / 2, height / 2, 0);
                    var regCrea = new mathis.reseau.Regular(generator);
                    regCrea.squareVersusTriangleMaille = false;
                    mamesh = regCrea.go();
                    var posiComp = new mathis.mameshAroundComputations.PositioningComputerForMameshVertices(mamesh);
                    /**tangents are given by the vector field*/
                    posiComp.computeTangent = false;
                    posiComp.sizesProp = new mathis.XYZ(0.15, 0.15, 0.15);
                    positionings = posiComp.go();
                }
                {
                    /**path init*/
                    var path = [];
                    var arrowModel = BABYLON.Mesh.CreateCylinder('', 2, 0, 1, 6, null, mathisFrame.scene);
                    var qua = new mathis.XYZW(0, 0, 0, 0);
                    mathis.geo.axisAngleToQuaternion(new mathis.XYZ(0, 0, 1), -Math.PI / 2, qua);
                    arrowModel.rotationQuaternion = qua;
                    arrowModel.bakeCurrentTransformIntoVertices();
                    var mat = new BABYLON.StandardMaterial('', mathisFrame.scene);
                    mat.diffuseColor = new BABYLON.Color3(0, 0, 1);
                    arrowModel.material = mat;
                    var serpentRadius_1 = 0.03;
                    for (var i = 0; i < maxPathSegment; i++)
                        path.push(departure);
                    var serpentMesh = BABYLON.Mesh.CreateTube('', path, serpentRadius_1, 10, null, BABYLON.Mesh.CAP_ALL, mathisFrame.scene, true);
                    var green = new BABYLON.StandardMaterial('', mathisFrame.scene);
                    green.diffuseColor = mathis.myFavoriteColors.green;
                    serpentMesh.material = green;
                    var headSerpent_1 = BABYLON.Mesh.CreateSphere('', 10, serpentRadius_1 * 2.5, mathisFrame.scene);
                    var red = new BABYLON.StandardMaterial('', mathisFrame.scene);
                    red.diffuseColor = new BABYLON.Color3(1, 0, 0);
                    headSerpent_1.material = red;
                    headSerpent_1.position.copyFrom(departure);
                    /**field init*/
                    mamesh.vertices.forEach(function (v) {
                        vectorField(0, v.position, positionings.getValue(v).frontDir);
                    });
                    var vertexVisu_1 = new mathis.visu3d.VerticesViewer(mamesh, mathisFrame.scene, positionings);
                    vertexVisu_1.meshModel = arrowModel;
                    vertexVisu_1.go();
                    function computeNewPathPoint(previousPoint, t, res) {
                        vectorField(t, previousPoint, res);
                        res.scale(deltaT);
                        res.add(previousPoint);
                    }
                    var verticeSorted_1 = [];
                    mamesh.vertices.forEach(function (v) { return verticeSorted_1.push(v); });
                    var functionToSortvertex_1 = function (v1, v2) { return v1.customerObject.squareLengthOfTangent - v2.customerObject.squareLengthOfTangent; };
                    var vertexRefSize_1 = positionings.getValue(mamesh.vertices[0]).scaling.x;
                    var curentTime_1 = 0;
                    var curentStep = 0;
                    var mainAction = new mathis.PeriodicAction(function () {
                        curentTime_1 += deltaT;
                        curentStep++;
                        var point = new mathis.XYZ(0, 0, 0);
                        computeNewPathPoint(path[path.length - 1], curentTime_1, point);
                        if (curentStep < maxPathSegment) {
                            for (var i = curentStep; i < maxPathSegment; i++)
                                path[i] = point;
                        }
                        else {
                            path.splice(0, 1);
                            path.push(point);
                        }
                        serpentMesh = BABYLON.Mesh.CreateTube('', path, serpentRadius_1, null, null, null, null, true, null, serpentMesh);
                        headSerpent_1.position = point;
                        mamesh.vertices.forEach(function (v) {
                            v.customerObject.squareLengthOfTangent = positionings.getValue(v).frontDir.lengthSquared();
                        });
                        verticeSorted_1.sort(functionToSortvertex_1);
                        for (var i = 0; i < verticeSorted_1.length; i++)
                            verticeSorted_1[i].customerObject.scaleFromOrder = (i / verticeSorted_1.length);
                        mamesh.vertices.forEach(function (v) {
                            var pos = positionings.getValue(v);
                            vectorField(curentTime_1, v.position, pos.frontDir);
                            pos.scaling.x = 2 * vertexRefSize_1 * (v.customerObject.scaleFromOrder + 1 / 4);
                            var epaisseur = vertexRefSize_1 * Math.max(1, v.customerObject.scaleFromOrder + 1 / 2);
                            pos.scaling.y = epaisseur;
                            pos.scaling.z = epaisseur;
                        });
                        vertexVisu_1.updatePositionings();
                    });
                    mainAction.id = "main action";
                    //mainAction.frameInterval=1
                    mathisFrame.pushPeriodicAction(mainAction);
                    /**onClick, we restart the snake*/
                    planForClick.onClick = function (dep) {
                        var action = new mathis.PeriodicAction(function () {
                            for (var i = 0; i < maxPathSegment; i++)
                                path[i] = dep;
                            curentStep = 0;
                            headSerpent_1.position = dep;
                        });
                        action.nbTimesThisActionMustBeFired = 1;
                        action.id = "click action";
                        action.passageOrderIndex = 2;
                        mathisFrame.pushPeriodicAction(action);
                    };
                }
                // let lineVisu=new visu3d.LinesVisuFastMaker(mamesh,scene)
                // lineVisu.go()
            }
            upLegend("<span> Trois systmes dynamiques avec des coefficients priodiques </span>", "public2014-B1.pdf", mainDiv);
            /**param*/
            var width = 5;
            var height = 2;
            var origin = new mathis.XYZ(-width / 2, -height / 2, 0);
            function to01(xyz, res) {
                res.copyFrom(xyz);
                res.substract(origin);
                res.x /= width;
                res.y /= height;
            }
            function toWH(xyz, res) {
                res.copyFrom(xyz);
                res.x *= width;
                res.y *= height;
                res.add(origin);
            }
            /**vecter field priodique*/
            var vectorField0;
            {
                var scaled_1 = new mathis.XYZ(0, 0, 0);
                var A1_4 = function (t) { return 0.4 * Math.sin(0.5 * t); };
                var A2_4 = function (t) { return 0.2 * Math.sin(0.5 * t); };
                var a11_4 = function (t) { return 0; };
                var a12_4 = function (t) { return 0; };
                var a21_4 = function (t) { return 0; };
                var a22_4 = function (t) { return 0; };
                vectorField0 = function (t, p, res) {
                    to01(p, scaled_1);
                    /**potential part*/
                    var raX = (scaled_1.x - 0.5) * 2;
                    var raY = (scaled_1.y - 0.5) * 4;
                    res.x = -raX * raY * raY;
                    res.y = -raX * raX * raY;
                    /**exitation part*/
                    res.x += scaled_1.x * (A1_4(t) + a11_4(t) * scaled_1.x + a12_4(t) * scaled_1.y);
                    res.y += scaled_1.y * (A2_4(t) + a21_4(t) * scaled_1.x + a22_4(t) * scaled_1.y);
                };
            }
            var vectorField1;
            {
                var scaled_2 = new mathis.XYZ(0, 0, 0);
                var A1_5 = function (t) { return 0.4 * Math.sin(t); };
                var A2_5 = function (t) { return 0.2 * Math.sin(0.5 * t); };
                var a11_5 = function (t) { return 0.1 * Math.sin(t); };
                var a12_5 = function (t) { return -0.1 * Math.sin(t); };
                var a21_5 = function (t) { return -0.1 * Math.sin(t); };
                var a22_5 = function (t) { return 0.1 * Math.sin(t); };
                vectorField1 = function (t, p, res) {
                    to01(p, scaled_2);
                    /**potential part*/
                    var raX = (scaled_2.x - 0.5) * 2;
                    var raY = (scaled_2.y - 0.5) * 4;
                    res.x = -raX * raY * raY;
                    res.y = -raX * raX * raY;
                    /**exitation part*/
                    res.x += scaled_2.x * (A1_5(t) + a11_5(t) * scaled_2.x + a12_5(t) * scaled_2.y);
                    res.y += scaled_2.y * (A2_5(t) + a21_5(t) * scaled_2.x + a22_5(t) * scaled_2.y);
                };
            }
            var vectorField2;
            {
                var scaled_3 = new mathis.XYZ(0, 0, 0);
                var A1_6 = function (t) { return 0.4 * Math.sin(0.5 * t); };
                var A2_6 = function (t) { return 0.2 * Math.sin(0.3 * t); };
                var a11_6 = function (t) { return 0; };
                var a12_6 = function (t) { return 0; };
                var a21_6 = function (t) { return 0; };
                var a22_6 = function (t) { return 0.1 * Math.sin(t); };
                vectorField2 = function (t, p, res) {
                    to01(p, scaled_3);
                    /**potential part*/
                    var raX = (scaled_3.x - 0.5) * 2;
                    var raY = (scaled_3.y - 0.5) * 4;
                    res.x = -raX * raY * raY;
                    res.y = -raX * raX * raY;
                    /**exitation part*/
                    res.x += scaled_3.x * (A1_6(t) + a11_6(t) * scaled_3.x + a12_6(t) * scaled_3.y);
                    res.y += scaled_3.y * (A2_6(t) + a21_6(t) * scaled_3.x + a22_6(t) * scaled_3.y);
                };
            }
            var mathisFrames = [];
            var legends = [];
            var divs = mathis.nDivInOneLine(3, mainDiv, "1px solid");
            for (var i = 0; i < 3; i++) {
                var frame = new mathis.MathisFrame(divs[i], false);
                mathisFrames.push(frame);
                var $legend = mathis.legend("30px", frame.canvasParent);
                legends.push($legend);
            }
            oneVectorField(width, height, origin, vectorField0, new mathis.XYZ(width * 0.3, height * 0.2, 0), mathisFrames[0]);
            oneVectorField(width, height, origin, vectorField1, new mathis.XYZ(-width * 0.4, height * 0.1, 0), mathisFrames[1]);
            oneVectorField(width, height, origin, vectorField2, new mathis.XYZ(width * 0.3, height * 0.2, 0), mathisFrames[2]);
        }
        function severalPolyhedron(mainDiv) {
            function polyhedron(type, mathisFrame) {
                var scene = mathisFrame.scene;
                var light0 = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(-1, 0, -0.7), scene);
                light0.diffuse = new BABYLON.Color3(1, 1, 1);
                light0.specular = new BABYLON.Color3(0.5, 0.5, 0.5);
                light0.groundColor = new BABYLON.Color3(0, 0, 0);
                var grabber = new mathis.macamera.SphericalGrabber(scene, new mathis.XYZ(1, 1, 1));
                grabber.mesh.visibility = 0;
                grabber.endOfZone1 = 0;
                grabber.endOfZone2 = 0;
                var macam = new mathis.macamera.GrabberCamera(mathisFrame, grabber);
                macam.useFreeModeWhenCursorOutOfGrabber = false;
                macam.changePosition(new mathis.XYZ(0, 0, -4), false);
                var res = new BABYLON.Mesh('', scene);
                var meshMaker = new mathis.creation3D.Polyhedron(type);
                var mamesh = meshMaker.go();
                mamesh.fillLineCatalogue();
                var model = BABYLON.Mesh.CreateCylinder('', 1, 1, 1, 20, null, scene);
                model.convertToFlatShadedMesh();
                var mat = new BABYLON.StandardMaterial('', scene);
                mat.diffuseColor = mathis.myFavoriteColors.green;
                model.material = mat;
                var lineMak = new mathis.visu3d.LinksViewer(mamesh, scene);
                lineMak.meshModel = model;
                lineMak.parentNode = res;
                lineMak.segmentOrientationFunction = function (vert0, vert1) {
                    if (vert0.hasMark(mathis.Vertex.Markers.polygonCenter) || vert1.hasMark(mathis.Vertex.Markers.polygonCenter))
                        return 0;
                    return 1;
                };
                lineMak.go();
                var surfaceGameoMaker = new mathis.visu3d.SurfaceViewer(mamesh, scene);
                surfaceGameoMaker.parentNode = res;
                surfaceGameoMaker.alpha = 0.7;
                surfaceGameoMaker.go();
                var positioningsMaker = new mathis.mameshAroundComputations.PositioningComputerForMameshVertices(mamesh);
                positioningsMaker.sizesProp = new mathis.XYZ(0.2, 0.2, 0.2);
                var nonPintaCenter = [];
                mamesh.vertices.forEach(function (v) {
                    if (!v.hasMark(mathis.Vertex.Markers.polygonCenter))
                        nonPintaCenter.push(v);
                });
                var vertMak = new mathis.visu3d.VerticesViewer(mamesh, scene, positioningsMaker.go());
                vertMak.parentNode = res;
                vertMak.vertices = nonPintaCenter;
                vertMak.go();
                // let vertexGameoMaker = new visu3d.VerticesGameoMaker(mamesh, scene)
                // vertexGameoMaker.parent=res
                // vertexGameoMaker.radiusMethod = (v:Vertex)=> {
                //     if (v.hasMark(Vertex.Markers.pintagoneCenter)) return 0
                //     else return 0.05
                // }
                // vertexGameoMaker.go()
                return res;
            }
            var divs = mathis.nDivInOneLine(5, mainDiv, "1px solid");
            var mathisFrames = [];
            var legends = [];
            for (var i = 0; i < 5; i++) {
                var frame = new mathis.MathisFrame(divs[i], false);
                mathisFrames.push(frame);
                var $legend = mathis.legend("30px", frame.canvasParent);
                legends.push($legend);
            }
            var Tetrahedron = polyhedron(mathis.creation3D.PolyhedronType.Tetrahedron, mathisFrames[0]);
            legends[0].innerHTML = "<p style='text-align: center'> ttradre </p>";
            var Cube = polyhedron(mathis.creation3D.PolyhedronType.Cube, mathisFrames[1]);
            legends[1].innerHTML = "<p style='text-align: center'> cube </p>";
            var Octahedron = polyhedron(mathis.creation3D.PolyhedronType.Octahedron, mathisFrames[2]);
            legends[2].innerHTML = "<p style='text-align: center'> octadre </p>";
            var dodeca = polyhedron(mathis.creation3D.PolyhedronType.Dodecahedron, mathisFrames[3]);
            legends[3].innerHTML = "<p style='text-align: center'> dodcadre </p>";
            var Icosahedron = polyhedron(mathis.creation3D.PolyhedronType.Icosahedron, mathisFrames[4]);
            legends[4].innerHTML = "<p style='text-align: center'> icosadre </p>";
        }
        function severalIsings(mainDiv) {
            upLegend("<span>plus beta est grand, et plus les particules de mme couleur s'attirent </span>", "public2009-A3.pdf", mainDiv);
            var divs = mathis.nDivInOneLine(3, mainDiv, "1px solid");
            //let canvass=mathis.nCanvasInOneLine(4,mainDiv)
            var frameInterval = 5;
            var q = 1.1;
            var qs = [q, q, q];
            var betas = [0, 0.5, 1];
            for (var i = 0; i < 3; i++) {
                var frame = new mathis.MathisFrame(divs[i], false);
                oneIsingSphere(frame, qs[i], betas[i], 1);
                var $legend = mathis.legend("30px", frame.canvasParent);
                $legend.innerHTML = "<p style='text-align: center'>&beta;=" + betas[i] + "</p>"; //"&beta="+betas[i]
            }
            function oneIsingSphere(mathisFrame, q, beta, sphereRadius) {
                var light0 = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(-1, 1, -1), mathisFrame.scene);
                light0.diffuse = new BABYLON.Color3(1, 1, 1);
                light0.specular = new BABYLON.Color3(1, 1, 1);
                light0.groundColor = new BABYLON.Color3(0, 1, 0);
                var center = new mathis.XYZ(0, 0, 0);
                //BABYLON.Mesh.CreateSphere('',20,2,scene)
                var grabber = new mathis.macamera.SphericalGrabber(mathisFrame.scene, new mathis.XYZ(sphereRadius, sphereRadius, sphereRadius), center);
                grabber.mesh.material.alpha = 1;
                grabber.endOfZone1 = 0;
                grabber.endOfZone2 = 0;
                var macam = new mathis.macamera.GrabberCamera(mathisFrame, grabber);
                macam.useFreeModeWhenCursorOutOfGrabber = false;
                macam.changePosition(new mathis.XYZ(0, 0, -4), false);
                //macam.camera.viewport=new BABYLON.Viewport(index/nbCam,0,1/nbCam,1)
                macam.attachControl(mathisFrame.canvas);
                //mathisFrame.scene.activeCameras.push(macam.camera)
                var sphereMaker = new mathis.creation3D.Polyhedron(mathis.creation3D.PolyhedronType.Dodecahedron);
                var mamesh = sphereMaker.go();
                new mathis.mameshModification.TriangleDichotomer(mamesh).go();
                new mathis.mameshModification.TriangleDichotomer(mamesh).go();
                new mathis.mameshModification.TriangleDichotomer(mamesh).go();
                mamesh.vertices.forEach(function (v) {
                    v.position.normalize().scale(sphereRadius).add(center);
                });
                //new visu3d.VerticesVisuMaker(mamesh,scene).go()
                var ising = new mathis.metropolis.IsingModel(mamesh.vertices);
                ising.beta = beta;
                ising.q = q;
                ising.nbActionsPerIteration = 100;
                ising.go();
                function modeleGen0(color) {
                    var model = BABYLON.Mesh.CreateSphere('', 6, 1, mathisFrame.scene);
                    var mat1 = new BABYLON.StandardMaterial('', mathisFrame.scene);
                    mat1.diffuseColor = color;
                    model.material = mat1;
                    var qua = new mathis.XYZW(0, 0, 0, 0);
                    mathis.geo.axisAngleToQuaternion(new mathis.XYZ(1, 0, 0), Math.PI / 2, qua);
                    model.rotationQuaternion = qua;
                    return model;
                }
                function modeleDisk(color) {
                    var model = BABYLON.Mesh.CreateDisc('', 0.5, 6, mathisFrame.scene, false, BABYLON.Mesh.BACKSIDE); //BABYLON.Mesh.CreateSphere('',10,1,scene)
                    var mat1 = new BABYLON.StandardMaterial('', mathisFrame.scene);
                    mat1.diffuseColor = color;
                    model.material = mat1;
                    var qua = new mathis.XYZW(0, 0, 0, 0);
                    mathis.geo.axisAngleToQuaternion(new mathis.XYZ(1, 0, 0), Math.PI / 2, qua);
                    model.rotationQuaternion = qua;
                    return model;
                }
                function modeleCylinder(color) {
                    var model = BABYLON.Mesh.CreateCylinder('', 0.1, 1, 1, 6, null, mathisFrame.scene); //BABYLON.Mesh.CreateSphere('',10,1,scene)
                    var mat1 = new BABYLON.StandardMaterial('', mathisFrame.scene);
                    mat1.diffuseColor = color;
                    model.material = mat1;
                    //let qua=new XYZW(0,0,0,0)
                    // geo.axisAngleToQuaternion(new XYZ(1,0,0),Math.PI/2,qua)
                    // model.rotationQuaternion=qua
                    return model;
                }
                var model1 = modeleGen0(new BABYLON.Color3(1, 0, 0));
                var model2 = modeleGen0(new BABYLON.Color3(0, 0, 1));
                var positionneur = new mathis.mameshAroundComputations.PositioningComputerForMameshVertices(mamesh);
                positionneur.sizesProp = new mathis.XYZ(1, 1, 1);
                var positionning = positionneur.go();
                var positionning1 = new mathis.HashMap();
                mamesh.vertices.forEach(function (v) {
                    var po = new mathis.Positioning();
                    po.copyFrom(positionning.getValue(v));
                    po.scaling.copyFromFloats(0, 0, 0);
                    positionning1.putValue(v, po);
                });
                var positionning2 = new mathis.HashMap();
                mamesh.vertices.forEach(function (v) {
                    var po = new mathis.Positioning();
                    po.copyFrom(positionning.getValue(v));
                    po.scaling.copyFromFloats(0, 0, 0);
                    positionning2.putValue(v, po);
                });
                var vertVisu1 = new mathis.visu3d.VerticesViewer(mamesh, mathisFrame.scene);
                vertVisu1.positionings = positionning1;
                vertVisu1.meshModel = model1;
                vertVisu1.go();
                var vertVisu2 = new mathis.visu3d.VerticesViewer(mamesh, mathisFrame.scene);
                vertVisu2.positionings = positionning2;
                vertVisu2.meshModel = model2;
                vertVisu2.go();
                var commonSizes = positionning.getValue(mamesh.vertices[0]).scaling;
                var cumul = 0;
                var action = new mathis.PeriodicAction(function () {
                    var changed = ising.iterateAndGetChangedVertices();
                    changed.allKeys().forEach(function (v) {
                        if (v.customerObject.value == 0) {
                            positionning1.getValue(v).scaling.copyFromFloats(0, 0, 0); //.getValue(v).sizes.copyFrom(0,0,0)
                            positionning2.getValue(v).scaling.copyFromFloats(0, 0, 0);
                        }
                        else if (v.customerObject.value == 1) {
                            positionning1.getValue(v).scaling.copyFrom(commonSizes);
                            positionning2.getValue(v).scaling.copyFromFloats(0, 0, 0);
                        }
                        else if (v.customerObject.value == -1) {
                            positionning2.getValue(v).scaling.copyFrom(commonSizes);
                            positionning1.getValue(v).scaling.copyFromFloats(0, 0, 0);
                        }
                    });
                    vertVisu1.updatePositionings();
                    vertVisu2.updatePositionings();
                    //vertVisu1.buildVertexVisu(changed1,changed0)
                    //vertVisu2.buildVertexVisu(changed_1,changed0)
                    //vertVisu2.buildVertexVisu(changed)
                });
                action.frameInterval = frameInterval;
                mathisFrame.pushPeriodicAction(action);
            }
        }
    })(siteAgreg = mathis.siteAgreg || (mathis.siteAgreg = {}));
})(mathis || (mathis = {}));
// /**
//  * Created by vigon on 03/03/2016.
//  */
//
//
//
// module mathis {
//
//
//
//    
//    
//         export function createSceneForMyWebPage(canvas):void {
//    
//    
//             scene.clearColor = new BABYLON.Color3(.5, .5, .5);
//    
//             var light0 = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(-1, 0, -0.7), scene);
//             light0.diffuse = new BABYLON.Color3(1, 1, 1);
//             light0.specular = new BABYLON.Color3(0.5, 0.5, 0.5);
//             light0.groundColor = new BABYLON.Color3(0, 0, 0);
//    
//    
//             {
//                 let r=0.8
//                 let a=2
//    
//                 let macam = new macamera.GrabberCamera(scene)
//                 macam.trueCamPos.changePosition(new XYZ(0,0,-10))
//                 macam.justOneGrabber.center=new XYZ(0,0,0)
//                 macam.justOneGrabber.constantRadius=a+r
//                 macam.showPredefinedConsoleLog=false
//                 macam.justOneGrabber.grabberIsVisible=false
//                 macam.go()
//                 macam.attachControl(canvas)
//    
//                 let IN_mamesh = new Mamesh()
//                 let meshMaker = new reseau.Regular(IN_mamesh)
//                 meshMaker.makeLinks=true
//                 meshMaker.nbX=5
//                 meshMaker.nbY=20
//                 meshMaker.minX=0
//                 meshMaker.maxX=2*Math.PI
//                 meshMaker.minY=0
//                 meshMaker.maxY=2*Math.PI
//                 meshMaker.nbVerticalDecays=2
//                 meshMaker.nbHorizontalDecays=1
//                 meshMaker.go()
//    
//    
//                 IN_mamesh.vertices.forEach((vertex:Vertex)=>{
//    
//                     let u=vertex.position.x
//                     let v=vertex.position.y
//    
//                     vertex.position.x=(r*Math.cos(u)+a)*Math.cos((v))
//                     vertex.position.y=(r*Math.cos(u)+a)*Math.sin((v))
//                     vertex.position.z=r*Math.sin(u)
//    
//                 })
//    
//    
//                 let merger=new mameshModification.Merger(IN_mamesh)
//                 merger.cleanDoubleLinksKeepingInPriorityThoseWithOpposite=true
//                 merger.mergeLink=true
//                 merger.go()
//    
//                 let oppositeAssocier=new linkModule.OppositeLinkAssocierByAngles(IN_mamesh.vertices)
//                 oppositeAssocier.maxAngleToAssociateLinks=Math.PI
//                 oppositeAssocier.go()
//    
//                 IN_mamesh.fillLineCatalogue()
//    
//                 //TODO let lll=new visu3d.LinesGameo(IN_mamesh,scene)
//                 //lll.lineInterpolerOptions.interpolationStyle=LineInterpoler.InterpolationStyle.none
//                 //lll.radiusFunction=visu3d.LinesGameo.constantRadius(0.02)
//                 //lll.drawLineFunction=(index:number,line:Vertex[])=>{
//                 //    if (index==0) return true
//                 //}
//                 //lll.colorFunction=visu3d.LinesGameo.constantRGBColor255(124,252,0)
//                 //lll.go()
//                 //
//                 //let lll2=new visu3d.LinesGameo(IN_mamesh,scene)
//                 //lll2.lineInterpolerOptions.interpolationStyle=LineInterpoler.InterpolationStyle.hermite
//                 //lll2.radiusFunction=visu3d.LinesGameo.constantRadius(0.02)
//                 //lll2.drawLineFunction=(index:number,line:Vertex[])=>{
//                 //    if (index==1) return true
//                 //}
//                 //lll2.colorFunction=visu3d.LinesGameo.constantRGBColor255(191,62,255)
//                 //lll2.go()
//    
//                 let bab=new visu3d.SurfaceVisuMaker(IN_mamesh,scene)
//                 bab.alpha=0.6
//                 bab.go()
//    
//    
//    
//             }
//    
//    
//    
//    
//    
//    
//     }
//    
//
// } 
//
// module mathis {
//
//
//     import Polyhedron = mathis.creation3D.PolyhedronStatic;
//     import Vector3=BABYLON.Vector3
//     import VertexBuffer = BABYLON.VertexBuffer;
//     import Mesh = BABYLON.Mesh;
//     import Color3 = BABYLON.Color3;
//     import GrabberCamera = mathis.macamera.GrabberCamera;
//
//     export module testWithBabylon{
//
//         import Multiply = mathis.periodicWorld.Multiply;
//         import FreeCamera = BABYLON.FreeCamera;
//         import InstancedMesh = BABYLON.InstancedMesh;
//         import Grabber = mathis.macamera.Grabber;
//         import GrabberCamera = mathis.macamera.GrabberCamera;
//         import Action = BABYLON.Action;
//         import AbstractMesh = BABYLON.AbstractMesh;
//         import StandardMaterial = BABYLON.StandardMaterial;
//
//
//         export function startSeveralFrame(){
//
//
//             let mainDiv:HTMLElement=document.getElementById("mainDiv");
//             let canvass=mathis.nCanvasInOneLine(2,mainDiv)
//
//             var secondFrame=new mathis.MathisFrame()
//             secondFrame.canvas=canvass[0]
//             secondFrame.go()
//             testOneGrabber(secondFrame,new BABYLON.Color3(1,0,0))
//
//
//             var starter=new mathis.MathisFrame()
//             starter.canvas=canvass[1]
//             starter.go()
//             testOneGrabber(starter,new BABYLON.Color3(0,0,1))
//
//
//         }
//
//
//         export function start(){
//             let mainDiv:HTMLElement=document.getElementById("mainDiv");
//
//
//             let canvass=mathis.nCanvasInOneLine(1,mainDiv)
//
//             let mathisFrame =new MathisFrame()
//             mathisFrame.canvas=canvass[0]
//             mathisFrame.go()
//
//           
//
//             {
//
//                 let infi=new infiniteWorlds.InfiniteCartesian(mathisFrame)
//
//                 infi.nbRepetition=8
//                 infi.nbSubdivision=3
//                 infi.fondamentalDomainSize=60
//                 infi.nbHorizontalDecays=1
//                 infi.nbVerticalDecays=1
//
//                 infi.squareVersusSemiVersusTri=0
//
//
//                 let mesh=BABYLON.Mesh.CreateSphere('',5,10,mathisFrame.scene)
//                 //let mesh=BABYLON.Mesh.CreateBox('',1,mathisFrame.scene)
//                 mesh.position=new XYZ(1,1,1)
//
//
//                 infi.population.push(mesh)
//
//                 infi.go()
//
//                 //infi.seeWorldFromOutside()
//                 infi.seeWorldFromInside()
//                 //
//                 //setTimeout(()=>{infi.seeWorldFromInside()},5000)
//
//
//             }
//
//            
//
//
//         }
//
//
//
//         function reseau3d(mathisFrame:MathisFrame){
//             let grabber0 = new macamera.SphericalGrabber(mathisFrame.scene)
//             let cam = new macamera.GrabberCamera(mathisFrame, grabber0)
//
//
//             // cam.translationSpeed=4
//             // cam.useOnlyFreeMode=true
//             // cam.changePosition(new XYZ(0.5,1,3))
//             // cam.changeFrontDir(new XYZ(-0.5,-1,1.5))
//             // cam.checkCollisions=true
//             //
//             cam.attachControl(mathisFrame.canvas)
//
//
//             // Ajout d'une lumire
//             var light0 = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(-1, 1, -1), mathisFrame.scene);
//             light0.diffuse = new BABYLON.Color3(1,1,1);
//             light0.specular = new BABYLON.Color3(0.,0.,0.);
//             light0.groundColor = new BABYLON.Color3(0, 0, 0.3);
//
//             let crea = new reseau.Regular3D()
//             crea.strateHaveSquareMailleVersusTriangleMaille=false
//             let mamesh=crea.go()
//
//             mamesh.fillLineCatalogue()
//
//
//
//             function lineVisu(ma:Mamesh,segmentSelectionFunction){
//                 let model=BABYLON.Mesh.CreateBox('',1,mathisFrame.scene)//BABYLON.Mesh.CreateCylinder('',1,0.2,0.2,4,null,scene)
//                 let material=new BABYLON.StandardMaterial('',mathisFrame.scene)
//                 material.diffuseColor=new BABYLON.Color3(0.6,0.6,0.6)
//                 //material.diffuseTexture = wallDiffuseTexture;
//                 model.material=material
//                 model.convertToFlatShadedMesh()
//
//                 let lineMak=new visu3d.LinksViewer(ma,mathisFrame.scene)
//                 lineMak.diameter=0.2
//                 /**collision sur les poutres pas terrible*/
//                 lineMak.checkCollision=false
//                 lineMak.meshModel=model
//                 lineMak.segmentSelectionFunction=segmentSelectionFunction
//                 let vec100=new XYZ(1,0,0)
//                 let vec010=new XYZ(0,1,0)
//                 lineMak.pairVertexToLateralDirection=(v1,v2)=>{
//                     if ( Math.abs(geo.dot(XYZ.newFrom(v1.position).substract(v2.position),vec100))<0.0001) return vec100
//                     else return vec010
//                         }
//                 lineMak.go()
//             }
//
//             lineVisu(mamesh,null)
//
//             cc(mamesh.toString())
//
//
//             let surfacer=new visu3d.SurfaceViewer(mamesh,mathisFrame.scene)
//             surfacer.go()
//
//
//
//
//
//
//
//
//
//
//
//
//
//         }
//
//        
//         function testOneSurface(mathisFrame:MathisFrame){
//
//             // Ajout d'une lumire
//             var light0 = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(-1, 1, -1), mathisFrame.scene);
//             light0.diffuse = new BABYLON.Color3(1, 1, 1);
//             light0.specular = new BABYLON.Color3(1, 0.5, 0.5);
//             light0.groundColor = new BABYLON.Color3(0, 0, 0);
//            
//             let grabber=new macamera.SphericalGrabber(mathisFrame.scene)
//             mathisFrame.camera=new macamera.GrabberCamera(mathisFrame,grabber)
//
//             let surfaceMaker=new riemann.SurfaceMaker(riemann.SurfaceName.cylinder)
//             let surface=surfaceMaker.go()
//             surface.drawTheWholeSurface(mathisFrame.scene)
//         }
//
//
//
//
//         // function testResau(mathisFrame:MathisFrame){
//         //     let macam = new macamera.GrabberCamera(mathisFrame.scene)
//         //     macam.changePosition(new XYZ(0,0,-4))
//         //
//         //     macam.FirstGrabber.center=new XYZ(0,0,0)
//         //     macam.FirstGrabber.constantRadius=1
//         //     macam.FirstGrabber.grabberIsVisible=true
//         //
//         //
//         //     macam.attachControl(mathisFrame.canvas)
//         //
//         //
//         //
//         //     // Ajout d'une lumire
//         //     var light0 = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(-1, 1, -1), mathisFrame.scene);
//         //     light0.diffuse = new BABYLON.Color3(1, 1, 1);
//         //     light0.specular = new BABYLON.Color3(1, 1, 1);
//         //     light0.groundColor = new BABYLON.Color3(0, 0, 0);
//         //
//         //
//         //     // let IN_mamesh=new Mamesh()
//         //     // let cre=new reseau.Regular(IN_mamesh)
//         //     // cre.go()
//         //     //
//         //     // linkModule.checkTheRegularityOfAGRaph(IN_mamesh.vertices)
//         //     //
//         //     //IN_mamesh.fillLineCatalogue()
//         //
//         //
//         //
//         //     let IN_mamesh=new Mamesh3dStratified()
//         //
//         //     let twoGe=new reseau.BasisForRegularReseau()
//         //     twoGe.nbHorizontalDecays=1
//         //     let res=twoGe.go()
//         //
//         //
//         //     let crea=new reseau.Regular3D(IN_mamesh)
//         //     crea.Vi=res.Vi
//         //     crea.Vj=res.Vj
//         //     crea.createIMameshes=true
//         //     crea.createJMameshes=true
//         //     crea.go()
//         //
//         //     IN_mamesh.fillLineCatalogueOfStrates()
//         //
//         //     IN_mamesh.kMameshes.forEach(mamesh2d=>{
//         //         cc(mamesh2d.toString(true))
//         //         let aaa=new visu3d.LinesVisuFastMaker(mamesh2d,scene)
//         //         aaa.go()
//         //
//         //
//         //
//         //         let verGa=new visu3d.VerticesViewer(mamesh2d,scene)
//         //         verGa.go()
//         //
//         //     })
//         //
//         //     IN_mamesh.iMameshes.forEach(mamesh2d=>{
//         //         cc(mamesh2d.toString(true))
//         //         let aaa=new visu3d.LinesVisuFastMaker(mamesh2d,scene)
//         //         aaa.go()
//         //
//         //
//         //
//         //     })
//         //
//         //     IN_mamesh.jMameshes.forEach(mamesh2d=>{
//         //         cc(mamesh2d.toString(true))
//         //         let aaa=new visu3d.LinesVisuFastMaker(mamesh2d,scene)
//         //         aaa.go()
//         //
//         //     })
//         //
//         //
//         // }
//         //
//         //
//         //
//
//         function testPeriodicWorldByLargeResau(mathisFrame:MathisFrame):void{
//
//
//             let useMacamera=true
//
//
//             let cam
//
//             if (useMacamera) {
//                 let grabber0 = new macamera.SphericalGrabber(mathisFrame.scene)
//                 grabber0.focusOnMyCenterWhenCameraGoDownWard = false
//                 grabber0.mesh.visibility = 0//TODO faire un grabber sans forcement de mesh
//                 //grabber0.showGrabberOnlyWhenGrabbing
//
//                 cam = new macamera.GrabberCamera(mathisFrame, grabber0)
//
//                 cam.translationSpeed=3
//                 cam.useOnlyFreeMode=true
//                 cam.changePosition(new XYZ(0.5,1,3).scale(1.5))
//                 cam.changeFrontDir(new XYZ(-0.5,-1,1.5))
//
//                 cam.keysFrontward =[66, 78];
//                 cam.keysBackward =[32];
//
//
//                 cam.attachControl(mathisFrame.canvas)
//
//             }
//             else {
//                 cam = new BABYLON.FreeCamera('', new BABYLON.Vector3(1, 0.5, 1), mathisFrame.scene)
//                 cam.speed *= 0.2
//             }
//
//             cam.checkCollisions = true
//             //
//
//
//             // Ajout d'une lumire
//             var light0 = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(-1, 1, -1), mathisFrame.scene);
//             light0.diffuse = new BABYLON.Color3(1,1,1);
//             light0.specular = new BABYLON.Color3(0.,0.,0.);
//             light0.groundColor = new BABYLON.Color3(0, 0, 0.3);
//
//
//             let camPosInWebCoor=new XYZ(0,0,0)
//             let camDomain=new periodicWorld.Domain(0,0,0)
//             let camDomainCenter=new XYZ(0,0,0)
//             let fondamentalDomainSize=9
//             let nbSubdivision=3
//             let nbRepetition=6
//
//             if (useMacamera) {
//                 var fd = new periodicWorld.CartesianFundamentalDomain(new XYZ(fondamentalDomainSize, 0, 0), new XYZ(0, fondamentalDomainSize, 0), new XYZ(0, 0, fondamentalDomainSize));
//                 cam.onTranslate = ()=> {
//
//                     fd.pointToWebCoordinate(cam.trueCamPos.position, camPosInWebCoor);
//                     camDomain.whichContains(camPosInWebCoor);
//                     camDomain.getCenter(fd, camDomainCenter);
//
//                     /**attention, il fautchnager simultanment la truePosition et la wished position. Donc mettre le smoothing  false*/
//                     cam.changePosition(cam.whishedCamPos.getPosition().substract(camDomainCenter), false)
//                     //cam.changePosition(cam.trueCamPos.getPosition().substract(camDomainCenter))
//
//                 }
//             }
//
//
//
//
//             let reseauGen=new reseau.BasisForRegularReseau()
//             reseauGen.end=new XYZ(fondamentalDomainSize,fondamentalDomainSize,0)
//             reseauGen.nbI=nbSubdivision
//             reseauGen.nbJ=nbSubdivision
//             reseauGen.nbVerticalDecays=0
//             reseauGen.nbHorizontalDecays=0
//             reseauGen.kComponentTranslation+=0
//             let VV=reseauGen.go()
//
//
//
//             function theReseau(nbRepetitions): Mamesh{
//
//                 let crea = new reseau.Regular3D()
//                 crea.nbI = nbSubdivision*nbRepetitions
//                 crea.nbJ = nbSubdivision*nbRepetitions
//                 crea.nbK = nbSubdivision*nbRepetitions
//                 crea.Vi = VV.Vi
//                 crea.Vj = VV.Vj
//                 crea.Vk = new XYZ(0, 0, fondamentalDomainSize / (nbSubdivision - 1))
//                 let totalSize=nbSubdivision*nbRepetitions*VV.Vi.length()
//                 crea.origine=new XYZ(-totalSize/2,-totalSize/2,-totalSize/2)
//                 crea.putAVertexOnlyAtXYZCheckingThisCondition=(xyz)=>xyz.length()<(totalSize/2*1.1)
//                 return crea.go()
//             }
//
//             let mamesh=theReseau(nbRepetition)
//             mamesh.fillLineCatalogue()
//
//             // let ma1=stratified1.toMamesh()
//             // ma1.fillLineCatalogue()
//
//             //ma2.fillLineCatalogue()
//             //oneMameshVisual(ma2)
//
//
//             var wallDiffuseTexture  = new BABYLON.Texture('../assets/texture/escher.jpg', mathisFrame.scene);
//             //var wallNormalsHeightTexture = new BABYLON.Texture('../assets/texture/GtIUsWW.png', scene);
//
//
//             function lineVisu(ma:Mamesh,segmentSelectionFunction){
//                 let model=BABYLON.Mesh.CreateBox('',1,mathisFrame.scene)//BABYLON.Mesh.CreateCylinder('',1,0.2,0.2,4,null,scene)
//                 let material=new BABYLON.StandardMaterial('',mathisFrame.scene)
//                 material.diffuseColor=new BABYLON.Color3(0.6,0.6,0.6)
//                 material.diffuseTexture = wallDiffuseTexture;
//                 model.material=material
//                 model.convertToFlatShadedMesh()
//
//                 let lineMak=new visu3d.LinksViewer(ma,mathisFrame.scene)
//                 lineMak.diameter=0.2
//                 /**collision sur les poutres pas terrible*/
//                 lineMak.checkCollision=false
//                 lineMak.meshModel=model
//                 lineMak.segmentSelectionFunction=segmentSelectionFunction
//                 let vec100=new XYZ(1,0,0)
//                 let vec010=new XYZ(0,1,0)
//                 lineMak.pairVertexToLateralDirection=(v1,v2)=>{
//                     if ( Math.abs(geo.dot(XYZ.newFrom(v1.position).substract(v2.position),vec100))<0.0001) return vec100
//                     else return vec010
//                 }
//                 lineMak.go()
//             }
//
//
//
//             function vertexVisu(mamesh2:Mamesh){
//                 let model=BABYLON.Mesh.CreateBox('',0.5,mathisFrame.scene)
//                 let material=new BABYLON.StandardMaterial('',mathisFrame.scene)
//                 material.diffuseTexture = wallDiffuseTexture;
//                 //material.bumpTexture = wallNormalsHeightTexture;
//                 //material.useParallax = true;
//                 // material.useParallaxOcclusion = true;
//                 // material.parallaxScaleBias = 0.1;
//                 //material.specularPower = 1000.0;
//                 //material.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);
//
//                 //mat.diffuseColor=col
//                 model.material=material
//                 //model.checkCollisions=true
//                 model.convertToFlatShadedMesh()
//                 let verticesVisuMaker=new visu3d.VerticesViewer(mamesh2,mathisFrame.scene)
//                 verticesVisuMaker.meshModel=model
//                 verticesVisuMaker.checkCollision=true
//                 let positioning=new Positioning()
//                 positioning.upVector=new XYZ(1,0,0)
//                 positioning.frontDir=new XYZ(0,1,0)
//                 verticesVisuMaker.vertexToPositioning=new HashMap<Vertex,Positioning>()
//                 for (let v of mamesh2.vertices) verticesVisuMaker.vertexToPositioning.putValue(v,positioning)
//                 verticesVisuMaker.go()
//             }
//
//             lineVisu(mamesh,null)
//             vertexVisu(mamesh)
//             //
//             // let count=0
//             //
//             // stratified1.kMameshes.forEach(ma=>{
//             //     count+=ma.vertices.length
//             //     lineVisu(ma,null)
//             //     vertexVisu(ma)
//             // })
//             //
//             // cc('nb vertice drawn:',count,'<',Math.pow(nbSubdivision*nbRepetition,3))
//             //
//             //
//             // let onlyVerticalFonc=(i:number,segment:Vertex[])=>{
//             //     return (segment[0].param.x==segment[1].param.x&& segment[0].param.y==segment[1].param.y)
//             // }
//             // stratified1.iMameshes.forEach(ma=>{
//             //     lineVisu(ma,onlyVerticalFonc)
//             // })
//
//
//             // stratified1.jMameshes.forEach(ma=>{
//             //     lineVisu(ma,new BABYLON.Color3(0,1,0))
//             // })
//             // stratified1.kMameshes.forEach(ma=>{
//             //     lineVisu(ma,new BABYLON.Color3(0,0,1))
//             // })
//
//
//
//
//
//
//             // function oneMerge(mesh1,mesh2){
//
//             // }
//             // oneMerge(directional1.iMamesh,directional2.iMamesh)
//             // oneMerge(directional1.jMamesh,directional2.jMamesh)
//             // oneMerge(directional1.kMamesh,directional2.kMamesh)
//             //
//             //
//             //
//             //
//             //
//             //
//             // function oneMameshVisual(IN_mamesh:Mamesh):void{
//             //     let link=new visu3d.LinesGameoMaker(IN_mamesh,scene)
//             //     link.parentGameo=rootGameo
//             //     link.lineOptionFunction=(i,line)=>{
//             //         let res=new visu3d.LineGameoStatic.LineGameoOption()
//             //         res.tesselation=4
//             //         return res
//             //     }
//             //     link.go()
//             // }
//             //
//             // oneMameshVisual(directional1.iMamesh)
//             //
//             //
//             // //  mamesh3d.iMameshes[0].vertices.forEach(v=>v.isInvisible=true)
//             // //  mamesh3d.jMameshes[0].vertices.forEach(v=>v.isInvisible=true)
//             // //  mamesh3d.kMameshes[0].vertices.forEach(v=>v.isInvisible=true)
//             // //
//             // //
//             // // mamesh3d.allMamesh().forEach(IN_mamesh=>{oneMameshVisual(IN_mamesh)})
//             //
//
//
//
//
//             //
//             // let arrete=fd.getArretes(scene)
//             //
//             //
//             // let mul=new periodicWorld.Multiply(fd,10)
//             // arrete.forEach(arr=>{mul.addAbstractMesh(arr)})
//             // //mul.addBabGameo(rootGameo)
//             //
//             //
//             // createSkybox(scene)
//
//
//             createSkybox(mathisFrame.scene)
//
//             mathisFrame.scene.fogMode = BABYLON.Scene.FOGMODE_EXP2;
//             mathisFrame.scene.fogDensity = 0.05;
//             mathisFrame.scene.fogColor = new BABYLON.Color3(1,1,1);
//
//
//
//             function createSkybox(scene:BABYLON.Scene) {
//
//                 var skybox = BABYLON.Mesh.CreateBox("skyBox", 100.0, scene);
//                 skybox.checkCollisions=true;
//                 var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
//                 skyboxMaterial.backFaceCulling = false;
//                 skybox.material = skyboxMaterial;
//                 skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
//                 skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
//                 skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("../assets/skybox/skybox", scene,['_px.jpg', '_py.jpg', '_pz.jpg', '_nx.jpg', '_ny.jpg', '_nz.jpg']);
//                 skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
//
//
//             }
//
//
//         }
//         //
//         // //
//         // // function testPeriodicWorldByMerging(mathisFrame:MathisFrame):void{
//         // //
//         // //     let macam = new macamera.GrabberCamera(mathisFrame.scene)
//         // //     macam.changePosition(new XYZ(0,0,-4))
//         // //     macam.FirstGrabber.grabberIsVisible=true
//         // //     macam.attachControl(mathisFrame.canvas)
//         // //
//         // //
//         // //     // Ajout d'une lumire
//         // //     var light0 = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(-1, 1, -1), mathisFrame.scene);
//         // //     light0.diffuse = new BABYLON.Color3(1, 1, 1);
//         // //     light0.specular = new BABYLON.Color3(1, 1, 1);
//         // //     light0.groundColor = new BABYLON.Color3(0, 0, 0);
//         // //
//         // //
//         // //     let camPosInWebCoor=new XYZ(0,0,0)
//         // //     let camDomain=new periodicWorld.Domain(0,0,0)
//         // //     let camDomainCenter=new XYZ(0,0,0)
//         // //
//         // //
//         // //     //let oldCamDomain=new periodicWorld.Domain(0,0,0)
//         // //
//         // //
//         // //     let fondamentalDomainSize=2
//         // //     var fd=new periodicWorld.CartesianFundamentalDomain(new XYZ(fondamentalDomainSize,0,0),new XYZ(0,fondamentalDomainSize,0),new XYZ(0,0,fondamentalDomainSize));
//         // //
//         // //
//         // //     // let action= new ActionBeforeRender(()=>{
//         // //     //
//         // //     //     fd.pointToWebCoordinate(macam.trueCamPos.getPosition(), camPosInWebCoor);
//         // //     //     camDomain.whichContains(camPosInWebCoor);
//         // //     //
//         // //     //     camDomain.getCenter(fd, camDomainCenter);
//         // //     //
//         // //     //     /**attention, il faut soutraire en mme temps, sinon on a un effet d'aller retour*/
//         // //     //     macam.whishedCamPos.position.substract(camDomainCenter)
//         // //     //     macam.trueCamPos.position.substract(camDomainCenter)
//         // //     //
//         // //     //
//         // //     // })
//         // //
//         // //     //action.frameInterval=1
//         // //     //mathisFrame.actionsBeforeRender['recenter']=action
//         // //
//         // //
//         // //     let rootGameo=new GameoBab()
//         // //
//         // //     let nb=7
//         // //
//         // //     let reseauGen=new reseau.BasisForRegularReseau()
//         // //     reseauGen.end=new XYZ(fondamentalDomainSize,fondamentalDomainSize,0)
//         // //     reseauGen.nbI=nb
//         // //     reseauGen.nbJ=nb
//         // //     reseauGen.nbVerticalDecays=1
//         // //     reseauGen.nbHorizontalDecays=2
//         // //     reseauGen.kComponentTranslation+=0.
//         // //
//         // //     let VV=reseauGen.go()
//         // //
//         // //     cc(VV.Vi,VV.Vj)
//         // //
//         // //
//         // //     function oneReseau(): Mamesh3dStratified{
//         // //         let mamesh3d = new Mamesh3dStratified()
//         // //         let crea = new reseau.Regular3D(mamesh3d)
//         // //         crea.nbI = nb
//         // //         crea.nbJ = nb
//         // //         crea.nbK = nb
//         // //         crea.Vi = VV.Vi//new XYZ(2,0,0)
//         // //         crea.Vj = VV.Vj//new XYZ(0,2,0)
//         // //         crea.Vk = new XYZ(0, 0, fondamentalDomainSize / (nb - 1))
//         // //         crea.makeSquares = false
//         // //         crea.go()
//         // //         return mamesh3d
//         // //     }
//         // //
//         // //
//         // //     let stratified1=oneReseau()
//         // //     let stratified2=oneReseau()
//         // //
//         // //     let ma1=stratified1.toMamesh()
//         // //     let ma2=stratified2.toMamesh()
//         // //
//         // //     ma2.vertices.forEach(v=>{
//         // //         v.position.x+=fondamentalDomainSize
//         // //     })
//         // //
//         // //
//         // //
//         // //         let merger=new mameshModification.Merger(ma1,ma2)
//         // //         merger.mergeSegmentsMiddle=false
//         // //         merger.mergeTrianglesAndSquares=false
//         // //     merger.rebuildParamToVertex=true
//         // //     merger.cleanDoubleLinksKeepingInPriorityThoseWithOpposite=false//TODO
//         // //         merger.go()
//         // //
//         // //     let aa =new linkModule.OppositeLinkAssocierByAngles(ma1.vertices)
//         // //     aa.go()
//         // //
//         // //
//         // //     ma1.fillLineCatalogue()
//         // //
//         // //     //ma2.fillLineCatalogue()
//         // //     //oneMameshVisual(ma2)
//         // //
//         // //
//         // //
//         // //     // function oneMerge(mesh1,mesh2){
//         // //
//         // //     // }
//         // //     // oneMerge(directional1.iMamesh,directional2.iMamesh)
//         // //     // oneMerge(directional1.jMamesh,directional2.jMamesh)
//         // //     // oneMerge(directional1.kMamesh,directional2.kMamesh)
//         // //     //
//         // //     //
//         // //     //
//         // //     //
//         // //     //
//         // //     //
//         // //     // function oneMameshVisual(IN_mamesh:Mamesh):void{
//         // //     //     let link=new visu3d.LinesGameoMaker(IN_mamesh,scene)
//         // //     //     link.parentGameo=rootGameo
//         // //     //     link.lineOptionFunction=(i,line)=>{
//         // //     //         let res=new visu3d.LineGameoStatic.LineGameoOption()
//         // //     //         res.tesselation=4
//         // //     //         return res
//         // //     //     }
//         // //     //     link.go()
//         // //     // }
//         // //     //
//         // //     // oneMameshVisual(directional1.iMamesh)
//         // //     //
//         // //     //
//         // //     // //  mamesh3d.iMameshes[0].vertices.forEach(v=>v.isInvisible=true)
//         // //     // //  mamesh3d.jMameshes[0].vertices.forEach(v=>v.isInvisible=true)
//         // //     // //  mamesh3d.kMameshes[0].vertices.forEach(v=>v.isInvisible=true)
//         // //     // //
//         // //     // //
//         // //     // // mamesh3d.allMamesh().forEach(IN_mamesh=>{oneMameshVisual(IN_mamesh)})
//         // //     //
//         // //
//         // //
//         // //
//         // //
//         // //     rootGameo.draw()
//         // //
//         // //     //cc(rootGameo.getAllAbstractMeshes())
//         // //
//         // //     let arrete=fd.getArretes(scene)
//         // //
//         // //
//         // //      let mul=new periodicWorld.Multiply(fd,10)
//         // //      arrete.forEach(arr=>{mul.addAbstractMesh(arr)})
//         // //      //mul.addBabGameo(rootGameo)
//         // //
//         // //
//         // //     createSkybox(scene)
//         // //
//         // //
//         // //
//         // //
//         // //
//         // //     function createSkybox(scene:BABYLON.Scene) {
//         // //
//         // //         var skybox = BABYLON.Mesh.CreateBox("skyBox", 100.0, scene);
//         // //         skybox.checkCollisions=true;
//         // //         var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
//         // //         skyboxMaterial.backFaceCulling = false;
//         // //         skybox.material = skyboxMaterial;
//         // //         skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
//         // //         skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
//         // //         skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("../assets/skybox/skybox", scene,['_px.jpg', '_py.jpg', '_pz.jpg', '_nx.jpg', '_ny.jpg', '_nz.jpg']);
//         // //         skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
//         // //
//         // //
//         // //     }
//         // //
//         // //
//         // // }
//         //
//         //
//
//
//         export function testOneGrabber(mathisFrame:MathisFrame,colorBullet:BABYLON.Color3):void{
//
//
//             // let cube=BABYLON.Mesh.CreateBox('1',1/2,scene)
//             let red=new BABYLON.StandardMaterial('',mathisFrame.scene)
//             red.diffuseColor=colorBullet
//             // cube.material=red
//
//             let grabber0=new macamera.SphericalGrabber(mathisFrame.scene)
//             let macam = new macamera.GrabberCamera(mathisFrame,grabber0)
//             macam.useFreeModeWhenCursorOutOfGrabber=false
//             macam.changePosition(new XYZ(0,0,0))
//
//
//             for (let i=0;i<30;i++){
//                 let me=BABYLON.Mesh.CreateSphere('',10,maud/20,mathisFrame.scene)
//                 me.position=new XYZ(2*Math.random()-1,2*Math.random()-1,2*Math.random()-1).normalize().scale(maud)
//                 me.material=red
//
//             }
//
//
//             let mamesh=new Mamesh()
//             let crea=new creation3D.Polyhedron(mamesh,creation3D.PolyhedronStatic.Type.Cube)
//             crea.go()
//
//
//
//             let vertVisu=new visu3d.LinesVisuMaker(mamesh,mathisFrame.scene).go()
//
//
//
//
//
//             // let grabber1=new macamera.Grabber(macam)
//             // grabber1.center=new XYZ(2,0,0)
//             // grabber1.constantRadius=1
//             // grabber1.grabberIsVisible=true
//             // grabber1.name='red'
//             //
//             // let grabber2=new macamera.Grabber(macam)
//             // grabber2.center=new XYZ(-2,0,0)
//             // grabber2.constantRadius=1
//             // grabber2.grabberIsVisible=true
//             // grabber2.name='blue'
//
//
//             //macam.grabbers.push(grabber0,grabber1,grabber2)
//
//             macam.attachControl(mathisFrame.canvas)
//
//
//
//
//
//             // Ajout d'une lumire
//             var light0 = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(-1, 1, -1), mathisFrame.scene);
//             light0.diffuse = new BABYLON.Color3(1, 1, 1);
//             light0.specular = new BABYLON.Color3(1, 1, 1);
//             light0.groundColor = new BABYLON.Color3(0, 0, 0);
//
//
//
//
//
//
//
//
//         }
//
//
//
//
//
//
//
//
//
//
//
//         //
//         // function testMultGrabber(mathisFrame:MathisFrame):void{
//         //
//         //
//         //     let macam = new macamera.GrabberCamera(mathisFrame.scene)
//         //     macam.changePosition(new XYZ(0,0,-4))
//         //
//         //     let grabber0=new macamera.Grabber(macam)
//         //     grabber0.center=new XYZ(0,0,0)
//         //     grabber0.constantRadius=1
//         //     grabber0.grabberIsVisible=true
//         //     grabber0.name='green'
//         //
//         //     let grabber1=new macamera.Grabber(macam)
//         //     grabber1.center=new XYZ(2,0,0)
//         //     grabber1.constantRadius=1
//         //     grabber1.grabberIsVisible=true
//         //     grabber1.name='red'
//         //
//         //     let grabber2=new macamera.Grabber(macam)
//         //     grabber2.center=new XYZ(-2,0,0)
//         //     grabber2.constantRadius=1
//         //     grabber2.grabberIsVisible=true
//         //     grabber2.name='blue'
//         //
//         //
//         //     macam.grabbers.push(grabber0,grabber1,grabber2)
//         //
//         //     macam.attachControl(mathisFrame.canvas)
//         //
//         //
//         //
//         //
//         //
//         //     // Ajout d'une lumire
//         //     var light0 = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(-1, 1, -1), mathisFrame.scene);
//         //     light0.diffuse = new BABYLON.Color3(1, 1, 1);
//         //     light0.specular = new BABYLON.Color3(1, 1, 1);
//         //     light0.groundColor = new BABYLON.Color3(0, 0, 0);
//         //
//         //
//         //
//         //
//         //
//         //
//         //
//         //
//         // }
//
//
//
//     }
//
//
//
//
//
// } 
var mathis;
(function (mathis) {
    var testFront;
    (function (testFront) {
        // export function startSeveralFrame() {
        //
        //
        //     let mainDiv:HTMLElement = document.getElementById("mainDiv");
        //     let canvass = mathis.nCanvasInOneLine(2, mainDiv)
        //
        //     var secondFrame = new mathis.MathisFrame()
        //     secondFrame.canvas = canvass[0]
        //     secondFrame.goChanging()
        //     testOneGrabber(secondFrame, new BABYLON.Color3(1, 0, 0))
        //
        //
        //     var starter = new mathis.MathisFrame()
        //     starter.canvas = canvass[1]
        //     starter.goChanging()
        //     testOneGrabber(starter, new BABYLON.Color3(0, 0, 1))
        //
        //
        // }
        function start() {
            //let mainDiv:HTMLElement = document.getElementById("mainDiv");
            //let canvass = mathis.nCanvasInOneLine(1, mainDiv)
            var mathisFrame = new mathis.MathisFrame(null, false);
            mathisFrame.resetScene();
            mathisFrame.addDefaultCamera();
            mathisFrame.addDefaultLight();
            var box = BABYLON.Mesh.CreateBox('', 1, mathisFrame.scene);
            var mat = new BABYLON.StandardMaterial('', mathisFrame.scene);
            mat.diffuseColor = new BABYLON.Color3(1, 0, 0);
            box.material = mat;
            //testCamera(mathisFrame)
            //testdiffSys(mathisFrame)
            //testIsing(mathisFrame)
            //testInfiniteWorld(mathisFrame)
        }
        testFront.start = start;
        function testCamera(mathisFrame) {
            var light0 = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(-1, 1, -1), mathisFrame.scene);
            light0.diffuse = new BABYLON.Color3(1, 1, 1);
            light0.specular = new BABYLON.Color3(1, 1, 1);
            light0.groundColor = new BABYLON.Color3(0.5, 0.5, 0.5);
            var center = new mathis.XYZ(3, 0, 0);
            //BABYLON.Mesh.CreateSphere('',20,2,scene)
            var sphereRadius = 2;
            var grabber = new mathis.macamera.SphericalGrabber(mathisFrame.scene, new mathis.XYZ(sphereRadius, sphereRadius, sphereRadius), center);
            grabber.mesh.material.alpha = 0.6;
            grabber.showGrabberOnlyWhenGrabbing = false;
            grabber.endOfZone1 = 0;
            grabber.endOfZone2 = 0;
            var macam = new mathis.macamera.GrabberCamera(mathisFrame, grabber);
            macam.useFreeModeWhenCursorOutOfGrabber = false;
            macam.changePosition(new mathis.XYZ(-1, -1, -10), false);
            //macam.camera.viewport=new BABYLON.Viewport(index/nbCam,0,1/nbCam,1)
            macam.attachControl(mathisFrame.canvas);
            var box = BABYLON.Mesh.CreateBox('', 1, mathisFrame.scene);
            var mat = new BABYLON.StandardMaterial('', mathisFrame.scene);
            mat.diffuseColor = new BABYLON.Color3(1, 0, 0);
            box.material = mat;
        }
        function testdiffSys(mathisFrame) {
            /**param*/
            var width = 5;
            var height = 2;
            var origin = new mathis.XYZ(-width / 2, -height / 2, 0);
            function to01(xyz, res) {
                res.copyFrom(xyz);
                res.substract(origin);
                res.x /= width;
                res.y /= height;
            }
            function toWH(xyz, res) {
                res.copyFrom(xyz);
                res.x *= width;
                res.y *= height;
                res.add(origin);
            }
            /**vecter field priodique*/
            var vectorField0;
            {
                var scaled_4 = new mathis.XYZ(0, 0, 0);
                var A1_7 = function (t) { return 0.4 * Math.sin(0.5 * t); };
                var A2_7 = function (t) { return 0.2 * Math.sin(0.5 * t); };
                var a11_7 = function (t) { return 0; };
                var a12_7 = function (t) { return 0; };
                var a21_7 = function (t) { return 0; };
                var a22_7 = function (t) { return 0; };
                vectorField0 = function (t, p, res) {
                    to01(p, scaled_4);
                    /**potential part*/
                    var raX = (scaled_4.x - 0.5) * 2;
                    var raY = (scaled_4.y - 0.5) * 4;
                    res.x = -raX * raY * raY;
                    res.y = -raX * raX * raY;
                    /**excitation part*/
                    res.x += scaled_4.x * (A1_7(t) + a11_7(t) * scaled_4.x + a12_7(t) * scaled_4.y);
                    res.y += scaled_4.y * (A2_7(t) + a21_7(t) * scaled_4.x + a22_7(t) * scaled_4.y);
                };
            }
            var diffsyst = new mathis.differentialSystem.TwoDim(vectorField0, mathisFrame);
            //diffsyst.height=height
            //diffsyst.width=width
            diffsyst.go();
        }
        function testIsing(mathisFrame) {
            var ising = new mathis.mecaStat.IsingOnMesh(mathisFrame);
            ising.go();
        }
        function testInfiniteWorld(mathisFrame) {
            var infi = new mathis.infiniteWorlds.InfiniteCartesian(mathisFrame);
            infi.nbRepetition = 8;
            infi.nbSubdivision = 3;
            infi.fondamentalDomainSize = 6;
            infi.nbHorizontalDecays = 1;
            infi.nbVerticalDecays = 1;
            infi.nameOfResau3d = mathis.infiniteWorlds.NameOfReseau3D.cube;
            infi.collisionForCamera = true;
            infi.collisionOnLinks = true;
            infi.collisionOnVertices = true;
            var mesh = BABYLON.Mesh.CreateSphere('', 5, 10, mathisFrame.scene);
            //let mesh=BABYLON.Mesh.CreateBox('',1,mathisFrame.scene)
            mesh.position = new mathis.XYZ(1, 1, 1);
            //infi.population.push(mesh)
            infi.go();
            //infi.seeWorldFromOutside()
            infi.seeWorldFromInside();
            //
            //setTimeout(()=>{infi.seeWorldFromInside()},5000)
        }
    })(testFront = mathis.testFront || (mathis.testFront = {}));
})(mathis || (mathis = {}));
///**
// * Created by vigon on 30/11/2015.
// */
//
//
//
//module mathis {
//
//
//    export function basicTest():Bilan {
//        var bilan = new Bilan(0, 0)
//
//        var v=basic.newXYZ(123,543,42345.2345)
//        var w=basic.newXYZ(0,0,0)
//        basic.copyXYZ(v,w)
//        bilan.assertTrue( (basic.xyzEquality(v,w)) )
//
//        var v=basic.newXYZ(1234+basic.epsilon*0.1,1234,1234)
//        var w=basic.newXYZ(1234,1234,1234)
//        bilan.assertTrue( !basic.xyzEquality(v,w) )
//        bilan.assertTrue (basic.xyzAlmostEquality(v,w))
//
//
//        var qua=new XYZW(1,2,3,4)
//        var qua2=new XYZW(1,2,3,4+basic.epsilon*0.1)
//        bilan.assertTrue(qua.almostLogicalEqual(qua2))
//
//
//        bilan.assertTrue(basic.almostEquality(1,1.0000000001))
//
//
//        var idPerturbed=MM.newIdentity()
//        idPerturbed.m[0]=1+basic.epsilon/4
//        var identity=MM.newIdentity()
//        bilan.assertTrue(!basic.matEquality(idPerturbed,identity))
//        bilan.assertTrue(idPerturbed.almostEqual(identity))
//
//
//
//        var randomMatr=MM.newRandomMat()
//        var randomMatrCopy=MM.newZero().copyFrom(randomMatr)
//        bilan.assertTrue(randomMatr.equal(randomMatrCopy))
//        bilan.assertTrue(randomMatr.inverse().inverse().equal(randomMatr))
//        bilan.assertTrue(randomMatr.leftMultiply(identity).almostEqual(randomMatrCopy))
//        bilan.assertTrue(randomMatr.rightMultiply(idPerturbed).almostEqual(randomMatrCopy))
//
//
//
//        var diago= MM.newIdentity()
//        diago.m[0]=10
//        diago.m[5]=2
//        diago.m[15]=-2
//        var elemMat=MM.newIdentity()
//        elemMat.m[3]=1
//        var resultProduct=MM.newIdentity().copyFrom(diago)
//        resultProduct.m[3]=-2
//        bilan.assertTrue(MM.newZero().copyFrom(elemMat).rightMultiply(diago).almostEqual(resultProduct))
//
//        var inverseElemMat=MM.newIdentity()
//        inverseElemMat.m[3]=-1
//        bilan.assertTrue(MM.newFrom(elemMat).inverse().almostEqual(inverseElemMat))
//
//        var random=MM.newRandomMat()
//        bilan.assertTrue(MM.newFrom(random).inverse().leftMultiply(random).almostEqual(MM.newIdentity()))
//        bilan.assertTrue(MM.newFrom(random).inverse().rightMultiply(random).almostEqual(MM.newIdentity()))
//
//
//
//        bilan.assertTrue(basic.almostEquality(modulo(3.1234,1),0.1234))
//        bilan.assertTrue(basic.almostEquality(modulo(-3.99,1),0.01))
//        bilan.assertTrue(basic.almostEquality(modulo(12*Math.PI+4.1234,2*Math.PI),4.1234))
//        bilan.assertTrue(basic.almostEquality(modulo(20*Math.PI-4.1234,2*Math.PI),2*Math.PI-4.1234))
//
//
//
//
//        return bilan
//
//    }
//
//}
// /**
// * Created by vigon on 25/01/2016.
// */
//
//
// module mathis{
//    export module flat{
//
//
//
//        export enum StickingMode{simple,inverse,none}
//
//        export class Rectangle{
//            nbX=4
//            nbY=3
//
//            minX=0
//            maxX=1
//            minY=0
//            maxY=1
//
//            protected mamesh:Mamesh
//
//            makeLinks=false
//            addTriangleOrSquare=true
//
//            borderStickingVertical=StickingMode.none
//            borderStickingHorizontal=StickingMode.none
//
//            nbVerticalDecays=0
//            nbHorizontalDecays=0
//
//
//
//
//            holeParameters= new Array<XYZ>()
//
//            protected paramIsHole(param:XYZ):boolean{
//                for (let i in this.holeParameters) {
//                    let pa:XYZ=this.holeParameters[i]
//                    if (geo.xyzAlmostEquality(param,pa)) return true
//                }
//                return false
//
//
//            }
//
//            //
//            //public stickingFunction: (i:number,j:number,nbX:number,nbY:number)=>{i:number;j:number} =null
//
//
//            constructor( mamesh:Mamesh){
//                this.IN_mamesh=IN_mamesh
//            }
//
//            //
//            //private buildStickingFunction():(i:number,j:number,nbX:number,nbY:number)=>{i:number;j:number}{
//            //
//            //    let resFunction= (i,j,nbX,nbY)=>{
//            //        let iRes=null
//            //        let jRes=null
//            //
//            //        if (j>=0 && j<nbY && i>=0 && i<nbX  ){
//            //            iRes=i
//            //            jRes=j
//            //            return {i:iRes,j:jRes}
//            //        }
//            //
//            //        if (this.borderStickingVertical==StickingMode.simple){
//            //
//            //            if (i==-1){
//            //                iRes=nbX-1
//            //                jRes=modulo(j,nbY)
//            //            }
//            //
//            //
//            //        }
//            //
//            //
//            //
//            //
//            //
//            //
//            //
//            //        if (i==-1) iRes=nbX-1
//            //        else if (i==nbX) iRes=0
//            //        else if (i>=0 && i<nbX) iRes=i
//            //
//            //        if (j==-1) jRes=nbY-1
//            //        else if (j==nbY) jRes=0
//            //        else if (j>=0 && j<nbY) jRes=j
//            //
//            //        return {i:iRes,j:jRes}
//            //
//            //    }
//            //
//            //
//            //    return resFunction
//            //
//            //
//            //}
//            //
//            //
//            //private buildStickingFunction(verticalMode:StickingMode,horizontalMode:StickingMode):(i:number,j:number,nbX:number,nbY:number)=>{i:number;j:number}{
//            //
//            //    let resFunction=null
//            //
//            //
//            //    if (verticalMode==StickingMode.simple && horizontalMode==StickingMode.simple  ){
//            //
//            //        resFunction= (i,j,nbX,nbY)=>{
//            //            let iRes=null
//            //            let jRes=null
//            //
//            //            if (i==-1) iRes=nbX-1
//            //            else if (i==nbX) iRes=0
//            //            else if (i>=0 && i<nbX) iRes=i
//            //
//            //            if (j==-1) jRes=nbY-1
//            //            else if (j==nbY) jRes=0
//            //            else if (j>=0 && j<nbY) jRes=j
//            //
//            //            return {i:iRes,j:jRes}
//            //
//            //        }
//            //
//            //    }
//            //    else if (verticalMode==StickingMode.simple && horizontalMode==StickingMode.none  ){
//            //
//            //        resFunction= (i,j,nbX,nbY)=>{
//            //            let iRes=null
//            //            let jRes=null
//            //
//            //            if (j>=0 && j<nbY) jRes=j
//            //
//            //            if (i==-1) iRes=nbX-1
//            //            else if (i==nbX) iRes=0
//            //            else if (i>=0 && i<nbX) iRes=i
//            //
//            //            return {i:iRes,j:jRes}
//            //
//            //        }
//            //
//            //    }
//            //
//            //    else if (verticalMode==StickingMode.simple && horizontalMode==StickingMode.inverse  ){
//            //
//            //        resFunction= (i,j,nbX,nbY)=>{
//            //            let iRes=null
//            //            let jRes=null
//            //
//            //            if (j>=0 && j<nbY){
//            //
//            //                if (i==-1) iRes=nbX-1
//            //                else if (i==nbX) iRes=0
//            //                else if (i>=0 && i<nbX) iRes=i
//            //            }
//            //
//            //            else {
//            //
//            //                if (j==-1){
//            //                    jRes=nbY-1
//            //
//            //                    if (i<=-1) iRes=null
//            //                    else if (i>=nbX) iRes=null
//            //                    else iRes= nbX-1-i
//            //                }
//            //                else if (j==nbY){
//            //                    jRes=0
//            //                    if (i<=-1) iRes=null
//            //                    else if (i>=nbX) iRes=null
//            //                    else iRes= nbX-1-i
//            //                }
//            //
//            //            }
//            //
//            //
//            //            return {i:iRes,j:jRes}
//            //
//            //        }
//            //
//            //    }
//            //    else if (verticalMode==StickingMode.none && horizontalMode==StickingMode.inverse  ){
//            //
//            //        resFunction= (i,j,nbX,nbY)=>{
//            //            let iRes=null
//            //            let jRes=null
//            //
//            //            if (j>=0 && j<nbY && i>=0 && i<nbX  ){
//            //                    iRes=i
//            //                    jRes=j
//            //            }
//            //            else {
//            //
//            //                if (j==-1){
//            //                    jRes=nbY-1
//            //
//            //                    if (i<=-1) iRes=null
//            //                    else if (i>=nbX) iRes=null
//            //                    else iRes= nbX-1-i
//            //                }
//            //                else if (j==nbY){
//            //                    jRes=0
//            //                    if (i<=-1) iRes=null
//            //                    else if (i>=nbX) iRes=null
//            //                    else iRes= nbX-1-i
//            //                }
//            //
//            //            }
//            //
//            //
//            //            return {i:iRes,j:jRes}
//            //
//            //        }
//            //
//            //    }
//            //    else if (verticalMode==StickingMode.none && horizontalMode==StickingMode.none  ){
//            //        resFunction= (i,j,nbX,nbY)=> {
//            //            let iRes = null
//            //            let jRes = null
//            //
//            //            if (j >= 0 && j < nbY) {
//            //                if (i >= 0 && i < nbX) {
//            //                    iRes = i
//            //                    jRes = j
//            //                }
//            //            }
//            //            return {i:iRes,j:jRes}
//            //        }
//            //    }
//            //
//            //    //else if (verticalMode==StickingMode.decay && horizontalMode==StickingMode.none  ){
//            //    //    resFunction= (i,j,nbX,nbY)=> {
//            //    //        let iRes = null
//            //    //        let jRes = null
//            //    //
//            //    //        if (j >= 0 && j < nbY && i >= 0 && i < nbX) {
//            //    //                iRes = i
//            //    //                jRes = j
//            //    //
//            //    //        }
//            //    //        else if (i==-1){
//            //    //            if (j>=1 && j<nbY){
//            //    //                iRes=nbX-1
//            //    //                jRes=j-1
//            //    //            }
//            //    //        }
//            //    //        else if (i==nbX){
//            //    //            if (j>=0 && j<nbY-1){
//            //    //                iRes=0
//            //    //                jRes=j+1
//            //    //            }
//            //    //        }
//            //    //
//            //    //
//            //    //        return {i:iRes,j:jRes}
//            //    //    }
//            //    //}
//            //
//            //
//            //
//            //        return resFunction
//            //}
//
//
//            superGo(){
//
//
//                //let sticking=this.buildStickingFunction(this.borderStickingVertical,this.borderStickingHorizontal)
//                //
//                //if (sticking!=null) {
//                //    this.stickingFunction=sticking
//                //
//                //}
//                //else {
//                //
//                //
//                //    sticking=this.buildStickingFunction(this.borderStickingHorizontal,this.borderStickingVertical)
//                //
//                //    if (sticking!=null) this.stickingFunction= (i,j,nbX,nbY)=>{
//                //        let res=sticking(j,i,nbY,nbX)
//                //        return {i:res.j,j:res.i}
//                //    }
//                //    else throw 'this combinaison of border sticking mode is impossible'
//                //
//                //}
//
//
//
//
//
//
//
//                //if (this.borderStickingHorizontal==StickingMode.simple) this.horizontalStickingFunction= (i)=>(i)
//                //else if (this.borderStickingHorizontal==StickingMode.inverse) this.horizontalStickingFunction= (i)=>(this.nbX-i-1)
//                //
//                //
//                //if (this.borderStickingVertical==StickingMode.simple) this.verticalStickingFunction= (i)=>(i)
//                //else if (this.borderStickingVertical==StickingMode.inverse) this.verticalStickingFunction= (i)=>(this.nbY-i-1)
//
//            }
//
//            protected paramToVertex:{[id:string]:Vertex}={}
//
//
//
//
//            protected getVertex(i:number,j:number):Vertex{
//
//
//                //let iRes=i
//                //let jRes=j
//                //
//                //if (this.borderStickingVertical!=StickingMode.none  && i!=modulo(i,this.nbX) ){
//                //    jRes=this.verticalStickingFunction(j)
//                //    iRes=modulo(iRes,this.nbX)
//                //
//                //    cc('i,iRes',i,iRes)
//                //    cc('j,jRes',j,jRes)
//                //}
//                //
//                //
//                //if (this.borderStickingHorizontal!=StickingMode.none  && j!=modulo(j,this.nbY) ){
//                //    iRes=this.horizontalStickingFunction(i)
//                //    jRes=modulo(j,this.nbY)
//                //}
//
//
//                //let ijRes=this.stickingFunction(i,j,this.nbX,this.nbY)
//
//                let iRes=null
//                let jRes=null
//                if (this.borderStickingVertical!=StickingMode.inverse&& this.borderStickingHorizontal!=StickingMode.inverse){
//                    if (this.borderStickingVertical==StickingMode.none) iRes=i
//                    else if (this.borderStickingVertical==StickingMode.simple) iRes=modulo(i,this.nbX)
//
//                    if (this.borderStickingHorizontal==StickingMode.none) jRes=j
//                    else if (this.borderStickingHorizontal==StickingMode.simple) jRes=modulo(j,this.nbY)
//                }
//                else if (this.borderStickingVertical==StickingMode.inverse && this.borderStickingHorizontal==StickingMode.none){
//                    if (i<0 || i>=this.nbX){
//                        iRes=modulo(i,this.nbX)
//                        jRes=this.nbY -1 - j
//                    }
//                    else {
//                        iRes=i
//                        jRes=j
//                    }
//                }
//
//
//
//
//
//                return this.paramToVertex[iRes+','+jRes]
//
//            }
//
//
//
//        }
//
//
//        export class Quinconce extends Rectangle{
//
//
//            oneMoreVertexInOddLines=false
//            addTriangles=true
//
//            addMarkForHoneyComb=false
//
//
//            private isHoneyCombCenter(i:number,j:number){
//
//                if (j%2==0 && i%3==2) return true
//                if (j%2==1 && i%3==1) return true
//                return false
//
//            }
//
//
//
//            private checkArgs(){
//
//                if (this.oneMoreVertexInOddLines){
//                    if (this.borderStickingHorizontal!=StickingMode.none) mawarning(' the vertical sticking may be strange')
//                    if (this.borderStickingHorizontal!=StickingMode.none && this.nbY%2!=0) throw 'horizontal sticking impossible with these parameters'
//
//                }
//
//                //if (this.borderStickingHorizontal!=BorderSticking.none && this.nbY%2!=0 ) throw 'nbY must be even to make some horizontal sticking'
//                //if (this.borderStickingVertical!=BorderSticking.none && this.oneMoreVertexInOddLines) throw 'oneMoreVertexInOddLines and borderStickingVertical are incompatible'
//            }
//
//
//
//
//            goChanging(){
//
//                this.checkArgs()
//                this.superGo()
//
//                var cellId = 0;
//
//
//
//
//                //var max = Math.max(this.nbX+1, this.nbY);
//                //var ecart =1/(max-1)
//
//
//                let positionPerhapsModulo=(x:number)=>{
//                    if (this.borderStickingVertical==StickingMode.none) return x
//                    if (x<0) return this.maxX-this.minX+x
//                    else return x
//                }
//
//
//                let addX=(this.borderStickingVertical!=StickingMode.none)?1:0
//                let addY=(this.borderStickingHorizontal!=StickingMode.none)?1:0
//
//                let deltaX=(this.maxX-this.minX)/(this.nbX-1+addX)
//                let deltaY=(this.maxY-this.minY)/(this.nbY-1+addY)
//
//                for (var j = 0; j < this.nbY; j++) {
//
//                    var  oneMore=(this.oneMoreVertexInOddLines) ?  j%2  :0
//                    for (var i = 0; i < this.nbX+oneMore; i++) {
//
//                        let param=new XYZ(i,j,0)
//
//
//                            if (this.holeParameters == null || !this.paramIsHole(param)) {
//
//
//                                let leftDecayForOddLines = ( j % 2 == 1) ? 0.5 * deltaX : 0;
//
//                                let currentVertDecay= (this.nbVerticalDecays==0)? 0 : i*deltaX/(this.maxX-this.minX)*this.nbVerticalDecays*deltaY
//
//
//                                let vertex = this.mamesh.newVertex()
//                                vertex.param = param
//                                vertex.position = geo.newXYZ(
//                                    i * deltaX - leftDecayForOddLines + this.minX,
//                                    (j * deltaY + this.minY)+currentVertDecay,
//                                    0)
//                                this.paramToVertex[i + ',' + j] = vertex
//
//
//                                cellId++;
//
//
//                                if (!this.addMarkForHoneyComb || ! this.isHoneyCombCenter(i,j) ) vertex.markers.push(Vertex.Markers.honeyComb)
//
//
//
//                                }
//
//
//                    }
//                }
//
//                if (this.makeLinks) this.linksCreationForSquare()
//
//
//            }
//
//
//            private linksCreation(){
//
//
//
//
//                this.mamesh.vertices.forEach((cell:Vertex)=> {
//
//                    {
//                        let c:Vertex = this.getVertex(cell.param.x + 1, cell.param.y);
//                        let cc:Vertex = this.getVertex(cell.param.x - 1, cell.param.y);
//
//                        if (c != null && cc != null) cell.setVoisinCoupleKeepingExistingAtBest(c, cc)
//                        else if (c == null && cc != null) cell.setOneLink(cc,true)
//                        else if (c != null && cc == null) cell.setOneLink(c,true)
//                    }
//
//                    /**even lines */
//                    if (cell.param.y%2==0){
//                        // sud est - nord ouest
//                        let c:Vertex = this.getVertex(cell.param.x + 1, cell.param.y + 1);
//                        let cc:Vertex = this.getVertex(cell.param.x, cell.param.y - 1);
//
//                        if (c != null && cc != null) cell.setVoisinCoupleKeepingExistingAtBest(c, cc)
//                        else if (c == null && cc != null) cell.setOneLink(cc,true)
//                        else if (c != null && cc == null) cell.setOneLink(c,true)
//
//
//                        // sud ouest - nord est
//                        c = this.getVertex(cell.param.x, cell.param.y + 1);
//                        cc = this.getVertex(cell.param.x + 1, cell.param.y - 1);
//
//                        if (c != null && cc != null) cell.setVoisinCoupleKeepingExistingAtBest(c, cc)
//                        else if (c == null && cc != null) cell.setOneLink(cc,true)
//                        else if (c != null && cc == null) cell.setOneLink(c,true)
//
//
//                    }
//                    /**odd lines */
//                    else {
//                        //sud est - nord ouest
//                        let c:Vertex = this.getVertex(cell.param.x, cell.param.y + 1);
//                        let cc:Vertex = this.getVertex(cell.param.x - 1, cell.param.y - 1);
//                        if (c != null && cc != null) cell.setVoisinCoupleKeepingExistingAtBest(c, cc)
//                        else if (c == null && cc != null) cell.setOneLink(cc,true)
//                        else if (c != null && cc == null) cell.setOneLink(c,true)
//
//                        //sud ouest - nord est
//                        c = this.getVertex(cell.param.x - 1, cell.param.y + 1);
//                        cc = this.getVertex(cell.param.x, cell.param.y - 1);
//                        if (c != null && cc != null) cell.setVoisinCoupleKeepingExistingAtBest(c, cc)
//                        else if (c == null && cc != null) cell.setOneLink(cc,true)
//                        else if (c != null && cc == null) cell.setOneLink(c,true)
//
//                    }
//
//
//
//                });
//
//
//                if (this.addTriangles) this.triangleCreation()
//
//
//
//            }
//
//
//            private triangleCreation(){
//
//                for (let vertex of this.mamesh.vertices){
//
//                    let i=vertex.param.x
//                    let j=vertex.param.y
//
//
//
//                    let v1=this.getVertex(i,j)
//                    if (v1==null)  continue
//
//                    let v2=this.getVertex(i+1,j+1)
//                    if (v2=null)  continue
//
//
//                    let v3=this.getVertex(i,j+1)
//                    if (v3!=null)this.mamesh.addATriangle(v1,v2,v3)
//
//
//                    let v4=this.getVertex(i+1,j)
//                    if (v4!=null)this.mamesh.addATriangle(v1,v4,v2)
//
//
//
//                }
//
//
//            }
//
//
//
//        }
//
//
//        export class Cartesian extends Rectangle{
//
//            cornersAreSharp=true
//            acceptDuplicateOppositeLinks=true
//
//            private checkArgs(){
//
//
//
//                if (this.nbX<2) throw 'this.nbX must be >=2'
//                if (this.nbY<2) throw 'this.nbY must be >=2'
//                if (this.maxX<=this.minX) throw 'we must have minX<maxX'
//                if (this.maxY<=this.minY) throw 'we must have minY<maxY'
//                if (!this.addTriangleOrSquare && !this.makeLinks) mawarning('few interest if you do not add neither square nor links')
//
//                if (!this.cornersAreSharp){
//                    if (this.borderStickingHorizontal!=StickingMode.none || this.borderStickingVertical!=StickingMode.none) mawarning(' the sticking we delete the links in the corners')
//                }
//
//                if (this.borderStickingVertical!=StickingMode.none && this.nbX==2) throw 'nbX too small for sticking'
//                if (this.borderStickingHorizontal!=StickingMode.none && this.nbY==2) throw 'nbY too small for sticking'
//
//
//            }
//
//
//            //private computeDecayVerctor(a,A,b,B):XYZ{
//            //
//            //    if (a==0) return new XYZ(0,b,0)
//            //    let denominator=(A*B-a*b)
//            //    return new XYZ(a*A*B/denominator,a*b*B/denominator,0)
//            //}
//
//
//
//            private computeDecayVector(a,A,b,B,dV,dH):XYZ{
//                let res=new XYZ(0,0,0)
//                res.x= a*A*B/( A*B - a*b*dH *dV )
//                res.y=b*dV/A*res.x
//                return res
//            }
//
//            goChanging():void{
//
//
//                this.checkArgs()
//                this.superGo()
//
//
//                let addX=(this.borderStickingVertical!=StickingMode.none)?1:0
//                let addY=(this.borderStickingHorizontal!=StickingMode.none)?1:0
//
//                let deltaX=(this.maxX-this.minX)/(this.nbX-1+addX)
//                let deltaY=(this.maxY-this.minY)/(this.nbY-1+addY)
//
//
//                let A=(this.maxX-this.minX)
//                let B=(this.maxY-this.minY)
//
//                let VX=this.computeDecayVector(deltaX,A,deltaY,B,this.nbVerticalDecays,this.nbHorizontalDecays)
//                let preVY=this.computeDecayVector(deltaY,B,deltaX,A,this.nbHorizontalDecays,this.nbVerticalDecays)
//                let VY=new XYZ(preVY.y,preVY.x,0)
//
//
//                let vertexId=0
//                for (let i=0;i<this.nbX;i++){
//                    for (let j=0;j<this.nbY;j++){
//                        let param = new XYZ(i, j, 0)
//                        if (this.holeParameters==null ||  !this.paramIsHole(param)) {
//
//                            //let currentVertDecay= (this.nbVerticalDecays==0)? 0 : i*deltaX/(this.maxX-this.minX)*this.nbVerticalDecays*deltaY
//                            //let currentHorDecay= (this.nbHorizontalDecays==0)? 0 : j*deltaY/(this.maxY-this.minY)*this.nbHorizontalDecays*deltaX
//
//                            let vertex = this.IN_mamesh.newVertex() // graphManip.addNewVertex(this.IN_mamesh.vertices, j * this.nbX + i)
//                            vertex.position =  XYZ.newFrom(VX).scale(i)
//                            let ortherDirection=XYZ.newFrom(VY).scale(j)
//                            vertex.position.add(ortherDirection)
//
//                            vertex.param=param
//                            this.paramToVertex[i + ',' + j] = vertex
//                            vertexId++
//
//                        }
//                    }
//                }
//
//
//
//                //
//                //if (this.makeLinks){
//                //    for (let i=0;i<this.nbX;i++) {
//                //        for (let j = 0; j < this.nbY; j++) {
//                //
//                //            if (i>0 && i<this.nbX-1){
//                //                this.IN_mamesh.vertices[(i)+(j)*this.nbX].setTwoOppositeLinks(this.IN_mamesh.vertices[(i-1)+(j)*this.nbX],this.IN_mamesh.vertices[(i+1)+(j)*this.nbX])
//                //            }
//                //            else if (i==0) this.IN_mamesh.vertices[(i)+(j)*this.nbX].setOneLink(this.IN_mamesh.vertices[(i+1)+(j)*this.nbX])
//                //            else if (i==this.nbX-1) this.IN_mamesh.vertices[(i)+(j)*this.nbX].setOneLink(this.IN_mamesh.vertices[(i-1)+(j)*this.nbX])
//                //
//                //
//                //            if (j>0 && j<this.nbY-1){
//                //                this.IN_mamesh.vertices[(i)+(j)*this.nbX].setTwoOppositeLinks(this.IN_mamesh.vertices[(i)+(j-1)*this.nbX],this.IN_mamesh.vertices[(i)+(j+1)*this.nbX])
//                //            }
//                //            else if (j==0) this.IN_mamesh.vertices[(i)+(j)*this.nbX].setOneLink(this.IN_mamesh.vertices[(i)+(j+1)*this.nbX])
//                //            else if (j==this.nbY-1) this.IN_mamesh.vertices[(i)+(j)*this.nbX].setOneLink(this.IN_mamesh.vertices[(i)+(j-1)*this.nbX])
//                //        }
//                //    }
//                //
//                //    if (!this.cornersAreSharp){
//                //        this.IN_mamesh.vertices[0].setTwoOppositeLinks(this.IN_mamesh.vertices[1],this.IN_mamesh.vertices[this.nbX],true)
//                //
//                //        this.getVertex(this.nbX-1,0).setTwoOppositeLinks(this.getVertex(this.nbX-1,1),this.getVertex(this.nbX-2,0),true)
//                //
//                //        this.getVertex(0,this.nbY-1).setTwoOppositeLinks(this.getVertex(0,this.nbY-2),this.getVertex(1,this.nbY-1),true)
//                //        this.getVertex(this.nbX-1,this.nbY-1).setTwoOppositeLinks(this.getVertex(this.nbX-1,this.nbY-2),this.getVertex(this.nbX-2,this.nbY-1),true)
//                //
//                //    }
//                //
//                //    if (this.borderStickingVertical!=BorderSticking.none){
//                //        let stickFunction
//                //        if(this.borderStickingVertical==BorderSticking.simple) stickFunction= (i:number)=>{return i}
//                //        else if(this.borderStickingVertical==BorderSticking.inverted) stickFunction= (i:number)=>{return this.nbY-1-i}
//                //
//                //        for (let j = 0; j < this.nbY; j++) {
//                //            this.getVertex(this.nbX - 1, j).setTwoOppositeLinks(this.getVertex(this.nbX - 2, j), this.getVertex(0, stickFunction(j)), true)
//                //            this.getVertex(0, j).setTwoOppositeLinks(this.getVertex(1, j), this.getVertex(this.nbX - 1, stickFunction(j)), true)
//                //        }
//                //    }
//                //
//                //    if (this.borderStickingHorizontal!=BorderSticking.none){
//                //        let stickFunction
//                //        if(this.borderStickingHorizontal==BorderSticking.simple) stickFunction= (i:number)=>{return i}
//                //        else if(this.borderStickingHorizontal==BorderSticking.inverted) stickFunction= (i:number)=>{return this.nbX-1-i}
//                //
//                //        for (let i = 0; i < this.nbX; i++) {
//                //            this.getVertex(i,this.nbY - 1).setTwoOppositeLinks(this.getVertex(i,this.nbY - 2), this.getVertex(stickFunction(i),0), true)
//                //            this.getVertex(i,0).setTwoOppositeLinks(this.getVertex(i,1), this.getVertex(stickFunction(i),this.nbY - 1), true)
//                //        }
//                //    }
//                //
//                //
//                //
//                //}
//
//
//                if (this.cornersAreSharp){
//                    let vertex:Vertex
//                    vertex=this.getVertex(0,0)
//                    if (vertex!=null)  vertex.isSharpAngle=true
//                    vertex=this.getVertex(this.nbX-1,this.nbY-1)
//                    if (vertex!=null)  vertex.isSharpAngle=true
//                    vertex=this.getVertex(0,this.nbY-1)
//                    if (vertex!=null)  vertex.isSharpAngle=true
//                    vertex=this.getVertex(this.nbX-1,0)
//                    if (vertex!=null)  vertex.isSharpAngle=true
//                }
//
//
//
//                if (this.makeLinks) this.linksCreation()
//
//                if (this.addSquare) this.squareCreation()
//
//
//
//
//                //if (this.addSquare){
//                //
//                //    for (let i=0;i<this.nbX-1;i++) {
//                //        for (let j = 0; j < this.nbY-1; j++) {
//                //            this.mamesh.addASquare((i)+(j)*this.nbX,(i+1)+(j)*this.nbX,(i+1)+(j+1)*this.nbX,(i)+(j+1)*this.nbX)
//                //        }
//                //    }
//                //
//                //    if (this.borderStickingVertical!=BorderSticking.none){
//                //        let stickFunction
//                //        if(this.borderStickingVertical==BorderSticking.simple) stickFunction= (i:number)=>{return i}
//                //        else if(this.borderStickingVertical==BorderSticking.inverted) stickFunction= (i:number)=>{return this.nbY-1-i}
//                //
//                //        for (let j = 0; j < this.nbY-1; j++) {
//                //           this.mamesh.addASquare(this.getId(this.nbX - 1, j),this.getId(0, stickFunction(j)),this.getId(0, stickFunction(j+1)), this.getId(this.nbX-1,j+1)   )
//                //        }
//                //
//                //    }
//                //    if (this.borderStickingHorizontal!=BorderSticking.none){
//                //        let stickFunction
//                //        if(this.borderStickingHorizontal==BorderSticking.simple) stickFunction= (i:number)=>{return i}
//                //        else if(this.borderStickingHorizontal==BorderSticking.inverted) stickFunction= (i:number)=>{return this.nbY-1-i}
//                //
//                //        for (let i = 0; i < this.nbX-1; i++) {
//                //            this.mamesh.addASquare(this.getId(i+1,this.nbY-1),this.getId( stickFunction(i+1),0), this.getId( stickFunction(i),0), this.getId(i,this.nbY - 1))
//                //        }
//                //
//                //    }
//                //
//                //
//                //
//                //
//                //}
//
//
//            }
//
//            private linksCreation(){
//
//
//                //var checkExistingLinks=(this.borderStickingHorizontal!=StickingMode.none) || (this.borderStickingVertical!=StickingMode.none)
//
//
//                this.mamesh.vertices.forEach((cell:Vertex)=> {
//
//                    {
//                        let decayWhenCrossingBorderRightward=0
//                        let decayWhenCrossingBorderLeftward=0
//                        if (cell.param.x==0) decayWhenCrossingBorderLeftward=(this.borderStickingVertical==StickingMode.inverse)?this.nbVerticalDecays :  -this.nbVerticalDecays
//                        if (cell.param.x==this.nbX-1) decayWhenCrossingBorderRightward=+this.nbVerticalDecays
//
//
//
//                        let c:Vertex = this.getVertex(cell.param.x + 1, cell.param.y+decayWhenCrossingBorderRightward);
//                        let cc:Vertex = this.getVertex(cell.param.x - 1, cell.param.y+decayWhenCrossingBorderLeftward);
//
//                        if (c != null && cc != null) {
//                            if (this.acceptDuplicateOppositeLinks) cell.setTwoOppositeLinks(c,cc,false)
//                            else cell.setVoisinCoupleKeepingExistingAtBest(c, cc)
//                        }
//                        else if (c == null && cc != null) cell.setOneLink(cc,true)
//                        else if (c != null && cc == null) cell.setOneLink(c,true)
//
//                    }
//
//
//                    {
//
//                        let decayWhenCrossingUpward=0
//                        let decayWhenCrossingDownWard=0
//                        if (cell.param.y==0) decayWhenCrossingDownWard=(this.borderStickingHorizontal==StickingMode.inverse)?this.nbHorizontalDecays :  -this.nbHorizontalDecays
//                        if (cell.param.y==this.nbY-1) decayWhenCrossingUpward=+this.nbHorizontalDecays
//
//
//                        let c:Vertex = this.getVertex(cell.param.x +decayWhenCrossingUpward , cell.param.y+1);
//                        let cc:Vertex = this.getVertex(cell.param.x +decayWhenCrossingDownWard , cell.param.y-1);
//
//                        if (c != null && cc != null) {
//                            if (this.acceptDuplicateOppositeLinks) cell.setTwoOppositeLinks(c,cc,false)
//                            else cell.setVoisinCoupleKeepingExistingAtBest(c, cc)
//                        }                        else if (c == null && cc != null) cell.setOneLink(cc,true)
//                        else if (c != null && cc == null) cell.setOneLink(c,true)
//
//                    }
//
//
//
//                });
//
//
//            }
//
//
//
//            private squareCreation(){
//
//                for (let vertex of this.mamesh.vertices){
//
//
//
//
//                    let i=vertex.param.x
//                    let j=vertex.param.y
//
//                    let rightDecayWhenCrossing=0
//                    if (i==this.nbX-1) rightDecayWhenCrossing=+this.nbVerticalDecays
//
//                    let upDecayWhenCrossing=0
//                    if (j==this.nbY-1) upDecayWhenCrossing=+this.nbHorizontalDecays
//
//
//
//
//
//                    let v1=this.getVertex(i,j)
//                    if (v1=null)  continue;
//
//                    let v2=this.getVertex(i+1,j+rightDecayWhenCrossing)
//                    if (v2==null) continue;
//
//                    let v3=this.getVertex(i+1+upDecayWhenCrossing,j+1+ rightDecayWhenCrossing)
//                    if (v3==null) continue;
//
//                    let v4=this.getVertex(i+upDecayWhenCrossing,j+1)
//                    if (v4==null)  continue;
//
//                    this.mamesh.addASquare(v1,v2,v3,v4)
//
//                }
//
//
//
//                //
//                //if (this.addTrianglesToClose) {
//                //
//                //    if (this.nbVerticalDecays==1 && this.nbHorizontalDecays ==1) {
//                //
//                //        let v:Vertex
//                //        let i1, i2, i3:number
//                //        v = this.getVertex(0, this.nbY - 1)
//                //        i1 = v.id
//                //
//                //        v = this.getVertex(this.nbHorizontalDecays, 0)
//                //        i2 = v.id
//                //
//                //        v = this.getVertex(0, 0)
//                //        i3 = v.id
//                //
//                //        this.mamesh.addATriangle(i1, i2, i3)
//                //
//                //
//                //        v = this.getVertex(this.nbX - 1, 0)
//                //        i1 = v.id
//                //
//                //        v = this.getVertex(0, 0)
//                //        i2 = v.id
//                //
//                //        v = this.getVertex(0, this.nbVerticalDecays)
//                //        i3 = v.id
//                //
//                //        this.mamesh.addATriangle(i1, i2, i3)
//                //
//                //
//                //    }
//                //    else throw 'adding triangle to close is not yet operationnal for such parameters'
//                //}
//                //
//
//
//
//
//
//
//
//            }
//
//
//
//
//        }
//
//
//
//        export class SingleSquare{
//            makeLinks=true
//            sharpAngles=true
//
//            goChanging():Mamesh{
//                let mesh=new Mamesh()
//
//                let vert0=mesh.newVertex()
//                vert0.position=geo.newXYZ(0,0,0)
//                vert0.dichoLevel=0
//
//                let vert1=mesh.newVertex()
//                vert1.position=geo.newXYZ(1,0,0)
//                vert1.dichoLevel=0
//
//                let vert2=mesh.newVertex()
//                vert2.position=geo.newXYZ(1,1,0)
//                vert2.dichoLevel=0
//
//                let vert3=mesh.newVertex()
//                vert3.position=geo.newXYZ(0,1,0)
//                vert3.dichoLevel=0
//
//
//                //let triangulatedRect=new Polygone([vert1,vert2,vert3])
//                //mesh.polygones.push(triangle)
//
//                mesh.addASquare(vert0,vert1,vert2,vert3)
//
//                if (this.sharpAngles){
//                    vert0.isSharpAngle=true
//                    vert1.isSharpAngle=true
//                    vert2.isSharpAngle=true
//                    vert3.isSharpAngle=true
//
//                }
//
//                if (this.makeLinks) {
//                    if (this.sharpAngles) {
//                        vert0.setOneLink(vert1, false)
//                        vert1.setOneLink(vert2, false)
//                        vert2.setOneLink(vert3, false)
//                        vert3.setOneLink(vert0, false)
//
//                        vert0.setOneLink(vert3, false)
//                        vert3.setOneLink(vert2, false)
//                        vert2.setOneLink(vert1, false)
//                        vert1.setOneLink(vert0, false)
//                    }
//                    else{
//                        vert0.setTwoOppositeLinks(vert1,vert3)
//                        vert1.setTwoOppositeLinks(vert2,vert0)
//                        vert2.setTwoOppositeLinks(vert3,vert1)
//                        vert3.setTwoOppositeLinks(vert0,vert2)
//
//                    }
//                    mesh.linksOK = true
//                }
//                else mesh.linksOK=false
//
//
//                return mesh
//            }
//
//        }
//
//
//        export class SingleTriangle {
//            makeLinks = true
//            sharpAngles = true
//
//            goChanging():Mamesh {
//                let mesh=new Mamesh()
//
//                let vert0=mesh.newVertex()
//                vert0.position=geo.newXYZ(0,0,0)
//                vert0.dichoLevel=0
//
//
//                let vert1=mesh.newVertex()
//                vert1.position=geo.newXYZ(0,1,0)
//                vert1.dichoLevel=0
//
//                let vert2=mesh.newVertex()
//                vert2.position=geo.newXYZ(1,0,0)
//                vert2.dichoLevel=0
//
//
//                //let triangulatedRect=new Polygone([vert1,vert2,vert3])
//                //mesh.polygones.push(triangle)
//
//                mesh.addATriangle(vert0,vert1,vert2)
//
//
//                if (this.sharpAngles) {
//                    vert0.isSharpAngle=true
//                    vert1.isSharpAngle=true
//                    vert2.isSharpAngle=true
//                }
//
//                if (this.makeLinks) {
//                    if (this.sharpAngles) {
//                        vert0.setOneLink(vert1, false)
//                        vert0.setOneLink(vert2, false)
//                        vert1.setOneLink(vert0, false)
//                        vert1.setOneLink(vert2, false)
//                        vert2.setOneLink(vert0, false)
//                        vert2.setOneLink(vert1, false)
//                    }
//                    else{
//                        vert0.setTwoOppositeLinks(vert1,vert2,false)
//                        vert1.setTwoOppositeLinks(vert2,vert0,false)
//                        vert2.setTwoOppositeLinks(vert0,vert1,false)
//                    }
//
//                    mesh.linksOK = true
//                }
//                else mesh.linksOK=false
//
//
//                return mesh
//            }
//        }
//
//
//
//        export class SingleSquareWithOneDiag {
//            makeLinks = true
//            sharpAngles = true
//
//            goChanging():Mamesh {
//                let mesh=new Mamesh()
//
//                let vert0=mesh.newVertex()
//                vert0.position=geo.newXYZ(0,0,0)
//                vert0.dichoLevel=0
//
//                let vert1=mesh.newVertex()
//                vert1.position=geo.newXYZ(1,0,0)
//                vert1.dichoLevel=0
//
//                let vert2=mesh.newVertex()
//                vert2.position=geo.newXYZ(1,1,0)
//                vert2.dichoLevel=0
//
//                let vert3=mesh.newVertex()
//                vert3.position=geo.newXYZ(0,1,0)
//                vert3.dichoLevel=0
//
//
//                //let triangle=new Polygone([vert1,vert2,vert3])
//                //mesh.polygones.push(triangle)
//
//                mesh.addATriangle(vert0,vert1,vert3)
//                mesh.addATriangle(vert1,vert2,vert3)
//
//                if (this.sharpAngles){
//                    vert0.isSharpAngle=true
//                    vert1.isSharpAngle=true
//                    vert2.isSharpAngle=true
//                    vert3.isSharpAngle=true
//                }
//
//                if (this.makeLinks) {
//
//                    vert1.setOneLink(vert3)
//                    vert3.setOneLink(vert1)
//
//
//                    if (this.sharpAngles){
//                        vert0.setOneLink(vert1)
//                        vert0.setOneLink(vert3)
//
//                        vert1.setOneLink(vert0)
//                        vert1.setOneLink(vert2)
//
//                        vert2.setOneLink(vert1)
//                        vert2.setOneLink(vert3)
//
//                        vert3.setOneLink(vert0)
//                        vert3.setOneLink(vert2)
//                    }
//                    else{
//                        vert0.setTwoOppositeLinks(vert1,vert3)
//                        vert1.setTwoOppositeLinks(vert2,vert0)
//                        vert2.setTwoOppositeLinks(vert3,vert1)
//                        vert3.setTwoOppositeLinks(vert0,vert2)
//                    }
//
//                    mesh.linksOK = true
//                }
//                else mesh.linksOK=false
//
//                return mesh
//            }
//        }
//
//
//        export class SingleSquareWithTwoDiag {
//            makeLinks = true
//            sharpAngles = true
//
//            goChanging():Mamesh {
//                let mesh=new Mamesh()
//
//                let vert0=mesh.newVertex()
//                vert0.position=geo.newXYZ(0,0,0)
//                vert0.dichoLevel=0
//
//
//                let vert1=mesh.newVertex()
//                vert1.position=geo.newXYZ(1,0,0)
//                vert1.dichoLevel=0
//
//                let vert2=mesh.newVertex()
//                vert2.position=geo.newXYZ(1,1,0)
//                vert2.dichoLevel=0
//
//                let vert3=mesh.newVertex()
//                vert3.position=geo.newXYZ(0,1,0)
//                vert3.dichoLevel=0
//
//                let vert4=mesh.newVertex()
//                vert4.position=geo.newXYZ(0.5,0.5,0)
//                vert4.dichoLevel=0
//
//
//                //let triangulatedRect=new Polygone([vert1,vert2,vert3])
//                //mesh.polygones.push(triangle)
//
//                mesh.addATriangle(vert0,vert1,vert4)
//                mesh.addATriangle(vert1,vert2,vert4)
//                mesh.addATriangle(vert2,vert3,vert4)
//                mesh.addATriangle(vert4,vert3,vert0)
//
//                if (this.sharpAngles){
//                    vert0.isSharpAngle=true
//                    vert1.isSharpAngle=true
//                    vert2.isSharpAngle=true
//                    vert3.isSharpAngle=true
//
//                }
//
//                if (this.makeLinks) {
//
//                    vert0.setOneLink(vert4)
//                    vert1.setOneLink(vert4)
//                    vert2.setOneLink(vert4)
//                    vert3.setOneLink(vert4)
//                    vert4.setTwoOppositeLinks(vert0, vert2)
//                    vert4.setTwoOppositeLinks(vert1, vert3)
//
//                    if (this.sharpAngles) {
//                        vert0.setOneLink(vert1)
//                        vert0.setOneLink(vert3)
//
//                        vert1.setOneLink(vert0)
//                        vert1.setOneLink(vert2)
//
//
//                        vert2.setOneLink(vert1)
//                        vert2.setOneLink(vert3)
//
//
//                        vert3.setOneLink(vert0)
//                        vert3.setOneLink(vert2)
//                    }
//                    else {
//                        vert0.setTwoOppositeLinks(vert1,vert3)
//                        vert1.setTwoOppositeLinks(vert2,vert0)
//                        vert2.setTwoOppositeLinks(vert3,vert1)
//                        vert3.setTwoOppositeLinks(vert0,vert2)
//                    }
//
//                    mesh.linksOK = true
//                }
//                else mesh.linksOK=false
//
//                return mesh
//            }
//        }
//
//
//        export class RegularPolygone{
//            aLoopLineAround=false
//            nbSides:number
//
//            constructor(nbSides){this.nbSides=nbSides}
//
//            goChanging():Mamesh {
//
//
//                let mesh=new Mamesh()
//                mesh.linksOK=true
//
//                let a = 1 / 2;
//                if (this.nbSides >= 4) {
//
//                    let vert0=mesh.newVertex()
//                    vert0.position=geo.newXYZ(1 / 2, 1 / 2, 0)
//                    vert0.dichoLevel=0
//                    for (let i = 0; i < this.nbSides; i++) {
//                        let verti=mesh.newVertex()
//                        verti.dichoLevel=0
//                        verti.position=geo.newXYZ(1 / 2 + Math.cos(2 * Math.PI * i / this.nbSides - Math.PI / 2) * a, 1 / 2 + Math.sin(2 * Math.PI * i / this.nbSides - Math.PI / 2) * a, 0)
//                    }
//
//                    for (let i = 1; i < this.nbSides + 1; i++) {
//                        //let triangulatedRect=new Polygone([resultMesh.vertices[0],resultMesh.vertices[i],resultMesh.vertices[i % this.nbSides + 1]])
//                        //resultMesh.polygones.push(triangle)
//                        mesh.addATriangle(mesh.vertices[0],mesh.vertices[i],mesh.vertices[i % this.nbSides + 1])
//
//                    }
//
//                    if (this.nbSides%2==0){
//                        for (let i=1;i<=this.nbSides/2;i++){
//                            vert0.setTwoOppositeLinks(mesh.vertices[i],mesh.vertices[i+this.nbSides/2])
//                        }
//                    }
//                    else{
//                        for (let i=1;i<=this.nbSides;i++) vert0.setOneLink(mesh.vertices[i])
//                    }
//
//                    for (let i=1;i<=this.nbSides;i++){
//                        let verti=mesh.vertices[i]
//                        let vertNext=(i==this.nbSides)? mesh.vertices[1]:mesh.vertices[i+1]
//                        let vertPrev=(i==1)? mesh.vertices[this.nbSides]:mesh.vertices[i-1]
//
//                        verti.setOneLink(vert0)
//                        if (this.aLoopLineAround) verti.setTwoOppositeLinks(vertPrev,vertNext)
//                        else{
//                            verti.setOneLink(vertNext)
//                            verti.setOneLink(vertPrev)
//                        }
//                    }
//
//                }
//                else if (this.nbSides == 3) {
//                    for (let i = 0; i < this.nbSides; i++) {
//                        let verti=mesh.newVertex()
//                        verti.dichoLevel=0
//                        verti.position=geo.newXYZ(1 / 2 + Math.cos(2 * Math.PI * i / this.nbSides - Math.PI / 2) * a, 1 / 2 + Math.sin(2 * Math.PI * i / this.nbSides - Math.PI / 2) * a, 0);
//                        verti.dichoLevel=0
//                    }
//                    mesh.addATriangle(mesh.vertices[0],mesh.vertices[1],mesh.vertices[2])
//                    let vert0=mesh.vertices[0]
//                    let vert1=mesh.vertices[1]
//                    let vert2=mesh.vertices[2]
//
//                    if (this.aLoopLineAround){
//                        vert0.setTwoOppositeLinks(vert1,vert2)
//                        vert1.setTwoOppositeLinks(vert2,vert0)
//                        vert2.setTwoOppositeLinks(vert0,vert1)
//                    }
//                    else{
//                        vert0.setOneLink(vert1)
//                        vert0.setOneLink(vert2)
//
//                        vert1.setOneLink(vert2)
//                        vert1.setOneLink(vert0)
//
//                        vert2.setOneLink(vert0)
//                        vert2.setOneLink(vert1)
//
//                    }
//
//
//
//                    //let triangulatedRect=new Polygone([resultMesh.vertices[0],resultMesh.vertices[1],resultMesh.vertices[2]])
//                    //resultMesh.polygones.push(triangle)
//                }
//
//                return mesh
//            }
//
//
//
//        }
//
//
//
//
//
//
//
//
//
//
//       
//
//
//
//
//
//    }
// } 
// /**
//  * Created by vigon on 04/03/2016.
//  */
//
//
// module mathis{
//
//
//
//
//     //
//     // export class ICell extends GameO {
//     //
//     // }
//     //
//     //
//     // export class ISoldier extends GameO {
//     //
//     // }
//     //
//     //
//     // export class Soldier3D extends ISoldier{
//     //
//     //     babVisual:BABYLON.Mesh
//     //     heigth=1.
//     //     constructor(){
//     //         super();
//     //
//     //     }
//     //
//     //     locDraw(){
//     //
//     //
//     //         this.babVisual=BABYLON.Mesh.CreateCylinder("soldier",this.heigth,0.8,0.8,4,10,scene,true)
//     //         this.babVisual.convertToFlatShadedMesh()
//     //
//     //         var material = new BABYLON.StandardMaterial("texture1", scene);
//     //         this.babVisual.material=material;
//     //         material.diffuseColor = new BABYLON.Color3(0., 1., 0.);
//     //         this.locActualize();
//     //     }
//     //
//     //
//     //
//     //     locScale(alpha:number){
//     //         //var pos=this.pos()
//     //         //this.babVisual.position=new BABYLON.Vector3(pos.x,pos.y+this.heigth/2*alpha,pos.z)
//     //         this.babVisual.scaling.x*=alpha
//     //         this.babVisual.scaling.y*=alpha
//     //         this.babVisual.scaling.z*=alpha
//     //     }
//     //
//     //
//     //
//     //     locActualize(){
//     //
//     //         this.babVisual.position=this.pos()
//     //
//     //         var constantRadius=this.constantRadius()
//     //         this.babVisual.scaling.x=constantRadius
//     //         this.babVisual.scaling.y=constantRadius
//     //         this.babVisual.scaling.z=constantRadius
//     //
//     //         this.babVisual.rotationQuaternion=this.quaternion()
//     //
//     //     }
//     //
//     //
//     //     locClear(){
//     //     }
//     //
//     // }
//     //
//     //
//     //
//     // export class Cell3D extends ICell{
//     //
//     //     babVisual:BABYLON.Mesh
//     //
//     //
//     //
//     //     locDraw(){
//     //
//     //         this.babVisual=BABYLON.Mesh.CreateCylinder("cell",0.1,1,1,20,10,scene)
//     //         this.babVisual.convertToFlatShadedMesh()
//     //         var material = new BABYLON.StandardMaterial("texture1", scene);
//     //         this.babVisual.material=material;
//     //         material.diffuseColor = new BABYLON.Color3(1.0, 0.2, 0.7);
//     //
//     //         this.locActualize();
//     //
//     //     }
//     //
//     //     locScale(alpha:number){
//     //         this.babVisual.scaling.x*=alpha
//     //         this.babVisual.scaling.y*=alpha
//     //         this.babVisual.scaling.z*=alpha
//     //     }
//     //
//     //     locActualize(){
//     //
//     //         this.babVisual.position=this.pos()
//     //
//     //         var constantRadius=this.constantRadius()
//     //         this.babVisual.scaling.x=constantRadius
//     //         this.babVisual.scaling.y=constantRadius
//     //         this.babVisual.scaling.z=constantRadius
//     //
//     //         this.babVisual.rotationQuaternion=this.quaternion()
//     //
//     //     }
//     //
//     //
//     //
//     //     locClear(){
//     //     }
//     //
//     // }
//
//
//
//
//
//     export class GameoBab extends GameO{
//
//         babMesh:BABYLON.AbstractMesh
//
//         locDrawAlreadyFired=false
//
//
//         material:any
//         /**this default color is used if no material is defined*/
//         color = new BABYLON.Color3(1,0.2,0.2)
//
//
//         getAllAbstractMeshes():BABYLON.AbstractMesh[]{
//             let res=[]
//             if (this.babMesh!=null ) res.push(this.babMesh)
//             this.children.forEach(gam=>{
//                 if (gam instanceof GameoBab){
//                     if (gam.babMesh!=null) res=res.concat(gam.getAllAbstractMeshes())
//                 }
//             })
//
//             return res
//
//         }
//
//
//         // locDraw(){
//         //     /** without the following test, we fact to fire several times method draw() will create several meshes */
//         //     if (this.locDrawAlreadyFired) return
//         //     this.locDrawAlreadyFired=true
//         //
//         //     if (this.material==null) {
//         //         this.material=new BABYLON.StandardMaterial("mat1", this.scene);
//         //         this.material.alpha = this.locOpacity;
//         //         this.material.diffuseColor = this.color
//         //         this.material.backFaceCulling = true
//         //     }
//         //
//         // }
//
//
//         private putMaterial():void{
//
//
//             if (this.material==null) {
//                 this.material=new BABYLON.StandardMaterial("mat1", this.babMesh.getScene());
//                 this.material.alpha = this.locOpacity;
//                 this.material.diffuseColor = this.color
//                 this.material.backFaceCulling = true
//             }
//             this.babMesh.material=this.material
//
//
//
//         }
//
//
//
//         /**important, add this in class which extends BabylonGameO*/
//         afterLocDraw(){
//
//
//             this.babMesh.visibility=1
//             this.putMaterial()
//             this.locActualize()
//
//             if (this.isClickable){
//                 this.babMesh.isPickable=true
//                 /**we add dynamically a field*/
//                 {(<any>this.babMesh).gameo=this}
//             }
//             else this.babMesh.isPickable=false
//         }
//
//
//
//         clickMethod=()=>{cc('j ai ete clique')}
//
//         // //TODO Check this
//         // locScale(alpha:number){
//         //     //var pos=this.pos()
//         //     //this.babVisual.position=new BABYLON.Vector3(pos.x,pos.y+this.heigth/2*alpha,pos.z)
//         //     this.babMesh.scaling.x*=alpha
//         //     this.babMesh.scaling.y*=alpha
//         //     this.babMesh.scaling.z*=alpha
//         // }
//
//
//         locActualize():void{
//
//             this.babMesh.position=this.pos()
//
//             var constantRadius=this.constantRadius()
//             this.babMesh.scaling.x=constantRadius
//             this.babMesh.scaling.y=constantRadius
//             this.babMesh.scaling.z=constantRadius
//
//             this.babMesh.material.alpha=this.opacity()
//
//             this.babMesh.rotationQuaternion=this.quaternion()
//
//         }
//
//
//         locClear(){
//             this.babMesh.dispose()
//         }
//     }
//
//
//     export class GameoFromMesh extends GameoBab{
//
//
//         constructor(mesh:BABYLON.Mesh){
//             super();
//             this.babMesh=mesh
//         }
//
//
//         locDraw(){
//             if (this.locDrawAlreadyFired) return
//             this.locDrawAlreadyFired=true
//
//             super.afterLocDraw()
//
//
//
//             // if (this.isClickable){
//             //     this.babMesh.isPickable=true
//             //     /**we add dynamically a field*/
//             //     {(<any>this.babMesh).gameo=this}
//             // }
//             // else this.babMesh.isPickable=false
//         }
//
//
//         //clickMethod=()=>{cc('j ai ete clique')}
//
//         // private _scale=1
//         // locScale(alpha:number){
//         //     //var pos=this.pos()
//         //     //this.babVisual.position=new BABYLON.Vector3(pos.x,pos.y+this.heigth/2*alpha,pos.z)
//         //     this._scale=alpha
//         // }
//
//
//         // locActualize():void{
//         //
//         //     this.babMesh.position=this.pos()
//         //
//         //     var constantRadius=this.constantRadius()
//         //     this.babMesh.scaling.x=constantRadius
//         //     this.babMesh.scaling.y=constantRadius
//         //     this.babMesh.scaling.z=constantRadius
//         //
//         //     this.babMesh.rotationQuaternion=this.quaternion()
//         //
//         // }
//         //
//         //
//         // locClear(){
//         //     this.babMesh.dispose()
//         // }
//     }
//
//
//     //
//     //
//     // export class VertexDataGameo extends GameoBab{
//     //
//     //     vertexData:BABYLON.VertexData
//     //
//     //     constructor(vertexData:BABYLON.VertexData,scene:BABYLON.Scene,locPosition:XYZ,locQuaternion:XYZW){
//     //         super(scene,locPosition,locQuaternion)
//     //         this.vertexData=vertexData
//     //     }
//     //
//     //     locDraw(){
//     //
//     //
//     //         super.locDraw()
//     //
//     //         this.babMesh=new BABYLON.Mesh('VertexDataGameo',scene)
//     //         this.vertexData.applyToMesh(this.babMesh)
//     //         this.babMesh.material=this.material
//     //
//     //         super.afterLocDraw()
//     //
//     //
//     //     }
//     // }
//
//
//     export class InstanceMeshGameo extends GameoBab{
//
//         protected scene:BABYLON.Scene
//
//         locDrawAlreadyFired=false
//
//
//         constructor(babInstancedMesh:BABYLON.InstancedMesh){
//             super();
//             this.babMesh=babInstancedMesh
//         }
//
//
//
//         locDraw(){
//             if (this.locDrawAlreadyFired) return
//
//             this.locDrawAlreadyFired=true
//
//             super.afterLocDraw()
//
//
//             // if (this.isClickable){
//             //     this.babInstancedMesh.isPickable=true
//             //     /**we add dynamically a field*/
//             //     {(<any>this.babInstancedMesh).gameo=this}
//             // }
//             // else this.babInstancedMesh.isPickable=false
//         }
//
//
//         clickMethod=()=>{cc('j ai ete clique')}
//
//
//
//
//
//         // locActualize():void{
//         //
//         //     this.babInstancedMesh.position=this.pos()
//         //
//         //     var constantRadius=this.constantRadius()
//         //     this.babInstancedMesh.scaling.x=constantRadius
//         //     this.babInstancedMesh.scaling.y=constantRadius
//         //     this.babInstancedMesh.scaling.z=constantRadius
//         //
//         //     this.babInstancedMesh.rotationQuaternion=this.quaternion()
//         //
//         // }
//         //
//         //
//         // locClear(){
//         //     this.babInstancedMesh.dispose()
//         // }
//     }
//
//
//     //
//     //class GameOOLD{
//     //
//     //    parent:GameO;
//     //    children=new Array<GameO>();
//     //
//     //
//     //    attachTo(parent:GameO){
//     //
//     //        if (this.parent!=null) throw 'une gameO ne doit pas avoir de parent pour tre attach';
//     //        this.parent=parent;
//     //        parent.children.push(this);
//     //
//     //    }
//     //
//     //    detach(){
//     //        if (this.parent!=null) {
//     //            removeFromArray<GameO>(this.parent.children, this);
//     //            this.parent = null;
//     //        }
//     //    }
//     //
//     //
//     //    /** PROPAGATION MONTANTE
//     //     * on calcule une valeur en fonction des parent.
//     //     * les changement effectus ainsi ncessitent ensuite un draw, ou un actualize pour tre visible*/
//     //    locPos=new XYZ(0,0,0);
//     //
//     //    posFromParent=(that:GameO)=>{
//     //        if (this.parent==null) throw 'il faut un parent non null';
//     //        var locPosScaled=this.locPos.scale(this.parent.constantRadius())
//     //
//     //        locPosScaled=rotateVectorByQuaternion(locPosScaled,this.parent.quaternion())
//     //
//     //        //console.log('this.locPos,this.parent.constantRadius(),locPosScaled,this.parent.pos().add(locPos)')
//     //        //console.log(this.locPos,this.parent.constantRadius(),locPosScaled,this.parent.pos().add(locPosScaled))
//     //        return this.parent.pos().add(locPosScaled);
//     //    };
//     //
//     //    posMethod:(gameO:GameO)=>XYZ=this.posFromParent;
//     //
//     //    pos():XYZ{
//     //        if (this.posMethod==null) throw 'la mthode pour calculer la position n est pas dfinie'
//     //        return this.posMethod(this);
//     //    }
//     //
//     //
//     //
//     //    locRadius=1;
//     //    static radiusFromParent=function(that:GameO):number{
//     //        if (that.parent==null) throw 'il faut un parent non null';
//     //        return that.parent.constantRadius()*that.locRadius;
//     //    };
//     //    radiusMethod:(gameO:GameO)=>number=GameO.radiusFromParent;
//     //    constantRadius():number{
//     //        if (this.radiusMethod==null) throw 'la mthode pour calculer le constantRadius n est pas dfinie'
//     //        return this.radiusMethod(this);
//     //    }
//     //
//     //    locOpacity=1;
//     //    opacity(){
//     //        if (this.parent==null) return this.locOpacity;
//     //        else return this.parent.opacity()*this.locOpacity;
//     //    }
//     //
//     //
//     //    clickMethod: ()=>void;
//     //
//     //    onClick():void{
//     //        if (this.clickMethod!=null)  this.clickMethod();
//     //        else if (this.parent!=null) this.parent.onClick();
//     //        //else nothing
//     //    }
//     //
//     //
//     //    locNoseDir=new BABYLON.Vector3(1,0,0)
//     //    locHeadDir=new BABYLON.Vector3(0,1,0)
//     //    quaternionMethodFromParent =()=>{
//     //        if (this.parent==null) throw "il faut avoir un parent"
//     //        var quaternionParent=this.parent.quaternion()
//     //        var locQuaternion=quaternionByGivingNewPositionForXandY(this.locNoseDir,this.locHeadDir)
//     //        return quaternionParent.multiply(locQuaternion)
//     //    }
//     //
//     //    quaternionMethodForRoot=()=>{
//     //        return quaternionByGivingNewPositionForXandY(this.locNoseDir,this.locHeadDir)
//     //    }
//     //
//     //    quaternionMethod=this.quaternionMethodFromParent
//     //
//     //
//     //    quaternion():BABYLON.Quaternion{
//     //        return this.quaternionMethod()
//     //    }
//     //
//     //
//     //
//     //
//     //    /**PROPAGATION DESCENDANTE*/
//     //
//     //    locDraw():void{}
//     //
//     //    putOverOrUnder(isOver:boolean){throw 'to override'}
//     //
//     //    draw():void{
//     //        //if (this.parent==null) console.log('un gameO sans parent est dessin',this);
//     //        this.locDraw();
//     //        this.children.forEach((goChanging:GameO)=>{goChanging.draw()})
//     //    }
//     //
//     //    locActualize():void{
//     //    }
//     //
//     //    actualize():void{
//     //        this.locActualize();
//     //        this.children.forEach((goChanging:GameO)=>{goChanging.actualize()})
//     //    }
//     //
//     //    /**le scaling est superficiel et temporaire : il ne change pas du tout le constantRadius
//     //     * le scaling est utilise temporairement pour mettre en avant un gameO */
//     //    locScale(alpha:number):void{
//     //    }
//     //
//     //    scale(alpha:number):void{
//     //        this.locScale(alpha);
//     //        this.children.forEach((goChanging:GameO)=>{goChanging.scale(alpha)})
//     //    }
//     //
//     //
//     //    locClear():void{}
//     //
//     //    clear():void{
//     //        this.locClear();
//     //        for (var c in this.children) this.children[c].clear();
//     //    }
//     //
//     //    dispose(){
//     //        this.clear();
//     //        this.detach();
//     //    }
//     //
//     //
//     //    /**cette mthode dtache l'objet de son parent*/
//     //    moveBetween(dep:GameO,arr:GameO,alpha:number):void{
//     //
//     //        var tempVec=new XYZ(0,0,0)
//     //
//     //        tempVec.x = (arr.pos().x - dep.pos().x) * alpha + dep.pos().x+this.locPos.x;
//     //        tempVec.y = (arr.pos().y - dep.pos().y) * alpha + dep.pos().y+this.locPos.y;
//     //        tempVec.z = (arr.pos().z - dep.pos().z) * alpha + dep.pos().z+this.locPos.z;
//     //
//     //
//     //        var constantRadius = (arr.constantRadius()*alpha + dep.constantRadius()*(1-alpha))*this.locRadius;
//     //
//     //        this.posMethod=(that:GameO)=>{return tempVec};
//     //        this.radiusMethod=(that:GameO)=>{return constantRadius};
//     //
//     //        this.actualize();
//     //    }
//     //
//     //    moveBetweenVec(dep:XYZ,arr:XYZ,radiusDep:number,radiusArr:number,alpha:number):void{
//     //
//     //        var bet=XYZ.between(alpha,dep,arr);
//     //        bet.add(this.locPos);
//     //
//     //        //tempVec.x = (arr.pos().x - dep.pos().x) * alpha + dep.pos().x+this.locPos.x;
//     //        //tempVec.y = (arr.pos().y - dep.pos().y) * alpha + dep.pos().y+this.locPos.y;
//     //        //tempVec.z = (arr.pos().z - dep.pos().z) * alpha + dep.pos().z+this.locPos.z;
//     //
//     //        var constantRadius = (radiusArr*alpha + radiusDep*(1-alpha))*this.locRadius;
//     //
//     //        this.posMethod=(that:GameO)=>{return bet};
//     //        this.radiusMethod=(that:GameO)=>{return constantRadius};
//     //
//     //        this.actualize();
//     //    }
//     //
//     //}
//    
//    
//    
//
//
// } 
/**
 * Created by vigon on 15/03/2016.
 */
var justBabylon;
(function (justBabylon) {
    function start() {
        function aScene(engine, canvas) {
            var scene = new BABYLON.Scene(engine);
            var camera = new BABYLON.ArcRotateCamera("Camera", 3 * Math.PI / 2, Math.PI / 8, 50, BABYLON.Vector3.Zero(), scene);
            scene.activeCamera = camera;
            camera.attachControl(canvas, false);
            var light = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scene);
            //Creation of a sphere
            //(name of the sphere, segments, diameter, scene)
            var sphere = BABYLON.Mesh.CreateSphere("sphere", 10.0, 10.0, scene);
            //let instance=sphere.createInstance('')
            //instance.position.x=3
            // Moving elements
            sphere.position = new BABYLON.Vector3(0, 0, 0); // Using a vector
            return scene;
        }
        function aScene2(engine, canvas) {
            var scene = new BABYLON.Scene(engine);
            var camera = new BABYLON.ArcRotateCamera("Camera", 3 * Math.PI / 2, Math.PI / 8, 50, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);
            var light = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scene);
            //Creation of a box
            //(name of the box, size, scene)
            var box = BABYLON.Mesh.CreateBox("box", 6.0, scene);
            // Moving elements
            box.position = new BABYLON.Vector3(-10, 0, 0); // Using a vector
            return scene;
        }
        var canvas = document.getElementById("renderCanvas");
        var engine = new BABYLON.Engine(canvas, true);
        var scene = aScene(engine, canvas);
        var count = 0;
        var meanFps = 0;
        var infoBox = document.getElementById("info");
        cc('activeCameras', scene.activeCamera);
        engine.runRenderLoop(function () {
            count++;
            scene.render();
            meanFps += engine.getFps();
            if (count % 100 == 0) {
                if (infoBox != null)
                    infoBox.textContent = (meanFps / 100).toFixed();
                meanFps = 0;
            }
        });
    }
    justBabylon.start = start;
})(justBabylon || (justBabylon = {}));
// /**
//  * Created by vigon on 06/11/2015.
//  */
// module mathis {
//
//
//
//     export module macamera {
//
//         import Vector3 = BABYLON.Vector3;
//         import Matrix = BABYLON.Matrix;
//         import Tools = BABYLON.Tools;
//         import Scene = BABYLON.Scene;
//         import Collider = BABYLON.Collider;
//
//         declare var window;
//
//         export class GrabberCamera {
//
//
//             translationSpeed=maud
//
//             checkCollisions=false
//
//
//             showPredefinedConsoleLog = false
//
//             currentGrabber:Grabber
//             grabbers:Grabber[] = []
//
//
//             useOnlyFreeMode = false
//             useFreeModeWhenCursorOutOfGrabber = true
//
//
//             _keys = [];
//             keysUp = [38];
//             keysDown = [40];
//             keysLeft = [37];
//             keysRight = [39];
//             keysFrontward =[] //[66, 78];
//             keysBackward =[] //[32];
//
//
//             onGrabberChange:(oldGrabber:Grabber,newGrabber:Grabber)=>void =null
//             onTranslate:()=>void=null
//             onPositioningChange:(positioning:Positioning)=>void
//             /**ex: when this function return oldPosition, this simply cancel all changement of position*/
//             positionChangesBiaiser:(oldPosition:XYZ,newPosition:XYZ,currentGrabber:Grabber)=>XYZ
//
//
//             private tooSmallAngle = 0.001
//             private tooBigAngle = 0.3
//             private cumulatedAngle = 0
//
//             private relativeCursorPositionOnGrabber = new XYZ(0, 0, 0)
//             private cursorPositionOnGrabberOld = new XYZ(0, 0, 0)
//             private angleOfRotationAroundGrabber = 0
//             private axeOfRotationAroundGrabber = new XYZ(0, 0, 0)
//
//             private camDir = new XYZ(0, 0, 0)
//             private oldCamDir = new XYZ(0, 0, 0)
//
//             private angleForCamRot = 0
//             private axisForCamRot = new XYZ(0, 0, 0)
//
//
//             /**un vecteur gal  {@link myNullVector} est considr comme null
//              * cependant, on n' aura pas besoin d' un new pour le raffecter*/
//             private myNullVector = new XYZ(123, 234, 345)
//
//             private frozonProjectionMatrix = new MM()
//             private frozonViewMatrix = new MM()
//
//             private pickingRay = {origin: new XYZ(0, 0, 0), direction: new XYZ(0, 0, 0)}
//
//
//             private aPartOfTheFrontDir = new XYZ(0, 0, 0)
//
//
//             public whishedCamPos = new WishedPositioning(this)
//             public trueCamPos = new CamPositioning(this)
//
//             private scene:Scene
//             public camera:BabCamera
//
//             private cursorActualStyle:string
//
//             private $canvasElement
//
//
//
//             changePosition(position:XYZ,smoothMovement=true):void{
//                 this.whishedCamPos.changePosition(position)
//                 if (!smoothMovement){
//                     this.trueCamPos.position=position
//                 }
//             }
//             changeFrontDir(position:XYZ,smoothMovement=true):void{
//                 this.whishedCamPos.changeFrontDir(position)
//                 if (!smoothMovement){
//                     this.trueCamPos.changeFrontDir(position)
//                 }
//
//             }
//             changeUpVector(position:XYZ,smoothMovement=true):void{
//                 this.whishedCamPos.changeUpVector(position)
//                 if (!smoothMovement){
//                     this.trueCamPos.changeUpVector(position)
//                 }
//             }
//
//
//
//             constructor(mathisFrame:MathisFrame,grabber:Grabber) {
//                 this.scene = mathisFrame.scene
//
//
//                 /**pour indiquer que les old vectors ne sont pas attribus (sans pour autant les nullifier, pour viter des affectations)*/
//                 geo.copyXYZ(this.myNullVector, this.cursorPositionOnGrabberOld)
//                 geo.copyXYZ(this.myNullVector, this.oldCamDir)
//                 this.camera = new macamera.BabCamera("toto", this.scene, this)
//                 //if (this.viewport != null) this.camera.viewport = this.viewport
//                 //this.whishedCamPos.copyFrom(this.trueCamPos)
//
//                 this.$canvasElement = mathisFrame.canvas
//                 this.toogleIconCursor('cursorDefault')
//
//                 this.replaceTheFirstGrabber(grabber)
//
//                 this.attachControl(mathisFrame.canvas)
//
//             }
//
//
//             // private camToGrab = new XYZ(0, 0, 0)
//             // private chooseCurrentGrabberAccordingToDistance():void {
//             //
//             //
//             //     if (this.grabbers.length > 1) {
//             //         let minDist = Number.MAX_VALUE
//             //
//             //         this.grabbers.forEach(gra=> {
//             //
//             //             let dist = geo.distance(gra.referenceCenter, this.trueCamPos.position)
//             //             geo.substract(gra.referenceCenter, this.trueCamPos.position, this.camToGrab)
//             //             if (geo.dot(this.camToGrab, this.trueCamPos.frontDir) < 0) dist *= 3
//             //
//             //             if (dist < minDist) {
//             //                 minDist = dist
//             //                 this.currentGrabber = gra
//             //             }
//             //
//             //         })
//             //     }
//             //     else this.currentGrabber = this.grabbers[0]
//             //
//             // }
//
//
//             addGrabber(grabber:Grabber):void{
//                 grabber.checkArgs()
//                 this.grabbers.push(grabber)
//                 //if (checkForChangingCurrentGrabber) this.chooseCurrentGrabberAccordingToDistance()
//             }
//
//             replaceTheFirstGrabber(grabber:Grabber):void{
//                 if(this.grabbers[0]!=null) this.grabbers[0].dispose()
//                 grabber.checkArgs()
//                 grabber.grabberCamera=this
//                 this.grabbers[0]=grabber
//                 this.currentGrabber=this.grabbers[0]
//             }
//
//
//
//             private controlIsAttached=false
//             attachControl(canvas) {
//                 if (this.controlIsAttached) {
//                     logger.c('the control is already attached. Please detach before re-attaching ')
//                     return
//                 }
//                 this.camera.attachControl(canvas)
//                 this.controlIsAttached=true
//             }
//
//
//             private _axeForKeyRotation = new XYZ(0, 0, 0)
//             private _additionnalVec = new XYZ(0, 0, 0)
//             private checkForKeyPushed():void {
//                 if (this._keys.length == 0) return
//
//                 geo.copyXyzFromFloat(0, 0, 0, this._axeForKeyRotation)
//
//                 for (var index = 0; index < this._keys.length; index++) {
//                     var keyCode = this._keys[index];
//
//                     if (this.keysLeft.indexOf(keyCode) !== -1) {
//                         geo.copyXYZ(this.whishedCamPos.upVector, this._additionnalVec)
//                         geo.scale(this._additionnalVec, -1, this._additionnalVec)
//                         geo.add(this._axeForKeyRotation, this._additionnalVec, this._axeForKeyRotation)
//
//                     }
//                     if (this.keysUp.indexOf(keyCode) !== -1) {
//                         geo.cross(this.whishedCamPos.frontDir, this.whishedCamPos.upVector, this._additionnalVec)
//                         geo.add(this._additionnalVec, this._axeForKeyRotation, this._axeForKeyRotation)
//                     }
//                     if (this.keysRight.indexOf(keyCode) !== -1) {
//                         geo.copyXYZ(this.whishedCamPos.upVector, this._additionnalVec)
//                         geo.add(this._additionnalVec, this._axeForKeyRotation, this._axeForKeyRotation)
//                     }
//                     if (this.keysDown.indexOf(keyCode) !== -1) {
//                         geo.cross(this.whishedCamPos.upVector, this.whishedCamPos.frontDir, this._additionnalVec)
//                         geo.add(this._additionnalVec, this._axeForKeyRotation, this._axeForKeyRotation)
//                     }
//
//                     if (this.keysBackward.indexOf(keyCode) !== -1) this.translateCam(-0.1)
//                     else if (this.keysFrontward.indexOf(keyCode) !== -1) this.translateCam(0.1)
//                 }
//
//                 /**it was already appears that the axis was too small : */
//                 if (geo.squareNorme(this._axeForKeyRotation) < geo.epsilon) return
//
//                 let angle = -0.02
//                 // var alpha = this.currentGrabber.interpolationCoefAccordingToCamPosition(this.whishedCamPos.getPosition())
//                 // if (alpha < 1 && alpha > 0) this.twoRotations(this._axeForKeyRotation, angle, this._axeForKeyRotation, angle, alpha)
//                 // else if (alpha == 1) this.rotateAroundCenter(this._axeForKeyRotation, angle, this.currentGrabber.rotationCenter)
//                 // else
//                 /**when key pushed, we always use free mode*/
//                     this.rotate(this._axeForKeyRotation, angle)
//             }
//
//
//             /**ROTATION MOVEMENTS*/
//             private toogleIconCursor(style:string) {
//
//                 if (this.cursorActualStyle != style) {
//                     this.$canvasElement.className = style
//                     //this.$canvasElement.className += "cursorGrabbing";
//                     this.cursorActualStyle = style
//                 }
//
//             }
//
//             private freeRotation():void {
//                 if (this.showPredefinedConsoleLog) console.log('free rotation angle', this.angleForCamRot.toFixed(4))
//                 this.rotate(this.axisForCamRot, this.angleForCamRot)
//                 this.toogleIconCursor("cursorMove")
//             }
//
//             private _paralDisplacement = new XYZ(0, 0, 0)
//             private grabberMovement():void {
//
//                 if (this.currentGrabber.parallelDisplacementInsteadOfRotation) {
//                     this._paralDisplacement.copyFrom(this.relativeCursorPositionOnGrabber).substract(this.cursorPositionOnGrabberOld).scale(-1)
//                     this._paralDisplacement.add(this.whishedCamPos.getPosition())
//                     this.whishedCamPos.changePosition(this._paralDisplacement)
//                 }
//                 else{
//                     if (this.showPredefinedConsoleLog) console.log('grabber rotation angle', this.angleOfRotationAroundGrabber.toFixed(4))
//                     this.rotateAroundCenter(this.axeOfRotationAroundGrabber, this.angleOfRotationAroundGrabber, this.currentGrabber.referenceCenter)
//                 }
//                 this.toogleIconCursor("cursorGrabbing")
//                 if (this.currentGrabber.showGrabberOnlyWhenGrabbing) this.currentGrabber.mesh.visibility=1
//
//             }
//
//             private mixedRotation(alpha):void {
//                 if (this.showPredefinedConsoleLog) console.log('free rotation angle', this.angleForCamRot.toFixed(4), 'grabber rotation angle', this.angleOfRotationAroundGrabber.toFixed(4))
//                 this.twoRotations(this.axisForCamRot, this.angleForCamRot, this.axeOfRotationAroundGrabber, this.angleOfRotationAroundGrabber, alpha)
//                 this.toogleIconCursor("cursorGrabbing")
//                 if (this.currentGrabber.showGrabberOnlyWhenGrabbing) this.currentGrabber.mesh.visibility=1
//
//             }
//
//             private _matrixRotationAroundCam = new MM()
//             private rotate(axis:XYZ, angle:number):void {
//                 geo.axisAngleToMatrix(axis, angle, this._matrixRotationAroundCam)
//                 geo.multiplicationMatrixVector(this._matrixRotationAroundCam, this.whishedCamPos.frontDir, this.whishedCamPos.frontDir)
//                 geo.multiplicationMatrixVector(this._matrixRotationAroundCam, this.whishedCamPos.upVector, this.whishedCamPos.upVector)
//             }
//
//             private _matrixRotationAroundZero = new MM()
//             private camRelativePos = new XYZ(0, 0, 0)
//             private rotateAroundCenter(axis:XYZ, angle:number, center:XYZ):void {
//                 if (this.currentGrabber.referenceCenter==null) return
//                 geo.axisAngleToMatrix(axis, angle, this._matrixRotationAroundZero)
//                 geo.multiplicationMatrixVector(this._matrixRotationAroundZero, this.whishedCamPos.frontDir, this.whishedCamPos.frontDir)
//                 geo.multiplicationMatrixVector(this._matrixRotationAroundZero, this.whishedCamPos.upVector, this.whishedCamPos.upVector)
//                 this.camRelativePos.copyFrom(this.whishedCamPos.getPosition()).substract(center)
//                 geo.multiplicationMatrixVector(this._matrixRotationAroundZero, this.camRelativePos, this.camRelativePos)
//                 //this.whishedCamPos.position.copyFrom(this.camRelativePos).add(center)
//                 this.camRelativePos.add(center)
//                 this.whishedCamPos.changePosition(this.camRelativePos)
//
//
//             }
//
//             private twoRotations(axeOfRotationAroundCam:XYZ, angleBetweenRays:number, axeOfRotationAroundZero:XYZ, angleOfRotationAroundZero:number, alpha:number) {
//                 this.rotate(axeOfRotationAroundCam, angleBetweenRays * (1 - alpha))
//                 this.rotateAroundCenter(axeOfRotationAroundZero, angleOfRotationAroundZero * alpha, this.currentGrabber.referenceCenter)
//             }
//
//
//             /**TRANSLATION MOVEMENT*/
//             private _collider=new Collider()
//             private correctionToRecenter = new XYZ(0, 0, 0)
//             private _deltaPosition = new XYZ(0, 0, 0)
//             private _popo=new XYZ(0,0,0)
//             /**fired wy wheeling or by keys*/
//             translateCam(delta:number):void {
//
//
//                 let impultion = delta*this.translationSpeed;
//
//                 /** amout <0 when we goChanging backward. when we goChanging backward, we align our vision to zero.*/
//                 if (delta < 0 && this.currentGrabber.focusOnMyCenterWhenCameraGoDownWard&&this.currentGrabber.referenceCenter!=null) {
//                     var alpha:number = Math.min(1,geo.distance(this.whishedCamPos.getPosition(),this.currentGrabber.referenceCenter)/this.currentGrabber.endOfZone3 )     //= this.currentGrabber.interpolationCoefAccordingToCamPosition(geo.distance(this.whishedCamPos.getPosition(),this.currentGrabber.referenceCenter));
//
//                     /**modification of alpha. The re-axis must be sufficiently slow */
//                     alpha = alpha * alpha * 0.1
//
//                     geo.scale(this.whishedCamPos.frontDir, 1 - alpha, this.aPartOfTheFrontDir)
//
//                     geo.substract(this.currentGrabber.referenceCenter, this.whishedCamPos.getPosition(), this.correctionToRecenter)
//                     if (this.correctionToRecenter.lengthSquared() > geo.epsilon) {
//                         geo.normalize(this.correctionToRecenter, this.correctionToRecenter)
//                         geo.scale(this.correctionToRecenter, alpha, this.correctionToRecenter)
//                         geo.add(this.correctionToRecenter, this.aPartOfTheFrontDir, this.aPartOfTheFrontDir)
//
//                     }
//
//                     this.whishedCamPos.changeFrontDir(this.aPartOfTheFrontDir)
//                 }
//
//                 if (impultion != 0) {
//                     geo.scale(this.whishedCamPos.frontDir, impultion, this._deltaPosition)
//
//                     //if(this.checkCollisions) this._collideWithWorld(this._deltaPosition)
//                     //else {
//                         /**attention : sans utiliser l'intermdiatre popo, cela cre un bug incomprhensible*/
//                         geo.add(this.whishedCamPos.getPosition(),this._deltaPosition,this._popo)
//                         this.whishedCamPos.changePosition(this._popo)
//
//                     //}
//
//                     if(this.onTranslate!=null) this.onTranslate()
//
//                     ///** inertialCoef is 0, but there is still inertia when wheeling. I think it is the default inertial of device-wheel*/
//                     // impultion *= this.intertialCoef
//                     // if (Math.abs(impultion) < BABYLON.Engine.Epsilon)
//                     //     impultion = 0;
//                 }
//
//             }
//
//
//
//
//             /** REACTION TO USER CONTROLS */
//
//             private getIntersectionWithGrabber(){
//
//             }
//
//             private _babylonRay:BABYLON.Ray = new BABYLON.Ray(new BABYLON.Vector3(0, 0, 0), new BABYLON.Vector3(0, 0, 1))
//             private pointerIsOnCurrentGrabber = false
//             private candidate1=new XYZ(0,0,0)
//             private candidate2=new XYZ(0,0,0)
//             onPointerMove(actualPointerX:number, actualPointerY:number):void {
//
//
//                 if (!this.pointerIsDown) return
//
//                 /**a priori on va faire les rotation, sauf si ... (cf plus loin)*/
//                 var grabberRotationOK = true
//                 var freeRotationOK = true
//
//
//                 /**if the actual current grabber has lost the pointer, we look for an other.
//                  *  But if not other, the currentGrabber stay (ex : we we go down, we center on it)*/
//
//                 if (!this.pointerIsOnCurrentGrabber && this.grabbers.length > 1) {
//
//                     for (let gra of this.grabbers) {
//
//                         this.createPickingRayWithFrozenCamera(actualPointerX, actualPointerY,
//                             <MM> gra.mesh.getWorldMatrix(),
//                             this.frozonViewMatrix,
//                             this.frozonProjectionMatrix,
//                             this.pickingRay)
//                         geo.copyXYZ(this.pickingRay.direction, this.camDir)
//
//                         /**true also we we are inside the grabber*/
//                         this._babylonRay.direction = this.pickingRay.direction
//                         this._babylonRay.origin = this.pickingRay.origin
//
//                         /**fast checking*/
//                         let pickInfo = gra.mesh.intersects(this._babylonRay, true)
//
//                         if (pickInfo.hit&&pickInfo.distance<gra.endOfZone3) {
//                             if (this.onGrabberChange!=null) this.onGrabberChange(this.currentGrabber,gra)
//                             this.currentGrabber = gra
//                             cc('we have changed grabber, the new one is: ', gra.name)
//                             break
//                         }
//                     }
//                 }
//
//
//                 /**le picking ray est relatif  un objet donn; ici : this.currentGrabber.mesh  */
//                 this.createPickingRayWithFrozenCamera(actualPointerX, actualPointerY,
//                     <MM> this.currentGrabber.mesh.getWorldMatrix(),
//                     this.frozonViewMatrix,
//                     this.frozonProjectionMatrix,
//                     this.pickingRay)
//                 geo.copyXYZ(this.pickingRay.direction, this.camDir)
//
//
//                     //
//                     //
//                     // this.createPickingRayWithFrozenCamera(actualPointerX, actualPointerY,
//                     //     <MM> this.currentGrabber.mesh.getWorldMatrix(),
//                     //     this.frozonViewMatrix,
//                     //     this.frozonProjectionMatrix,
//                     //     this.pickingRay)
//
//
//                     // let worldMatrix=<MM>this.currentGrabber.mesh.getWorldMatrix()
//                     // //geo.inverse(worldMatrix,worldMatrix)
//                     // geo.multiplicationMatrixVector(worldMatrix,this.pickingRay.direction,this.pickingRay.direction)
//                     // geo.multiplicationMatrixVector(worldMatrix,this.pickingRay.origin,this.pickingRay.origin)
//
//
//                     /**Be carefull: pickInfo.hit is true also when we are inside the grabber*/
//                     this._babylonRay.direction = this.pickingRay.direction
//                     this._babylonRay.origin = this.pickingRay.origin
//                     let pickInfo = this.currentGrabber.mesh.intersects(this._babylonRay, false)
//                     this.pointerIsOnCurrentGrabber = pickInfo.hit
//                     let distToGrabbed = pickInfo.distance
//                     if (this.pointerIsOnCurrentGrabber) {
//                         this.relativeCursorPositionOnGrabber.x = pickInfo.pickedPoint.x
//                         this.relativeCursorPositionOnGrabber.y = pickInfo.pickedPoint.y
//                         this.relativeCursorPositionOnGrabber.z = pickInfo.pickedPoint.z
//                     }
//                
//                
//                     if(this.currentGrabber.referenceCenter!=null) this.relativeCursorPositionOnGrabber.substract(this.currentGrabber.referenceCenter)
//
//
//
//                 /**
//                  * Cette mthode tait sympa (pas de boucle pour trouver le point d'intersection avec le grabber). Malheureusement, cela ne marche pas quand le grabber n'est pas centr en zro
//                  *
//                  let constantRadius=(<SphericalGrabber> this.currentGrabber).constantRadius
//                  this.pointerIsOnCurrentGrabber = geo.intersectionBetweenRayAndSphereFromRef(this.pickingRay.origin, this.pickingRay.direction,constantRadius,this.currentGrabber.referenceCenter,this.candidate1,this.candidate2 )
//                  distToGrabbed=geo.closerOf(this.candidate1,this.candidate2,this.whishedCamPos.position,this.relativeCursorPositionOnGrabber)
//                  *
//                  * */
//
//
//                 let alpha = this.currentGrabber.interpolationCoefAccordingToCamPosition(this.trueCamPos.position,distToGrabbed)
//                 if (this.showPredefinedConsoleLog) cc('alpha', alpha)
//
//
//
//
//                 if (geo.xyzEquality(this.oldCamDir, this.myNullVector)) {
//                     geo.copyXYZ(this.camDir, this.oldCamDir)
//                     freeRotationOK = false
//                 }
//
//
//                 if (geo.xyzEquality(this.cursorPositionOnGrabberOld, this.myNullVector)) {
//                     if (this.pointerIsOnCurrentGrabber) {
//                         geo.copyXYZ(this.relativeCursorPositionOnGrabber, this.cursorPositionOnGrabberOld)
//                     }
//                     grabberRotationOK = false
//                 }
//                 else if (!this.pointerIsOnCurrentGrabber) {
//                     geo.copyXYZ(this.myNullVector, this.cursorPositionOnGrabberOld)
//                     grabberRotationOK = false
//                 }
//
//
//                 if (freeRotationOK) {
//                     this.angleForCamRot = geo.angleBetweenTwoVectorsBetween0andPi(this.camDir, this.oldCamDir)
//                     if (this.angleForCamRot > this.tooSmallAngle) {
//                         geo.cross(this.camDir, this.oldCamDir, this.axisForCamRot)
//                         geo.normalize(this.axisForCamRot, this.axisForCamRot)
//                     }
//                     else freeRotationOK = false
//                 }
//
//
//                 if (grabberRotationOK) {
//                     this.angleOfRotationAroundGrabber = geo.angleBetweenTwoVectorsBetween0andPi(this.relativeCursorPositionOnGrabber, this.cursorPositionOnGrabberOld);
//                     if (this.angleOfRotationAroundGrabber > this.tooSmallAngle) {
//                         geo.cross(this.relativeCursorPositionOnGrabber, this.cursorPositionOnGrabberOld, this.axeOfRotationAroundGrabber)
//                         this.axeOfRotationAroundGrabber.normalize()
//                     }
//                     else grabberRotationOK = false
//                 }
//
//                 /**un pensement ici pour une erreur non compris : quand on est proche de la sphre, l'angle de la rotation autour de zro prend parfois de trs grand valeur*/
//                 if (grabberRotationOK && this.angleOfRotationAroundGrabber > this.tooBigAngle) {
//                     console.log('a too big angle around zero : ignored' + this.angleOfRotationAroundGrabber.toFixed(4))
//                     geo.copyXYZ(this.relativeCursorPositionOnGrabber, this.cursorPositionOnGrabberOld)
//                     return
//                 }
//
//
//                 if (this.useOnlyFreeMode && freeRotationOK) this.freeRotation()
//                 else if (this.pointerIsOnCurrentGrabber) {
//                     if (alpha == 0) {
//                         if (freeRotationOK) this.freeRotation()
//                     }
//                     /** camera position is close to grabber */
//                     else if (alpha < 1 && alpha > 0) {
//                         if ( freeRotationOK && grabberRotationOK) this.mixedRotation(alpha)
//                         else if (grabberRotationOK) this.grabberMovement()
//                     }
//                     /** camera is far from graber*/
//                     else if (alpha == 1 && grabberRotationOK) this.grabberMovement()
//                 }
//                 else if (this.useFreeModeWhenCursorOutOfGrabber && freeRotationOK) this.freeRotation()
//
//
//                 /**on  affecte les nouvelles positions si l' on vient d' effectuer une rotation
//                  * Attention, il ne faut pas affecter de nouvelle valeur  chaque fois, sinon les angles ne dpassent jamais les seuils critiques*/
//                 if (grabberRotationOK) geo.copyXYZ(this.relativeCursorPositionOnGrabber, this.cursorPositionOnGrabberOld)
//                 if (freeRotationOK)  geo.copyXYZ(this.camDir, this.oldCamDir)
//
//
//                 if (grabberRotationOK) this.cumulatedAngle += this.angleOfRotationAroundGrabber
//                 if (freeRotationOK) this.cumulatedAngle += this.angleForCamRot
//
//                 if (this.cumulatedAngle > Math.PI / 12) {
//                     geo.copyMat(this.getProjectionMatrix(), this.frozonProjectionMatrix)
//                     geo.copyMat(this.getViewMatrix(), this.frozonViewMatrix)
//                     this.cumulatedAngle = 0
//                     geo.copyXYZ(this.myNullVector, this.oldCamDir)
//                     geo.copyXYZ(this.myNullVector, this.cursorPositionOnGrabberOld)
//                     if (this.showPredefinedConsoleLog) console.log('nouvelles matrices enregistres')
//                 }
//
//             }
//
//
//             /**copi sur {@link BABYLON.Scene.createPickingRay}  */
//             private  createPickingRayWithFrozenCamera(x:number, y:number, world:MM, frozenViewMatrix:MM, frozonProjectionMatrix:MM, result:{origin:XYZ;direction:XYZ}):void {
//                 var engine = this.camera.getEngine();
//                 var cameraViewport = this.camera.viewport;
//                 var viewport = cameraViewport.toGlobal(engine);
//
//                 // Moving coordinates to local viewport world
//                 x = x / engine.getHardwareScalingLevel() - viewport.x;
//                 y = y / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - viewport.y - viewport.height);
//
//                 this.createNewRay(x, y, viewport.width, viewport.height, world, frozenViewMatrix, frozonProjectionMatrix, result)
//             }
//
//             private _tempCN = new XYZ(0, 0, 0)
//             private _end = new XYZ(0, 0, 0)
//             private createNewRay(x:number, y:number, viewportWidth:number, viewportHeight:number, world:MM, view:MM, projection:MM, result:{origin:XYZ;direction:XYZ}):void {
//
//                 geo.unproject(geo.copyXyzFromFloat(x, y, 0, this._tempCN), viewportWidth, viewportHeight, world, view, projection, result.origin)
//                 geo.unproject(geo.copyXyzFromFloat(x, y, 1, this._tempCN), viewportWidth, viewportHeight, world, view, projection, this._end)
//
//                 //var start = BABYLON.Vector3.Unproject(new BABYLON.Vector3(x, y, 0), viewportWidth, viewportHeight, world, view, projection);
//                 //var end = BABYLON.Vector3.Unproject(new BABYLON.Vector3(x, y, 1), viewportWidth, viewportHeight, world, view, projection);
//                 geo.substract(this._end, result.origin, result.direction)
//                 geo.normalize(result.direction, result.direction)
//
//             }
//
//
//             private pointerIsDown = false
//              onPointerDown() {
//
//                 this.pointerIsDown = true
//                 /**on glace ces matrices pour viter les instabilits*/
//                 geo.copyMat(this.getProjectionMatrix(), this.frozonProjectionMatrix)
//                 geo.copyMat(this.getViewMatrix(), this.frozonViewMatrix)
//                 this.cumulatedAngle = 0
//             }
//
//              onPointerUp() {
//                 this.toogleIconCursor('cursorDefault')
//                 if (this.currentGrabber.showGrabberOnlyWhenGrabbing) this.currentGrabber.mesh.visibility=0
//
//                 this.pointerIsDown = false
//                 geo.copyXYZ(this.myNullVector, this.oldCamDir)
//                 geo.copyXYZ(this.myNullVector, this.cursorPositionOnGrabberOld)
//             }
//
//              onKeyDown(evt:any) {
//                 if (this.keysUp.indexOf(evt.keyCode) !== -1 ||
//                     this.keysDown.indexOf(evt.keyCode) !== -1 ||
//                     this.keysLeft.indexOf(evt.keyCode) !== -1 ||
//                     this.keysRight.indexOf(evt.keyCode) !== -1 ||
//                     this.keysBackward.indexOf(evt.keyCode) !== -1 ||
//                     this.keysFrontward.indexOf(evt.keyCode) !== -1) {
//                     var index = this._keys.indexOf(evt.keyCode);
//
//                     if (index === -1) {
//                         this._keys.push(evt.keyCode);
//                     }
//
//                     if (evt.preventDefault) {
//                         //if (!noPreventDefault) {
//                         evt.preventDefault();
//                         //}
//                     }
//                 }
//             }
//
//              onKeyUp(evt) {
//                 if (this.keysUp.indexOf(evt.keyCode) !== -1 ||
//                     this.keysDown.indexOf(evt.keyCode) !== -1 ||
//                     this.keysLeft.indexOf(evt.keyCode) !== -1 ||
//                     this.keysRight.indexOf(evt.keyCode) !== -1 ||
//                     this.keysBackward.indexOf(evt.keyCode) !== -1 ||
//                     this.keysFrontward.indexOf(evt.keyCode) !== -1) {
//                     var index = this._keys.indexOf(evt.keyCode);
//
//                     if (index >= 0) {
//                         this._keys.splice(index, 1);
//                     }
//
//                     if (evt.preventDefault) {
//                         evt.preventDefault();
//                     }
//                 }
//             }
//
//              update() {
//                 this.checkForKeyPushed()
//                 if (!this.trueCamPos.almostEqual(this.whishedCamPos))   this.trueCamPos.goCloser(this.whishedCamPos)
//             }
//
//
//
//
//             /** when we detach control  */
//             reset() {
//                 this._keys = []
//                 //TODO what else ?
//
//             }
//
//
//             isSynchronized():boolean {
//                 return this.trueCamPos.almostEqual(this.whishedCamPos)
//             }
//
//
//             private projectionMM = new MM()
//
//             public getProjectionMatrix():MM {
//
//
//                 var engine = this.camera.getEngine();
//                 if (this.camera.minZ <= 0) {
//                     this.camera.minZ = 0.1;
//                 }
//
//                 geo.PerspectiveFovLH(this.camera.fov, engine.getAspectRatio(this.camera), this.camera.minZ, this.camera.maxZ, this.projectionMM);
//                 return this.projectionMM;
//
//                 //var halfWidth = engine.getRenderWidth() / 2.0;
//                 //var halfHeight = engine.getRenderHeight() / 2.0;
//                 //Matrix.OrthoOffCenterLHToRef(this.orthoLeft || -halfWidth, this.orthoRight || halfWidth, this.orthoBottom || -halfHeight, this.orthoTop || halfHeight, this.minZ, this.maxZ, this._projectionMatrix);
//                 //return this._projectionMatrix;
//             }
//
//
//             private _target = XYZ.newZero()
//             public viewMM = new MM()
//
//             public getViewMatrix():MM {
//                 //this.trueCamPos.copyFrom(this.whishedCamPos)
//                 geo.copyXYZ(this.trueCamPos.position, this._target)
//                 geo.add(this._target, this.trueCamPos.frontDir, this._target)
//                 geo.LookAtLH(this.trueCamPos.position, this._target, this.trueCamPos.upVector, this.viewMM)
//
//                 return this.viewMM;
//             }
//
//
//
//         }
//
//
//         export class CamPositioning extends Positioning{
//             position:XYZ =new XYZ(0,0,-3)
//             upVector:XYZ = new XYZ(0, 1, 0)
//             frontDir:XYZ = new XYZ(0, 0, 1)
//             sizes=new XYZ(1,1,1)
//
//             smoothParam = 0.5
//
//             constructor(private grabberPilot:GrabberCamera){
//                 super()
//             }
//
//             almostEqual(camCarac:WishedPositioning):boolean {
//                 return geo.xyzAlmostEquality(this.position, camCarac.getPosition()) && geo.xyzAlmostEquality(this.upVector, camCarac.upVector) && geo.xyzAlmostEquality(this.frontDir, camCarac.frontDir)
//             }
//
//             /**TODO problme ici si l'on prend une wished positionning trs loin de la cam positionning*/
//             goCloser(positioning:WishedPositioning):void {
//                 geo.between(positioning.position, this.position, this.smoothParam, this.position)
//
//                 geo.between(positioning.upVector, this.upVector, this.smoothParam, this.upVector)
//                 geo.between(positioning.frontDir, this.frontDir, this.smoothParam, this.frontDir)
//
//                 if (this.upVector.lengthSquared()<geo.epsilonSquare ){
//                     this.upVector.copyFrom(positioning.upVector).scale(-1)
//                     logger.c('a wished upVector was opposite to the true upVector')
//                 }
//                 if (this.frontDir.lengthSquared()<geo.epsilonSquare ){
//                     this.frontDir.copyFrom(positioning.frontDir).scale(-1)
//                     logger.c('a wished frontDir was opposite to the true frontDir')
//                 }
//
//
//
//                 if(this.grabberPilot.onPositioningChange!=null) {
//                     this.positioningCopy.copyFrom(this)
//                     this.grabberPilot.onPositioningChange(this.positioningCopy)
//                 }
//             }
//
//             private positioningCopy=new Positioning()
//             copyFrom(positioning:Positioning) {
//                 geo.copyXYZ(positioning.position, this.position)
//                 geo.copyXYZ(positioning.upVector, this.upVector)
//                 geo.copyXYZ(positioning.frontDir, this.frontDir)
//                 // if(this.grabberPilot.onPositioningChange!=null) {
//                 //     this.positioningCopy.copyFrom(this)
//                 //     this.grabberPilot.onPositioningChange(this.positioningCopy)
//                 // }
//
//             }
//
//             changeFrontDir(vector:XYZ):void {
//                 geo.orthonormalizeKeepingFirstDirection(vector, this.upVector, this.frontDir, this.upVector)
//                 // if(this.grabberPilot.onPositioningChange!=null) {
//                 //     this.positioningCopy.copyFrom(this)
//                 //     this.grabberPilot.onPositioningChange(this.positioningCopy)
//                 // }
//             }
//             changeUpVector(vector:XYZ):void {
//                 geo.orthonormalizeKeepingFirstDirection( this.upVector,vector , this.upVector,this.frontDir)
//                 // if(this.grabberPilot.onPositioningChange!=null) {
//                 //     this.positioningCopy.copyFrom(this)
//                 //     this.grabberPilot.onPositioningChange(this.positioningCopy)
//                 // }
//             }
//
//         }
//
//
//         export class WishedPositioning extends Positioning{
//
//             constructor(private grabberPilot:GrabberCamera){
//                 super()
//             }
//
//             upVector:XYZ = new XYZ(0, 1, 0)
//             frontDir:XYZ = new XYZ(0, 0, 1)
//             position:XYZ = new XYZ(0, 0, -3)
//
//             getPosition():XYZ{
//                 return this.position
//             }
//
//
//
//             private _newPositionBeforCollision=new XYZ(0,0,0)
//             private _velocity=new XYZ(0,0,0)
//
//
//             changePosition(newPosition:XYZ){
//
//                 // if (positionConstraint==null) {
//                 //     this._positionBeforCollision=newPosition
//                 //
//                 // }
//                 // else if (positionConstraint.positionConstraint0==null && positionConstraint.positionConstraint1==null){
//                 //     this._positionBeforCollision=newPosition
//                 // }
//                 // else if (positionConstraint.positionConstraint0!=null && positionConstraint.positionConstraint1==null){
//                 //     geo.orthogonalProjectionOnLine(positionConstraint.positionConstraint0,this._projMat)
//                 //     geo.multiplicationMatrixVector(this._projMat,newPosition,this._positionBeforCollision)
//                 //
//                 // }
//                 // else if (positionConstraint.positionConstraint0!=null && positionConstraint.positionConstraint1!=null){
//                 //     geo.orthogonalProjectionOnPlane(positionConstraint.positionConstraint0,positionConstraint.positionConstraint1,this._projMat)
//                 //     geo.multiplicationMatrixVector(this._projMat,newPosition,this._positionBeforCollision)
//                 //
//                 // }
//
//                 if (this.grabberPilot.positionChangesBiaiser!=null){
//                     this._newPositionBeforCollision.copyFrom(this.grabberPilot.positionChangesBiaiser(this.position,newPosition,this.grabberPilot.currentGrabber))
//                 }
//                 else this._newPositionBeforCollision.copyFrom(newPosition)
//
//
//                 if ( this.grabberPilot.checkCollisions){
//                     this._velocity.copyFrom(this._newPositionBeforCollision).substract(this.grabberPilot.trueCamPos.position)
//                     this._collideWithWorld(this._velocity,this._newPositionBeforCollision)
//                 }
//                 else this.position.copyFrom(this._newPositionBeforCollision)
//
//
//                 //if (this.grabberPilot.onPositioningChange!=null) this.grabberPilot.onPositioningChange(this,this.grabberPilot.currentGrabber)
//
//             }
//
//             // changeFrontDir(vector:XYZ):void {
//             //     geo.orthonormalizeKeepingFirstDirection(vector, this.upVector, this.frontDir, this.upVector)
//             //
//             // }
//             // changeUpVector(vector:XYZ):void {
//             //     geo.orthonormalizeKeepingFirstDirection( this.upVector,vector , this.upVector,this.frontDir)
//             // }
//             //
//             // changePositioning(positioning:Positioning){
//             //     this.position.copyFrom(positioning.position)
//             //     this.upVector.copyFrom(positioning.upVector)
//             //     this.frontDir.copyFrom(positioning.frontDir)
//             // }
//
//
//
//             /**COLLISION*/
//             private _collider=new Collider()
//              ellipsoid=new XYZ(1,1,1)
//             private _oldPosition=new XYZ(0,0,0)
//             private _collideWithWorld(velocity: Vector3,candidatePos:XYZ): void {
//                 // var globalPosition=this.getPosition()
//                 // /** in babylon Free Camera, they decal the impact point by ellipsoid.y, but this is not very natural */
//                 // globalPosition.subtractFromFloatsToRef(0, 0, 0, this._oldPosition);
//
//                 this._collider.constantRadius = this.ellipsoid;
//                 this._oldPosition.copyFrom(candidatePos)
//                 this.grabberPilot.camera.getScene().collisionCoordinator.getNewPosition(this._oldPosition, velocity, this._collider, 3, null, this._onCollisionPositionChange, -13);
//
//             }
//
//             //private getScene():BABYLON.Scene{return this.grabberPilot.camera.getScene()}
//             private _diffPosition=new XYZ(0,0,0)
//             private _newPosition=new XYZ(0,0,0)
//             private _inter=new XYZ(0,0,0)
//             private _upPerturbation=new XYZ(0,0,0)
//             private _onCollisionPositionChange = (collisionId: number, newPosition: XYZ, collidedMesh: BABYLON.AbstractMesh = null) => {
//                 //if (this.getScene().workerCollisions) newPosition.multiplyInPlace(this._collider.constantRadius);
//
//                 this._newPosition.copyFrom(newPosition);
//                 this._newPosition.subtractToRef(this._oldPosition, this._diffPosition).scale(2)
//
//                 //this._position.copyFrom(this._newPosition)
//
//                 if (collidedMesh!=null) {
//                     cc('collision')
//                     this._upPerturbation.copyFrom(this.upVector).scale(0.005)
//                     this.position.add(this._diffPosition).add(this._upPerturbation)
//                 }
//                 else this.position.copyFrom(this._oldPosition)
//
//
//
//                 // if (this._diffPosition.length() > BABYLON.Engine.CollisionsEpsilon) {
//                 //
//                 //     this._position.add(this._diffPosition)
//                 //     //this._inter.copyFrom(this.getPosition()).add(this._diffPosition)
//                 //     //this.whishedCamPos.changePosition(this._inter,this.currentConstraints)
//                 // }
//
//                 // var updatePosition = (newPos) => {
//
//                 // }
//                 //
//                 // updatePosition(newPosition);
//             }
//
//
//
//         }
//
//
//         export class Grabber {
//
//
//             grabberCamera:GrabberCamera
//
//             parallelDisplacementInsteadOfRotation=false
//             showGrabberOnlyWhenGrabbing=true
//
//             mesh:BABYLON.Mesh
//
//             name:string
//
//             /**can stay null e.g. for plane grabber
//              * but if null no grabber rotation is possible, and no "recentring while go back" */
//             referenceCenter : XYZ=null
//             //rotationAxis:XYZ=null
//
//             onGrabbingActions=new StringMap<(alpha:number)=>void>()
//
//             //constantRadius = 1
//
//             endOfZone1=maud
//             endOfZone2=2
//             endOfZone3=10
//
//             zoneAreDefinedFromCenterRatherFromSurface=true
//
//
//
//             /**will produce no effect if no {@link Grabber.referenceCenter} is given*/
//             focusOnMyCenterWhenCameraGoDownWard=true
//
//             dispose():void{
//                 this.mesh.dispose()
//             }
//
//
//             /** return
//              * 0 is we are too close of the wrapper, so we use freeMovement
//              * 1 if wee are far, so we use pure wrapping mode
//              * between 0 and 1 we can use mixed mode (or not depending to a boolean)
//              * */
//             interpolationCoefAccordingToCamPosition(camPosition:XYZ,distCamToGrabber:number):number {
//                 //let l = geo.distance(this.rotationCenter, cameraPosition)
//                 let distance=0
//                 if (this.zoneAreDefinedFromCenterRatherFromSurface) distance=geo.distance(camPosition,this.referenceCenter)
//                 else distance=distCamToGrabber
//
//
//                 if (distance <= this.endOfZone1) return 0;
//                 if (distance >= this.endOfZone2) return 1;
//                 return (distance - this.endOfZone1) / (this.endOfZone2 - this.endOfZone1)
//
//             }
//
//             checkArgs() {
//
//                 if (this.zoneAreDefinedFromCenterRatherFromSurface && this.referenceCenter==null) throw 'you must define a reference center when zoneAreDefinedFromCenterRatherFromSurface'
//                 if (this.focusOnMyCenterWhenCameraGoDownWard && this.referenceCenter==null) throw 'you must define a reference center when focusOnMyCenterWhenCameraGoDownWard'
//
//                 if (this.endOfZone1  > this.endOfZone2) throw 'zone2 must contains zone1'
//                 if (this.endOfZone2  > this.endOfZone3) throw 'zone3 must contains zone2'
//
//             }
//
//
//             constructor(){}
//
//
//
//
//
//
//
//         }
//
//
//
//
//         export class SphericalGrabber extends Grabber{
//             public constantRadius=1
//
//             constructor(scene:BABYLON.Scene,sizes=new XYZ(maud,maud,maud),positionAndReferenceCenter=new XYZ(0,0,0),isPickable=false){
//                 super()
//                 this.constantRadius=sizes.x
//
//                 this.referenceCenter=positionAndReferenceCenter
//                 this.focusOnMyCenterWhenCameraGoDownWard=true
//                 this.parallelDisplacementInsteadOfRotation=false
//                 this.showGrabberOnlyWhenGrabbing=true
//
//                 let mesh= BABYLON.Mesh.CreateSphere("default sphere for grabbing", 10, 2, scene);
//                 mesh.position=positionAndReferenceCenter
//                 mesh.scaling=sizes
//
//                 var material = new BABYLON.StandardMaterial("texture1", scene)
//                 material.alpha = 0.3
//                 material.diffuseColor = new BABYLON.Color3(1, 1, 1)
//
//                 mesh.material = material
//
//                 this.mesh=mesh
//                 this.mesh.isPickable=isPickable
//             }
//         }
//
//
//
//         export class PlanarGrabber extends Grabber{
//
//             //quaternion=new XYZW(0,0,0,1)
//             //sizes=new XYZ(maud,maud,maud)
//
//             constructor(scene:BABYLON.Scene,sizes=new XYZ(maud,maud,maud),position=new XYZ(0,0,0),quaternion=new XYZW(0,0,0,1),isPickable=false){
//                 super()
//
//                 this.referenceCenter=null
//                 this.focusOnMyCenterWhenCameraGoDownWard=false
//                 this.parallelDisplacementInsteadOfRotation=true
//
//                 this.zoneAreDefinedFromCenterRatherFromSurface=false
//
//                 this.endOfZone1=0
//                 this.endOfZone2=0
//
//                 let mesh= BABYLON.Mesh.CreatePlane("default plane for grabbing",1,scene);
//                 mesh.position=position
//                 mesh.scaling=sizes
//                 mesh.rotationQuaternion=quaternion
//
//                 var material = new BABYLON.StandardMaterial("texture1", scene)
//                 material.alpha = 0.5
//                 material.diffuseColor = new BABYLON.Color3(1, 1, 1)
//                 //material.sideOrientation=BABYLON.Mesh.DOUBLESIDE
//                 material.backFaceCulling=false
//                 mesh.material = material
//                 this.mesh=mesh
//
//                 this.mesh.isPickable=isPickable
//
//             }
//
//         }
//
//
//
//         export class BabCamera extends BABYLON.Camera {
//
//             /**with @link super.upVector and super.position, this determine the position and the orientation of the camera */
//             //public frontDir = new Vector3(0, 0, 1)
//
//
//             private _target = new XYZ(0, 0, 0)
//
//             public wheelPrecision = 1.0;
//
//
//             public zoomOnFactor = 1;
//
//             private _attachedElement:HTMLElement;
//
//             private _onPointerDown:(e:PointerEvent) => void;
//             private _onPointerUp:(e:PointerEvent) => void;
//             private _onPointerMove:(e:PointerEvent) => void;
//             private _wheel:(e:MouseWheelEvent) => void;
//             private _onMouseMove:(e:MouseEvent) => any;
//             private _onKeyDown:(e:KeyboardEvent) => any;
//             private _onKeyUp:(e:KeyboardEvent) => any;
//             private _onLostFocus:(e:FocusEvent) => any;
//             private _reset:() => void;
//             private _onGestureStart:(e:PointerEvent) => void;
//             private _onGesture:(e:MSGestureEvent) => void;
//             private _MSGestureHandler:MSGesture;
//
//
//             private eventPrefix = Tools.GetPointerPrefix()
//
//
//             private cameraPilot:GrabberCamera
//
//
//             constructor(name:string, scene:Scene, cameraPilot:GrabberCamera) {
//
//                 //the vector in this constructor has no effect
//                 super(name, new BABYLON.Vector3(0, 0, -100), scene);
//                 this.cameraPilot = cameraPilot
//
//             }
//
//
//             // Cache
//             public _initCache() {
//                 super._initCache();
//             }
//
//
//             public _updateCache(ignoreParentClass?:boolean):void {
//
//                 if (!ignoreParentClass) {
//                     /**ici sont mis en cache, notamment upVector et position */
//                     super._updateCache();
//                 }
//
//             }
//
//             // Synchronized
//             public _isSynchronizedViewMatrix():boolean {
//                 if (!super._isSynchronizedViewMatrix()) {
//                     return false;
//                 }
//                 return this.cameraPilot.isSynchronized()
//             }
//
//             public _update():void {
//                 /**MATHIS*/
//                 this.cameraPilot.update()
//                 this.position=this.cameraPilot.trueCamPos.position
//                 this.upVector=this.cameraPilot.trueCamPos.upVector
//
//             }
//
//             /**n' est appel que si _isSynchronizedViewMatrix renvoit faux */
//             //private _viewMatrix = new BABYLON.Matrix()
//             public _getViewMatrix():Matrix {
//                 //geo.MMtoBabylonMatrix(this.cameraPilot.getViewMatrix(),this._viewMatrix)
//                 //return this._viewMatrix;
//                 return this.cameraPilot.getViewMatrix()
//             }
//
//
//             private deltaNotToBigFunction(delta:number):number {
//                 if (delta > 0.1) return 0.1
//                 if (delta < -0.1) return -0.1
//                 return delta
//             }
//
//             // Methods
//             public attachControl(element:HTMLElement, noPreventDefault?:boolean):void {
//                 var pointerId;
//
//                 if (this._attachedElement) {
//                     return;
//                 }
//                 this._attachedElement = element;
//
//                 var engine = this.getEngine();
//
//                 //if (this._onPointerDown === undefined) {
//                 this._onPointerDown = evt => {
//
//                     if (pointerId) {
//                         return;
//                     }
//
//                     pointerId = evt.pointerId;
//
//                     /**MATHIS*/
//                     this.cameraPilot.onPointerDown()
//
//
//                     if (!noPreventDefault) {
//                         evt.preventDefault();
//                     }
//                 };
//
//                 this._onPointerUp = evt => {
//
//                     pointerId = null;
//                     if (!noPreventDefault) {
//                         evt.preventDefault();
//                     }
//
//                     /**MATHIS*/
//                     this.cameraPilot.onPointerUp()
//
//                 };
//
//
//                 this._onPointerMove = evt => {
//
//                     if (pointerId !== evt.pointerId) {
//                         return;
//                     }
//
//                     var rect = element.getBoundingClientRect();
//                     //console.log(rect.top, rect.right, rect.bottom, rect.left);
//
//                     /**MATHIS*/
//                     this.cameraPilot.onPointerMove(evt.clientX - rect.left, evt.clientY - rect.top)
//
//                     if (!noPreventDefault) {
//                         evt.preventDefault();
//                     }
//                 };
//
//                 this._onMouseMove = this._onPointerMove
//
//                 //this._onMouseMove = evt => {
//                 //    if (!engine.isPointerLock) {
//                 //        return;
//                 //    }
//                 //
//                 //    var offsetX = evt.movementX || evt.mozMovementX || evt.webkitMovementX || evt.msMovementX || 0;
//                 //    var offsetY = evt.movementY || evt.mozMovementY || evt.webkitMovementY || evt.msMovementY || 0;
//                 //
//                 //    this.inertialAlphaOffset -= offsetX / this.angularSensibility;
//                 //    this.inertialBetaOffset -= offsetY / this.angularSensibility;
//                 //
//                 //    if (!noPreventDefault) {
//                 //        evt.preventDefault();
//                 //    }
//                 //};
//
//                 this._wheel = event => {
//                     var delta = 0;
//                     if (event.wheelDelta) {
//                         delta = this.deltaNotToBigFunction(event.wheelDelta / (this.wheelPrecision * 300))
//                         //delta = (event.wheelDelta / (this.wheelPrecision * 300))
//
//
//                     } else if (event.detail) {
//                         delta = this.deltaNotToBigFunction(-event.detail / (this.wheelPrecision * 30))
//
//                     }
//
//                     /**MATHIS*/
//                     if (delta) this.cameraPilot.translateCam(delta)
//
//                     if (event.preventDefault) {
//                         if (!noPreventDefault) {
//                             event.preventDefault();
//                         }
//                     }
//                 };
//
//                 this._onKeyDown = evt => {
//                     /**MATHIS*/
//                     this.cameraPilot.onKeyDown(evt)
//                 }
//
//                 this._onKeyUp = evt => {
//                     /**MATHIS*/
//                     this.cameraPilot.onKeyUp(evt)
//                 }
//
//                 this._onLostFocus = () => {
//                     this.cameraPilot._keys = [];
//                     pointerId = null;
//                 };
//
//                 this._onGestureStart = e => {
//                     if (window.MSGesture === undefined) {
//                         return;
//                     }
//
//                     if (!this._MSGestureHandler) {
//                         this._MSGestureHandler = new MSGesture();
//                         this._MSGestureHandler.target = element;
//                     }
//
//                     this._MSGestureHandler.addPointer(e.pointerId);
//                 };
//
//                 this._onGesture = e => {
//                     //TODO this.constantRadius *= e.scale;
//                     //
//                     //
//                     //if (e.preventDefault) {
//                     //    if (!noPreventDefault) {
//                     //        e.stopPropagation();
//                     //        e.preventDefault();
//                     //    }
//                     //}
//                 };
//
//                 this._reset = () => {
//                     /**MATHIS*/
//                     this.cameraPilot.reset()
//                     pointerId = null;
//                 };
//                 //}
//
//                 element.addEventListener(this.eventPrefix + "down", this._onPointerDown, false);
//                 element.addEventListener(this.eventPrefix + "up", this._onPointerUp, false);
//                 element.addEventListener(this.eventPrefix + "out", this._onPointerUp, false);
//                 element.addEventListener(this.eventPrefix + "move", this._onPointerMove, false);
//                 element.addEventListener("mousemove", this._onMouseMove, false);
//                 element.addEventListener("MSPointerDown", this._onGestureStart, false);
//                 element.addEventListener("MSGestureChange", this._onGesture, false);
//                 element.addEventListener('mousewheel', this._wheel, false);
//                 element.addEventListener('DOMMouseScroll', this._wheel, false);
//
//                 Tools.RegisterTopRootEvents([
//                     {name: "keydown", handler: this._onKeyDown},
//                     {name: "keyup", handler: this._onKeyUp},
//                     {name: "blur", handler: this._onLostFocus}
//                 ]);
//             }
//
//
//             public detachControl(element:HTMLElement):void {
//                 if (this._attachedElement != element) {
//                     return;
//                 }
//
//                 element.removeEventListener(this.eventPrefix + "down", this._onPointerDown);
//                 element.removeEventListener(this.eventPrefix + "up", this._onPointerUp);
//                 element.removeEventListener(this.eventPrefix + "out", this._onPointerUp);
//                 element.removeEventListener(this.eventPrefix + "move", this._onPointerMove);
//                 element.removeEventListener("mousemove", this._onMouseMove);
//                 element.removeEventListener("MSPointerDown", this._onGestureStart);
//                 element.removeEventListener("MSGestureChange", this._onGesture);
//                 element.removeEventListener('mousewheel', this._wheel);
//                 element.removeEventListener('DOMMouseScroll', this._wheel);
//
//                 Tools.UnregisterTopRootEvents([
//                     {name: "keydown", handler: this._onKeyDown},
//                     {name: "keyup", handler: this._onKeyUp},
//                     {name: "blur", handler: this._onLostFocus}
//                 ]);
//
//                 this._MSGestureHandler = null;
//                 this._attachedElement = null;
//
//                 if (this._reset) {
//                     this._reset();
//                 }
//             }
//
//
//         }
//
//
//
//
//     }
//
// }
//
// //
// //
// // module BABYLON {
// //     export class FreeCamera2 extends TargetCamera {
// //         public ellipsoid = new Vector3(0.5, 1, 0.5);
// //
// //         public keysUp = [38];
// //
// //         public keysDown = [40];
// //
// //         public keysLeft = [37];
// //
// //         public keysRight = [39];
// //
// //         public checkCollisions = true;//TODO
// //
// //         public applyGravity = false;
// //
// //         public angularSensibility = 2000.0;
// //
// //         public onCollide: (collidedMesh: AbstractMesh) => void;
// //
// //         private _keys = [];
// //         private _collider = new Collider();
// //         private _needMoveForGravity = false;
// //         private _oldPosition = Vector3.Zero();
// //         private _diffPosition = Vector3.Zero();
// //         private _newPosition = Vector3.Zero();
// //         private _attachedElement: HTMLElement;
// //         private _localDirection: Vector3;
// //         private _transformedDirection: Vector3;
// //
// //         private _onMouseDown: (e: MouseEvent) => any;
// //         private _onMouseUp: (e: MouseEvent) => any;
// //         private _onMouseOut: (e: MouseEvent) => any;
// //         private _onMouseMove: (e: MouseEvent) => any;
// //         private _onKeyDown: (e: KeyboardEvent) => any;
// //         private _onKeyUp: (e: KeyboardEvent) => any;
// //
// //         constructor(name: string, position: Vector3, scene: Scene) {
// //             super(name, position, scene);
// //         }
// //
// //         public _onLostFocus(e: FocusEvent): void {
// //             this._keys = [];
// //         }
// //
// //         // Controls
// //         public attachControl(element: HTMLElement, noPreventDefault?: boolean): void {
// //             var previousPosition;
// //             var engine = this.getEngine();
// //
// //             if (this._attachedElement) {
// //                 return;
// //             }
// //             this._attachedElement = element;
// //             noPreventDefault = false//Camera.ForceAttachControlToAlwaysPreventDefault ? false : noPreventDefault;
// //
// //             if (this._onMouseDown === undefined) {
// //                 this._onMouseDown = evt => {
// //                     previousPosition = {
// //                         x: evt.clientX,
// //                         y: evt.clientY
// //                     };
// //
// //                     if (!noPreventDefault) {
// //                         evt.preventDefault();
// //                     }
// //                 };
// //
// //                 this._onMouseUp = evt => {
// //                     previousPosition = null;
// //                     if (!noPreventDefault) {
// //                         evt.preventDefault();
// //                     }
// //                 };
// //
// //                 this._onMouseOut = evt => {
// //                     previousPosition = null;
// //                     this._keys = [];
// //                     if (!noPreventDefault) {
// //                         evt.preventDefault();
// //                     }
// //                 };
// //
// //                 this._onMouseMove = evt => {
// //                     if (!previousPosition && !engine.isPointerLock) {
// //                         return;
// //                     }
// //
// //                     var offsetX;
// //                     var offsetY;
// //
// //                     if (!engine.isPointerLock) {
// //                         offsetX = evt.clientX - previousPosition.x;
// //                         offsetY = evt.clientY - previousPosition.y;
// //                     } else {
// //                         offsetX = evt.movementX || evt.mozMovementX || evt.webkitMovementX || evt.msMovementX || 0;
// //                         offsetY = evt.movementY || evt.mozMovementY || evt.webkitMovementY || evt.msMovementY || 0;
// //                     }
// //
// //                     this.cameraRotation.y += offsetX / this.angularSensibility;
// //                     this.cameraRotation.x += offsetY / this.angularSensibility;
// //
// //                     previousPosition = {
// //                         x: evt.clientX,
// //                         y: evt.clientY
// //                     };
// //                     if (!noPreventDefault) {
// //                         evt.preventDefault();
// //                     }
// //                 };
// //
// //                 this._onKeyDown = evt => {
// //                     if (this.keysUp.indexOf(evt.keyCode) !== -1 ||
// //                         this.keysDown.indexOf(evt.keyCode) !== -1 ||
// //                         this.keysLeft.indexOf(evt.keyCode) !== -1 ||
// //                         this.keysRight.indexOf(evt.keyCode) !== -1) {
// //                         var index = this._keys.indexOf(evt.keyCode);
// //
// //                         if (index === -1) {
// //                             this._keys.push(evt.keyCode);
// //                         }
// //                         if (!noPreventDefault) {
// //                             evt.preventDefault();
// //                         }
// //                     }
// //                 };
// //
// //                 this._onKeyUp = evt => {
// //                     if (this.keysUp.indexOf(evt.keyCode) !== -1 ||
// //                         this.keysDown.indexOf(evt.keyCode) !== -1 ||
// //                         this.keysLeft.indexOf(evt.keyCode) !== -1 ||
// //                         this.keysRight.indexOf(evt.keyCode) !== -1) {
// //                         var index = this._keys.indexOf(evt.keyCode);
// //
// //                         if (index >= 0) {
// //                             this._keys.splice(index, 1);
// //                         }
// //                         if (!noPreventDefault) {
// //                             evt.preventDefault();
// //                         }
// //                     }
// //                 };
// //
// //                 this._reset = () => {
// //                     this._keys = [];
// //                     previousPosition = null;
// //                     this.cameraDirection = new Vector3(0, 0, 0);
// //                     this.cameraRotation = new Vector2(0, 0);
// //                 };
// //             }
// //
// //             element.addEventListener("mousedown", this._onMouseDown, false);
// //             element.addEventListener("mouseup", this._onMouseUp, false);
// //             element.addEventListener("mouseout", this._onMouseOut, false);
// //             element.addEventListener("mousemove", this._onMouseMove, false);
// //
// //             Tools.RegisterTopRootEvents([
// //                 { name: "keydown", handler: this._onKeyDown },
// //                 { name: "keyup", handler: this._onKeyUp },
// //                 { name: "blur", handler: this._onLostFocus }
// //             ]);
// //         }
// //
// //         public detachControl(element: HTMLElement): void {
// //             if (this._attachedElement !== element) {
// //                 return;
// //             }
// //
// //             element.removeEventListener("mousedown", this._onMouseDown);
// //             element.removeEventListener("mouseup", this._onMouseUp);
// //             element.removeEventListener("mouseout", this._onMouseOut);
// //             element.removeEventListener("mousemove", this._onMouseMove);
// //
// //             Tools.UnregisterTopRootEvents([
// //                 { name: "keydown", handler: this._onKeyDown },
// //                 { name: "keyup", handler: this._onKeyUp },
// //                 { name: "blur", handler: this._onLostFocus }
// //             ]);
// //
// //             this._attachedElement = null;
// //             if (this._reset) {
// //                 this._reset();
// //             }
// //         }
// //
// //         public _collideWithWorld(velocity: Vector3): void {
// //             var globalPosition: Vector3;
// //
// //             if (this.parent) {
// //                 globalPosition = Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix());
// //             } else {
// //                 globalPosition = this.position;
// //             }
// //
// //             globalPosition.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition);
// //             this._collider.constantRadius = this.ellipsoid;
// //
// //             //no need for clone, as long as gravity is not on.
// //             var actualVelocity = velocity;
// //
// //             //add gravity to the velocity to prevent the dual-collision checking
// //             if (this.applyGravity) {
// //                 //this prevents mending with cameraDirection, a global variable of the free camera class.
// //                 actualVelocity = velocity.add(this.getScene().gravity);
// //             }
// //
// //             this.getScene().collisionCoordinator.getNewPosition(this._oldPosition, actualVelocity, this._collider, 3, null, this._onCollisionPositionChange, -13);
// //
// //         }
// //
// //         private _onCollisionPositionChange = (collisionId: number, newPosition: Vector3, collidedMesh: AbstractMesh = null) => {
// //             //TODO move this to the collision coordinator!
// //             if (this.getScene().workerCollisions)
// //                 newPosition.multiplyInPlace(this._collider.constantRadius);
// //
// //             var updatePosition = (newPos) => {
// //                 this._newPosition.copyFrom(newPos);
// //
// //                 this._newPosition.subtractToRef(this._oldPosition, this._diffPosition);
// //
// //                 cc('this._diffPosition',this._diffPosition)
// //                 var oldPosition = this.position.clone();
// //                 if (this._diffPosition.length() > Engine.CollisionsEpsilon) {
// //                     this.position.addInPlace(this._diffPosition);
// //                     if (this.onCollide && collidedMesh) {
// //                         this.onCollide(collidedMesh);
// //                     }
// //                 }
// //             }
// //
// //             updatePosition(newPosition);
// //         }
// //
// //         public _checkInputs(): void {
// //             if (!this._localDirection) {
// //                 this._localDirection = Vector3.Zero();
// //                 this._transformedDirection = Vector3.Zero();
// //             }
// //
// //             // Keyboard
// //             for (var index = 0; index < this._keys.length; index++) {
// //                 var keyCode = this._keys[index];
// //                 var speed = this._computeLocalCameraSpeed();
// //
// //                 if (this.keysLeft.indexOf(keyCode) !== -1) {
// //                     this._localDirection.copyFromFloats(-speed, 0, 0);
// //                 } else if (this.keysUp.indexOf(keyCode) !== -1) {
// //                     this._localDirection.copyFromFloats(0, 0, speed);
// //                 } else if (this.keysRight.indexOf(keyCode) !== -1) {
// //                     this._localDirection.copyFromFloats(speed, 0, 0);
// //                 } else if (this.keysDown.indexOf(keyCode) !== -1) {
// //                     this._localDirection.copyFromFloats(0, 0, -speed);
// //                 }
// //
// //                 this.getViewMatrix().invertToRef(this._cameraTransformMatrix);
// //                 Vector3.TransformNormalToRef(this._localDirection, this._cameraTransformMatrix, this._transformedDirection);
// //                 this.cameraDirection.addInPlace(this._transformedDirection);
// //             }
// //
// //             super._checkInputs();
// //         }
// //
// //         public _decideIfNeedsToMove(): boolean {
// //             return this._needMoveForGravity || Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;
// //         }
// //
// //         public _updatePosition(): void {
// //             if (this.checkCollisions && this.getScene().collisionsEnabled) {
// //                 this._collideWithWorld(this.cameraDirection);
// //             } else {
// //                 this.position.addInPlace(this.cameraDirection);
// //             }
// //         }
// //
// //         public getTypeName(): string {
// //             return "FreeCamera";
// //         }
// //     }
// // }
///**
// * Created by vigon on 25/01/2016.
// */
//
//
//module mathis{
//
//
//
//
//    export module morpher{
//
//
//        export class Reliefer{
//
//            private mamesh:Mamesh
//            private map:(param:XYZ)=>XYZ
//
//            constructor(mamesh:Mamesh,map:(param:XYZ)=>XYZ){
//                this.IN_mamesh=IN_mamesh
//                this.map=map
//            }
//
//            goChanging(){
//                this.mamesh.vertices.forEach((vertex:Vertex)=>{
//
//                })
//            }
//
//
//
//        }
//
//
//    }
//
//    export module relief{
//
//
//        //export function apply(mamesh:Mamesh,map:(param:XYZ)=>XYZ){
//        //
//        //    mamesh.vertices.forEach((vert:Vertex)=>{
//        //        vert.position=map(vert.mapParam)
//        //    })
//        //
//        //}
//
//
//
//    }
//
//
//
//} 
// /**
//  * Created by vigon on 06/04/2016.
//  */
//
//
//
//
//
//
//
// /**these last methods are not use finaly*/
//
// export class TubeVertexData{
//
//     path: XYZ[]
//     constantRadius: number=1
//     tessellation: number=64
//     radiusFunction: { (i: number, distance: number): number; }
//     cap: number=Mesh.NO_CAP
//     arc: number=1
//     updatable: boolean
//     sideOrientation: number =Mesh.FRONTSIDE
//
//
//
//
//     private _rotationMatrix=new MM()
//
//     constructor(path:XYZ[]){
//         this.path=path
//     }
//
//     goChanging():VertexData{
//         // tube geometry
//         var tubePathArray = (path, path3D, circlePaths, constantRadius, tessellation, radiusFunction, cap, arc) => {
//             var tangents = path3D.getTangents();
//             var normals = path3D.getNormals();
//             var distances = path3D.getDistances();
//             var pi2 = Math.PI * 2;
//             var step = pi2 / tessellation * arc;
//             var returnRadius: { (i: number, distance: number): number; } = () => constantRadius;
//             var radiusFunctionFinal: { (i: number, distance: number): number; } = radiusFunction || returnRadius;
//
//             var circlePath: XYZ[];
//             var rad: number;
//             var normal: XYZ;
//             var rotated: XYZ;
//             var rotationMatrix=this._rotationMatrix
//             var index = (cap === Mesh._NO_CAP || cap === Mesh.CAP_END) ? 0 : 2;
//             for (var i = 0; i < path.length; i++) {
//                 rad = radiusFunctionFinal(i, distances[i]); // current constantRadius
//                 circlePath = Array<XYZ>();              // current circle array
//                 normal = normals[i];                        // current normal
//                 for (var t = 0; t < tessellation; t++) {
//                     geo.axisAngleToMatrix(tangents[i], step * t, rotationMatrix)
//                     //Matrix.RotationAxisToRef();
//                     rotated = circlePath[t] ? circlePath[t] : new XYZ(0,0,0)
//                     XYZ.TransformCoordinatesToRef(normal, rotationMatrix, rotated);
//                     rotated.scaleInPlace(rad).addInPlace(path[i]);
//                     circlePath[t] = rotated;
//                 }
//                 circlePaths[index] = circlePath;
//                 index++;
//             }
//             // cap
//             var capPath = (nbPoints, pathIndex) => {
//                 var pointCap = Array<XYZ>();
//                 for (var i = 0; i < nbPoints; i++) {
//                     pointCap.push(path[pathIndex]);
//                 }
//                 return pointCap;
//             };
//             switch (cap) {
//                 case Mesh.NO_CAP:
//                     break;
//                 case Mesh.CAP_START:
//                     circlePaths[0] = capPath(tessellation, 0);
//                     circlePaths[1] = circlePaths[2].slice(0);
//                     break;
//                 case Mesh.CAP_END:
//                     circlePaths[index] = circlePaths[index - 1].slice(0);
//                     circlePaths[index + 1] = capPath(tessellation, path.length - 1);
//                     break;
//                 case Mesh.CAP_ALL:
//                     circlePaths[0] = capPath(tessellation, 0);
//                     circlePaths[1] = circlePaths[2].slice(0);
//                     circlePaths[index] = circlePaths[index - 1].slice(0);
//                     circlePaths[index + 1] = capPath(tessellation, path.length - 1);
//                     break;
//                 default:
//                     break;
//             }
//             return circlePaths;
//         };
//         var path3D;
//         var pathArray;
//
//         path3D = <any>new Path3D(this.path);
//         var newPathArray = new Array<Array<XYZ>>();
//         pathArray = tubePathArray(this.path, path3D, newPathArray, this.constantRadius, this.tessellation, this.radiusFunction, this.cap, this.arc);
//
//         let ribbonVertexData=new RibbonVertexData(pathArray)
//         ribbonVertexData.closePath=true
//         return ribbonVertexData.goChanging()
//
//     }
// }
//
// //
// //function CreateTube(name: string, options: { path: Vector3[], constantRadius?: number, tessellation?: number, radiusFunction?: { (i: number, distance: number): number; }, cap?: number, arc?: number, updatable?: boolean, sideOrientation?: number, instance?: Mesh }, scene: Scene): Mesh {
// //    var path = options.path;
// //    var constantRadius = options.constantRadius || 1;
// //    var tessellation = options.tessellation || 64;
// //    var radiusFunction = options.radiusFunction;
// //    var cap = options.cap || Mesh.NO_CAP;
// //    var updatable = options.updatable;
// //    var sideOrientation = options.sideOrientation || Mesh.DEFAULTSIDE;
// //    var instance = options.instance;
// //    options.arc = (options.arc <= 0 || options.arc > 1) ? 1 : options.arc || 1;
// //
// //    // tube geometry
// //    var tubePathArray = (path, path3D, circlePaths, constantRadius, tessellation, radiusFunction, cap, arc) => {
// //        var tangents = path3D.getTangents();
// //        var normals = path3D.getNormals();
// //        var distances = path3D.getDistances();
// //        var pi2 = Math.PI * 2;
// //        var step = pi2 / tessellation * arc;
// //        var returnRadius: { (i: number, distance: number): number; } = () => constantRadius;
// //        var radiusFunctionFinal: { (i: number, distance: number): number; } = radiusFunction || returnRadius;
// //
// //        var circlePath: Vector3[];
// //        var rad: number;
// //        var normal: Vector3;
// //        var rotated: Vector3;
// //        var rotationMatrix: Matrix = Tmp.Matrix[0];
// //        var index = (cap === Mesh._NO_CAP || cap === Mesh.CAP_END) ? 0 : 2;
// //        for (var i = 0; i < path.length; i++) {
// //            rad = radiusFunctionFinal(i, distances[i]); // current constantRadius
// //            circlePath = Array<Vector3>();              // current circle array
// //            normal = normals[i];                        // current normal
// //            for (var t = 0; t < tessellation; t++) {
// //                Matrix.RotationAxisToRef(tangents[i], step * t, rotationMatrix);
// //                rotated = circlePath[t] ? circlePath[t] : Vector3.Zero();
// //                Vector3.TransformCoordinatesToRef(normal, rotationMatrix, rotated);
// //                rotated.scaleInPlace(rad).addInPlace(path[i]);
// //                circlePath[t] = rotated;
// //            }
// //            circlePaths[index] = circlePath;
// //            index++;
// //        }
// //        // cap
// //        var capPath = (nbPoints, pathIndex) => {
// //            var pointCap = Array<Vector3>();
// //            for (var i = 0; i < nbPoints; i++) {
// //                pointCap.push(path[pathIndex]);
// //            }
// //            return pointCap;
// //        };
// //        switch (cap) {
// //            case Mesh.NO_CAP:
// //                break;
// //            case Mesh.CAP_START:
// //                circlePaths[0] = capPath(tessellation, 0);
// //                circlePaths[1] = circlePaths[2].slice(0);
// //                break;
// //            case Mesh.CAP_END:
// //                circlePaths[index] = circlePaths[index - 1].slice(0);
// //                circlePaths[index + 1] = capPath(tessellation, path.length - 1);
// //                break;
// //            case Mesh.CAP_ALL:
// //                circlePaths[0] = capPath(tessellation, 0);
// //                circlePaths[1] = circlePaths[2].slice(0);
// //                circlePaths[index] = circlePaths[index - 1].slice(0);
// //                circlePaths[index + 1] = capPath(tessellation, path.length - 1);
// //                break;
// //            default:
// //                break;
// //        }
// //        return circlePaths;
// //    };
// //    var path3D;
// //    var pathArray;
// //    if (instance) { // tube update
// //        var arc = options.arc || (<any>instance).arc;
// //        path3D = ((<any>instance).path3D).update(path);
// //        pathArray = tubePathArray(path, path3D, (<any>instance).pathArray, constantRadius, (<any>instance).tessellation, radiusFunction, (<any>instance).cap, arc);
// //        instance = MeshBuilder.CreateRibbon(null, { pathArray: pathArray, instance: instance });
// //        (<any>instance).path3D = path3D;
// //        (<any>instance).pathArray = pathArray;
// //        (<any>instance).arc = arc;
// //
// //        return instance;
// //
// //    }
// //    // tube creation
// //    path3D = <any>new Path3D(path);
// //    var newPathArray = new Array<Array<Vector3>>();
// //    cap = (cap < 0 || cap > 3) ? 0 : cap;
// //    pathArray = tubePathArray(path, path3D, newPathArray, constantRadius, tessellation, radiusFunction, cap, options.arc);
// //    var tube = MeshBuilder.CreateRibbon(name, { pathArray: pathArray, closePath: true, closeArray: false, updatable: updatable, sideOrientation: sideOrientation }, scene);
// //    (<any>tube).pathArray = pathArray;
// //    (<any>tube).path3D = path3D;
// //    (<any>tube).tessellation = tessellation;
// //    (<any>tube).cap = cap;
// //    (<any>tube).arc = options.arc;
// //
// //    return tube;
// //}
//
//
// export class RibbonVertexData{
//
//     pathArray: XYZ[][]
//     closeArray = false;
//     closePath =  false;
//     sideOrientation: number =  Mesh.DOUBLESIDE;
//     offset=0
//
//     constructor(pathArray: XYZ[][]){
//         this.pathArray=pathArray
//     }
//
//
//     goChanging(){
//         var positions: number[] = [];
//         var indices: number[] = [];
//         var normals: number[] = [];
//         var uvs: number[] = [];
//
//         var us: number[][] = [];        		// us[path_id] = [uDist1, uDist2, uDist3 ... ] distances between points on path path_id
//         var vs: number[][] = [];        		// vs[i] = [vDist1, vDist2, vDist3, ... ] distances between points i of consecutives paths from pathArray
//         var uTotalDistance: number[] = []; 		// uTotalDistance[p] : total distance of path p
//         var vTotalDistance: number[] = []; 		//  vTotalDistance[i] : total distance between points i of first and last path from pathArray
//         var minlg: number;          	        // minimal length among all paths from pathArray
//         var lg: number[] = [];        		    // array of path lengths : nb of vertex per path
//         var idx: number[] = [];       		    // array of path indexes : index of each path (first vertex) in the total vertex number
//         var p: number;							// path iterator
//         var i: number;							// point iterator
//         var j: number;							// point iterator
//
//         // if single path in pathArray
//         if (this.pathArray.length < 2) {
//             var ar1: XYZ[] = [];
//             var ar2: XYZ[] = [];
//             for (i = 0; i < this.pathArray[0].length - this.offset; i++) {
//                 ar1.push(this.pathArray[0][i]);
//                 ar2.push(this.pathArray[0][i + this.offset]);
//             }
//             this.pathArray = [ar1, ar2];
//         }
//
//         // positions and horizontal distances (u)
//         var idc: number = 0;
//         var closePathCorr: number = (this.closePath) ? 1 : 0;
//         var path: XYZ[];
//         var l: number;
//         minlg = this.pathArray[0].length;
//         var vectlg: number;
//         var dist: number;
//         for (p = 0; p < this.pathArray.length; p++) {
//             uTotalDistance[p] = 0;
//             us[p] = [0];
//             path = this.pathArray[p];
//             l = path.length;
//             minlg = (minlg < l) ? minlg : l;
//
//             j = 0;
//             while (j < l) {
//                 positions.push(path[j].x, path[j].y, path[j].z);
//                 if (j > 0) {
//                     vectlg = path[j].subtract(path[j - 1]).length();
//                     dist = vectlg + uTotalDistance[p];
//                     us[p].push(dist);
//                     uTotalDistance[p] = dist;
//                 }
//                 j++;
//             }
//
//             if (this.closePath) {
//                 j--;
//                 positions.push(path[0].x, path[0].y, path[0].z);
//                 vectlg = path[j].subtract(path[0]).length();
//                 dist = vectlg + uTotalDistance[p];
//                 us[p].push(dist);
//                 uTotalDistance[p] = dist;
//             }
//
//             lg[p] = l + closePathCorr;
//             idx[p] = idc;
//             idc += (l + closePathCorr);
//         }
//
//         // vertical distances (v)
//         var path1: XYZ[];
//         var path2: XYZ[];
//         var vertex1: XYZ;
//         var vertex2: XYZ;
//         for (i = 0; i < minlg + closePathCorr; i++) {
//             vTotalDistance[i] = 0;
//             vs[i] = [0];
//             for (p = 0; p < this.pathArray.length - 1; p++) {
//                 path1 = this.pathArray[p];
//                 path2 = this.pathArray[p + 1];
//                 if (i === minlg) {   // closePath
//                     vertex1 = path1[0];
//                     vertex2 = path2[0];
//                 }
//                 else {
//                     vertex1 = path1[i];
//                     vertex2 = path2[i];
//                 }
//                 vectlg = vertex2.subtract(vertex1).length();
//                 dist = vectlg + vTotalDistance[i];
//                 vs[i].push(dist);
//                 vTotalDistance[i] = dist;
//             }
//             if (this.closeArray) {
//                 path1 = this.pathArray[p];
//                 path2 = this.pathArray[0];
//                 if (i === minlg) {   // closePath
//                     vertex2 = path2[0];
//                 }
//                 vectlg = vertex2.subtract(vertex1).length();
//                 dist = vectlg + vTotalDistance[i];
//                 vTotalDistance[i] = dist;
//             }
//         }
//
//
//         // uvs
//         var u: number;
//         var v: number;
//         for (p = 0; p < this.pathArray.length; p++) {
//             for (i = 0; i < minlg + closePathCorr; i++) {
//                 u = us[p][i] / uTotalDistance[p];
//                 v = vs[i][p] / vTotalDistance[i];
//                 uvs.push(u, v);
//             }
//         }
//
//         // indices
//         p = 0;                    					// path index
//         var pi: number = 0;                    		// positions array index
//         var l1: number = lg[p] - 1;           		// path1 length
//         var l2: number = lg[p + 1] - 1;         	// path2 length
//         var min: number = (l1 < l2) ? l1 : l2;   	// current path stop index
//         var shft: number = idx[1] - idx[0];         // shift
//         var path1nb: number = this.closeArray ? lg.length : lg.length - 1;     // number of path1 to iterate	on
//
//         while (pi <= min && p < path1nb) {       	//  stay under min and don't goChanging over next to last path
//             // draw two triangles between path1 (p1) and path2 (p2) : (p1.pi, p2.pi, p1.pi+1) and (p2.pi+1, p1.pi+1, p2.pi) clockwise
//
//             indices.push(pi, pi + shft, pi + 1);
//             indices.push(pi + shft + 1, pi + 1, pi + shft);
//             pi += 1;
//             if (pi === min) {                   			// if end of one of two consecutive paths reached, goChanging to next existing path
//                 p++;
//                 if (p === lg.length - 1) {                 // last path of pathArray reached <=> closeArray == true
//                     shft = idx[0] - idx[p];
//                     l1 = lg[p] - 1;
//                     l2 = lg[0] - 1;
//                 }
//                 else {
//                     shft = idx[p + 1] - idx[p];
//                     l1 = lg[p] - 1;
//                     l2 = lg[p + 1] - 1;
//                 }
//                 pi = idx[p];
//                 min = (l1 < l2) ? l1 + pi : l2 + pi;
//             }
//         }
//
//         // normals
//         VertexData.ComputeNormals(positions, indices, normals);
//
//         if (this.closePath) {
//             var indexFirst: number = 0;
//             var indexLast: number = 0;
//             for (p = 0; p < this.pathArray.length; p++) {
//                 indexFirst = idx[p] * 3;
//                 if (p + 1 < this.pathArray.length) {
//                     indexLast = (idx[p + 1] - 1) * 3;
//                 }
//                 else {
//                     indexLast = normals.length - 3;
//                 }
//                 normals[indexFirst] = (normals[indexFirst] + normals[indexLast]) * 0.5;
//                 normals[indexFirst + 1] = (normals[indexFirst + 1] + normals[indexLast + 1]) * 0.5;
//                 normals[indexFirst + 2] = (normals[indexFirst + 2] + normals[indexLast + 2]) * 0.5;
//                 normals[indexLast] = normals[indexFirst];
//                 normals[indexLast + 1] = normals[indexFirst + 1];
//                 normals[indexLast + 2] = normals[indexFirst + 2];
//             }
//         }
//
//         // sides
//         _ComputeSides(this.sideOrientation, positions, indices, normals, uvs);
//
//         // Result
//         var vertexData = new VertexData();
//
//         vertexData.indices = indices;
//         vertexData.positions = positions;
//         vertexData.normals = normals;
//         vertexData.uvs = uvs;
//
//         /**alors a, a quoi cela sert ???*/
//         if (this.closePath) {
//             (<any>vertexData)._idx = idx;
//         }
//
//         return vertexData;
//     }
//
//
// }
//
//
//
// function _ComputeSides(sideOrientation: number, positions: number[] | Float32Array, indices: number[] | Float32Array, normals: number[] | Float32Array, uvs: number[] | Float32Array) {
//     var li: number = indices.length;
//     var ln: number = normals.length;
//     var i: number;
//     var n: number;
//     sideOrientation = sideOrientation || Mesh.DEFAULTSIDE;
//
//     switch (sideOrientation) {
//
//         case Mesh.FRONTSIDE:
//             // nothing changed
//             break;
//
//         case Mesh.BACKSIDE:
//             var tmp: number;
//             // indices
//             for (i = 0; i < li; i += 3) {
//                 tmp = indices[i];
//                 indices[i] = indices[i + 2];
//                 indices[i + 2] = tmp;
//             }
//             // normals
//             for (n = 0; n < ln; n++) {
//                 normals[n] = -normals[n];
//             }
//             break;
//
//         case Mesh.DOUBLESIDE:
//             // positions
//             var lp: number = positions.length;
//             var l: number = lp / 3;
//             for (var p = 0; p < lp; p++) {
//                 positions[lp + p] = positions[p];
//             }
//             // indices
//             for (i = 0; i < li; i += 3) {
//                 indices[i + li] = indices[i + 2] + l;
//                 indices[i + 1 + li] = indices[i + 1] + l;
//                 indices[i + 2 + li] = indices[i] + l;
//             }
//             // normals
//             for (n = 0; n < ln; n++) {
//                 normals[ln + n] = -normals[n];
//             }
//
//             // uvs
//             var lu: number = uvs.length;
//             for (var u: number = 0; u < lu; u++) {
//                 uvs[u + lu] = uvs[u];
//             }
//             break;
//     }
// }
//
///**
// * Created by vigon on 04/12/2015.
// */
//
//module mathis {
//
//
//    export function surfaceCreatorTest():Bilan {
//
//
//        let bilan = new Bilan(0, 0)
//
//
//
//        let mmc =new MameshCreator()
//
//
//        {
//            let mamesh=mmc.createSquareWithOneDiag(false)
//            let mmm=new MameshManipulator(mamesh)
//            mmm.doTriangleDichotomy(false,[IN_mamesh.vertices[0],IN_mamesh.vertices[1],IN_mamesh.vertices[3]])
//            mmm.makeLinksFromTrianglesAndSquares()
//
//        }
//
//
//        {
//            let meshSquareBis = mmc.createSquareWithOneDiag(false,false)
//
//            let mmmBis=new MameshManipulator(meshSquareBis)
//            mmmBis.doTriangleDichotomy(false)
//
//            mmmBis.makeLinksFromTrianglesAndSquares()
//
//        }
//
//
//
//
//        {
//            let meshSquare = mmc.createSquareWithOneDiag(true,false)
//            let mmm=new MameshManipulator(meshSquare)
//            mmm.doTriangleDichotomy( true)
//            mmm.fillLineCatalogue()
//
//            let meshSquareBis = mmc.createSquareWithOneDiag(false,false)
//            let mmmBis=new MameshManipulator(meshSquareBis)
//            mmmBis.doTriangleDichotomy( false)
//            mmmBis.makeLinksFromTrianglesAndSquares()
//            mmmBis.fillLineCatalogue()
//            bilan.assertTrue(meshSquareBis.equalAsGraph(meshSquare))
//        }
//
//
//
//
//
//
//
//
//
//        {
//
//            let meshTriangleLinksMadeAtTheEnd = mmc.createTriangle(false, true)
//            let mmm=new MameshManipulator(meshTriangleLinksMadeAtTheEnd)
//            mmm.doTriangleDichotomy( false)
//            mmm.makeLinksFromTrianglesAndSquares()
//
//        }
//
//
//        //{
//        //    let meshTriangleLinksMadeAtEachDicho=mmc.createTriangle(true,true)
//        //    cc(meshTriangleLinksMadeAtEachDicho.toString())
//        //
//        //    {
//        //        let mmm = new MameshManipulator(meshTriangleLinksMadeAtEachDicho)
//        //        mmm.doTriangleDichotomy(true)
//        //        //mmm.doTriangleDichotomy(true)
//        //        //mmm.doTriangleDichotomy(true)
//        //        //mmm.doTriangleDichotomy(true)
//        //        //mmm.doTriangleDichotomy(true)
//        //    }
//        //    cc(meshTriangleLinksMadeAtEachDicho.toString())
//        //
//        //}
//
//
//        //{
//        //
//        //    let time1=performance.now()
//        //    let meshTriangleLinksMadeAtTheEnd=mmc.createTriangle(false,true)
//        //    {
//        //        let mmm = new MameshManipulator(meshTriangleLinksMadeAtTheEnd)
//        //        mmm.doTriangleDichotomy(false)
//        //        mmm.doTriangleDichotomy(false)
//        //        mmm.doTriangleDichotomy(false)
//        //        mmm.doTriangleDichotomy(false)
//        //        mmm.doTriangleDichotomy(false)
//        //        mmm.doTriangleDichotomy(false)
//        //
//        //        mmm.createPolygonesFromSmallestTrianglesAnSquares()
//        //        mmm.makeLinksFromTrianglesAndSquares()
//        //    }
//        //    let tt1=performance.now()-time1
//        //    cc('angles sharp',tt1)
//        //
//        //
//        //}
//        //{
//        //
//        //    let time1=performance.now()
//        //    let meshTriangleLinksMadeAtTheEnd=mmc.createTriangle(false,false)
//        //    {
//        //        let mmm = new MameshManipulator(meshTriangleLinksMadeAtTheEnd)
//        //        mmm.doTriangleDichotomy(false)
//        //        mmm.doTriangleDichotomy(false)
//        //        mmm.doTriangleDichotomy(false)
//        //        mmm.doTriangleDichotomy(false)
//        //        mmm.doTriangleDichotomy(false)
//        //        mmm.doTriangleDichotomy(false)
//        //
//        //        mmm.createPolygonesFromSmallestTrianglesAnSquares()
//        //        mmm.makeLinksFromTrianglesAndSquares()
//        //    }
//        //    let tt1=performance.now()-time1
//        //    cc('angles rond',tt1)
//        //
//        //
//        //}
//
//
//
//
//        function twoWays(sharpAngle){
//            let time0=performance.now()
//            let meshTriangleLinksMadeAtEachDicho=mmc.createTriangle(true,sharpAngle)
//            {
//                let mmm = new MameshManipulator(meshTriangleLinksMadeAtEachDicho)
//                mmm.doTriangleDichotomy(true)
//                mmm.doTriangleDichotomy(true)
//                mmm.doTriangleDichotomy(true)
//                mmm.doTriangleDichotomy(true)
//                mmm.doTriangleDichotomy(true)
//                mmm.doTriangleDichotomy(true)
//
//            }
//            let tt0=performance.now()-time0
//
//
//            let time1=performance.now()
//            let meshTriangleLinksMadeAtTheEnd=mmc.createTriangle(false,sharpAngle)
//            {
//                let mmm = new MameshManipulator(meshTriangleLinksMadeAtTheEnd)
//                mmm.doTriangleDichotomy(false)
//                mmm.doTriangleDichotomy(false)
//                mmm.doTriangleDichotomy(false)
//                mmm.doTriangleDichotomy(false)
//                mmm.doTriangleDichotomy(false)
//                mmm.doTriangleDichotomy(false)
//
//                mmm.makeLinksFromTrianglesAndSquares()
//            }
//            let tt1=performance.now()-time1
//
//
//            /**le temps de la procdure <<au fur et a mesure>> doit tre infrieure au temps de la <<procdure d'un coup>>*/
//            bilan.assertTrue(tt0<tt1)
//            /** et les deux graphes doivent tre gaux */
//
//
//            //cc('meshTriangleLinksMadeAtEachDicho',meshTriangleLinksMadeAtEachDicho.toString())
//            //cc('meshTriangleLinksMadeAtTheEnd',meshTriangleLinksMadeAtTheEnd.toString())
//
//            bilan.assertTrue(meshTriangleLinksMadeAtEachDicho.equalAsGraph(meshTriangleLinksMadeAtTheEnd))
//
//        }
//
//        twoWays(true)
//        twoWays(false)
//
//
//
//
//
//
//
//        {
//            let twoDiagSquareMesh = mmc.createSquareWithTwoDiag(true)
//            let mmm=new MameshManipulator(twoDiagSquareMesh)
//            mmm.doTriangleDichotomy( true)
//
//            let twoDiagSquareMeshBis = mmc.createSquareWithTwoDiag(false)
//            let mmmBis=new MameshManipulator(twoDiagSquareMeshBis)
//            mmmBis.doTriangleDichotomy( false)
//            mmmBis.makeLinksFromTrianglesAndSquares()
//
//            bilan.assertTrue(twoDiagSquareMeshBis.equalAsGraph(twoDiagSquareMesh))
//        }
//
//
//
//        {
//            let meshPoly3 = mmc.createPolygone(3)
//            let mmm = new MameshManipulator(meshPoly3)
//            mmm.fillLineCatalogue()
//            bilan.assertTrue(meshPoly3.straightLines.length == 3)
//        }
//        {
//
//
//            let meshPoly4 = mmc.createPolygone(4)
//            let mmm = new MameshManipulator(meshPoly4)
//            mmm.fillLineCatalogue()
//            bilan.assertTrue(meshPoly4.straightLines.length == 6)
//
//        }
//        {
//
//            let meshPoly4 = mmc.createPolygone(4, true)
//            let mmm = new MameshManipulator(meshPoly4)
//            mmm.fillLineCatalogue()
//            bilan.assertTrue(meshPoly4.straightLines.length == 2)
//        }
//        {
//            let meshPoly13=mmc.createPolygone(13,true)
//            let mmm = new MameshManipulator(meshPoly13)
//            mmm.fillLineCatalogue()
//            bilan.assertTrue(meshPoly13.straightLines.length==13 && meshPoly13.loopLines.length==1 )
//        }
//
//        //TODO remake these test
//        //{
//        //    let a=[23,456,4567,1,2,3,4,5,6,7,8,9]
//        //    let b=[23,456,4567,4,5,6]
//        //    let c=mmm.removeTriangleFromList(a,b)
//        //
//        //    bilan.assertTrue(JSON.stringify([1,2,3,7,8,9])==JSON.stringify(c))
//        //    a=[5,6,7,8,1,2,3,4,13,123,123,123]
//        //    b=[1,2,3,4]
//        //    c=mmm.removeSquareFromList(a,b)
//        //    bilan.assertTrue(JSON.stringify([5,6,7,8,13,123,123,123])==JSON.stringify(c))
//        //
//        //
//        //}
//
//
//{
//
//    let mamesh=mmc.createSquareWithTwoDiag(true)
//    let mmm=new MameshManipulator(mamesh)
//    mmm.doTriangleDichotomy(true,[IN_mamesh.vertices[0],IN_mamesh.vertices[1],IN_mamesh.vertices[4],IN_mamesh.vertices[1],IN_mamesh.vertices[2],IN_mamesh.vertices[4]])
//    mmm.fillLineCatalogue()
//    let compt=[0,0,0,0,0,0]
//    for (let line of mamesh.straightLines){
//        compt[line.length]++
//    }
//    bilan.assertTrue(JSON.stringify(compt)=='[0,0,4,4,1,1]')
//}
//
//
//
//
//
//
//        return bilan
//    }
//
//} 
//
// module mathis {
//
//
//     import Polyhedron = mathis.creation3D.PolyhedronStatic;
//     import Vector3=BABYLON.Vector3
//     import VertexBuffer = BABYLON.VertexBuffer;
//     import Mesh = BABYLON.Mesh;
//     import Color3 = BABYLON.Color3;
//     import GrabberCamera = mathis.macamera.GrabberCamera;
//
//     export module testWithBabylon{
//
//         import Multiply = mathis.periodicWorld.Multiply;
//         import FreeCamera = BABYLON.FreeCamera;
//         import InstancedMesh = BABYLON.InstancedMesh;
//         import Grabber = mathis.macamera.Grabber;
//         import GrabberCamera = mathis.macamera.GrabberCamera;
//         import Action = BABYLON.Action;
//         import AbstractMesh = BABYLON.AbstractMesh;
//         import StandardMaterial = BABYLON.StandardMaterial;
//
//
//         export function startSeveralFrame(){
//
//
//             let mainDiv:HTMLElement=document.getElementById("mainDiv");
//             let canvass=mathis.nCanvasInOneLine(2,mainDiv)
//
//             var secondFrame=new mathis.MathisFrame()
//             secondFrame.canvas=canvass[0]
//             secondFrame.goChanging()
//             testOneGrabber(secondFrame,new BABYLON.Color3(1,0,0))
//
//
//             var starter=new mathis.MathisFrame()
//             starter.canvas=canvass[1]
//             starter.goChanging()
//             testOneGrabber(starter,new BABYLON.Color3(0,0,1))
//
//
//             //mainDiv.innerHTML=mathis.twoCanvas//"<div style='width: 10%;height: 10px;background-color: red'></div>"
//
//
//
//
//
//
//
//         }
//
//
//         export function start(){
//             let mainDiv:HTMLElement=document.getElementById("mainDiv");
//
//             let canvass=mathis.nCanvasInOneLine(2,mainDiv)
//
//             let frame =new MathisFrame()
//             frame.canvas=canvass[0]
//             frame.goChanging()
//
//             let frame2 =new MathisFrame()
//             frame2.canvas=canvass[1]
//             frame2.goChanging()
//
//             GaussCurvarture(frame,frame2,mainDiv)
//
//         }
//
//
//
//         //
//         //
//         // function testSymm(mathisFrame:MathisFrame){
//         //     let macam = new macamera.GrabberCamera(mathisFrame.scene)
//         //     macam.changePosition(new XYZ(0,0,-4))
//         //
//         //     macam.FirstGrabber.center=new XYZ(0,0,0)
//         //     macam.FirstGrabber.constantRadius=1
//         //     macam.FirstGrabber.grabberIsVisible=false
//         //
//         //
//         //     macam.attachControl(mathisFrame.canvas)
//         //
//         //
//         //
//         //     // Ajout d'une lumire
//         //     var light0 = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(-1, 1, -1), mathisFrame.scene);
//         //     light0.diffuse = new BABYLON.Color3(1, 1, 1);
//         //     light0.specular = new BABYLON.Color3(1, 0.5, 0.5);
//         //     light0.groundColor = new BABYLON.Color3(0, 0, 0);
//         //
//         //
//         //
//         //     let mamesh=new Mamesh()
//         //     let crea=new reseau.Regular(mamesh)
//         //     crea.nbI=5
//         //     crea.nbJ=6
//         //     crea.oneMoreVertexForOddLine=true
//         //     crea.goChanging()
//         //
//         //     mamesh.fillLineCatalogue()
//         //
//         //     let lineVisu=new visu3d.LinesVisuFastMaker(mamesh,scene)
//         //     lineVisu.goChanging()
//         //
//         // }
//         //
//         //
//         //
//         // function testCamFok(mathisFrame:MathisFrame){
//         //
//         //
//         //     let bow=BABYLON.Mesh.CreateBox('',0.5,scene)
//         //
//         //     /**param*/
//         //     let width=5
//         //     let height=1
//         //     let origin=new XYZ(-width/2,-height/2,0)
//         //     let maxPathSegment=500
//         //     let deltaT=0.1
//         //
//         //
//         //
//         //     let light0 = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(-1, 1, -1), mathisFrame.scene);
//         //     light0.diffuse = new BABYLON.Color3(0.5, 0.5, 0.5);
//         //     light0.specular = new BABYLON.Color3(0.7, 0.7, 0.7);
//         //     light0.groundColor = new BABYLON.Color3(1, 1, 1);
//         //
//         //     let plan = BABYLON.Mesh.CreatePlane('', 1, scene)
//         //     plan.scaling = new XYZ(width, height, 0)
//         //     plan.position = new XYZ(0, 0, 0.06)
//         //     plan.bakeCurrentTransformIntoVertices();
//         //
//         //
//         //     let macam=new macamera.GrabberCamera(scene)
//         //     macam.FirstGrabber.setMesh(plan)
//         //     //plan.isPickable=true
//         //     macam.FirstGrabber.setParallelMode()
//         //     macam.attachControl(mathisFrame.canvas)
//         //
//         //
//         // }
//         //
//         //
//
//         class ArrowCreator{
//
//             totalHeight=maud
//             bodyProp=3/4
//             headProp=1/4
//             bodyDiameterProp=0.1
//             headDiameterProp=0.2
//
//             headUp=true
//             arrowFootAtOrigin=true
//             scene:BABYLON.Scene
//
//             constructor(scene:BABYLON.Scene){
//                 this.scene=scene
//             }
//
//
//             goChanging():Mesh{
//                 let bodyHeight=this.bodyProp*this.totalHeight
//                 let headHeight=this.headProp*this.totalHeight
//                 let body=BABYLON.Mesh.CreateCylinder('',bodyHeight,this.bodyDiameterProp*this.totalHeight,this.bodyDiameterProp*this.totalHeight,6,null,this.scene)
//                 body.position=new XYZ(0,bodyHeight/2,0)
//                 let head=BABYLON.Mesh.CreateCylinder('',headHeight,0,this.headDiameterProp*this.totalHeight,6,null,this.scene)
//                 head.position=new XYZ(0,bodyHeight+headHeight/2,0)
//                 let arrow=BABYLON.Mesh.MergeMeshes([body,head])
//                 if(!this.headUp) {
//                     let quat=new XYZW(0,0,0,0)
//                     geo.axisAngleToQuaternion(new XYZ(1,0,0),Math.PI,quat)
//                     arrow.rotationQuaternion=quat
//                 }
//
//                 if(!this.arrowFootAtOrigin){
//                     arrow.position.addInPlace(new XYZ(0,-this.totalHeight/2,0))
//                 }
//
//                 arrow.bakeCurrentTransformIntoVertices()
//                 return arrow
//             }
//
//         }
//         // function testResau(mathisFrame:MathisFrame){
//         //     let macam = new macamera.GrabberCamera(mathisFrame.scene)
//         //     macam.changePosition(new XYZ(0,0,-4))
//         //
//         //     macam.FirstGrabber.center=new XYZ(0,0,0)
//         //     macam.FirstGrabber.constantRadius=1
//         //     macam.FirstGrabber.grabberIsVisible=true
//         //
//         //
//         //     macam.attachControl(mathisFrame.canvas)
//         //
//         //
//         //
//         //     // Ajout d'une lumire
//         //     var light0 = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(-1, 1, -1), mathisFrame.scene);
//         //     light0.diffuse = new BABYLON.Color3(1, 1, 1);
//         //     light0.specular = new BABYLON.Color3(1, 1, 1);
//         //     light0.groundColor = new BABYLON.Color3(0, 0, 0);
//         //
//         //
//         //     // let mamesh=new Mamesh()
//         //     // let cre=new reseau.Regular(mamesh)
//         //     // cre.goChanging()
//         //     //
//         //     // linker.checkTheRegularityOfAGRaph(mamesh.vertices)
//         //     //
//         //     //mamesh.fillLineCatalogue()
//         //
//         //
//         //
//         //     let mamesh=new Mamesh3dStratified()
//         //
//         //     let twoGe=new reseau.BasisForRegularReseau()
//         //     twoGe.nbHorizontalDecays=1
//         //     let res=twoGe.goChanging()
//         //
//         //
//         //     let crea=new reseau.Regular3D(mamesh)
//         //     crea.Vi=res.Vi
//         //     crea.Vj=res.Vj
//         //     crea.createIMameshes=true
//         //     crea.createJMameshes=true
//         //     crea.goChanging()
//         //
//         //     mamesh.fillLineCatalogueOfStrates()
//         //
//         //     mamesh.kMameshes.forEach(mamesh2d=>{
//         //         cc(mamesh2d.toString(true))
//         //         let aaa=new visu3d.LinesVisuFastMaker(mamesh2d,scene)
//         //         aaa.goChanging()
//         //
//         //
//         //
//         //         let verGa=new visu3d.VerticesViewer(mamesh2d,scene)
//         //         verGa.goChanging()
//         //
//         //     })
//         //
//         //     mamesh.iMameshes.forEach(mamesh2d=>{
//         //         cc(mamesh2d.toString(true))
//         //         let aaa=new visu3d.LinesVisuFastMaker(mamesh2d,scene)
//         //         aaa.goChanging()
//         //
//         //
//         //
//         //     })
//         //
//         //     mamesh.jMameshes.forEach(mamesh2d=>{
//         //         cc(mamesh2d.toString(true))
//         //         let aaa=new visu3d.LinesVisuFastMaker(mamesh2d,scene)
//         //         aaa.goChanging()
//         //
//         //     })
//         //
//         //
//         // }
//         //
//         //
//         //
//         // function testPeriodicWorldByLargeResau(mathisFrame:MathisFrame):void{
//         //
//         //
//         //     let cam =new macamera.GrabberCamera(scene)
//         //     cam.translationSpeed=4
//         //     cam.useOnlyFreeMode=true
//         //     cam.changePosition(new XYZ(0.5,1,3))
//         //     cam.changeFrontDir(new XYZ(-0.5,-1,1.5))
//         //
//         //
//         //     //let cam=new BABYLON.FreeCamera2('',new Vector3(0,0,-2),scene)
//         //     //cam.checkCollisions = true;
//         //
//         //     cam.checkCollisions=true
//         //
//         //     cam.attachControl(mathisFrame.canvas)
//         //
//         //     //cam.speed = 0.5;
//         //
//         //     //cam.ellipsoid = new BABYLON.Vector3(1, 1, 1);
//         //
//         //     // let macam = new macamera.GrabberCamera(mathisFrame.scene)
//         //     // macam.trueCamPos.position=new XYZ(0,0,-4)
//         //     // macam.recenterOnGrabberWhenGoingDownward=false
//         //     // macam.justOneGrabber.grabberIsVisible=true
//         //     // macam.justOneGrabber.alpha=0.3
//         //     // macam.goChanging()
//         //     // macam.attachControl(mathisFrame.canvas)
//         //
//         //     scene.collisionsEnabled = true;
//         //
//         //
//         //     // Ajout d'une lumire
//         //     var light0 = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(-1, 1, -1), mathisFrame.scene);
//         //     light0.diffuse = new BABYLON.Color3(1,1,1);
//         //     light0.specular = new BABYLON.Color3(0.,0.,0.);
//         //     light0.groundColor = new BABYLON.Color3(0, 0, 0.3);
//         //
//         //
//         //
//         //     let camPosInWebCoor=new XYZ(0,0,0)
//         //     let camDomain=new periodicWorld.Domain(0,0,0)
//         //     let camDomainCenter=new XYZ(0,0,0)
//         //     let fondamentalDomainSize=9
//         //     let nbSubdivision=3
//         //     let nbRepetition=6
//         //
//         //     var fd=new periodicWorld.CartesianFundamentalDomain(new XYZ(fondamentalDomainSize,0,0),new XYZ(0,fondamentalDomainSize,0),new XYZ(0,0,fondamentalDomainSize));
//         //     cam.onTranslate=()=>{
//         //
//         //         fd.pointToWebCoordinate(cam.trueCamPos.position, camPosInWebCoor);
//         //         camDomain.whichContains(camPosInWebCoor);
//         //         camDomain.getCenter(fd, camDomainCenter);
//         //
//         //         /**attention, il fautchnager simultanment la truePosition et la wished position. Donc mettre le smoothing  false*/
//         //         cam.changePosition(cam.whishedCamPos.getPosition().substract(camDomainCenter),false)
//         //         //cam.changePosition(cam.trueCamPos.getPosition().substract(camDomainCenter))
//         //
//         //     }
//         //
//         //
//         //
//         //
//         //     let reseauGen=new reseau.BasisForRegularReseau()
//         //     reseauGen.end=new XYZ(fondamentalDomainSize,fondamentalDomainSize,0)
//         //     reseauGen.nbI=nbSubdivision
//         //     reseauGen.nbJ=nbSubdivision
//         //     reseauGen.nbVerticalDecays=0
//         //     reseauGen.nbHorizontalDecays=0
//         //     reseauGen.kComponentTranslation+=0
//         //     let VV=reseauGen.goChanging()
//         //
//         //
//         //
//         //     function theReseau(nbRepetitions): Mamesh3dStratified{
//         //         let mamesh3d = new Mamesh3dStratified()
//         //         let crea = new reseau.Regular3D(mamesh3d)
//         //         crea.nbI = nbSubdivision*nbRepetitions
//         //         crea.nbJ = nbSubdivision*nbRepetitions
//         //         crea.nbK = nbSubdivision*nbRepetitions
//         //         crea.Vi = VV.Vi
//         //         crea.Vj = VV.Vj
//         //         crea.Vk = new XYZ(0, 0, fondamentalDomainSize / (nbSubdivision - 1))
//         //         crea.makeSquares = true
//         //         let totalSize=nbSubdivision*nbRepetitions*VV.Vi.length()
//         //         crea.origine=new XYZ(-totalSize/2,-totalSize/2,-totalSize/2)
//         //         crea.putAVertexOnlyAtXYZCheckingThisCondition=(xyz)=>xyz.length()<(totalSize/2*1.1)
//         //         crea.goChanging()
//         //         return mamesh3d
//         //     }
//         //
//         //     let stratified1=theReseau(nbRepetition)
//         //     stratified1.fillLineCatalogueOfStrates()
//         //
//         //     // let ma1=stratified1.toMamesh()
//         //     // ma1.fillLineCatalogue()
//         //
//         //     //ma2.fillLineCatalogue()
//         //     //oneMameshVisual(ma2)
//         //
//         //
//         //     var wallDiffuseTexture  = new BABYLON.Texture('../assets/texture/escher.jpg', scene);
//         //     //var wallNormalsHeightTexture = new BABYLON.Texture('../assets/texture/GtIUsWW.png', scene);
//         //
//         //
//         //     function lineVisu(ma:Mamesh,segmentSelectionFunction){
//         //         let model=BABYLON.Mesh.CreateBox('',1,scene)//BABYLON.Mesh.CreateCylinder('',1,0.2,0.2,4,null,scene)
//         //         let material=new BABYLON.StandardMaterial('',scene)
//         //         material.diffuseColor=new BABYLON.Color3(0.6,0.6,0.6)
//         //         material.diffuseTexture = wallDiffuseTexture;
//         //         //material.bumpTexture = wallNormalsHeightTexture;
//         //         model.material=material
//         //         model.convertToFlatShadedMesh()
//         //         let lineMak=new visu3d.LinesVisuFastMaker(ma,scene)
//         //         lineMak.diameter=0.2
//         //         /**collision sur les poutres pas terrible*/
//         //         lineMak.checkCollision=false
//         //         lineMak.meshModel=model
//         //         lineMak.segmentSelectionFunction=segmentSelectionFunction
//         //         lineMak.goChanging()
//         //     }
//         //
//         //     function vertexVisu(mamesh:Mamesh){
//         //         let model=BABYLON.Mesh.CreateBox('',1,scene)
//         //         let material=new BABYLON.StandardMaterial('',scene)
//         //         material.diffuseTexture = wallDiffuseTexture;
//         //         //material.bumpTexture = wallNormalsHeightTexture;
//         //         //material.useParallax = true;
//         //         // material.useParallaxOcclusion = true;
//         //         // material.parallaxScaleBias = 0.1;
//         //         //material.specularPower = 1000.0;
//         //         //material.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);
//         //
//         //         //mat.diffuseColor=col
//         //         model.material=material
//         //         //model.checkCollisions=true
//         //         model.convertToFlatShadedMesh()
//         //         let verticesVisuMaker=new visu3d.VerticesViewer(mamesh,scene)
//         //         verticesVisuMaker.meshModel=model
//         //         verticesVisuMaker.checkCollision=true
//         //
//         //
//         //         verticesVisuMaker.goChanging()
//         //     }
//         //
//         //     let count=0
//         //     stratified1.kMameshes.forEach(ma=>{
//         //         count+=ma.vertices.length
//         //         lineVisu(ma,null)
//         //         vertexVisu(ma)
//         //     })
//         //
//         //     cc('nb vertice drawn:',count,'<',Math.pow(nbSubdivision*nbRepetition,3))
//         //
//         //
//         //     let onlyVerticalFonc=(i:number,segment:Vertex[])=>{
//         //         if (segment[0].param.x==segment[1].param.x&& segment[0].param.y==segment[1].param.y) return true
//         //         return false
//         //     }
//         //     stratified1.iMameshes.forEach(ma=>{
//         //         lineVisu(ma,onlyVerticalFonc)
//         //     })
//         //
//         //
//         //     // stratified1.jMameshes.forEach(ma=>{
//         //     //     lineVisu(ma,new BABYLON.Color3(0,1,0))
//         //     // })
//         //     // stratified1.kMameshes.forEach(ma=>{
//         //     //     lineVisu(ma,new BABYLON.Color3(0,0,1))
//         //     // })
//         //
//         //
//         //
//         //
//         //
//         //
//         //     // function oneMerge(mesh1,mesh2){
//         //
//         //     // }
//         //     // oneMerge(directional1.iMamesh,directional2.iMamesh)
//         //     // oneMerge(directional1.jMamesh,directional2.jMamesh)
//         //     // oneMerge(directional1.kMamesh,directional2.kMamesh)
//         //     //
//         //     //
//         //     //
//         //     //
//         //     //
//         //     //
//         //     // function oneMameshVisual(mamesh:Mamesh):void{
//         //     //     let link=new visu3d.LinesGameoMaker(mamesh,scene)
//         //     //     link.parentGameo=rootGameo
//         //     //     link.lineOptionFunction=(i,line)=>{
//         //     //         let res=new visu3d.LineGameoStatic.LineGameoOption()
//         //     //         res.tesselation=4
//         //     //         return res
//         //     //     }
//         //     //     link.goChanging()
//         //     // }
//         //     //
//         //     // oneMameshVisual(directional1.iMamesh)
//         //     //
//         //     //
//         //     // //  mamesh3d.iMameshes[0].vertices.forEach(v=>v.isInvisible=true)
//         //     // //  mamesh3d.jMameshes[0].vertices.forEach(v=>v.isInvisible=true)
//         //     // //  mamesh3d.kMameshes[0].vertices.forEach(v=>v.isInvisible=true)
//         //     // //
//         //     // //
//         //     // // mamesh3d.allMamesh().forEach(IN_mamesh=>{oneMameshVisual(IN_mamesh)})
//         //     //
//         //
//         //
//         //
//         //
//         //     //
//         //     // let arrete=fd.getArretes(scene)
//         //     //
//         //     //
//         //     // let mul=new periodicWorld.Multiply(fd,10)
//         //     // arrete.forEach(arr=>{mul.addAbstractMesh(arr)})
//         //     // //mul.addBabGameo(rootGameo)
//         //     //
//         //     //
//         //     // createSkybox(scene)
//         //
//         //
//         //     createSkybox(scene)
//         //
//         //     scene.fogMode = BABYLON.Scene.FOGMODE_EXP2;
//         //     scene.fogDensity = 0.05;
//         //     scene.fogColor = new BABYLON.Color3(1,1,1);
//         //
//         //
//         //
//         //     function createSkybox(scene:BABYLON.Scene) {
//         //
//         //         var skybox = BABYLON.Mesh.CreateBox("skyBox", 100.0, scene);
//         //         skybox.checkCollisions=true;
//         //         var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
//         //         skyboxMaterial.backFaceCulling = false;
//         //         skybox.material = skyboxMaterial;
//         //         skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
//         //         skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
//         //         skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("../assets/skybox/skybox", scene,['_px.jpg', '_py.jpg', '_pz.jpg', '_nx.jpg', '_ny.jpg', '_nz.jpg']);
//         //         skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
//         //
//         //
//         //     }
//         //
//         //
//         // }
//         //
//         // //
//         // // function testPeriodicWorldByMerging(mathisFrame:MathisFrame):void{
//         // //
//         // //     let macam = new macamera.GrabberCamera(mathisFrame.scene)
//         // //     macam.changePosition(new XYZ(0,0,-4))
//         // //     macam.FirstGrabber.grabberIsVisible=true
//         // //     macam.attachControl(mathisFrame.canvas)
//         // //
//         // //
//         // //     // Ajout d'une lumire
//         // //     var light0 = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(-1, 1, -1), mathisFrame.scene);
//         // //     light0.diffuse = new BABYLON.Color3(1, 1, 1);
//         // //     light0.specular = new BABYLON.Color3(1, 1, 1);
//         // //     light0.groundColor = new BABYLON.Color3(0, 0, 0);
//         // //
//         // //
//         // //     let camPosInWebCoor=new XYZ(0,0,0)
//         // //     let camDomain=new periodicWorld.Domain(0,0,0)
//         // //     let camDomainCenter=new XYZ(0,0,0)
//         // //
//         // //
//         // //     //let oldCamDomain=new periodicWorld.Domain(0,0,0)
//         // //
//         // //
//         // //     let fondamentalDomainSize=2
//         // //     var fd=new periodicWorld.CartesianFundamentalDomain(new XYZ(fondamentalDomainSize,0,0),new XYZ(0,fondamentalDomainSize,0),new XYZ(0,0,fondamentalDomainSize));
//         // //
//         // //
//         // //     // let action= new ActionBeforeRender(()=>{
//         // //     //
//         // //     //     fd.pointToWebCoordinate(macam.trueCamPos.getPosition(), camPosInWebCoor);
//         // //     //     camDomain.whichContains(camPosInWebCoor);
//         // //     //
//         // //     //     camDomain.getCenter(fd, camDomainCenter);
//         // //     //
//         // //     //     /**attention, il faut soutraire en mme temps, sinon on a un effet d'aller retour*/
//         // //     //     macam.whishedCamPos.position.substract(camDomainCenter)
//         // //     //     macam.trueCamPos.position.substract(camDomainCenter)
//         // //     //
//         // //     //
//         // //     // })
//         // //
//         // //     //action.frameInterval=1
//         // //     //mathisFrame.actionsBeforeRender['recenter']=action
//         // //
//         // //
//         // //     let rootGameo=new GameoBab()
//         // //
//         // //     let nb=7
//         // //
//         // //     let reseauGen=new reseau.BasisForRegularReseau()
//         // //     reseauGen.end=new XYZ(fondamentalDomainSize,fondamentalDomainSize,0)
//         // //     reseauGen.nbI=nb
//         // //     reseauGen.nbJ=nb
//         // //     reseauGen.nbVerticalDecays=1
//         // //     reseauGen.nbHorizontalDecays=2
//         // //     reseauGen.kComponentTranslation+=0.
//         // //
//         // //     let VV=reseauGen.goChanging()
//         // //
//         // //     cc(VV.Vi,VV.Vj)
//         // //
//         // //
//         // //     function oneReseau(): Mamesh3dStratified{
//         // //         let mamesh3d = new Mamesh3dStratified()
//         // //         let crea = new reseau.Regular3D(mamesh3d)
//         // //         crea.nbI = nb
//         // //         crea.nbJ = nb
//         // //         crea.nbK = nb
//         // //         crea.Vi = VV.Vi//new XYZ(2,0,0)
//         // //         crea.Vj = VV.Vj//new XYZ(0,2,0)
//         // //         crea.Vk = new XYZ(0, 0, fondamentalDomainSize / (nb - 1))
//         // //         crea.makeSquares = false
//         // //         crea.goChanging()
//         // //         return mamesh3d
//         // //     }
//         // //
//         // //
//         // //     let stratified1=oneReseau()
//         // //     let stratified2=oneReseau()
//         // //
//         // //     let ma1=stratified1.toMamesh()
//         // //     let ma2=stratified2.toMamesh()
//         // //
//         // //     ma2.vertices.forEach(v=>{
//         // //         v.position.x+=fondamentalDomainSize
//         // //     })
//         // //
//         // //
//         // //
//         // //         let merger=new mameshModification.Merger(ma1,ma2)
//         // //         merger.mergeSegmentsMiddle=false
//         // //         merger.mergeTrianglesAndSquares=false
//         // //     merger.rebuildParamToVertex=true
//         // //     merger.cleanDoubleLinksKeepingInPriorityThoseWithOpposite=false//TODO
//         // //         merger.goChanging()
//         // //
//         // //     let aa =new linker.OppositeLinkAssocierByAngles(ma1.vertices)
//         // //     aa.goChanging()
//         // //
//         // //
//         // //     ma1.fillLineCatalogue()
//         // //
//         // //     //ma2.fillLineCatalogue()
//         // //     //oneMameshVisual(ma2)
//         // //
//         // //
//         // //
//         // //     // function oneMerge(mesh1,mesh2){
//         // //
//         // //     // }
//         // //     // oneMerge(directional1.iMamesh,directional2.iMamesh)
//         // //     // oneMerge(directional1.jMamesh,directional2.jMamesh)
//         // //     // oneMerge(directional1.kMamesh,directional2.kMamesh)
//         // //     //
//         // //     //
//         // //     //
//         // //     //
//         // //     //
//         // //     //
//         // //     // function oneMameshVisual(mamesh:Mamesh):void{
//         // //     //     let link=new visu3d.LinesGameoMaker(mamesh,scene)
//         // //     //     link.parentGameo=rootGameo
//         // //     //     link.lineOptionFunction=(i,line)=>{
//         // //     //         let res=new visu3d.LineGameoStatic.LineGameoOption()
//         // //     //         res.tesselation=4
//         // //     //         return res
//         // //     //     }
//         // //     //     link.goChanging()
//         // //     // }
//         // //     //
//         // //     // oneMameshVisual(directional1.iMamesh)
//         // //     //
//         // //     //
//         // //     // //  mamesh3d.iMameshes[0].vertices.forEach(v=>v.isInvisible=true)
//         // //     // //  mamesh3d.jMameshes[0].vertices.forEach(v=>v.isInvisible=true)
//         // //     // //  mamesh3d.kMameshes[0].vertices.forEach(v=>v.isInvisible=true)
//         // //     // //
//         // //     // //
//         // //     // // mamesh3d.allMamesh().forEach(IN_mamesh=>{oneMameshVisual(IN_mamesh)})
//         // //     //
//         // //
//         // //
//         // //
//         // //
//         // //     rootGameo.draw()
//         // //
//         // //     //cc(rootGameo.getAllAbstractMeshes())
//         // //
//         // //     let arrete=fd.getArretes(scene)
//         // //
//         // //
//         // //      let mul=new periodicWorld.Multiply(fd,10)
//         // //      arrete.forEach(arr=>{mul.addAbstractMesh(arr)})
//         // //      //mul.addBabGameo(rootGameo)
//         // //
//         // //
//         // //     createSkybox(scene)
//         // //
//         // //
//         // //
//         // //
//         // //
//         // //     function createSkybox(scene:BABYLON.Scene) {
//         // //
//         // //         var skybox = BABYLON.Mesh.CreateBox("skyBox", 100.0, scene);
//         // //         skybox.checkCollisions=true;
//         // //         var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
//         // //         skyboxMaterial.backFaceCulling = false;
//         // //         skybox.material = skyboxMaterial;
//         // //         skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
//         // //         skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
//         // //         skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("../assets/skybox/skybox", scene,['_px.jpg', '_py.jpg', '_pz.jpg', '_nx.jpg', '_ny.jpg', '_nz.jpg']);
//         // //         skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
//         // //
//         // //
//         // //     }
//         // //
//         // //
//         // // }
//         //
//         //
//         // function testFastLinkVisu(mathisFrame:MathisFrame){
//         //     let macam = new macamera.GrabberCamera(mathisFrame.scene)
//         //     macam.changePosition(new XYZ(0,0,-4))
//         //
//         //     macam.FirstGrabber.center=new XYZ(0,0,0)
//         //     macam.FirstGrabber.constantRadius=1
//         //     macam.FirstGrabber.grabberIsVisible=false
//         //
//         //
//         //     macam.attachControl(mathisFrame.canvas)
//         //
//         //
//         //
//         //     // Ajout d'une lumire
//         //     var light0 = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(-1, 1, -1), mathisFrame.scene);
//         //     light0.diffuse = new BABYLON.Color3(1, 1, 1);
//         //     light0.specular = new BABYLON.Color3(1, 0.5, 0.5);
//         //     light0.groundColor = new BABYLON.Color3(0, 0, 0);
//         //
//         //
//         //
//         //     let mamesh=new Mamesh()
//         //
//         //
//         //     //new creationFlat.SingleSquare(mamesh).goChanging()
//         //
//         //     new creation3D.Polyhedron(mamesh,creation3D.PolyhedronStatic.Type.Icosahedron).goChanging()
//         //
//         //     // let rota=new MM()
//         //     // geo.axisAngleToMatrix(new XYZ(0,1,1).normalize(),2,rota)
//         //     // mamesh.vertices.forEach(v=>geo.multiplicationMatrixVector(rota,v.position,v.position))
//         //
//         //
//         //
//         //     mamesh.fillLineCatalogue()
//         //
//         //
//         //     let mesh=new BABYLON.Mesh('',scene)
//         //
//         //
//         //     let original=BABYLON.Mesh.CreateCylinder('',1,1,1,4,null,scene)//BABYLON.Mesh.CreateBox('',1,scene)//
//         //     original.convertToFlatShadedMesh()
//         //     let mat=new BABYLON.StandardMaterial('',scene)
//         //     mat.diffuseColor=new BABYLON.Color3(1,0,0)
//         //     original.material=mat
//         //
//         //     let fast=new visu3d.LinesVisuFastMaker(mamesh,scene)
//         //     fast.meshModel=original
//         //     fast.parentNode=mesh
//         //     fast.goChanging()
//         //
//         //
//         //     let surface=new visu3d.SurfaceVisuMaker(mamesh,scene)
//         //     surface.parentNode=mesh
//         //     surface.goChanging()
//         //
//         //     let vertVisu=new visu3d.VerticesViewer(mamesh,scene)
//         //     vertVisu.parentNode=mesh
//         //     vertVisu.goChanging()
//         //
//         //     mesh.rotationQuaternion=new XYZW(0,0,0,1)
//         //     geo.axisAngleToQuaternion(new XYZ(0,0,1),0.5,mesh.rotationQuaternion)
//         //
//         //
//         // }
//         //
//
//         export function testOneGrabber(mathisFrame:MathisFrame,colorBullet:BABYLON.Color3):void{
//
//
//             // let cube=BABYLON.Mesh.CreateBox('1',1/2,scene)
//             let red=new BABYLON.StandardMaterial('',mathisFrame.scene)
//             red.diffuseColor=colorBullet
//             // cube.material=red
//
//             let grabber0=new macamera.SphericalGrabber(mathisFrame.scene)
//             let macam = new macamera.GrabberCamera(mathisFrame,grabber0)
//             macam.useFreeModeWhenCursorOutOfGrabber=false
//             macam.changePosition(new XYZ(0,0,0))
//
//
//             for (let i=0;i<30;i++){
//                 let me=BABYLON.Mesh.CreateSphere('',10,maud/20,mathisFrame.scene)
//                 me.position=new XYZ(2*Math.random()-1,2*Math.random()-1,2*Math.random()-1).normalize().scale(maud)
//                 me.material=red
//
//             }
//
//
//             let mamesh=new Mamesh()
//             let crea=new creation3D.Polyhedron(mamesh,creation3D.PolyhedronStatic.Type.Cube)
//             crea.goChanging()
//
//
//
//             let vertVisu=new visu3d.LinesVisuMaker(mamesh,mathisFrame.scene).goChanging()
//
//
//
//
//
//             // let grabber1=new macamera.Grabber(macam)
//             // grabber1.center=new XYZ(2,0,0)
//             // grabber1.constantRadius=1
//             // grabber1.grabberIsVisible=true
//             // grabber1.name='red'
//             //
//             // let grabber2=new macamera.Grabber(macam)
//             // grabber2.center=new XYZ(-2,0,0)
//             // grabber2.constantRadius=1
//             // grabber2.grabberIsVisible=true
//             // grabber2.name='blue'
//
//
//             //macam.grabbers.push(grabber0,grabber1,grabber2)
//
//             macam.attachControl(mathisFrame.canvas)
//
//
//
//
//
//             // Ajout d'une lumire
//             var light0 = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(-1, 1, -1), mathisFrame.scene);
//             light0.diffuse = new BABYLON.Color3(1, 1, 1);
//             light0.specular = new BABYLON.Color3(1, 1, 1);
//             light0.groundColor = new BABYLON.Color3(0, 0, 0);
//
//
//
//
//
//
//
//
//         }
//
//
//
//         class Coordinate{
//
//             X:(u:number,v:number)=>XYZ
//             Xu:(u:number,v:number)=>XYZ
//             Xv:(u:number,v:number)=>XYZ
//             Xuu:(u:number,v:number)=>XYZ
//             Xuv:(u:number,v:number)=>XYZ
//             Xvv:(u:number,v:number)=>XYZ
//
//             /** -1 to inverse orientation*/
//             orientationCoef=+1
//             unit=maud
//
//             private e(u:number,v:number):number{
//                 return geo.dot(this.newN(u,v),this.Xuu(u,v))
//             }
//             private f(u:number,v:number):number{
//                 return geo.dot(this.newN(u,v),this.Xuv(u,v))
//             }
//             private g(u:number,v:number):number{
//                 return geo.dot(this.newN(u,v),this.Xvv(u,v))
//             }
//             private E(u:number,v:number):number{
//                 return geo.dot(this.Xu(u,v),this.Xu(u,v))
//             }
//             private F(u:number,v:number):number{
//                 return geo.dot(this.Xu(u,v),this.Xv(u,v))
//             }
//             private G(u:number,v:number):number{
//                 return geo.dot(this.Xv(u,v),this.Xv(u,v))
//             }
//
//             private dNinTangentBasis(u:number,v:number):M22{
//                 let res=new M22()
//
//                 let e=this.e(u,v)
//                 let f=this.f(u,v)
//                 let g=this.g(u,v)
//                 let E=this.E(u,v)
//                 let F=this.F(u,v)
//                 let G=this.G(u,v)
//
//                 let det=E*G-F*F
//                 res.m11=(f*F-e*G)/det
//                 res.m12=(g*F-f*G)/det
//                 res.m21=(e*F-f*E)/det
//                 res.m22=(f*F-g*E)/det
//
//                 return res
//             }
//
//
//             dNaction(u:number,v:number,vect:XYZ):XYZ{
//
//                 let a=this.dNinTangentBasis(u,v)
//                 let vectUV=this.canonicalToTangentBasis(u,v,vect)
//                 let trans=a.multiplyUV(vectUV)
//                 return this.tagentToCanonicalBasis(u,v,trans)
//
//             }
//
//
//             private canonicalToTangentBasis(u:number,v:number,vect:XYZ):UV{
//
//                 let Xu=this.Xu(u,v)
//                 let Xv=this.Xv(u,v)
//                 let mat=new M22()
//                 mat.m11=Xu.x
//                 mat.m21=Xu.y
//                 mat.m21=Xv.x
//                 mat.m22=Xv.y
//
//                 let inv=mat.inverse()
//
//                 let vect2=new UV(vect.x,vect.y)
//                 return inv.multiplyUV(vect2)
//
//             }
//             private tagentToCanonicalBasis(u:number,v:number,vect:UV):XYZ{
//
//                 let Xu=this.Xu(u,v)
//                 let Xv=this.Xv(u,v)
//                 Xu.scale(vect.u)
//                 Xv.scale(vect.v)
//
//                 return Xu.add(Xv)
//
//             }
//
//
//
//             newN(u:number,v:number):XYZ{
//                 let res=new XYZ(0,0,0)
//                 geo.cross(this.Xu(u,v),this.Xv(u,v),res)
//                 res.normalize().scale(this.unit*this.orientationCoef)
//                 return res
//             }
//
//         }
//
//
//         type TwoMeshes={initial:BABYLON.AbstractMesh,onSphere:BABYLON.AbstractMesh}
//
//         class DrawNormalAndTangentVector{
//
//             coordinate:Coordinate
//             vertices:Vertex[]
//             surfaceScene:BABYLON.Scene
//             sphereScene:BABYLON.Scene
//             cam:GrabberCamera
//             sizes=new XYZ(maud,maud,maud)
//
//             surface:BABYLON.Mesh
//
//             /**out*/
//             //naturalOrientationComesToCam:boolean=null
//
//             constructor(coordinate:Coordinate,
//                         vertices:Vertex[],
//                         scene:BABYLON.Scene,
//                         sphereScene:BABYLON.Scene,
//                         cam:GrabberCamera,
//                         surface:BABYLON.Mesh
//             ){
//                 this.coordinate=coordinate
//                 this.vertices=vertices
//                 this.surfaceScene=scene
//                 this.cam=cam
//                 this.sphereScene=sphereScene
//                 this.surface=surface
//
//             }
//
//
//             findClosestVertex(point:XYZ):Vertex{
//                 let res:Vertex=null
//                 let minDist=Number.MAX_VALUE
//
//                 this.vertices.forEach(v=>{
//                     let dist=geo.distance(v.position,point)
//                     if (dist<minDist) {
//                         minDist=dist
//                         res=v
//                     }
//                 })
//                 return  res
//             }
//
//
//             // findUV(point:XYZ,vertices:Vertex[]):XYZ{
//             //     let res:Vertex=null
//             //     let minDist=Number.MAX_VALUE
//             //
//             //     vertices.forEach(v=>{
//             //         let dist=geo.distance(v.position,point)
//             //         if (dist<minDist) {
//             //             minDist=dist
//             //             res=v
//             //         }
//             //     })
//             //     return  {u:res.}
//             // }
//
//
//             private checkOrientation(u:number,v:number):void{
//                 let pointToCam=XYZ.newFrom(this.cam.trueCamPos.position).substract(this.coordinate.X(u,v))
//                 if (geo.dot(pointToCam,this.coordinate.newN(u,v))<0) this.coordinate.orientationCoef*=-1
//             }
//
//
//
//             // findAndDraw(point:XYZ):void{
//             //     let clickedVertex=this.findClosestVertex(point,this.vertices)
//             //     let u=clickedVertex.mathUV.x
//             //     let v=clickedVertex.mathUV.y
//             //     this.draw(u,v)
//             // }
//
//             arrowColor=new Color3(1,0,0)
//             private oneArrowOnOneScene(point:XYZ,quaternion:XYZW,scene:BABYLON.Scene,sizes:XYZ):BABYLON.Mesh{
//                 let creatorArrowMesh=new ArrowCreator(scene)
//                 //creatorArrowMesh.headUp=this.naturalOrientationComesToCam
//                 let arrow=creatorArrowMesh.goChanging()
//                 arrow.position=point
//                 arrow.rotationQuaternion=quaternion
//                 let mat=new BABYLON.StandardMaterial('',scene)
//                 mat.diffuseColor=this.arrowColor
//                 arrow.material=mat
//                 arrow.scaling=sizes
//                 return arrow
//             }
//
//
//
//             drawNormalVectors(u:number,v:number):TwoMeshes{
//
//                 this.checkOrientation(u,v)
//
//
//                 let positionning=new Positioning()
//                 positionning.upVector=this.coordinate.newN(u,v)
//
//                 let quat=positionning.quaternion()
//
//                 let initial= this.oneArrowOnOneScene(this.coordinate.X(u,v),quat,this.surfaceScene,this.sizes)
//                 let onSphere=this.oneArrowOnOneScene(new XYZ(0,0,0),quat.clone(),this.sphereScene,new XYZ(this.sizes.x,maud,this.sizes.z))
//
//                 return {initial:initial,onSphere:onSphere}
//
//             }
//
//
//             planeColor=new Color3(0,0,1)
//             planeRadius=0.2
//             private oneTangentPlane(normal:XYZ, tangent:XYZ, position:XYZ, scene:BABYLON.Scene, onClick:(xyz:XYZ)=>void=null):BABYLON.Mesh{
//
//                 let res=BABYLON.Mesh.CreateDisc('',this.planeRadius,60,scene)
//                 let qua=new XYZW(0,0,0,0)
//                 geo.aQuaternionMovingABtoCD(new XYZ(0,0,1),new XYZ(1,0,0),normal.scale(-1),tangent,qua,false)
//
//                 res.rotationQuaternion=qua
//                 res.position=position
//
//                 let biMat=new BABYLON.StandardMaterial('',scene)
//                 biMat.sideOrientation=BABYLON.Mesh.DOUBLESIDE
//                 biMat.diffuseColor=this.planeColor
//                 biMat.backFaceCulling=false
//                 res.material=biMat
//
//                 if (onClick!=null){
//                     ;(<any> res).onClick=onClick
//                 }
//
//
//                 return res
//
//             }
//
//
//
//             tangentDiameter=0.1
//             drawOneTangentVector(deb:XYZ,end:XYZ,scene:BABYLON.Scene):AbstractMesh{
//                 let arrowCrea=new ArrowCreator(scene)
//                 //arrowCrea.bodyDiameterProp=
//                 arrowCrea.arrowFootAtOrigin=false
//                 let arrowMesh=arrowCrea.goChanging()
//                 let mat=new StandardMaterial('',scene)
//                 mat.diffuseColor=new Color3(1,0,0)
//                 arrowMesh.material=mat
//                 let elongate=new visu3d.ElongateAMeshFromBeginToEnd(deb,end,arrowMesh)
//                 elongate.diameter=this.tangentDiameter
//                 elongate.goChanging()
//                 return arrowMesh
//             }
//
//
//
//
//             drawTangentPlanes(u:number,v:number,clickOnPlaneNow:boolean):TwoMeshes{
//
//                 this.checkOrientation(u,v)
//
//                 let onClick=null
//                 if (clickOnPlaneNow){
//                     // onClick=(clickXyz:XYZ)=>{
//                     //
//                     //     this.drawOneTangentVector(this.coordinate.X(u,v),clickXyz,this.surfaceScene)
//                     //
//                     //     let tangent=XYZ.newFrom(clickXyz).substract(this.coordinate.X(u,v))
//                     //     let dNtangent=this.coordinate.dNaction(u,v,tangent)
//                     //
//                     //     //TODO dNNuuu
//                     //     let begin=this.coordinate.newN(u,v)
//                     //     let end=XYZ.newFrom(begin).add(dNtangent)
//                     //     this.drawOneTangentVector(begin,end,this.sphereScene)
//                     //
//                     // }
//
//                     this.surface.isPickable=false
//
//                     onClick=(clickXyz:XYZ)=>{
//
//                         this.drawOneTangentVector(this.coordinate.X(u,v),clickXyz,this.surfaceScene)
//
//                         let tangent=XYZ.newFrom(clickXyz).substract(this.coordinate.X(u,v))
//                         let dNtangent=this.coordinate.dNaction(u,v,tangent)
//
//                         //TODO dNNuuu
//                         let begin=this.coordinate.newN(u,v)
//                         let end=XYZ.newFrom(begin).add(dNtangent)
//                         this.drawOneTangentVector(begin,end,this.sphereScene)
//
//                     }
//                 }
//
//
//                 let onSurface=this.oneTangentPlane(this.coordinate.newN(u,v),this.coordinate.Xu(u,v),this.coordinate.X(u,v),this.surfaceScene,onClick)
//                 let onSphere=this.oneTangentPlane(this.coordinate.newN(u,v),this.coordinate.Xu(u,v),this.coordinate.newN(u,v),this.sphereScene)
//
//                 return {initial:onSurface,onSphere:onSphere}
//
//
//             }
//
//
//         }
//
//
//
//
//         class GaussDerivativeMode{
//
//             drawNormalVector:DrawNormalAndTangentVector
//             meshSurf:BABYLON.Mesh
//
//             constructor(drawNormalVector:DrawNormalAndTangentVector,meshSurf:BABYLON.Mesh){
//                 this.drawNormalVector=drawNormalVector
//                 this.meshSurf=meshSurf
//
//                 ;(<any> this.meshSurf).onClick=this.gaussMapDerivativeClick
//
//             }
//
//
//             gaussMapDerivativeClick=(clickedPoint:XYZ)=>{
//                 let clickedVertex=this.drawNormalVector.findClosestVertex(clickedPoint)
//                 let UV=clickedVertex.mathUV
//
//                 this.drawNormalVector.arrowColor=new Color3(0,1,0)
//                 this.drawNormalVector.drawNormalVectors(UV.u,UV.v)
//
//                 this.drawNormalVector.planeRadius=0.2
//                 this.drawNormalVector.drawTangentPlanes(UV.u,UV.v,true)
//             }
//
//         }
//
//
//
//         class GaussDifferenceMode{
//
//             drawNormalVector:DrawNormalAndTangentVector
//             meshSurf:BABYLON.Mesh
//             surfaceMathisFrame:MathisFrame
//             arrowsToDispose:AbstractMesh[]=[]
//             wholeContainer:HTMLElement
//
//             constructor(drawNormalVector:DrawNormalAndTangentVector,meshSurf:BABYLON.Mesh,surfaceMathisFrame:MathisFrame,wholeContainer:HTMLElement){
//                 this.drawNormalVector=drawNormalVector
//                 this.meshSurf=meshSurf
//                 this.surfaceMathisFrame=surfaceMathisFrame
//                 this.wholeContainer=wholeContainer
//
//                 ;(<any> this.meshSurf).onClick=this.firstClick
//
//                 cc('arrowsToDispose',this.arrowsToDispose)
//                
//                 this.addControlButton()
//
//             }
//
//
//             addControlButton(){
//                 cc('in add arrowsToDispose',this.arrowsToDispose)
//
//                 setTimeout(()=>{
//                     cc('in add setTimeout',this.arrowsToDispose)
//
//                     let control=legend('40px',this.wholeContainer,false)
//                     cc('control',control)
//                     let buttonClear=document.createElement('div')
//                     buttonClear.classList.add("controlButtonRelative")
//                     buttonClear.innerHTML="<p>nettoyer</p>"
//                     buttonClear.onclick=()=>{this.clear()}
//                     // buttonClear.style.zIndex="100"
//                     // buttonClear.style.backgroundColor="blue"
//                     control.appendChild(buttonClear)
//                 },10)
//
//
//             }
//
//             clear(){
//                 cc('clear')
//                 cc('arrowsToDispose',this.arrowsToDispose)
//
//                 this.arrowsToDispose.forEach(m=>{
//                     if (m!=null) m.dispose()
//                 })
//             }
//
//
//             firstClick=(clickedPoint:XYZ)=>{
//
//
//                 let clickedVertex=this.drawNormalVector.findClosestVertex(clickedPoint)
//                 let UV=clickedVertex.mathUV
//                 let color=new Color3(0,1,0)
//                 this.drawNormalVector.arrowColor=color
//                 let twoMesh=this.drawNormalVector.drawNormalVectors(UV.u,UV.v)
//                 this.arrowsToDispose.push(twoMesh.initial)
//                 this.arrowsToDispose.push(twoMesh.onSphere)
//
//
//                 ;(<any> this.meshSurf).onClick=(secondClicked:XYZ)=>{
//                     let secondClickedVertex=this.drawNormalVector.findClosestVertex(secondClicked)
//                     let secondUV=secondClickedVertex.mathUV
//                     this.secondClick(UV,secondUV)
//
//                     ;(<any> this.meshSurf).onClick=this.firstClick
//                 }
//
//
//             }
//
//             // gaussMapDerivativeClick=(clickedPoint:XYZ)=>{
//             //     let clickedVertex=this.drawNormalVector.findClosestVertex(clickedPoint)
//             //     let UV=clickedVertex.mathUV
//             //
//             //     this.drawNormalVector.arrowColor=new Color3(0,1,0)
//             //     this.drawNormalVector.drawNormalVectors(UV.x,UV.y)
//             //
//             //     this.drawNormalVector.planeRadius=0.2
//             //     this.drawNormalVector.drawTangentPlanes(UV.x,UV.y,true)
//             // }
//
//
//             secondClick(UVcenter:UV,UVclicked:UV){
//
//                 let coor=  this.drawNormalVector.coordinate
//
//
//                 let alphas:number[]=[]
//                 let pas=0.01
//                 let alpha=0
//                 while (alpha<0.8){
//                     alphas.push(alpha)
//                     alpha+=pas
//                 }
//
//
//                 let count=0
//                 let pointCenter=coor.X(UVcenter.u,UVcenter.v)
//                 // let length=geo.distance(pointCenter,coor.X(UVclicked.x,UVclicked.y))
//
//                 let currentNormal:TwoMeshes=null
//                 let currentDifference:TwoMeshes={initial:null,onSphere:null}
//
//                 let action=new PeriodicActionBeforeRender(()=>{
//
//                     let UVinter=new UV(0,0)
//                     geo.betweenUV(UVclicked,UVcenter,alphas[count],UVinter)
//                     if (currentNormal!=null) {
//                         currentNormal.initial.dispose()
//                         currentNormal.onSphere.dispose()
//                     }
//                     currentNormal=this.drawNormalVector.drawNormalVectors(UVinter.u,UVinter.v)
//                     count++
//
//                     if (currentDifference.initial!=null&&count!=alphas.length+1) {
//                         currentDifference.initial.dispose()
//                         currentDifference.onSphere.dispose()
//                     }
//
//                     /**un peu idiot de crer autant de flche : 2 que l'on deplacerait suffirait*/
//                     currentDifference.initial=this.drawNormalVector.drawOneTangentVector(pointCenter,coor.X(UVinter.u,UVinter.v),this.drawNormalVector.surfaceScene)
//                     currentDifference.onSphere=this.drawNormalVector.drawOneTangentVector(coor.newN(UVcenter.u,UVcenter.v),coor.newN(UVinter.u,UVinter.v),this.drawNormalVector.sphereScene)
//
//
//
//                     //currentDifference.onSphere=drawOneDifference(sphereFrame.scene,)
//
//                 })
//                 action.nbTimesThisActionMustBeFired=alphas.length+1
//                 action.timeIntervalMilli=3000/alphas.length
//
//
//                 /**to dispose all the last*/
//                 this.arrowsToDispose.push(currentDifference.initial)
//                 this.arrowsToDispose.push(currentDifference.onSphere)
//                 //this.arrowsToDispose.push(currentNormal.initial)
//                 //this.arrowsToDispose.push(currentNormal.onSphere)
//
//                 this.surfaceMathisFrame.pushPeriodicAction(action)
//
//
//             }
//
//
//
//
//
//         }
//
//
//
//
//         class GaussMapMode{
//
//             drawNormalVector:DrawNormalAndTangentVector
//             meshSurf:BABYLON.Mesh
//
//             constructor(drawNormalVector:DrawNormalAndTangentVector,meshSurf:BABYLON.Mesh){
//                 this.drawNormalVector=drawNormalVector
//                 this.meshSurf=meshSurf
//
//                 ;(<any> this.meshSurf).onClick=this.gaussMapClick
//
//             }
//
//
//             gaussMapClick=(clickedPoint:XYZ)=>{
//                 let clickedVertex=this.drawNormalVector.findClosestVertex(clickedPoint)
//                 let UV=clickedVertex.mathUV
//                 let color=new Color3(Math.random(),Math.random(),Math.random())
//                 this.drawNormalVector.arrowColor=color
//                 this.drawNormalVector.drawNormalVectors(UV.u,UV.v)
//                 this.drawNormalVector.planeRadius=0.03
//                 this.drawNormalVector.drawTangentPlanes(UV.u,UV.v,false)
//             }
//
//
//
//
//         }
//
//
//         export function GaussCurvarture(mathisFrame:MathisFrame, sphereFrame:MathisFrame,mainDiv:HTMLElement){
//
//
//             function createGaussSphere(sphereFrame:MathisFrame){
//
//                 var light0 = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(-1, 1, -1), sphereFrame.scene);
//                 light0.diffuse = new BABYLON.Color3(1, 1, 1);
//                 light0.specular = new BABYLON.Color3(1, 1, 1);
//                 light0.groundColor = new BABYLON.Color3(0, 0, 0);
//
//                 let grabber=new macamera.SphericalGrabber(sphereFrame.scene,new XYZ(maud,maud,maud))
//                 grabber.endOfZone1=0.5
//                 grabber.endOfZone2=maud
//                 grabber.mesh.visibility=1
//                 let mat=new BABYLON.StandardMaterial('',sphereFrame.scene)
//                 mat.alpha=0.3
//                 mat.diffuseColor=new Color3(1,1,1)
//                 grabber.mesh.material=mat
//
//                 let cam=new macamera.GrabberCamera(sphereFrame,grabber);
//
//             }
//
//
//             var light0 = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(-1, 1, -1), mathisFrame.scene);
//             light0.diffuse = new BABYLON.Color3(1, 1, 1);
//             light0.specular = new BABYLON.Color3(1, 1, 1);
//             light0.groundColor = new BABYLON.Color3(0, 0, 0);
//
//             let grabber=new macamera.SphericalGrabber(mathisFrame.scene,new XYZ(maud,maud,maud))
//             grabber.endOfZone1=0.5
//             grabber.endOfZone2=maud
//             grabber.mesh.visibility=0
//
//             let cam=new macamera.GrabberCamera(mathisFrame,grabber);
//             //let camPos=new XYZ(-2,-2,-2)
//             let camPos=new XYZ(0,0,-1.5)
//
//             cam.changePosition(camPos)
//             cam.changeFrontDir(XYZ.newFrom(camPos).scale(-1))
//
//
//             createGaussSphere(sphereFrame)
//
//
//             // let plan=BABYLON.Mesh.CreatePlane('',1,mathisFrame.scene)
//             // let biMat=new BABYLON.StandardMaterial('',mathisFrame.scene)
//             // biMat.sideOrientation=BABYLON.Mesh.DOUBLESIDE
//             // biMat.backFaceCulling=false
//             // plan.material=biMat
//
//
//
//             let mamesh=new Mamesh()
//
//             let coef=0.6
//             let gene=new reseau.BasisForRegularReseau()
//             gene.origin=new XYZ(-maud*coef,-maud*coef,0)
//             gene.end=new XYZ(maud*coef,maud*coef,0)
//             gene.nbI=40+1
//             gene.nbJ=40+1
//
//
//             let crea=new reseau.Regular(mamesh,gene)
//             crea.goChanging()
//
//
//             let coor=new Coordinate()
//             coor.X=(u,v)=>new XYZ(u,v,v*v-u*u)
//             coor.Xu=(u,v)=>new XYZ(1,0,-2*u)
//             coor.Xv=(u,v)=>new XYZ(0,1,2*v)
//
//             coor.Xuu=(u,v)=>new XYZ(0,0,-2)
//             coor.Xuv=(u,v)=>new XYZ(0,0,0)
//             coor.Xvv=(u,v)=>new XYZ(0,0,2)
//
//
//
//             mamesh.vertices.forEach(vert=>{
//                 let u=vert.position.x
//                 let v=vert.position.y
//                 vert.mathUV=new UV(u,v)
//                 vert.position=coor.X(u,v)
//
//             })
//
//
//
//             function lineIsChosen(line:Vertex[],space:number):boolean{
//
//                 let vertOk=true
//                 for (let vert of line){
//                     if (vert.param.x%space!=0 ) {
//                         vertOk=false
//                         break
//                     }
//                 }
//                 let horOk=true
//                 for (let vert of line){
//                     if (vert.param.y%space!=0 ) {
//                         horOk=false
//                         break
//                     }
//                 }
//
//                 return vertOk||horOk
//             }
//
//
//             let lin=new visu3d.LinesVisuMaker(mamesh,mathisFrame.scene)
//             lin.lineOptionFunction=(i,line)=>{
//                 let res=new visu3d.LineGameoStatic.LineVisuOption()
//                 res.drawTheLineIfStraight=lineIsChosen(line,3)
//                 res.color=myFavoriteColors.green
//                 res.constantRadius=0.002
//                 return res
//             }
//             let lineMeshes=lin.goChanging()
//             lineMeshes.forEach(mesh=>mesh.isPickable=false)
//
//
//             let surf=new visu3d.SurfaceVisuMaker(mamesh,mathisFrame.scene)
//             let meshSurf=surf.goChanging()
//
//
//
//             // let positioningsMaker=new visu3d.PositioningComputerForMameshVertices(mamesh);
//             // positioningsMaker.sizesProp=new XYZ(0.5,0.5,0.5);
//             //let positionnings=positioningsMaker.goChanging()
//
//
//
//             let drawNormalVector=new DrawNormalAndTangentVector(coor,
//                 mamesh.vertices,
//                 mathisFrame.scene,
//                 sphereFrame.scene,
//                 cam,
//                 meshSurf
//             )
//             drawNormalVector.sizes=new XYZ(0.1,0.1,0.1)
//
//
//             //let wholeContainer=document.body
//             enum Mode{gaussMap,gaussDifferenceMode,gaussMapDerivative}
//             let mode=Mode.gaussDifferenceMode
//             if (mode==Mode.gaussMap) new GaussMapMode(drawNormalVector,meshSurf)
//             else if (mode==Mode.gaussMapDerivative) new GaussDerivativeMode(drawNormalVector,meshSurf)
//             else if (mode==Mode.gaussDifferenceMode)  new GaussDifferenceMode(drawNormalVector,meshSurf,mathisFrame,mainDiv)
//
//             //
//             // ;(<any> meshSurf).onClick=(clickedPoint:XYZ)=>{
//             //
//             //     clickCount++
//             //
//             //
//             //     if (mode==Mode.gaussMap) gaussMapMode(clickedPoint)
//             //     else if (mode==Mode.gaussDrivative) gaussDrivativeMode(clickedPoint)
//             //
//             //     // let clickedVertex=drawNormalVector.findClosestVertex(clickedPoint,mamesh.vertices)
//             //     // let UV=clickedVertex.mathUV
//             //     //
//             //     // let color=new Color3(Math.random(),Math.random(),Math.random())
//             //     // drawNormalVector.arrowColor=color
//             //     // drawNormalVector.drawNormalVectors(UV.x,UV.y)
//             //     // UVs.push(UV)
//             //     //
//             //     // drawNormalVector.planeRadius=0.03
//             //     // drawNormalVector.drawTangentPlanes(UV.x,UV.y,false)
//             //
//             //     // if (mode==Mode.approachDerivation){
//             //     //     if (clickCount%2==0){
//             //     //         approachDerivation(UVs[UVs.length-2],UVs[UVs.length-1],coor,mathisFrame,sphereFrame,drawNormalVector)
//             //     //     }
//             //     // }
//             //
//             // }
//             //
//
//
//
//             // let action=new PeriodicActionBeforeRender(()=>{
//             //     // let UVinter=new XYZ(0,0,0)
//             //     // geo.between(UVs[1],UVs[0],alphas[count],UVinter)
//             //     // drawNormalVector.draw(UVinter.x,UVinter.y)
//             //     // count++
//             //     cc('count')
//             // })
//             // action.nbTimesThisActionMustBeFired=3
//             // action.timeIntervalMilli=500
//             // mathisFrame.pushPeriodicAction(action)
//
//
//
//
//
//
//
//
//
//         }
//
//
//
//         //
//         // function testMultGrabber(mathisFrame:MathisFrame):void{
//         //
//         //
//         //     let macam = new macamera.GrabberCamera(mathisFrame.scene)
//         //     macam.changePosition(new XYZ(0,0,-4))
//         //
//         //     let grabber0=new macamera.Grabber(macam)
//         //     grabber0.center=new XYZ(0,0,0)
//         //     grabber0.constantRadius=1
//         //     grabber0.grabberIsVisible=true
//         //     grabber0.name='green'
//         //
//         //     let grabber1=new macamera.Grabber(macam)
//         //     grabber1.center=new XYZ(2,0,0)
//         //     grabber1.constantRadius=1
//         //     grabber1.grabberIsVisible=true
//         //     grabber1.name='red'
//         //
//         //     let grabber2=new macamera.Grabber(macam)
//         //     grabber2.center=new XYZ(-2,0,0)
//         //     grabber2.constantRadius=1
//         //     grabber2.grabberIsVisible=true
//         //     grabber2.name='blue'
//         //
//         //
//         //     macam.grabbers.push(grabber0,grabber1,grabber2)
//         //
//         //     macam.attachControl(mathisFrame.canvas)
//         //
//         //
//         //
//         //
//         //
//         //     // Ajout d'une lumire
//         //     var light0 = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(-1, 1, -1), mathisFrame.scene);
//         //     light0.diffuse = new BABYLON.Color3(1, 1, 1);
//         //     light0.specular = new BABYLON.Color3(1, 1, 1);
//         //     light0.groundColor = new BABYLON.Color3(0, 0, 0);
//         //
//         //
//         //
//         //
//         //
//         //
//         //
//         //
//         // }
//
//
//
//     }
//
//
//
//
//
// } 
// /**
//  * Created by vigon on 25/01/2016.
//  */
//
// module mathis{
//
//
//     export function flatTest():Bilan {
//
//
//         let bilan = new Bilan(0, 0)
//
//
//         function rectangleWithDifferentsParameters(makeLinks, addSquare):Mamesh{
//             let mamesh = new Mamesh()
//             let meshMaker = new creationFlat.Cartesian(mamesh)
//             meshMaker.createNewLinks=createNewLinks
//             meshMaker.nbX=8
//             meshMaker.nbY=5
//             meshMaker.addTriangleOrSquare=addSquare
//             meshMaker.goChanging()
//             return mamesh
//         }
//
//
//
//
//
//
//
//         //TODO refaire ce test
//         //{
//         //    /**duplication of positions when normals are too differents:*/
//         //
//         //
//         //    let mamesh = new Mamesh()
//         //    let meshMaker = new flat.Cartesian(mamesh)
//         //    meshMaker.makeLinks=true
//         //    meshMaker.nbX=3
//         //    meshMaker.minX=-1
//         //    meshMaker.maxX=1
//         //    meshMaker.nbY=2
//         //    meshMaker.minY=-1
//         //    meshMaker.maxY=+1
//         //    meshMaker.cornersAreSharp=true
//         //    meshMaker.addTriangleOrSquare=true
//         //    meshMaker.goChanging()
//         //
//         //    mamesh.fillLineCatalogue()
//         //
//         //
//         //    mamesh.vertices[1].position.changeBy(0,-1,-1)
//         //    mamesh.vertices[4].position.changeBy(0,1,-1)
//         //
//         //    let babVertexData=new visu3d.MameshToBabVertexData(mamesh)
//         //
//         //    let positions=[]
//         //    for (let v of mamesh.vertices) {
//         //        positions.push(v.position.x, v.position.y, v.position.z)
//         //    }
//         //
//         //    let positionSize=positions.length
//         //
//         //    let indices = mamesh.smallestTriangles.concat([])
//         //
//         //
//         //
//         //    for (let i=0;i<mamesh.smallestSquares.length;i+=4){
//         //        indices.push(IN_mamesh.smallestSquares[i],IN_mamesh.smallestSquares[i+1],IN_mamesh.smallestSquares[i+3],
//         //            IN_mamesh.smallestSquares[i+1],IN_mamesh.smallestSquares[i+2],IN_mamesh.smallestSquares[i+3])
//         //        //i,i+1,i+3,i+1,i+2,i+3)
//         //    }
//         //    let normalsOfTriangles=babVertexData.computeOneNormalPerTriangle(positions,indices)
//         //    let normalsOfVertices = babVertexData.computeVertexNormalFromTrianglesNormal(positions,indices,normalsOfTriangles)
//         //
//         //    let newPositionSize=positions.length
//         //
//         //    bilan.assertTrue(newPositionSize==positionSize+3*3)
//         //
//         //
//         //
//         //
//         //
//         //
//         //
//         //}
//
//         {
//
//             let mamesh = new Mamesh()
//             let meshMaker = new creationFlat.Quinconce(mamesh)
//             meshMaker.makeLinks=true
//             meshMaker.nbX=3
//             meshMaker.nbY=2
//             meshMaker.addTriangleOrSquare=true
//             meshMaker.goChanging()
//
//
//             ///mamesh.fillLineCatalogue()
//
//         }
//
//
//         //{
//         //    /**loop line on moebius band*/
//         //
//         //    let mamesh = new Mamesh()
//         //    let meshMaker = new flat.Cartesian(mamesh)
//         //    meshMaker.makeLinks=true
//         //    meshMaker.nbX=3
//         //    meshMaker.maxX=2*Math.PI
//         //    meshMaker.nbY=2
//         //    meshMaker.minY=-1
//         //    meshMaker.maxY=+1
//         //    meshMaker.cornersAreSharp=true
//         //    meshMaker.addTriangleOrSquare=true
//         //    meshMaker.borderStickingVertical=flat.BorderSticking.inverted
//         //    meshMaker.goChanging()
//         //
//         //    mamesh.fillLineCatalogue()
//         //    cc(mamesh.toString())
//         //
//         //
//         //
//         //}
//
//
//
//
//
//         return bilan
//
//
//     }
//
//
//
//
//     } 
var mathis;
(function (mathis) {
    var terMaster;
    (function (terMaster) {
        function start() {
            var mainDiv = document.getElementById("mainLeftCol");
            var canvass = mathis.nCanvasInOneLine(1, mainDiv);
            var mathisFrame = new mathis.MathisFrame(canvass[0], false);
            drawEllipsoide(mathisFrame);
        }
        terMaster.start = start;
        function drawEllipsoide(mathisFrame) {
            var grabber0 = new mathis.macamera.SphericalGrabber(mathisFrame.scene);
            var macam = new mathis.macamera.GrabberCamera(mathisFrame, grabber0);
            var light0 = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(-1, 1, -1), mathisFrame.scene);
            light0.diffuse = new BABYLON.Color3(1, 1, 1);
            light0.specular = new BABYLON.Color3(1, 1, 1);
            light0.groundColor = new BABYLON.Color3(0, 0, 0);
            // {
            //     let crea = new creation2D.Concentric(9,13)
            //     crea.nbPatches=1
            //     crea.shapes=[creation2D.PartShape.triangulatedRect]
            //     crea.percolationProba=[0.5]
            //
            //
            //     let mamesh=crea.goChanging()
            //
            //     mamesh.fillLineCatalogue()
            //
            //     new lineModule.CreateAColorIndexRespectingBifurcationsAndSymmetries(mamesh).goChanging()
            //
            //
            //     mamesh.fillLineCatalogue()
            //
            //     let liner=new visu3d.LinesViewer(mamesh,mathisFrame.scene)
            //     liner.interpolationOption=new geometry.InterpolationOption()
            //     liner.interpolationOption.interpolationStyle=geometry.InterpolationStyle.octavioStyle
            //     liner.goChanging()
            //
            //
            //
            // }
            {
                function createMamesh(origin, end, permute) {
                    if (permute === void 0) { permute = false; }
                    var gene = new mathis.reseau.BasisForRegularReseau();
                    gene.origin = origin;
                    gene.end = end;
                    gene.nbI = 32 + 1;
                    gene.nbJ = 32 + 1;
                    var mamesh = new mathis.reseau.Regular(gene).go();
                    var a = 1;
                    var b = 0.75;
                    var c = 0.5;
                    var map;
                    if (!permute) {
                        map = function (u, v) { return new mathis.XYZ(a * Math.cos(u) * Math.cos(v), b * Math.cos(u) * Math.sin(v), c * Math.sin(u)); };
                    }
                    else {
                        map = function (u, v) { return new mathis.XYZ(a * Math.sin(u), b * Math.cos(u) * Math.cos(v), c * Math.cos(u) * Math.sin(v)); };
                    }
                    mamesh.vertices.forEach(function (vert) {
                        var u = vert.position.x;
                        var v = vert.position.y;
                        vert.position = map(u, v);
                    });
                    return mamesh;
                }
                var delta = 0.8;
                var ma1 = createMamesh(new mathis.XYZ(-Math.PI / 2 + delta, -Math.PI + delta, 0), new mathis.XYZ(Math.PI / 2 - delta, Math.PI - delta, 0));
                var ma2 = createMamesh(new mathis.XYZ(-Math.PI / 2 + delta, -Math.PI + delta, 0), new mathis.XYZ(Math.PI / 2 - delta, Math.PI - delta, 0), true);
                var concurenter = new mathis.grateAndGlue.ConcurrentMameshesGraterAndSticker();
                concurenter.IN_mameshes = [ma1, ma2];
                concurenter.justGrateDoNotStick = false;
                var mamesh = concurenter.goChanging(); //oneCarte(new XYZ(-Math.PI/2,-Math.PI, 0),new XYZ(Math.PI/2 , Math.PI , 0)).arrivalOpenMesh
                var liner = new mathis.visu3d.LinksViewer(mamesh, mathisFrame.scene);
                liner.lateralScalingConstant = 0.01;
                liner.go();
                var surfacer = new mathis.visu3d.SurfaceViewer(mamesh, mathisFrame.scene);
                surfacer.go();
            }
        }
    })(terMaster = mathis.terMaster || (mathis.terMaster = {}));
})(mathis || (mathis = {}));
// /**
//  * Created by vigon on 09/03/2016.
//  */
//
//
//
// module mathis{
//
//     export class MameshForTest extends Mamesh{
//
//
//         toStringForTest0():string{
//
//             let substractHashCode=true
//
//             let toSubstract=0
//             if (substractHashCode){
//                 toSubstract=Number.MAX_VALUE
//                 for (let vert of this.vertices){
//                     if (vert.hashNumber<toSubstract) toSubstract=vert.hashNumber
//                 }
//
//
//             }
//
//
//             let res=""
//             for (let vert of this.vertices){
//                 res+=vert.toString(toSubstract)+""
//             }
//             res+="tri:"
//             for (let j=0;j<this.smallestTriangles.length;j+=3){
//                 res+="["+(this.smallestTriangles[j].hashNumber-toSubstract)+","+(this.smallestTriangles[j+1].hashNumber-toSubstract)+","+(this.smallestTriangles[j+2].hashNumber-toSubstract)+"]"
//             }
//             res+="squa:"
//             for (let j=0;j<this.smallestSquares.length;j+=4){
//                 res+="["+(this.smallestSquares[j].hashNumber-toSubstract)+","+(this.smallestSquares[j+1].hashNumber-toSubstract)+","+(this.smallestSquares[j+2].hashNumber-toSubstract)+","+(this.smallestSquares[j+3].hashNumber-toSubstract)+"]"
//             }
//
//
//             if (this.straightLines!=null) {
//                 res += "strai:"
//                 for (let line of this.straightLines) {
//                     res += "["
//                     for (let ver of line) {
//                         res += (ver.hashNumber-toSubstract) + ","
//                     }
//                     res += "]"
//                 }
//             }
//
//             if (this.loopLines!=null) {
//                 res += "loop:"
//                 for (let line of this.loopLines) {
//                     res += "["
//                     for (let ver of line) {
//                         res += (ver.hashNumber-toSubstract) + ","
//                     }
//                     res += "]"
//                 }
//             }
//
//             return res
//
//
//         }
//
//         toStringForTest1():string{
//
//             let toSubstract=0
//             toSubstract=Number.MAX_VALUE
//             for (let vert of this.vertices){
//                 if (vert.hashNumber<toSubstract) toSubstract=vert.hashNumber
//             }
//
//
//
//
//
//             let res=""
//             for (let vert of this.vertices){
//                 res+=vert.toString(toSubstract)+""
//             }
//             res+="tri:"
//             for (let j=0;j<this.smallestTriangles.length;j+=3){
//                 res+="["+(this.smallestTriangles[j].hashNumber-toSubstract)+","+(this.smallestTriangles[j+1].hashNumber-toSubstract)+","+(this.smallestTriangles[j+2].hashNumber-toSubstract)+"]"
//             }
//             res+="squa:"
//             for (let j=0;j<this.smallestSquares.length;j+=4){
//                 res+="["+(this.smallestSquares[j].hashNumber-toSubstract)+","+(this.smallestSquares[j+1].hashNumber-toSubstract)+","+(this.smallestSquares[j+2].hashNumber-toSubstract)+","+(this.smallestSquares[j+3].hashNumber-toSubstract)+"]"
//             }
//
//
//             if (this.straightLines!=null) {
//                 res += "strai:"
//                 for (let line of this.straightLines) {
//                     res += "["
//                     for (let ver of line) {
//                         res += (ver.hashNumber-toSubstract) + ","
//                     }
//                     res += "]"
//                 }
//             }
//
//             if (this.loopLines!=null) {
//                 res += "loop:"
//                 for (let line of this.loopLines) {
//                     res += "["
//                     for (let ver of line) {
//                         res += (ver.hashNumber-toSubstract) + ","
//                     }
//                     res += "]"
//                 }
//             }
//
//             res+="cutSegments"
//             for (let key in this.cutSegmentsDico){
//                 let segment=this.cutSegmentsDico[key]
//                 res+= '{'+(segment.a.hashNumber-toSubstract)+','+(segment.middle.hashNumber-toSubstract)+','+(segment.b.hashNumber-toSubstract)+'}'
//             }
//
//             return res
//
//
//         }
//
//
//     }
//
//
// }
var mathis;
(function (mathis) {
    //
    // class Tata{}
    //
    // class Toto extends Tata{}
    //
    //
    //
    // class CanEat {
    //     public eat() {
    //         cc('Munch Munch.');
    //     }
    // }
    //
    // class CanSleep {
    //     age:number
    //
    //     sleep() {
    //         cc('Zzzzzzz.'+this.age);
    //     }
    // }
    //
    // function applyMixins(derivedCtor: any, baseCtors: any[]) {
    //     baseCtors.forEach(baseCtor => {
    //         Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {
    //             if (name !== 'constructor') {
    //                 derivedCtor.prototype[name] = baseCtor.prototype[name];
    //             }
    //         });
    //     });
    // }
    //
    //
    // class Being implements CanEat, CanSleep {
    //     age:number
    //
    //     eat: () => void;
    //     sleep: () => void;
    //
    //     static mixinsWasMade=false
    //
    //     constructor(){
    //         if(!Being.mixinsWasMade) {
    //             applyMixins (Being, [CanEat, CanSleep]);
    //             Being.mixinsWasMade=true
    //         }
    //
    //     }
    //
    // }
    //
    //
    //
    // function compareArrayVersusDico() {
    //     let t1 = performance.now()
    //     var maxNbData = 10000
    //     var nbCreation = 100000
    //     var nbIntero = 10000
    //
    //     function oneIndex() {
    //         return Math.floor(Math.random() * maxNbData)
    //     }
    //
    //     var trueTab = new Array<string>(maxNbData * maxNbData)
    //     for (var i = 0; i < nbCreation; i++) {
    //         let a = oneIndex()
    //         let b = oneIndex()
    //         trueTab[a * maxNbData + b] = a + ',' + b
    //     }
    //
    //
    //     for (let j = 0; j < nbIntero; j++) {
    //         let a = oneIndex()
    //         let b = oneIndex()
    //         let k = trueTab[a * maxNbData + b]
    //     }
    //     let perfTab = t1 - performance.now()
    //
    //
    //     let s1 = performance.now()
    //     var dictionnary = []
    //
    //
    //     for (var i = 0; i < nbCreation; i++) {
    //         let a = oneIndex()
    //         let b = oneIndex()
    //         dictionnary[a + "," + b] = a + ',' + b
    //     }
    //
    //
    //     for (let j = 0; j < nbIntero; j++) {
    //         let a = oneIndex()
    //         let b = oneIndex()
    //         let k = dictionnary[a + "," + b]
    //     }
    //     console.log('ratio', (s1 - performance.now()) / perfTab)
    //
    //
    // }
    //
    //
    function doAllTest() {
        var visualization = true;
        if (visualization) {
            var mathisFrame = new mathis.MathisFrame(null, false);
            var grabber0 = new mathis.macamera.SphericalGrabber(mathisFrame.scene);
            mathisFrame.scene.activeCamera = new mathis.macamera.GrabberCamera(mathisFrame, grabber0);
            var light0 = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(-1, 1, -1), mathisFrame.scene);
            light0.diffuse = new BABYLON.Color3(1, 1, 1);
            light0.specular = new BABYLON.Color3(1, 1, 1);
            light0.groundColor = new BABYLON.Color3(0, 0, 0);
        }
        var bilanGlobal = new mathis.Bilan();
        //bilanGlobal.add(linkerTest())
        // bilanGlobal.add(testCreation3D(mathisFrame))
        //
        // bilanGlobal.add(testCreation(mathisFrame))
        // bilanGlobal.add(testMameshModification(mathisFrame))
        // bilanGlobal.add(informatisTest())
        bilanGlobal.add(mathis.geometryTest());
        // bilanGlobal.add(symmetriesTest())
        // bilanGlobal.add(testRiemann(mathisFrame))
        console.log('bilanGlobal', bilanGlobal.toString());
        return;
        //console.log('bilanGlobal',bilanGlobal)
    }
    mathis.doAllTest = doAllTest;
})(mathis || (mathis = {}));
/**
 * Created by vigon on 02/06/2016.
 */
var mathis;
(function (mathis) {
    var PartShape = mathis.creation2D.PartShape;
    function testCreation(mathisFrame) {
        var bilan = new mathis.Bilan();
        //
        //
        // {
        //     let crea = new creation2D.Concentric(9,13)
        //     crea.nbPatches=1
        //     crea.shapes=[PartShape.triangulatedRect]
        //     crea.percolationProba=[0.5]
        //     //crea.SUB_mameshCleaner.suppressLinkWithoutOppositeFunction=(v)=>(!v.isBorder())
        //
        //
        //     let mamesh=crea.goChanging()
        //
        //
        //
        //     mamesh.fillLineCatalogue()
        //
        //     new lineModule.CreateAColorIndexRespectingBifurcationsAndSymmetries(mamesh).goChanging()
        //
        //
        //     mamesh.fillLineCatalogue()
        //
        //     let liner=new visu3d.LinesViewer(mamesh,mathisFrame.scene)
        //     liner.interpolationOption=new geometry.InterpolationOption()
        //     liner.interpolationOption.interpolationStyle=geometry.InterpolationStyle.octavioStyle
        //     liner.goChanging()
        //
        //
        //
        // }
        //
        // {
        //     let crea = new creation2D.Concentric(13,13)
        //     crea.nbPatches=1
        //     crea.shapes=[PartShape.polygon4]
        //     //crea.individualScales=[new UV(2,1)]
        //     //crea.SUB_mameshCleaner.suppressLinkWithoutOppositeFunction=null
        //     crea.SUB_mameshCleaner.suppressCellWithNoVoisin=false
        //     crea.percolationProba=[1]
        //     //crea.individualRotations=[Math.PI/4]
        //     crea.scalingBeforeOppositeLinkAssociations=new XYZ(1,0.3,0)
        //
        //     let mamesh=crea.goChanging()
        //
        //     mamesh.fillLineCatalogue()
        //
        //     new lineModule.CreateAColorIndexRespectingBifurcationsAndSymmetries(mamesh).goChanging()
        //
        //
        //
        //     mamesh.fillLineCatalogue()
        //
        //
        //     let liner=new visu3d.LinesViewer(mamesh,mathisFrame.scene)
        //     liner.interpolationOption=new geometry.InterpolationOption()
        //     liner.interpolationOption.interpolationStyle=geometry.InterpolationStyle.octavioStyle
        //     liner.goChanging()
        //
        // }
        // return bilan
        // {
        //
        //     let crea = new creation2D.Concentric(6,12)
        //     crea.nbPatches=1
        //     crea.shapes=[PartShape.triangulatedRect]
        //     crea.percolationProba=[0.5]
        //     crea.SUB_mameshCleaner.suppressLinkWithoutOppositeFunction=v=>(!v.isBorder())
        //     crea.SUB_oppositeLinkAssocierByAngles.maxAngleToAssociateLinks=Math.PI*0.3
        //
        //     let mamesh=crea.goChanging()
        //
        //
        //     cc('OUT_nbVerticesSuppressed',crea.SUB_mameshCleaner.OUT_nbVerticesSuppressed)
        //
        //
        //     mamesh.fillLineCatalogue()
        //
        //
        //     let liner=new visu3d.LinesViewer(mamesh,mathisFrame.scene)
        //     liner.interpolationOption=new geometry.InterpolationOption()
        //     liner.interpolationOption.interpolationStyle=geometry.InterpolationStyle.octavioStyle
        //     liner.goChanging()
        //
        // }
        //
        // return bilan
        /**branching of a percolated hexagone*/
        {
            var crea = new mathis.reseau.TriangulatedPolygone(6);
            crea.nbSubdivisionInARadius = 7;
            var mamesh = crea.go();
            var perco = new mathis.mameshModification.PercolationOnLinks(mamesh);
            perco.percolationProba = 0.3;
            perco.goChanging();
            mamesh.isolateMameshVerticesFromExteriorVertices();
            var associer = new mathis.linkModule.OppositeLinkAssocierByAngles(mamesh.vertices);
            associer.clearAllExistingOppositeBefore = true;
            //associer.maxAngleToAssociateLinks=Math.PI*0.33
            //associer.propToleranceForBifurcation=1 //il faut cela pour qu'un lien droit branche
            associer.doNotBranchOnBorder = true;
            associer.goChanging();
            var cleaner = new mathis.mameshModification.MameshCleaner(mamesh);
            cleaner.suppressLinkWithoutOppositeFunction = function (v) { return (!v.hasMark(mathis.Vertex.Markers.border)); };
            cleaner.goChanging();
            bilan.assertTrue(cleaner.OUT_nbLinkSuppressed == 142);
            cc(associer.OUT_nbBranching == 10);
            mamesh.fillLineCatalogue();
            bilan.assertTrue(mamesh.lines.length == 42);
        }
        /** border and corner of triangulated rectangle */
        {
            var mamesh_1;
            var aaa_1;
            var test = function (ni, nj, oneMoreOnOdd, corner) {
                if (corner === void 0) { corner = false; }
                var gene = new mathis.reseau.BasisForRegularReseau();
                gene.nbI = ni;
                gene.nbJ = nj;
                var crea = new mathis.reseau.Regular(gene);
                crea.oneMoreVertexForOddLine = oneMoreOnOdd;
                crea.squareVersusTriangleMaille = false;
                mamesh_1 = crea.go();
                mamesh_1.fillLineCatalogue();
                aaa_1 = [];
                for (var _i = 0, _a = mamesh_1.vertices; _i < _a.length; _i++) {
                    var v = _a[_i];
                    if (!corner && v.isBorder())
                        aaa_1.push(v);
                    else if (corner && v.hasMark(mathis.Vertex.Markers.corner))
                        aaa_1.push(v);
                }
                return aaa_1.length;
            };
            bilan.assertTrue(test(3, 4, false) == 10);
            bilan.assertTrue(test(4, 4, false) == 12);
            bilan.assertTrue(test(3, 3, false) == 8);
            bilan.assertTrue(test(3, 4, true) == 11);
            bilan.assertTrue(test(3, 3, true) == 8);
            bilan.assertTrue(test(3, 4, false, true) == 4);
            bilan.assertTrue(test(4, 4, false, true) == 4);
            bilan.assertTrue(test(3, 3, false, true) == 4);
            bilan.assertTrue(test(3, 3, true, true) == 4);
            bilan.assertTrue(test(3, 4, true, true) == 4);
        }
        /** heu */
        {
            var crea = new mathis.creation2D.Concentric(7, 12);
            crea.nbPatches = 3;
            crea.shapes = [PartShape.square, PartShape.polygon6, PartShape.square];
            //structureDescription.proportions=[new UV(1,1),new UV(0.6,0.6)]
            crea.propBeginToRound = [0];
            crea.propEndToRound = [0, 0.5];
            crea.individualTranslation = [new mathis.XYZ(-0.3, 0, 0), new mathis.XYZ(0, 0, 0), new mathis.XYZ(0.3, 0, 0)];
            //crea.SUB_mameshCleaner.suppressLinkWithoutOppositeFunction=null
            //crea.SUB_oppositeLinkAssocierByAngles.canCreateBifurcations=false
            var mamesh = crea.go();
            mamesh.fillLineCatalogue();
            bilan.assertTrue(mamesh.allLinesAsASortedString() == 'straightLines:["[0,1,2,3,4,5,6,7,8,9,10,11]","[0,12,24]","[1,13,25,102,143,91,104,93,115,94,211,223]","[10,22,34,98,129,97,119,95,117,94,210,222]","[106,107,104,105,113,119,124,125]","[11,23,35]","[12,13,14,15,16,17,18,19,20,21,22,23]","[144,143,140,134,127,126,129,128]","[2,14,90,137,101,134,84,113,95,116,87,213,225]","[205,206,207,208,209,210,211,212,213,214,215,216]","[217,218,219,220,221,222,223,224,225,226,227,228]","[219,207]","[226,214]","[24,25,141,142,140,103,105,112,117,118,212,224]","[3,15]","[35,34,132,131,126,120,113,112,115,114,209,221]","[4,16,139,138,133,127,120,119,122,121,203,204]","[4,16,139,138,133,127,120,119,122,121,203,215,227]","[5,17,100,136,99,126,97,124,96,204,216,228]","[6,18,100,138,101,140,91,107,92,193,205,217]","[7,19,135,136,133,134,103,104,110,111,194,193]","[7,19,135,136,133,134,103,104,110,111,194,206,218]","[8,20]","[85,108,91,103,84,120,97,123,88]","[9,21,89,130,99,127,84,105,93,109,86,208,220]"]|loopLines:["[107,110,109,115,117,116,122,124,123,129,131,130,136,138,137,142,143,108]","[85,106,92,111,86,114,94,118,87,121,96,125,88,128,98,132,89,135,100,139,90,141,102,144]"]');
            bilan.assertTrue(crea.SUB_mameshCleaner.OUT_nbLinkSuppressed == 27);
        }
        /**'chu*/
        {
            var crea = new mathis.creation2D.Patchwork(6, 6, 2, 2);
            crea.patchesInQuinconce = true;
            crea.shapes = [PartShape.square];
            crea.individualRotations = [0, Math.PI / 4, 0];
            crea.individualScales = [new mathis.UV(1.2, 1.2)];
            crea.integerBeginToRound = [0];
            crea.integerEndToRound = [-2];
            //crea.SUB_mameshCleaner.suppressLinkWithoutOppositeFunction=null
            var mamesh = crea.go();
            mamesh.fillLineCatalogue();
            bilan.assertTrue(mamesh.allLinesAsASortedString() == 'straightLines:["[1,7,13,19,25,31,55,56,57,58,59]","[12,13,14,15,16,17,98,99,100,101]","[140,134,128,122,116]","[18,19,20,21,22,23,116,117,118,119]","[2,8,14,20,26,43,44,45,46,47,140,141,142,143,137,131,125,119,101,95,89,83,77,76,75,74,73,72,78,4,10,16,22,28,45,51,57,63,69]","[24,25,26,27,28,121,122,123,124,125]","[24,25,26,27,28,127,128,129,130,131]","[3,9,15,21,27,43,49,55,61,67]","[53,52,51,50,49,31,30,24,18,12,6,0,1,2,3,4,85,86,87,88,89]","[6,7,8,9,10,91,92,93,94,95]","[60,66,67,68,69,70,71,65,59,53,47]","[65,64,63,62,61,60]","[68,62,56,50,44]","[69,63,57,51,45,127,128,129,130,131]","[70,64,58,52,46,133,127,121,23,17,91,85,79,73]","[70,64,58,52,46,133,134,135,136,137]","[74,80,86,92,98]","[75,81,87,93,99,117,123,129,135,141]","[76,82,88,94,100,118,124,130,136,142]","[83,82,81,80,79,78]"]');
            bilan.assertTrue(crea.SUB_mameshCleaner.OUT_nbLinkSuppressed == 1);
        }
        // /**'col' */
        // {
        //     let crea = new creation2D.Patchwork(7,7,3,3)
        //     crea.shapes = [PartShape.square]
        //     crea.individualRotations=[Math.PI/3,-Math.PI/3]
        //     crea.integerBeginToRound=[0]
        //     crea.integerEndToRound=[-2]
        //
        //
        //     //crea.SUB_mameshCleaner.suppressLinkWithoutOppositeFunction=v=>(!v.hasMark(Vertex.Markers.border))
        //
        //     let IN_mamesh=crea.goChanging()
        //     IN_mamesh.fillLineCatalogue()
        //     cc(IN_mamesh.allLinesAsASortedString())
        //
        //     cc('suppp',crea.SUB_mameshCleaner.OUT_nbLinkSuppressed)
        //
        //
        //     new lineModule.CreateAColorIndexRespectingBifurcationsAndSymmetries(IN_mamesh).goChanging()
        //
        //     let liner=new visu3d.LinesViewer(IN_mamesh,mathisFrame.scene)
        //     liner.interpolationOption=new geometry.InterpolationOption()
        //     liner.interpolationOption.interpolationStyle=geometry.InterpolationStyle.octavioStyle
        //     liner.goChanging()
        //
        //
        //
        // }
        //
        // return bilan
        /**prefab ans*/
        {
            var crea = new mathis.creation2D.Patchwork(6, 6, 3, 3);
            crea.patchesInQuinconce = true;
            crea.shapes = [PartShape.square];
            crea.individualRotations = [0, Math.PI / 4, 0];
            crea.individualScales = [new mathis.UV(1.2, 1.2)];
            crea.SUB_mameshCleaner.suppressLinkWithoutOppositeFunction = function (v) { return (!v.hasMark(mathis.Vertex.Markers.border)); };
            //crea.SUB_oppositeLinkAssocierByAngles.suppressLinkWithoutOppositeForVertexWithValenceAtLeast5=true
            var mamesh = crea.go();
            mamesh.fillLineCatalogue();
            bilan.assertTrue(crea.SUB_mameshCleaner.OUT_nbLinkSuppressed == 7);
            bilan.assertTrue(mamesh.lines.length == 39);
            bilan.assertTrue(crea.SUB_oppositeLinkAssocierByAngles.OUT_nbBranching == 10);
        }
        /**prefab gag*/
        {
            var crea = new mathis.creation2D.Concentric(12, 12);
            crea.nbPatches = 2;
            crea.shapes = [PartShape.square, PartShape.triangulatedTriangle];
            crea.proportions = [new mathis.UV(1, 1), new mathis.UV(0.4, 0.4)];
            crea.individualScales = [new mathis.UV(1, 1), new mathis.UV(1.2, 1.2)];
            crea.SUB_mameshCleaner.suppressLinkWithoutOppositeFunction = function (v) { return (!v.hasMark(mathis.Vertex.Markers.border)); };
            var mamesh = crea.go();
            mamesh.fillLineCatalogue();
            bilan.assertTrue(mamesh.allLinesAsASortedString() == 'straightLines:["[0,1,2,3,4,5,6,7,8,9,10,11]","[0,12,24,36,48,60,72,84,96,108,120,132]","[1,13,25,37,49,61,73,85,97,109,121,133]","[10,22,34,46,58,70,82,94,106,118,130,142]","[108,109,110,111,112,113,114,115,116,117,118,119]","[11,23,35,47,59,71,83,95,107,119,131,143]","[12,13,14,15,16,17,18,19,20,21,22,23]","[120,121,122,123,124,125,126,127,128,129,130,131]","[132,133,134,135,136,137,138,139,140,141,142,143]","[135,123,111,99,87,163,151,188,157,184,45,46,47]","[137,125,113,101,176,154,171,81,82,83]","[2,14,26,38,50,62,74,86,98,110,122,134]","[24,25,26,27,28,29,30,31,32,33,34,35]","[3,15,27,39,51,160,87,99,111,123,135]","[3,15,27,39,51,166,151,186,154,172,105,106,107]","[36,37,38,39,40,41,42,181,184,57,58,59]","[4,16,28,40,52,166,163,88,100,112,124,136]","[48,49,50,51,52,167,188,187,171,93,94,95]","[5,17,29,41,167,151,162,101,113,125,137]","[5,17,29,41,180,157,185,69,70,71]","[6,18,30,42,180,188,186,176,102,114,126,138]","[60,61,62,160,163,162,176,175,169,105,106,107]","[60,61,62,160,163,162,176,175,169,117,118,119]","[7,19,31,181,157,187,154,175,115,127,139]","[72,73,74,160,166,167,180,181,178,33,34,35]","[72,73,74,160,166,167,180,181,178,45,46,47]","[8,20,32,178,184,185,171,172,169,116,128,140]","[84,85,86,87,88,162,186,187,185,57,58,59]","[9,21,33,45,57,69,81,93,105,117,129,141]","[96,97,98,99,100,101,102,175,172,93,94,95]"]');
            bilan.assertTrue(crea.SUB_mameshCleaner.OUT_nbLinkSuppressed == 4);
        }
        // {
        //
        //     let crea = new creation2D.Concentric(11,11)
        //
        //     crea.nbPatches=2
        //     crea.shapes=[mathis.creation2D.PartShape.square]
        //     crea.proportions=[new UV(1,1),new UV(0.5,0.5)]
        //     crea.individualRotations=[0,Math.PI/4]
        //     crea.individualScales=[new UV(1,1),new UV(0.8,0.8)]
        //
        //     let IN_mamesh=crea.goChanging()
        //
        //     IN_mamesh.fillLineCatalogue()
        //
        //     new lineModule.CreateAColorIndexRespectingBifurcationsAndSymmetries(IN_mamesh).goChanging()
        //
        //     let liner=new visu3d.LinesViewer(IN_mamesh,mathisFrame.scene)
        //     liner.interpolationOption=new geometry.InterpolationOption()
        //     liner.interpolationOption.interpolationStyle=geometry.InterpolationStyle.octavioStyle
        //     liner.goChanging()
        //
        //
        //
        //
        //
        //
        // }
        //
        // return bilan
        {
            var crea = new mathis.reseau.TriangulatedPolygone(6);
            crea.nbSubdivisionInARadius = 4;
            var mamesh = crea.go();
            mamesh = new mathis.grateAndGlue.ExtractCentralPart(mamesh, 1).go();
            mamesh.isolateMameshVerticesFromExteriorVertices();
            var nbBorder = 0;
            for (var _i = 0, _a = mamesh.vertices; _i < _a.length; _i++) {
                var v = _a[_i];
                if (v.hasMark(mathis.Vertex.Markers.border))
                    nbBorder++;
            }
            bilan.assertTrue(nbBorder == 18);
        }
        // {
        //     let gene=new reseau.BasisForRegularReseau()
        //     gene.nbI=9
        //     gene.nbJ=9
        //
        //     let crea = new reseau.Regular(gene)
        //     crea.strateHaveSquareMailleVersusTriangleMaille=false
        //
        //     let IN_mamesh=crea.goChanging()
        //
        //
        //     let perco=new mameshModification.PercolationOnLinks(IN_mamesh)
        //     perco.maxPercolationForAVertexAlreadyPercolate=0
        //     perco.probaToPercolateFunction=1
        //     perco.goChanging()
        //     IN_mamesh.isolateMameshVerticesFromExteriorVertices()
        //
        //
        //
        //     let associer=new linkModule.OppositeLinkAssocierByAngles(IN_mamesh.vertices)
        //     associer.clearAllExistingOppositeBefore=true
        //     associer.maxAngleToAssociateLinks=Math.PI*0.33
        //     associer.toleranceForBifurcation=Math.PI*0.5
        //     associer.goChanging()
        //
        //
        //     IN_mamesh.fillLineCatalogue()
        //     cc('nb line',IN_mamesh.lines.length)
        //
        //     let packer=new lineModule.CreateAColorIndexRespectingBifurcationsAndSymmetries(IN_mamesh)
        //     packer.packSymmetricLines=true
        //     packer.useConsecutiveIntegerForPackNumber=true
        //     let lineToColor=packer.goChanging()
        //
        //
        //     cc(packer.OUT_nbFoundSymmetricLines)
        //     cc(tab.maxValue(lineToColor))
        //
        //     let liner=new visu3d.LinesViewer(IN_mamesh,mathisFrame.scene)
        //     liner.interpolationOption=new geometry.InterpolationOption()
        //     liner.interpolationOption.interpolationStyle=geometry.InterpolationStyle.octavioStyle
        //     liner.goChanging()
        //
        // }
        //
        //
        // return bilan
        /**test sur les symetries*/
        {
            var gene = new mathis.reseau.BasisForRegularReseau();
            gene.nbI = 3;
            gene.nbJ = 3;
            var crea = new mathis.reseau.Regular(gene);
            var mamesh = crea.go();
            mamesh.fillLineCatalogue();
            new mathis.spacialTransformations.Similitude(mamesh.vertices, Math.PI / 4).goChanging();
            var packer = new mathis.lineModule.CreateAColorIndexRespectingBifurcationsAndSymmetries(mamesh);
            packer.packSymmetricLines = true;
            packer.useConsecutiveIntegerForPackNumber = true;
            var lineToLevel = packer.go();
            bilan.assertTrue(packer.OUT_nbFoundSymmetricLines == 4 && mathis.tab.maxValue(lineToLevel.allValues()) == 1);
        }
        /**choli*/
        {
            var crea = new mathis.creation2D.Concentric(7, 7);
            crea.individualTranslation = [new mathis.XYZ(0, 0, 0), new mathis.XYZ(0.3, 0, 0)];
            crea.individualRotations = [0, Math.PI / 4];
            var mamesh = crea.go();
            bilan.assertTrue(crea.SUB_oppositeLinkAssocierByAngles.OUT_nbBranching == 3);
            mamesh.fillLineCatalogue();
            var packer = new mathis.lineModule.CreateAColorIndexRespectingBifurcationsAndSymmetries(mamesh);
            packer.packSymmetricLines = true;
            packer.useConsecutiveIntegerForPackNumber = true;
            var lineToLevel = packer.go();
            bilan.assertTrue(packer.OUT_nbFoundSymmetricLines == 6 && mathis.tab.maxValue(lineToLevel.allValues()) == 9); //cela pass  vite  10 quand l'ago manque une fourche
        }
        // {
        //
        //     let crea = new creation2D.Concentric(9,9)
        //     crea.individualTranslation=[new XYZ(0,0,0),new XYZ(0.3,0,0)]
        //     crea.individualRotations=[0,Math.PI/4]
        //
        //     let IN_mamesh=crea.goChanging()
        //
        //     bilan.assertTrue(crea.SUB_oppositeLinkAssocierByAngles.OUT_nbBranching==3)
        //
        //     IN_mamesh.fillLineCatalogue()
        //
        //     bilan.assertTrue(IN_mamesh.allLinesAsASortedString()=='straightLines:["[0,1,2,3,4,5,6,7,8]","[0,9,18,27,36,45,54,146,147,148,149,150,151,152]","[1,10,19,28,37,46,55,138,139,140,141,142,143]","[1,10,19,28,37,46,55,146,155]","[161,152,143,134,125,116,107]","[161,160,159,158,157,156,155]","[18,19,20,21,22,23,24,25,26]","[2,11,20,29,38,47,56,138]","[27,28,29,30,31,32,33,34,35]","[3,12,21,30,39,48,120,121,122,123,124,125]","[36,37,38,39,40,41,42,43,44]","[4,13,22,31,40,49,112,113,114,115,116]","[4,13,22,31,40,49,120,129,138,147,156]","[45,46,47,48,49,50,51,52,53]","[5,14,23,32,41,50,112,121,130,139,148,157]","[54,55,56,129,130,131,132,133,134]","[6,15,24,33,42,51,60,114]","[62,61,60,113,122,131,140,149,158]","[7,16,25,34,43,52,61,106,107]","[7,16,25,34,43,52,61,114,123,132,141,150,159]","[8,17,26,35,44,53,62,106,115,124,133,142,151,160]","[9,10,11,12,13,14,15,16,17]"]')
        //
        //     // new lineModule.CreateAColorIndexRespectingBifurcationsAndSymmetries(IN_mamesh).goChanging()
        //     //
        //     // let liner=new visu3d.LinesViewer(IN_mamesh,mathisFrame.scene)
        //     // liner.interpolationOption=new geometry.InterpolationOption()
        //     // liner.interpolationOption.interpolationStyle=geometry.InterpolationStyle.octavioStyle
        //     // liner.goChanging()
        //
        // }
        {
            var crea = new mathis.reseau.Regular();
            var mamesh = crea.go();
            mathis.Vertex.separateTwoVoisins(mamesh.vertices[0], mamesh.vertices[1]);
            mamesh.fillLineCatalogue();
            bilan.assertTrue(mamesh.allLinesAsASortedString() == 'straightLines:["[0,3,6]","[1,2]","[1,4,7]","[2,5,8]","[3,4,5]","[6,7,8]"]');
        }
        /**here we test that, the sub IN_mamesh extractor take care of square*/
        {
            var crea = new mathis.reseau.Regular();
            crea.nbI = 7;
            crea.nbJ = 7;
            var mamesh = crea.go();
            var toKeep = [];
            for (var i = 0; i < mamesh.vertices.length; i++) {
                if (i != 11)
                    toKeep.push(mamesh.vertices[i]);
            }
            var suber = new mathis.grateAndGlue.SubMameshExtractor(mamesh, toKeep);
            suber.addBorderPolygonInsteadOfSuppress = true;
            mamesh = suber.go();
            mamesh.isolateMameshVerticesFromExteriorVertices();
            mamesh.fillLineCatalogue();
            bilan.assertTrue(mamesh.allLinesAsASortedString() == 'straightLines:["[0,1,2,3,4,5,6]","[0,7,14,21,28,35,42]","[1,8,15,22,29,36,43]","[14,15,16,17,18,19,20]","[2,9,16,23,30,37,44]","[21,22,23,24,25,26,27]","[28,29,30,31,32,33,34]","[3,10,17,24,31,38,45]","[35,36,37,38,39,40,41]","[4,11,18,25,32,39,46]","[42,43,44,45,46,47,48]","[5,12,19,26,33,40,47]","[6,13,20,27,34,41,48]","[7,8,9,10,11,12,13]"]');
        }
        /**here we test that, the sub IN_mamesh extractor take care of square*/
        {
            var crea = new mathis.reseau.Regular();
            crea.nbI = 7;
            crea.nbJ = 7;
            var mamesh = crea.go();
            var toKeep = [];
            for (var i = 0; i < mamesh.vertices.length; i++) {
                if (i != 11)
                    toKeep.push(mamesh.vertices[i]);
            }
            var suber = new mathis.grateAndGlue.SubMameshExtractor(mamesh, toKeep);
            mamesh = suber.go();
            mamesh.isolateMameshVerticesFromExteriorVertices();
            mamesh.fillLineCatalogue();
            bilan.assertTrue(mamesh.allLinesAsASortedString() == 'straightLines:["[0,1,2,3]","[0,7,14,21,28,35,42]","[1,8,15,22,29,36,43]","[12,13]","[14,15,16,17,18,19,20]","[18,25,32,39,46]","[2,9,16,23,30,37,44]","[21,22,23,24,25,26,27]","[28,29,30,31,32,33,34]","[3,10,17,24,31,38,45]","[35,36,37,38,39,40,41]","[42,43,44,45,46,47,48]","[5,12,19,26,33,40,47]","[5,6]","[6,13,20,27,34,41,48]","[7,8,9,10]"]');
        }
        {
            var crea = new mathis.reseau.Regular();
            crea.nbI = 7;
            crea.nbJ = 7;
            var mamesh = crea.go();
            var supp = new mathis.grateAndGlue.ExtractCentralPart(mamesh, 2);
            supp.suppressFromBorderVersusCorner = false;
            mamesh = supp.go();
            mamesh.isolateMameshVerticesFromExteriorVertices();
            mamesh.fillLineCatalogue();
            bilan.assertTrue(mamesh.allLinesAsASortedString() == 'straightLines:["[0,1,2]","[0,7,14,21,28,35,42]","[1,8,15,22,29,36,43]","[10,17,24,31,38]","[12,13,14,15,16,17,18]","[12,19,26]","[18,25,32]","[19,20,21,22,23,24,25]","[2,9,16,23,30,37,44]","[26,27,28,29,30,31,32]","[34,35,36,37,38]","[42,43,44]","[6,13,20,27,34]","[6,7,8,9,10]"]');
        }
        {
            var crea = new mathis.reseau.Regular();
            crea.nbI = 5;
            crea.nbJ = 5;
            var mamesh = crea.go();
            var supp = new mathis.grateAndGlue.ExtractCentralPart(mamesh, 1);
            supp.suppressFromBorderVersusCorner = false;
            mamesh = supp.go();
            mamesh.isolateMameshVerticesFromExteriorVertices();
            bilan.assertTrue(mamesh.allSquareAndTrianglesAsSortedString() == 'square:["[0,5,6,1]","[1,6,7,2]","[10,15,16,11]","[11,16,17,12]","[12,17,18,13]","[15,20,21,16]","[16,21,22,17]","[4,9,10,5]","[5,10,11,6]","[6,11,12,7]","[7,12,13,8]","[9,14,15,10]"]triangle:[]');
        }
        {
            var crea = new mathis.reseau.TriangulatedTriangle();
            crea.nbSubdivisionInSide = 3;
            var mamesh = crea.go();
            var supp = new mathis.grateAndGlue.ExtractCentralPart(mamesh, 1);
            supp.suppressFromBorderVersusCorner = false;
            mamesh = supp.go();
            mamesh.isolateMameshVerticesFromExteriorVertices();
            mamesh.fillLineCatalogue();
            bilan.assertTrue(mamesh.allLinesAsASortedString() == 'straightLines:["[0,4,2]","[0,7,1]","[1,10,2]","[3,0,8]","[3,4,10,11]","[3,5]","[5,2,9]","[5,4,7,6]","[6,1,11]","[6,8]","[8,7,10,9]","[9,11]"]');
        }
        // {
        //     let crea= new reseau.Regular()
        //     crea.nbI=4
        //     crea.nbJ=3
        //     let IN_mamesh=crea.goChanging()
        //
        //     let liner=new visu3d.LinesViewer(IN_mamesh,mathisFrame.scene)
        //     liner.interpolationOption=new geometry.InterpolationOption()
        //     liner.interpolationOption.interpolationStyle=geometry.InterpolationStyle.octavioStyle
        //     liner.goChanging()
        //
        //     cc(IN_mamesh.toString())
        //
        // }
        {
            var crea = new mathis.reseau.TriangulatedPolygone(3);
            var mamesh = crea.go();
            mamesh.vertices[0].setTwoOppositeLinks(mamesh.vertices[1], mamesh.vertices[3]);
            var linkOp = new mathis.linkModule.OppositeLinkAssocierByAngles(mamesh.vertices);
            linkOp.clearAllExistingOppositeBefore = false;
            linkOp.maxAngleToAssociateLinks = 2 * Math.PI * 0.4;
            linkOp.goChanging();
            mamesh.fillLineCatalogue();
            bilan.assertTrue(mamesh.allLinesAsASortedString() == 'straightLines:["[0,2]","[1,0,3]"]|loopLines:["[1,2,3]"]');
        }
        {
            var crea = new mathis.reseau.TriangulatedPolygone(3);
            var mamesh = crea.go();
            mamesh.vertices[0].setTwoOppositeLinks(mamesh.vertices[2], mamesh.vertices[3]);
            // IN_mamesh.vertices[0].setTwoOppositeLinks(IN_mamesh.vertices[1],IN_mamesh.vertices[2])
            // IN_mamesh.vertices[0].setTwoOppositeLinks(IN_mamesh.vertices[2],IN_mamesh.vertices[3])
            var linkOp = new mathis.linkModule.OppositeLinkAssocierByAngles(mamesh.vertices);
            linkOp.clearAllExistingOppositeBefore = false;
            linkOp.maxAngleToAssociateLinks = 2 * Math.PI * 0.4;
            linkOp.goChanging();
            mamesh.fillLineCatalogue();
            bilan.assertTrue(mamesh.allLinesAsASortedString() == 'straightLines:["[0,1]","[2,0,3]"]|loopLines:["[1,2,3]"]');
        }
        {
            var crea = new mathis.reseau.TriangulatedPolygone(5);
            var mamesh = crea.go();
            var linkOp = new mathis.linkModule.OppositeLinkAssocierByAngles(mamesh.vertices);
            linkOp.clearAllExistingOppositeBefore = true;
            linkOp.goChanging();
            new mathis.mameshModification.MameshCleaner(mamesh).goChanging();
            mamesh.fillLineCatalogue();
            bilan.assertTrue(mamesh.allLinesAsASortedString() == 'straightLines:["[1,0,4]","[1,2]","[1,5]","[2,0,5]","[2,3]","[3,0,5]","[3,4]","[4,5]"]');
        }
        {
            var crea = new mathis.reseau.TriangulatedPolygone(3);
            var mamesh = crea.go();
            new mathis.spacialTransformations.Similitude(mamesh.vertices, 0.01).goChanging();
            var linkOp = new mathis.linkModule.OppositeLinkAssocierByAngles(mamesh.vertices);
            linkOp.clearAllExistingOppositeBefore = true;
            linkOp.maxAngleToAssociateLinks = 2 * Math.PI * 0.4;
            linkOp.goChanging();
            mamesh.fillLineCatalogue();
            bilan.assertTrue(mamesh.allLinesAsASortedString() == 'straightLines:["[1,0,2]","[1,0,3]"]|loopLines:["[1,2,3]"]');
        }
        {
            var gene = new mathis.reseau.BasisForRegularReseau();
            gene.nbI = 3;
            gene.nbJ = 3;
            var crea = new mathis.reseau.Regular(gene);
            var mamesh = crea.go();
            mamesh.vertices[4].setTwoOppositeLinks(mamesh.vertices[1], mamesh.vertices[5]);
            mamesh.vertices[4].setTwoOppositeLinks(mamesh.vertices[1], mamesh.vertices[3]);
            mamesh.fillLineCatalogue();
            bilan.assertTrue(mamesh.allLinesAsASortedString() == 'straightLines:["[0,1,2]","[0,3,6]","[1,4,3]","[1,4,5]","[1,4,7]","[2,5,8]","[3,4,5]","[6,7,8]"]');
        }
        {
            var crea = new mathis.reseau.TriangulatedPolygone(3);
            var mamesh = crea.go();
            mamesh.vertices[0].setTwoOppositeLinks(mamesh.vertices[3], mamesh.vertices[1]);
            mamesh.vertices[0].setTwoOppositeLinks(mamesh.vertices[1], mamesh.vertices[2]);
            mamesh.vertices[0].setTwoOppositeLinks(mamesh.vertices[2], mamesh.vertices[3]);
            mamesh.fillLineCatalogue();
            bilan.assertTrue(mamesh.allLinesAsASortedString() == 'straightLines:["[1,0,2]","[1,0,3]","[1,2]","[1,3]","[2,0,3]","[2,3]"]');
        }
        {
            var gene = new mathis.reseau.BasisForRegularReseau();
            gene.nbI = 3;
            gene.nbJ = 3;
            var crea = new mathis.reseau.Regular(gene);
            var mamesh = crea.go();
            mamesh.vertices[4].setTwoOppositeLinks(mamesh.vertices[1], mamesh.vertices[5]);
            mamesh.vertices[4].setTwoOppositeLinks(mamesh.vertices[1], mamesh.vertices[3]);
            mamesh.vertices[4].setTwoOppositeLinks(mamesh.vertices[7], mamesh.vertices[5]);
            mamesh.vertices[4].setTwoOppositeLinks(mamesh.vertices[7], mamesh.vertices[3]);
            mamesh.fillLineCatalogue();
            bilan.assertTrue(mamesh.allLinesAsASortedString() == 'straightLines:["[0,1,2]","[0,3,6]","[1,4,3]","[1,4,5]","[1,4,7]","[2,5,8]","[3,4,5]","[3,4,7]","[5,4,7]","[6,7,8]"]');
        }
        {
            var gene = new mathis.reseau.BasisForRegularReseau();
            gene.nbI = 3;
            gene.nbJ = 3;
            var crea = new mathis.reseau.Regular(gene);
            var mamesh = crea.go();
            mamesh.vertices[4].setTwoOppositeLinks(mamesh.vertices[7], mamesh.vertices[5]);
            mamesh.vertices[4].setTwoOppositeLinks(mamesh.vertices[7], mamesh.vertices[3]);
            mamesh.fillLineCatalogue();
            bilan.assertTrue(mamesh.allLinesAsASortedString() == 'straightLines:["[0,1,2]","[0,3,6]","[1,4,7]","[2,5,8]","[3,4,5]","[3,4,7]","[5,4,7]","[6,7,8]"]');
        }
        {
            var mamesh = new mathis.Mamesh();
            new mathis.creationFlat.SingleSquareWithOneDiag(mamesh).go();
            //new mameshModification.TriangleDichotomer(IN_mamesh).goChanging()
            var v0 = mamesh.vertices[0];
            var v1 = mamesh.vertices[1];
            var v2 = mamesh.vertices[2];
            var v3 = mamesh.vertices[3];
            v0.setTwoOppositeLinks(v1, v3);
            v1.setTwoOppositeLinks(v2, v0);
            v2.setTwoOppositeLinks(v3, v1);
            v3.setTwoOppositeLinks(v0, v2);
            mamesh.fillLineCatalogue();
            bilan.assertTrue(mamesh.allLinesAsASortedString() == 'straightLines:["[1,3]"]|loopLines:["[0,1,2,3]"]');
        }
        {
            var crea = new mathis.creation2D.Concentric(6, 6);
            crea.nbPatches = 3;
            //crea.SUB_gratAndStick.justGrateDoNotStick=true
            crea.shapes = [PartShape.square];
            crea.proportions = [new mathis.UV(1, 1)];
            crea.SUB_gratAndStick.proximityCoefToStick = [2];
            crea.SUB_gratAndStick.SUB_grater.proportionOfSeeds = [0.09];
            var angle = [0, Math.PI / 3, -Math.PI / 3];
            crea.individualRotations = angle;
            var rad = 0.5;
            crea.individualTranslation = [new mathis.XYZ(Math.cos(angle[0]) + 1, Math.sin(angle[0]), 0).scale(rad), new mathis.XYZ(Math.cos(angle[1]), Math.sin(angle[1]), 0).scale(rad), new mathis.XYZ(Math.cos(angle[2]), Math.sin(angle[2]), 0).scale(rad)];
            var mamesh = crea.go();
            mamesh.fillLineCatalogue();
            bilan.assertTrue(mamesh.allLinesAsASortedString() == 'straightLines:["[11,12,13,14,15,16]","[17,18,19,20,21,22]","[23,17,11,5,83,77,71,65]","[23,24,25,26,27,28]","[24,18,12,6,0,91,92,54,48,42,36,30]","[25,19,13,7,1,91,85,79,73,67]","[26,20,14,8,2,56,50,44,38,32]","[27,21,15,9,3,56,55,54,87,81,75,69]","[28,22,16,10,52,46,40,34]","[29,30,31,32,33,34]","[29,35,41,47,88,82,76,70]","[31,37,43,49,55,92,86,80,74,68]","[33,39,45,51,3,2,1,0,84,78,72,66]","[35,36,37,38,39,40]","[41,42,43,44,45,46]","[47,48,49,50,51,52]","[5,6,7,8,9,10]","[70,69,68,67,66,65]","[76,75,74,73,72,71]","[82,81,80,79,78,77]","[88,87,86,85,84,83]"]');
        }
        // {
        //
        //
        //     let crea=new creation2D.Patchwork(7,7,2,1)
        //
        //     crea.shapes = [PartShape.square]
        //     crea.individualRotations=[Math.PI/4]
        //
        //     let IN_mamesh=crea.goChanging()
        //
        //     IN_mamesh.fillLineCatalogue()
        //
        //
        //     let liner=new visu3d.LinesViewer(IN_mamesh,mathisFrame.scene)
        //     liner.interpolationOption=new geometry.InterpolationOption()
        //     liner.interpolationOption.interpolationStyle=geometry.InterpolationStyle.octavioStyle
        //     liner.goChanging()
        //
        //     let vertexVisu=new visu3d.VerticesViewer(null,mathisFrame.scene)
        //     vertexVisu.selectedVertices=crea.SUB_gratAndStick.SUB_grater.OUTAllSeeds
        //     vertexVisu.goChanging()
        //
        //
        //
        // }
        // {
        //     let gene=new reseau.BasisForRegularReseau()
        //     gene.nbI=5
        //     gene.nbJ=5
        //
        //
        //     let crea=new reseau.Regular(gene)
        //     let IN_mamesh=crea.goChanging()
        //
        //
        //     let lineFiller=new mameshAroundComputations.LineComputer(IN_mamesh)
        //     lineFiller.computeAllLinesVersusInnerLines=false
        //     lineFiller.selectLineSpacing=1
        //     lineFiller.goChanging()
        //
        //
        //
        //     let liner=new visu3d.LinesViewer(IN_mamesh,mathisFrame.scene)
        //     liner.interpolationOption=new geometry.InterpolationOption()
        //     liner.interpolationOption.interpolationStyle=geometry.InterpolationStyle.octavioStyle
        //     liner.goChanging()
        //
        //
        // }
        //
        // return bilan
        // /**un blason*/
        // {
        //
        //     let crea=new creation2D.Concentric(8,8)
        //     crea.nbPatches=1
        //     crea.shapes=[PartShape.polygon3]
        //     crea.propBeginToRound=[0]
        //     crea.propEndToRound=[1]
        //     crea.exponentOfRoundingFunction=[0.5]
        //     crea.SUB_gratAndStick.SUB_grater.proportionOfSeeds=[0.2]
        //     crea.SUB_oppositeLinkAssocierByAngles.canCreateBifurcations=true
        //     crea.SUB_mameshCleaner.suppressLinkWithoutOppositeFunction=null
        //
        //     let IN_mamesh=crea.goChanging()
        //
        //
        //     IN_mamesh.fillLineCatalogue()
        //     bilan.assertTrue(IN_mamesh.allLinesAsASortedString()=='straightLines:["[0,10,4,15,1]","[0,12,6,16,2]","[0,20,8,23,3]","[1,13,5,18,2]","[1,30,9,27,3]","[10,12]","[10,20]","[11,10,26]","[11,12,19,24,25]","[12,20]","[13,15,30]","[15,14,17]","[15,29,28]","[16,22,24,23]","[18,16,21]","[2,21,7,25,3]","[21,22,19,20,26]","[25,23,27]","[4,11,17,18]","[4,26,28,27]","[5,14,4,29,9]","[5,17,16]","[6,11,14,13]","[6,19,8]","[7,22,6,17]","[7,24,8,28]","[8,26,29,30]","[9,28,23]"]')
        //
        //
        //
        //
        //
        // }
        /**a funny miro shape*/
        {
            var crea = new mathis.creation2D.Patchwork(7, 7, 2, 2);
            crea.shapes = [PartShape.polygon4];
            crea.individualScales = [new mathis.UV(1.2, 1.2)];
            crea.patchesInQuinconce = true;
            crea.oddPatchLinesAreTheSameVersusLongerVersusShorter = 2;
            crea.integerBeginToRound = [1];
            crea.integerEndToRound = [-1];
            crea.SUB_gratAndStick.SUB_grater.proportionOfSeeds = [0.2];
            crea.SUB_oppositeLinkAssocierByAngles.canCreateBifurcations = false;
            var mamesh = crea.go();
            mamesh.fillLineCatalogue();
            bilan.assertTrue(mamesh.allLinesAsASortedString() == 'straightLines:["[100,23,76,416,303,335,245,168,221]","[101,102,97,72,71,74,247,242,217,216,219,192]","[101,125,123,41,42,48,270,268,186,187,193,192]","[101,30,98,0,43,15,47,243,145,188,160,192]","[125,30,102]","[126,13,45]","[190,158,271]","[191,158,186,145,217,168,220]","[191,190,187,188,216,221,220,338,305,364]","[191,271,268,243,242,245,220]","[193,160,219]","[270,47,247,336,416,413,388,387,390,365]","[365,313,362,290,331,303]","[390,313,366]","[391,320,388,290,333,305,337]","[391,392,387,362,361,364,337]","[391,415,413,331,332,338,337]","[46,126,123,98,97,100,75,415,320,392]","[46,13,41,0,72,23,75]","[46,45,42,43,71,76,75]","[48,15,74,336,335,332,333,361,366,365]"]');
        }
        /**trois carrs*/
        {
            var crea = new mathis.creation2D.Patchwork(7, 7, 2, 2);
            crea.shapes = [PartShape.polygon4];
            crea.individualScales = [new mathis.UV(1.2, 1.2)];
            crea.patchesInQuinconce = true;
            crea.oddPatchLinesAreTheSameVersusLongerVersusShorter = 2;
            crea.SUB_gratAndStick.SUB_grater.proportionOfSeeds = [0.2];
            crea.SUB_oppositeLinkAssocierByAngles.canCreateBifurcations = false;
            crea.SUB_mameshCleaner.suppressLinkWithoutOppositeFunction = null;
            var mamesh = crea.go();
            mamesh.fillLineCatalogue();
            bilan.assertTrue(mamesh.allLinesAsASortedString() == 'straightLines:["[100,23,76]","[101,102,100,75,415,320,392]","[101,125,126,46]","[101,30,98,0,43,15,175,243,145,188,160,192]","[102,97,72,71,74,247,242,217,216,219]","[125,123,41,42,48,270,268,186,187,193]","[125,30,102]","[126,123,98,97,100]","[126,13,45]","[13,42,15]","[158,268,175]","[160,187,158]","[160,216,168]","[168,242,175]","[186,243]","[188,186]","[188,217]","[190,158,271]","[190,187,188,216,221]","[191,158,186,145,217,168,220]","[191,271,270,175,247,336,416,415,391]","[192,193,190,191]","[192,219,221,220,338,305,364]","[193,160,219]","[217,243]","[220,245,247]","[221,168,245]","[23,71,15]","[271,268,243,242,245,335,332,333,361,366]","[30,123,13]","[30,97,23]","[305,332,303]","[313,361,305]","[313,387,320]","[320,413,303]","[333,331]","[362,333]","[362,388]","[365,313,362,290,331,303,336]","[365,366,364,337]","[365,390,392,391]","[388,331]","[390,313,366]","[391,320,388,290,333,305,337]","[392,387,362,361,364]","[41,43]","[415,413,331,332,338]","[416,303,335]","[45,42,43,71,76,416,413,388,387,390]","[46,13,41,0,72,23,75]","[46,45,48,15,74,336,335,338,337]","[72,43]","[75,76,74]","[98,41]","[98,72]"]');
        }
        {
            var crea = new mathis.creation2D.Patchwork(7, 7, 2, 2);
            crea.shapes = [PartShape.polygon4];
            crea.individualScales = [new mathis.UV(1.0, 1.0)];
            crea.SUB_gratAndStick.SUB_grater.proportionOfSeeds = [0.2];
            var mamesh = crea.go();
            var OUTAllSeeds = [];
            for (var _b = 0, _c = crea.SUB_gratAndStick.SUB_grater.OUT_allSeeds; _b < _c.length; _b++) {
                var seeds = _c[_b];
                OUTAllSeeds = OUTAllSeeds.concat(seeds);
            }
            bilan.assertTrue(OUTAllSeeds.length == 36);
        }
        /**4 carrs*/
        {
            var crea = new mathis.creation2D.Patchwork(4, 4, 2, 2);
            crea.shapes = [PartShape.polygon4];
            crea.individualScales = [new mathis.UV(1.0, 1.0)];
            crea.SUB_gratAndStick.SUB_grater.seedComputedFromBarycentersVersusFromAllPossibleCells = false;
            var mamesh = crea.go();
            var OUTAllSeeds = [];
            for (var _d = 0, _e = crea.SUB_gratAndStick.SUB_grater.OUT_allSeeds; _d < _e.length; _d++) {
                var seeds = _e[_d];
                OUTAllSeeds = OUTAllSeeds.concat(seeds);
            }
            bilan.assertTrue(OUTAllSeeds.length == 44);
            mamesh.fillLineCatalogue();
            bilan.assertTrue(mamesh.allLinesAsASortedString() == 'straightLines:["[1,12,4]","[1,5,0,9,3,31,26,35,29]","[1,6,2,23,16,45,41]","[10,11,12]","[14,18,13,22,16,44,39,48,42]","[14,19,15]","[14,25,2,8,3,38,30]","[15,21,16,51,28,34,29]","[19,18,25]","[19,20,21]","[21,22,23]","[23,24,25]","[29,36,30]","[30,37,26,33,28,50,39,46,41]","[32,31,38]","[32,33,34]","[34,35,36]","[36,37,38]","[4,10,3,32,28,49,42]","[4,11,0,7,2,24,13,20,15]","[41,47,42]","[45,44,51]","[45,46,47]","[47,48,49]","[49,50,51]","[6,5,12]","[6,7,8]","[8,9,10]"]');
        }
        /**to check the suppression of overlpaing seeds */
        {
            var crea = new mathis.creation2D.Patchwork(4, 4, 2, 2);
            crea.shapes = [PartShape.polygon4];
            crea.individualScales = [new mathis.UV(1.01, 1.01)];
            crea.SUB_gratAndStick.SUB_grater.proportionOfSeeds = [0.5];
            var mamesh = crea.go();
            bilan.assertTrue(mamesh.vertices.length == 48);
        }
        {
            var crea = new mathis.creation2D.Concentric(11, 11);
            crea.nbPatches = 2;
            crea.shapes = [PartShape.polygon6, PartShape.square];
            crea.proportions = [new mathis.UV(1, 1), new mathis.UV(0.5, 0.5)];
            crea.integerBeginToRound = [1];
            crea.integerEndToRound = [-2];
            crea.SUB_gratAndStick.SUB_grater.proportionOfSeeds = [0.1];
            crea.SUB_gratAndStick.SUB_grater.asymmetriesForSeeds = [{ direction: new mathis.XYZ(0, 1, 0), influence: 0.5, modulo: Math.PI / 2 }, { direction: new mathis.XYZ(1, 0, 0), influence: 0.5 }];
            crea.SUB_gratAndStick.SUB_grater.seedComputedFromBarycentersVersusFromAllPossibleCells = true;
            var mamesh = crea.go();
        }
        // {
        //
        //     let crea=new creation2D.Concentric(7,7)
        //     crea.nbPatches=2
        //     crea.shapes=[PartShape.square,PartShape.triangulatedTriangle]
        //     crea.proportions=[new UV(1,1),new UV(0.5,0.5)]
        //     let IN_mamesh=crea.goChanging()
        //
        //     IN_mamesh.fillLineCatalogue()
        //     bilan.assertTrue(IN_mamesh.allLinesAsASortedString()=='straightLines:["[0,1,2,3,4,5,6]","[0,7,14,21,28,35,42]","[1,8,15,22,29,36,43]","[10,61,63]","[11,51,63,53,58,50,39]","[14,15,16,54,62,53]","[2,9,16,57,55,30,37,44]","[21,22]","[28,29,30,52,59,53]","[3,10,54,56,52,38,45]","[35,36,37,38,39,40,41]","[38,60,58]","[4,11,61,62,59,60,39,46]","[42,43,44,45,46,47,48]","[47,40,50,60,52,55]","[48,41]","[5,12,51,61,54,57]","[58,59,56,57]","[6,13]","[63,62,56,55]","[7,8,9,10,11,12,13]"]')
        //
        //
        //     cc(IN_mamesh.allLinesAsASortedString())
        //     let liner=new visu3d.LinesViewer(IN_mamesh,mathisFrame.scene)
        //     liner.interpolationOption=new geometry.InterpolationOption()
        //     liner.interpolationOption.interpolationStyle=geometry.InterpolationStyle.octavioStyle
        //     liner.goChanging()
        //
        // }
        {
            var poly = new mathis.reseau.TriangulatedTriangle();
            poly.nbSubdivisionInSide = 5;
            var mamesh = poly.go();
            mamesh.fillLineCatalogue();
            bilan.assertTrue(mamesh.allLinesAsASortedString() == 'straightLines:["[11,0,16]","[11,35,36,34]","[12,0,37,6,33]","[12,15]","[15,0,35,3,21]","[16,37,36,20]","[18,21,20,34,33,27]","[20,3,25]","[21,24]","[24,3,36,6,30]","[25,35,37,29]","[29,6,34]","[30,33]","[9,12,11,25,24,18]","[9,15,16,29,30,27]"]');
        }
        //return bilan
        {
            var poly = new mathis.reseau.TriangulatedPolygone(5);
            poly.nbSubdivisionInARadius = 3;
            var mamesh = poly.go();
            mamesh.fillLineCatalogue();
            bilan.assertTrue(mamesh.allLinesAsASortedString() == 'straightLines:["[0,108,33,111]","[0,134,40,137]","[0,51,16,56]","[0,53,18,57]","[0,82,26,85]","[110,107,108,134,159,162]","[111,136,138,137]","[112,33,133,40,161]","[55,16,159,40,138]","[55,52,53,82,107,112]","[56,162,161,137]","[56,55,58,57]","[57,84,86,85]","[58,18,81,26,110]","[58,52,51,134,133,136]","[84,18,52,16,162]","[84,81,82,108,133,138]","[85,110,112,111]","[86,26,107,33,136]","[86,81,53,51,159,161]"]');
        }
        //return bilan
        // {
        //
        //     let poly=new reseau.TriangulatedPolygone(9)
        //     poly.nbSubdivisionsInARadius=3
        //     let mamesh=poly.goChanging()
        //
        //     let rounder=new spacialTransformations.RoundSomeStrates(mamesh)
        //
        //     rounder.integerBeginToRound=1
        //     rounder.integerEndToRound=-1
        //
        //     rounder.exponentOfRoundingFunction=1
        //     rounder.referenceRadiusIsMinVersusMaxVersusMean=2
        //     rounder.preventStratesCrossings=true
        //     rounder.goChanging()
        //
        //
        //     mamesh.clearOppositeInLinks()
        //
        //
        //     let asso=new linkModule.OppositeLinkAssocierByAngles(mamesh.vertices)
        //     asso.canCreateBifurcations=false
        //     asso.goChanging()
        //
        //     new mameshModification.MameshCleaner(mamesh).goChanging()
        //
        //
        //     let lineFill=new lineModule.LineComputer(mamesh)
        //     lineFill.lookAtBifurcation=false
        //     lineFill.goChanging()
        //
        //     bilan.assertTrue(mamesh.allLinesAsASortedString()=='straightLines:["[0,122,38,125]","[124,121,122,148,173,178]","[126,121,93,91,303,305]","[150,147,148,174,199,204]","[151,45,148,0,252,73,255]","[176,173,174,200,225,230]","[177,52,174,0,278,80,281]","[202,199,200,226,251,256]","[228,225,226,252,277,282]","[254,251,252,278,303,306]","[28,306]","[28,95]","[30,124]","[30,98]","[38,126]","[38,150]","[45,152]","[45,176]","[52,178]","[52,202]","[59,204]","[59,228]","[66,230]","[66,254]","[73,256]","[73,280]","[80,282]","[80,305]","[95,92,93,122,147,152]","[96,28,91,0,200,59,203]","[97,30,93,0,226,66,229]","[98,92,91,278,277,280]"]|loopLines:["[28,92,30,121,38,147,45,173,52,199,59,225,66,251,73,277,80,303]","[95,96,306,305,281,282,280,255,256,254,229,230,228,203,204,202,177,178,176,151,152,150,125,126,124,97,98]"]')
        //     //bilan.assertTrue(IN_mamesh.allLinesAsASortedString()=='straightLines:["[0,252,73,255]","[124,121,122,148,173,178]","[125,38,122,0,226,66,229]","[126,121,93,91,303,305]","[150,147,148,174,199,204]","[151,45,148,0,278,80,281]","[176,173,174,200,225,230]","[202,199,200,226,251,256]","[228,225,226,252,277,282]","[254,251,252,278,303,306]","[28,306]","[28,95]","[30,124]","[30,98]","[38,126]","[38,150]","[45,152]","[45,176]","[52,178]","[52,202]","[59,204]","[59,228]","[66,230]","[66,254]","[73,256]","[73,280]","[80,282]","[80,305]","[95,92,93,122,147,152]","[96,28,91,0,174,52,177]","[97,30,93,0,200,59,203]","[98,92,91,278,277,280]"]|loopLines:["[28,92,30,121,38,147,45,173,52,199,59,225,66,251,73,277,80,303]","[95,96,306,305,281,282,280,255,256,254,229,230,228,203,204,202,177,178,176,151,152,150,125,126,124,97,98]"]')
        //
        //     // cc(IN_mamesh.allLinesAsASortedString())
        //     let liner=new visu3d.LinesViewer(IN_mamesh,mathisFrame.scene)
        //     liner.interpolationOption=new geometry.InterpolationOption()
        //     liner.interpolationOption.interpolationStyle=geometry.InterpolationStyle.octavioStyle
        //     liner.goChanging()
        //
        //
        // }
        // {
        //
        //     let poly=new reseau.TriangulatedPolygone(9)
        //     poly.nbSubdivisionsInARadius=3
        //     let IN_mamesh=poly.goChanging()
        //
        //     let rounder=new spacialTransformations.RoundSomeStrates(IN_mamesh)
        //
        //     rounder.integerBeginToRound=1
        //     rounder.integerEndToRound=-1
        //
        //     rounder.exponentOfRoundingFunction=1
        //     rounder.referenceRadiusIsMinVersusMaxVersusMean=2
        //     rounder.preventStratesCrossings=true
        //     rounder.goChanging()
        //
        //     IN_mamesh.clearOppositeInLinks()
        //
        //     let asso=new linkModule.OppositeLinkAssocierByAngles(IN_mamesh.vertices)
        //     asso.goChanging()
        //
        //     IN_mamesh.fillLineCatalogue()
        //
        //
        //     bilan.assertTrue(IN_mamesh.allLinesAsASortedString()=='straightLines:["[0,122,38,125]","[124,121,122,148,173,178]","[126,121,93,91,303,305]","[150,147,148,174,199,204]","[151,45,148,0,252,73,255]","[151,45,148,0,278,80,281]","[176,173,174,200,225,230]","[202,199,200,226,251,256]","[228,225,226,252,277,282]","[254,251,252,278,303,306]","[28,306]","[28,95]","[30,124]","[30,98]","[38,126]","[38,150]","[45,152]","[45,176]","[52,178]","[52,202]","[59,204]","[59,228]","[66,230]","[66,254]","[73,256]","[73,280]","[80,282]","[80,305]","[95,92,93,122,147,152]","[96,28,91,0,174,52,177]","[96,28,91,0,200,59,203]","[97,30,93,0,226,66,229]","[98,92,91,278,277,280]"]|loopLines:["[28,92,30,121,38,147,45,173,52,199,59,225,66,251,73,277,80,303]","[95,96,306,305,281,282,280,255,256,254,229,230,228,203,204,202,177,178,176,151,152,150,125,126,124,97,98]"]')
        //
        //
        //     cc(IN_mamesh.allLinesAsASortedString())
        //     let liner=new visu3d.LinesViewer(IN_mamesh,mathisFrame.scene)
        //     liner.interpolationOption=new geometry.InterpolationOption()
        //     liner.interpolationOption.interpolationStyle=geometry.InterpolationStyle.octavioStyle
        //     liner.goChanging()
        //
        //
        // }
        // {
        //     let structureDescription = new creation2D.Concentric(9,9)
        //     structureDescription.nbPatches=1
        //     structureDescription.shapes=[mathis.creation2D.PartShape.square]
        //     structureDescription.individualRotations=[Math.PI/4,0]
        //     structureDescription.proportions=[new UV(1,1),new UV(0.3,1)]
        //     //structureDescription.individualTranslation=[new XYZ(0,0,0),new XYZ(1.5,0,0)]
        //     //structureDescription.individualScales=[new UV(1,1),new UV(0.8,0.8)]
        //     // let rad=0.5
        //     // structureDescription.individualTranslation=[new XYZ(Math.cos(angle[0])+1,Math.sin(angle[0]),0).scale(rad),new XYZ(Math.cos(angle[1]),Math.sin(angle[1]),0).scale(rad),new XYZ(Math.cos(angle[2]),Math.sin(angle[2]),0).scale(rad)]
        //
        //     //structureDescription.individualTranslation=[new XYZ(1,0,0),new XYZ(-1,0,0)]
        //
        //
        //     let IN_mamesh=structureDescription.goChanging()
        //     cc(structureDescription.OUTComputedSize)
        //
        //     let liner=new visu3d.LinesViewer(IN_mamesh,mathisFrame.scene)
        //     liner.interpolationOption=new geometry.InterpolationOption()
        //     liner.interpolationOption.interpolationStyle=geometry.InterpolationStyle.octavioStyle
        //     liner.goChanging()
        //
        //     let vertexer=new visu3d.VerticesViewer(IN_mamesh,mathisFrame.scene)
        //     vertexer.goChanging()
        //
        // }
        {
            var poly = new mathis.reseau.TriangulatedPolygone(4);
            poly.nbSubdivisionInARadius = 4;
            var mamesh = poly.go();
            mamesh.fillLineCatalogue();
            bilan.assertTrue(mamesh.allLinesAsASortedString() == 'straightLines:["[1,16,6,21,2]","[1,18,5,13,0,23,9,26,3]","[1,40,12,37,4]","[16,17,14,15,23,29,34,35]","[16,18,39,38,33,35]","[2,19,7,15,0,30,11,33,4]","[2,24,8,28,3]","[21,19,25,27,26,31]","[21,20,14,13,30,29,32,31]","[24,19,20,17,18,40]","[24,25,22,23,30,36,39,40]","[28,26,32,34,33,37]","[28,27,22,15,13,36,38,37]","[3,31,10,35,4]","[6,17,5,36,11,34,10]","[6,20,7,22,9,32,10]","[8,25,7,14,5,39,12]","[8,27,9,29,11,38,12]"]');
        }
        {
            var reseuCrea = new mathis.reseau.Regular();
            reseuCrea.nbI = 3;
            reseuCrea.nbJ = 3;
            var reso = reseuCrea.go();
            var border = [];
            for (var _f = 0, _g = reso.vertices; _f < _g.length; _f++) {
                var ver = _g[_f];
                if (ver.hasMark(mathis.Vertex.Markers.border))
                    border.push(ver);
            }
            var rings = mathis.graph.ringify(border);
            bilan.assertTrue(rings[0].length == 8 && rings[1].length == 1);
        }
        {
            var reseuCrea = new mathis.reseau.Regular();
            reseuCrea.nbI = 3;
            reseuCrea.nbJ = 4;
            var reso = reseuCrea.go();
            var border = [];
            for (var _h = 0, _j = reso.vertices; _h < _j.length; _h++) {
                var ver = _j[_h];
                if (ver.hasMark(mathis.Vertex.Markers.border))
                    border.push(ver);
            }
            var rings = mathis.graph.ringify(border);
            bilan.assertTrue(rings[0].length == 10 && rings[1].length == 2);
        }
        {
            var reseuCrea = new mathis.reseau.Regular();
            reseuCrea.nbI = 4;
            reseuCrea.nbJ = 4;
            var reso = reseuCrea.go();
            var border = [];
            for (var _k = 0, _l = reso.vertices; _k < _l.length; _k++) {
                var ver = _l[_k];
                if (ver.hasMark(mathis.Vertex.Markers.border))
                    border.push(ver);
            }
            var rings = mathis.graph.ringify(border);
            bilan.assertTrue(rings[0].length == 12 && rings[1].length == 4);
        }
        {
            var reseuCrea = new mathis.reseau.Regular();
            reseuCrea.nbI = 5;
            reseuCrea.nbJ = 5;
            var reso = reseuCrea.go();
            var border = [];
            for (var _m = 0, _o = reso.vertices; _m < _o.length; _m++) {
                var ver = _o[_m];
                if (ver.hasMark(mathis.Vertex.Markers.border))
                    border.push(ver);
            }
            var rings = mathis.graph.ringify(border);
            bilan.assertTrue(rings[0].length == 16 && rings[1].length == 8 && rings[2].length == 1);
        }
        {
            var test = function (nbSides) {
                var crea = new mathis.reseau.TriangulatedPolygone(nbSides);
                var mamesh = crea.go();
                var nbDicho = 2;
                for (var dic = 0; dic < nbDicho; dic++) {
                    var dicotomer = new mathis.mameshModification.TriangleDichotomer(mamesh);
                    dicotomer.makeLinks = false;
                    dicotomer.go();
                }
                var linkMaker = new mathis.linkModule.LinkCreaterSorterAndBorderDetecterByPolygons(mamesh);
                linkMaker.goChanging();
                return mamesh;
            };
            var mamesh = test(3);
            var count = 0;
            for (var _p = 0, _q = mamesh.vertices; _p < _q.length; _p++) {
                var ve = _q[_p];
                if (ve.hasMark(mathis.Vertex.Markers.border))
                    count++;
            }
            bilan.assertTrue(count == 12);
            mamesh = test(4);
            count = 0;
            for (var _r = 0, _s = mamesh.vertices; _r < _s.length; _r++) {
                var ve = _s[_r];
                if (ve.hasMark(mathis.Vertex.Markers.border))
                    count++;
            }
            bilan.assertTrue(count == 16);
            mamesh = test(5);
            count = 0;
            for (var _t = 0, _u = mamesh.vertices; _t < _u.length; _t++) {
                var ve = _u[_t];
                if (ve.hasMark(mathis.Vertex.Markers.border))
                    count++;
            }
            bilan.assertTrue(count == 20);
        }
        // {
        //
        //     let gene=new reseau.BasisForRegularReseau()
        //     gene.nbI=4
        //     gene.nbJ=4
        //     gene.origin=new XYZ(-0.5,-0.5,0)
        //     gene.end=new XYZ(0.5,0.5,0)
        //
        //
        //     let creater=new reseau.Regular(gene)
        //     let IN_mamesh=creater.goChanging()
        //
        //
        //
        //     new creation2D.Similitude(IN_mamesh.vertices,Math.PI/4).goChanging()
        //
        //     IN_mamesh.vertices.forEach((v)=>{
        //         v.links.forEach(li=>{
        //             li.opposite=null
        //         })
        //     })
        //
        //
        //     let linkOp=new mameshAroundComputations.LinksSorterAndCleanerByAngles(IN_mamesh)
        //     linkOp.goChanging()
        //
        //     cc(IN_mamesh.toString())
        //
        //     new visu3d.LinesViewer(IN_mamesh,mathisFrame.scene).goChanging()
        //
        //
        //
        //
        // }
        //
        //
        // return bilan
        {
            var test = function (angleBetween, maxAngle) {
                var mamesh = new mathis.Mamesh();
                var v0 = new mathis.Vertex();
                v0.param = new mathis.XYZ(Math.random(), 0, 0);
                v0.position = new mathis.XYZ(0, 0, 0);
                mamesh.addVertex(v0);
                var otherVertices = [];
                var anglesProp = [];
                for (var i = 0; i < 1; i += angleBetween)
                    anglesProp.push(i);
                var p = 1;
                for (var _i = 0, anglesProp_1 = anglesProp; _i < anglesProp_1.length; _i++) {
                    var i = anglesProp_1[_i];
                    var angle = 2 * Math.PI * i;
                    var v = new mathis.Vertex();
                    v.param = new mathis.XYZ(p++, 0, 0);
                    v.position = new mathis.XYZ(Math.cos(angle), Math.sin(angle), 0);
                    otherVertices.push(v);
                }
                //shuffle(otherVertices)
                for (var _a = 0, otherVertices_1 = otherVertices; _a < otherVertices_1.length; _a++) {
                    var v = otherVertices_1[_a];
                    v0.setOneLink(v);
                    v.setOneLink(v0);
                    mamesh.addVertex(v);
                }
                var sorter = new mathis.linkModule.LinksSorterAndCleanerByAngles(mamesh, new mathis.XYZ(0, 0, 1));
                sorter.suppressLinksAngularlyTooCloseVersusNot = true;
                sorter.suppressLinksAngularParam = 2 * Math.PI * maxAngle; //default
                sorter.goChanging();
                return mamesh;
            };
            var mamesh = void 0;
            mamesh = test(0.25, 0.1);
            bilan.assertTrue(mamesh.vertices[0].links.length == 4);
            mamesh = test(0.1, 0.05);
            bilan.assertTrue(mamesh.vertices[0].links.length == 10);
        }
        {
            var test = function (nb, perturb) {
                var mamesh = new mathis.Mamesh();
                var v0 = new mathis.Vertex();
                v0.param = new mathis.XYZ(Math.random(), 0, 0);
                v0.position = new mathis.XYZ(0, 0, 0);
                mamesh.addVertex(v0);
                var otherVertices = [];
                var anglesProp = [];
                for (var i = 0; i < 1; i += 1 / nb)
                    anglesProp.push(i);
                var p = 1;
                for (var _i = 0, anglesProp_2 = anglesProp; _i < anglesProp_2.length; _i++) {
                    var i = anglesProp_2[_i];
                    var angle = 2 * Math.PI * i;
                    var angleBis = 2 * Math.PI * (i + perturb);
                    var v = new mathis.Vertex();
                    var vBis = new mathis.Vertex();
                    v.param = new mathis.XYZ(p++, 0, 0);
                    vBis.param = new mathis.XYZ(p++, 1, 0);
                    v.position = new mathis.XYZ(Math.cos(angle), Math.sin(angle), 0);
                    vBis.position = new mathis.XYZ(2 * Math.cos(angleBis), 2 * Math.sin(angleBis), 0);
                    otherVertices.push(v);
                    otherVertices.push(vBis);
                }
                mathis.shuffle(otherVertices);
                for (var _a = 0, otherVertices_2 = otherVertices; _a < otherVertices_2.length; _a++) {
                    var v = otherVertices_2[_a];
                    v0.setOneLink(v);
                    v.setOneLink(v0);
                    mamesh.addVertex(v);
                }
                var sorter = new mathis.linkModule.LinksSorterAndCleanerByAngles(mamesh, new mathis.XYZ(0, 0, 1));
                sorter.suppressLinksAngularlyTooCloseVersusNot = true;
                sorter.suppressLinksAngularParam = 2 * Math.PI * 0.1;
                sorter.goChanging();
                return mamesh;
            };
            var mamesh = void 0;
            mamesh = test(4, 0.02);
            bilan.assertTrue(mamesh.vertices[0].links.length == 4);
            /**we check that it is the shortest link that we keep*/
            var ok_2 = true;
            mamesh.vertices[0].links.forEach(function (li) {
                ok_2 = ok_2 && (li.to.param.y == 0);
            });
            bilan.assertTrue(ok_2);
            //new visu3d.LinksViewer(IN_mamesh,mathisFrame.scene).goChanging()
            mamesh = test(5, 0.09);
            bilan.assertTrue(mamesh.vertices[0].links.length == 5);
            mamesh = test(8, 0.01);
            bilan.assertTrue(mamesh.vertices[0].links.length == 8);
            ok_2 = true;
            mamesh.vertices[0].links.forEach(function (li) {
                ok_2 = ok_2 && (li.to.param.y == 0);
            });
            bilan.assertTrue(ok_2);
        }
        // {
        //     let IN_mamesh = new Mamesh()
        //     let v0 = new Vertex()
        //     v0.param = new XYZ(Math.random(), 0, 0)
        //     v0.position = new XYZ(0, 0, 0)
        //     IN_mamesh.addVertex(v0)
        //
        //     let otherVertices:Vertex[] = []
        //     let anglesProp:number[] = []
        //     for (let i = 0; i < 1; i += 0.1) anglesProp.push(i)
        //     let p = 1
        //     for (let i of anglesProp) {
        //         let angle = 2 * Math.PI * i
        //         let v = new Vertex()
        //
        //         v.param = new XYZ(p++, 0, 0)
        //         v.position = new XYZ(Math.cos(angle), Math.sin(angle), 0)
        //
        //         otherVertices.push(v)
        //     }
        //
        //     shuffle(otherVertices)
        //
        //     for (let v of otherVertices) {
        //         v0.setOneLink(v)
        //         v.setOneLink(v0)
        //         IN_mamesh.addVertex(v)
        //     }
        //
        //
        //     let sorter = new linkModule.LinksSorterAndCleanerByAngles(IN_mamesh)
        //     sorter.normalsFromMameshVersusFixedNormal = false
        //     sorter.suppressLinksAngularlyTooClose=false
        //     sorter.goChanging()
        //
        //
        //     for (let i = 0; i < v0.links.length - 1; i++) {
        //         let link0 = v0.links[i]
        //         let link1 = v0.links[i + 1]
        //
        //         bilan.assertTrue(link0.to.param.x < link1.to.param.x || Math.abs(link0.to.param.x - link1.to.param.x) == anglesProp.length - 1)
        //
        //     }
        //
        //
        // }
        {
            bilan.assertTrue(mathis.modulo(3, 4, true) == -1);
            bilan.assertTrue(mathis.modulo(5, 4, true) == 1);
            var vect0 = new mathis.XYZ(1, 0, 0);
            var normal = new mathis.XYZ(0, 0, 1);
            for (var i = -2; i < 2; i += 0.1) {
                var angle = 2 * Math.PI * i;
                var vect = new mathis.XYZ(Math.cos(angle), Math.sin(angle), 0);
                var compAngle = mathis.geo.angleBetweenTwoVectorsBetweenMinusPiAndPi(vect0, vect, normal);
                var ok = mathis.roundWithGivenPrecision(mathis.modulo(compAngle / Math.PI / 2, 1), 1) == mathis.roundWithGivenPrecision(mathis.modulo(i, 1), 1);
                bilan.assertTrue(ok);
            }
        }
        // {
        //
        //     let IN_mamesh=new Mamesh()
        //     let v0=new Vertex()
        //     v0.param=new XYZ(Math.random(),0,0)
        //     let v1=new Vertex()
        //     v1.param=new XYZ(Math.random(),0,0)
        //     let v2=new Vertex()
        //     v2.param=new XYZ(Math.random(),0,0)
        //     let v3=new Vertex()
        //     v3.param=new XYZ(Math.random(),0,0)
        //
        //     v1.links.push(new Link(v0))
        //     v1.links.push(new Link(v0))
        //     v1.links.push(new Link(v0))
        //     v1.setTwoOppositeLinks(v0,v1)
        //
        //     v0.setOneLink(v1)
        //     v1.setTwoOppositeLinks(v0,v1)
        //     v2.setOneLink(v1)
        //
        //     v2.setTwoOppositeLinks(v1,v3)
        //
        //
        //     v1.links.push(new Link(v0))
        //     v1.links.push(new Link(v0))
        //     v1.links.push(new Link(v0))
        //     v1.links.push(new Link(v0))
        //     v1.setTwoOppositeLinks(v0,v1)
        //
        //
        //     v2.setTwoOppositeLinks(v1,v3)
        //
        //
        //     IN_mamesh.addVertex(v0)
        //     IN_mamesh.addVertex(v1)
        //     IN_mamesh.addVertex(v2)
        //     IN_mamesh.addVertex(v3)
        //
        //     //cc(IN_mamesh.toString())
        //
        //     new linkModule.GraphCleaning(IN_mamesh.vertices).goChanging()
        //
        //     bilan.assertTrue(IN_mamesh.toStringForTest0()=='0|links:(1)1|links:(0,1)(1,0)2|links:(1,3)(3,1)3|links:tri:squa:')
        //
        // }
        return bilan;
    }
    mathis.testCreation = testCreation;
})(mathis || (mathis = {}));
/**
 * Created by vigon on 05/03/2016.
 */
/**
 * Created by vigon on 25/01/2016.
 */
var mathis;
(function (mathis) {
    function testCreation3D(mathisFrame) {
        var bilan = new mathis.Bilan();
        {
            var crea = new mathis.reseau.Regular3D();
            crea.strateHaveSquareMailleVersusTriangleMaille = false;
            var mamesh = crea.go();
            mamesh.fillLineCatalogue();
            bilan.assertTrue(mamesh.allLinesAsASortedString() == 'straightLines:["[0,1]","[0,3,6]","[0,4,5]","[0,9,18]","[1,10,19]","[1,2]","[1,4,7]","[10,11]","[10,13,16]","[11,13,12]","[11,14,17]","[12,16,17]","[14,16,15]","[18,19]","[18,21,24]","[18,22,23]","[19,20]","[19,22,25]","[2,11,20]","[2,4,3]","[2,5,8]","[20,22,21]","[20,23,26]","[21,25,26]","[23,25,24]","[3,12,21]","[3,7,8]","[4,13,22]","[5,14,23]","[5,7,6]","[6,15,24]","[7,16,25]","[8,17,26]","[9,10]","[9,12,15]","[9,13,14]"]');
            bilan.assertTrue(mamesh.allSquareAndTrianglesAsSortedString() == 'square:["[0,1,10,9]","[0,3,12,9]","[1,2,11,10]","[1,4,13,10]","[10,11,20,19]","[10,13,22,19]","[11,14,23,20]","[12,13,22,21]","[12,15,24,21]","[13,14,23,22]","[13,16,25,22]","[14,17,26,23]","[15,16,25,24]","[16,17,26,25]","[2,5,14,11]","[3,4,13,12]","[3,6,15,12]","[4,5,14,13]","[4,7,16,13]","[5,8,17,14]","[6,7,16,15]","[7,8,17,16]","[9,10,19,18]","[9,12,21,18]"]triangle:["[0,3,4]","[0,4,1]","[1,4,2]","[10,13,11]","[11,13,14]","[12,15,16]","[12,16,13]","[13,16,14]","[14,16,17]","[18,21,22]","[18,22,19]","[19,22,20]","[2,4,5]","[20,22,23]","[21,24,25]","[21,25,22]","[22,25,23]","[23,25,26]","[3,6,7]","[3,7,4]","[4,7,5]","[5,7,8]","[9,12,13]","[9,13,10]"]');
        }
        {
            var crea = new mathis.reseau.Regular3D();
            crea.strateHaveSquareMailleVersusTriangleMaille = true;
            var mamesh = crea.go();
            mamesh.fillLineCatalogue();
            bilan.assertTrue(mamesh.allLinesAsASortedString() == 'straightLines:["[0,1,2]","[0,3,6]","[0,9,18]","[1,10,19]","[1,4,7]","[10,13,16]","[11,14,17]","[12,13,14]","[15,16,17]","[18,19,20]","[18,21,24]","[19,22,25]","[2,11,20]","[2,5,8]","[20,23,26]","[21,22,23]","[24,25,26]","[3,12,21]","[3,4,5]","[4,13,22]","[5,14,23]","[6,15,24]","[6,7,8]","[7,16,25]","[8,17,26]","[9,10,11]","[9,12,15]"]');
            bilan.assertTrue(mamesh.allSquareAndTrianglesAsSortedString() == 'square:["[0,1,10,9]","[0,3,12,9]","[0,3,4,1]","[1,2,11,10]","[1,4,13,10]","[1,4,5,2]","[10,11,20,19]","[10,13,14,11]","[10,13,22,19]","[11,14,23,20]","[12,13,22,21]","[12,15,16,13]","[12,15,24,21]","[13,14,23,22]","[13,16,17,14]","[13,16,25,22]","[14,17,26,23]","[15,16,25,24]","[16,17,26,25]","[18,21,22,19]","[19,22,23,20]","[2,5,14,11]","[21,24,25,22]","[22,25,26,23]","[3,4,13,12]","[3,6,15,12]","[3,6,7,4]","[4,5,14,13]","[4,7,16,13]","[4,7,8,5]","[5,8,17,14]","[6,7,16,15]","[7,8,17,16]","[9,10,19,18]","[9,12,13,10]","[9,12,21,18]"]triangle:[]');
        }
        {
            var crea = new mathis.reseau.Regular3D();
            crea.strateHaveSquareMailleVersusTriangleMaille = true;
            crea.oneMoreVertexForOddLine = false;
            crea.decayOddStrates = true;
            crea.createJKSquares = true;
            crea.createIKSquaresOrTriangles = true;
            crea.interStrateMailleAreSquareVersusTriangle = false;
            var mamesh = crea.go();
            mamesh.fillLineCatalogue();
            bilan.assertTrue(mamesh.allLinesAsASortedString() == 'straightLines:["[0,1,2]","[0,12,21]","[0,3,6]","[0,9]","[1,10]","[1,13,22]","[1,4,7]","[10,13,16]","[10,19]","[11,14,17]","[11,20]","[12,13,14]","[15,16,17]","[18,19,20]","[18,21,24]","[19,22,25]","[2,11]","[2,14,23]","[2,5,8]","[20,23,26]","[21,22,23]","[24,25,26]","[3,12,18]","[3,15,24]","[3,4,5]","[4,13,19]","[4,16,25]","[5,14,20]","[5,17,26]","[6,15,21]","[6,7,8]","[7,16,22]","[8,17,23]","[9,10,11]","[9,12,15]","[9,18]"]');
            bilan.assertTrue(mamesh.allSquareAndTrianglesAsSortedString() == 'square:["[0,1,10,9]","[0,3,4,1]","[1,2,11,10]","[1,4,5,2]","[10,11,20,19]","[10,13,14,11]","[12,13,22,21]","[12,15,16,13]","[13,14,23,22]","[13,16,17,14]","[15,16,25,24]","[16,17,26,25]","[18,21,22,19]","[19,22,23,20]","[21,24,25,22]","[22,25,26,23]","[3,4,13,12]","[3,6,7,4]","[4,5,14,13]","[4,7,8,5]","[6,7,16,15]","[7,8,17,16]","[9,10,19,18]","[9,12,13,10]"]triangle:["[0,12,9]","[0,3,12]","[1,13,10]","[1,4,13]","[10,13,19]","[11,14,20]","[12,15,21]","[12,21,18]","[13,16,22]","[13,22,19]","[14,17,23]","[14,23,20]","[15,24,21]","[16,25,22]","[17,26,23]","[2,14,11]","[2,5,14]","[3,15,12]","[3,6,15]","[4,16,13]","[4,7,16]","[5,17,14]","[5,8,17]","[9,12,18]"]');
        }
        // {
        //     let crea = new reseau.Regular3D()
        //     crea.strateHaveSquareMailleVersusTriangleMaille = true
        //     crea.oneMoreVertexForOddLine=false
        //     crea.decayOddStrates=false
        //     crea.createJKSquares=true
        //     crea.createIKSquaresOrTriangles=true
        //     crea.interStrateMaille=reseau.Maille.square
        //
        //
        //     let mamesh = crea.goChanging()
        //
        //     mamesh.fillLineCatalogue()
        //
        //     cc(mamesh.allLinesAsASortedString())
        //     cc(mamesh.allSquareAndTrianglesAsSortedString())
        //
        //     let liner = new visu3d.LinksViewer(mamesh, mathisFrame.scene)
        //     liner.goChanging()
        //
        //     let surfacer = new visu3d.SurfaceViewer(mamesh, mathisFrame.scene)
        //     surfacer.goChanging()
        // }
        //
        // {
        //
        //     let infi=new infiniteWorlds.InfiniteCartesian(mathisFrame)
        //     infi.recenterCamera=false
        //     infi.nbRepetition=3
        //     infi.nbSubdivision=3
        //     infi.squareVersusSemiVersusTri=0
        //     infi.addFog=false
        //     infi.notDrawMeshesAtFarCorners=true
        //     infi.cameraInitialPosition=new XYZ(0,10,-50)
        //     infi.goChanging()
        //
        //
        // }
        //
        return bilan;
    }
    mathis.testCreation3D = testCreation3D;
})(mathis || (mathis = {}));
/**
 * Created by vigon on 30/11/2015.
 */
var mathis;
(function (mathis) {
    function geometryTest() {
        var bilanGeo = new mathis.Bilan();
        // {
        //
        //     let v0=new XYZ(0,0,0)
        //     let v1=new XYZ(0,2,0)
        //     let temps=new XYZ(0,0,0)
        //     geo.cross(v0,v1,temps)
        //     console.log(temps)
        //
        // }
        {
            var v0 = new mathis.XYZ(1, 0, 0);
            var v1 = new mathis.XYZ(10, 0, 0);
            var v2 = new mathis.XYZ(-10, 0, 0);
            bilanGeo.assertTrue(mathis.geo.almostParallel(v0, v1, true));
            bilanGeo.assertTrue(mathis.geo.almostParallel(v0, v2, true));
            bilanGeo.assertTrue(!mathis.geo.almostParallel(v0, v2, false));
            var creator = new mathis.creation3D.Polyhedron(mathis.creation3D.PolyhedronType.Cube);
            var mamesh = creator.go();
            var count100 = 0;
            var count010 = 0;
            var count001 = 0;
            for (var _i = 0, _a = mamesh.segments; _i < _a.length; _i++) {
                var segment = _a[_i];
                var dir = mathis.XYZ.newFrom(segment[0].position).substract(segment[1].position);
                if (mathis.geo.almostParallel(dir, new mathis.XYZ(1, 0, 0), true, 0.001))
                    count100++;
                if (mathis.geo.almostParallel(dir, new mathis.XYZ(0, 1, 0)))
                    count010++;
                if (mathis.geo.almostParallel(dir, new mathis.XYZ(0, 0, 1)))
                    count001++;
            }
            bilanGeo.assertTrue(count100 == 4);
            bilanGeo.assertTrue(count010 == 4);
            bilanGeo.assertTrue(count001 == 4);
        }
        {
            var originIN = new mathis.XYZ(0, 0, 0);
            var endIN = new mathis.XYZ(2, 2, 0);
            var originOUT = new mathis.XYZ(0, 0, 0);
            var endOUT = new mathis.XYZ(0.5, 0.5, 0);
            var affine = mathis.geo.affineTransformGenerator(originIN, endIN, originOUT, endOUT);
            var res = new mathis.XYZ(0, 0, 0);
            affine(new mathis.XYZ(4, 4, 0), res);
            affine(res, res);
            bilanGeo.assertTrue(res.almostEqual(new mathis.XYZ(0.25, 0.25, 0)));
        }
        {
            var originIN = new mathis.XYZ(1, 1, 0);
            var endIN = new mathis.XYZ(2, 2, 0);
            var originOUT = new mathis.XYZ(-1, -1, 0);
            var endOUT = new mathis.XYZ(0.5, 0.5, 0);
            var affine = mathis.geo.affineTransformGenerator(originIN, endIN, originOUT, endOUT);
            var affineInv = mathis.geo.affineTransformGenerator(originOUT, endOUT, originIN, endIN);
            var res = new mathis.XYZ(0, 0, 0);
            affine(new mathis.XYZ(4, 4, 0), res);
            affineInv(res, res);
            bilanGeo.assertTrue(res.almostEqual(new mathis.XYZ(4, 4, 0)));
        }
        var xAxis = mathis.XYZ.newZero();
        var yAxis = mathis.XYZ.newZero();
        var zAxis = mathis.XYZ.newZero();
        xAxis.x = 1;
        yAxis.y = 1;
        zAxis.z = 1;
        var diag = mathis.XYZ.newZero();
        diag.x = 1;
        diag.y = 1;
        {
            var theta = Math.random() * 10;
            var mat = mathis.MM.newZero();
            mathis.geo.axisAngleToMatrix(zAxis, theta, mat);
            var matInv = mathis.MM.newZero();
            mathis.geo.axisAngleToMatrix(zAxis, -theta, matInv);
            bilanGeo.assertTrue(mathis.MM.newFrom(mat).inverse().almostEqual(matInv));
            var other = mathis.XYZ.newZero();
            mathis.geo.orthonormalizeKeepingFirstDirection(xAxis, diag, other, diag);
            bilanGeo.assertTrue(other.almostEqual(xAxis) && diag.almostEqual(yAxis));
            var aaa = mathis.MM.newRandomMat();
            bilanGeo.assertTrue(mathis.MM.newFrom(aaa).transpose().transpose().almostEqual(aaa));
            var rotMatrix = mathis.MM.newZero();
            var rotMatrixMinus = mathis.MM.newZero();
            var angle = Math.random() * 2 * Math.PI;
            var axis = mathis.XYZ.newRandom();
            mathis.geo.axisAngleToMatrix(axis, angle, rotMatrix);
            mathis.geo.axisAngleToMatrix(axis, -angle, rotMatrixMinus);
            bilanGeo.assertTrue(mathis.MM.newFrom(rotMatrix).transpose().almostEqual(rotMatrixMinus));
            bilanGeo.assertTrue(mathis.MM.newFrom(rotMatrix).inverse().almostEqual(rotMatrixMinus));
        }
        /**axisAngle <-> quaternion <-> rotation matrix*/
        {
            var nb = 10;
            var quat = new mathis.XYZW(0, 0, 0, 0);
            var quat2 = new mathis.XYZW(0, 0, 0, 0);
            var matQua = mathis.MM.newZero();
            var matQua2 = mathis.MM.newZero();
            var otherMatQua = mathis.MM.newZero();
            for (var i = 0; i <= nb; i++) {
                var axisForQuat = mathis.XYZ.newRandom().normalize();
                var theta = i * Math.PI * 2 / nb;
                mathis.geo.axisAngleToQuaternion(axisForQuat, theta, quat);
                mathis.geo.quaternionToMatrix(quat, matQua);
                mathis.geo.matrixToQuaternion(matQua, quat2);
                mathis.geo.quaternionToMatrix(quat2, matQua2);
                bilanGeo.assertTrue(mathis.geo.almostLogicalEqual(quat, quat2));
                bilanGeo.assertTrue(matQua.almostEqual(matQua2));
                mathis.geo.axisAngleToMatrix(axisForQuat, theta, otherMatQua);
                bilanGeo.assertTrue(otherMatQua.almostEqual(matQua));
            }
        }
        var ve = mathis.XYZ.newRandom();
        var veCopy = mathis.XYZ.newZero().copyFrom(ve);
        var ve2 = mathis.XYZ.newRandom();
        bilanGeo.assertTrue(ve.add(ve2).add(ve2.scale(-1)).almostEqual(veCopy));
        /**we rotate a basis, checking cross product, anglesComputation */
        var vv = mathis.XYZ.newZero();
        mathis.geo.cross(xAxis, yAxis, vv);
        bilanGeo.assertTrue(vv.almostEqual(zAxis));
        var xBase = mathis.XYZ.newFrom(xAxis);
        var yBase = mathis.XYZ.newFrom(yAxis);
        var zBase = mathis.XYZ.newFrom(zAxis);
        diag.x = 1;
        diag.y = 1;
        diag.z = 0;
        bilanGeo.assertTrue(mathis.geo.almostEquality(mathis.geo.angleBetweenTwoVectorsBetween0andPi(xAxis, diag), Math.PI / 4));
        bilanGeo.assertTrue(mathis.geo.almostEquality(mathis.geo.angleBetweenTwoVectorsBetween0andPi(yAxis, diag), Math.PI / 4));
        bilanGeo.assertTrue(mathis.geo.almostEquality(mathis.geo.angleBetweenTwoVectorsBetween0andPi(mathis.XYZ.newFrom(xAxis).scale(-1), diag), 3 * Math.PI / 4));
        //let angle=2*Math.PI/nb*i
        //let axx=new XYZ(0,0,1)
        //let Rot=MM.newZero()
        //geo.axisAngleToMatrix(axx,angle,Rot)
        //let xAxRot=XYZ.newFrom(xAxis)
        //geo.multiplicationMatrixVector(randRot,xBase,xBase)
        //
        //
        //return bilanGeo
        {
            var nb = 10;
            for (var i = 0; i < nb; i++) {
                var angle = 2 * Math.PI / nb * i * 12;
                var randAxis = mathis.XYZ.newRandom().normalize();
                var randRot = mathis.MM.newZero();
                mathis.geo.axisAngleToMatrix(randAxis, angle, randRot);
                mathis.geo.multiplicationMatrixVector(randRot, xAxis, xBase);
                mathis.geo.multiplicationMatrixVector(randRot, yAxis, yBase);
                mathis.geo.multiplicationMatrixVector(randRot, zAxis, zBase);
                bilanGeo.assertTrue(mathis.geo.almostEquality(mathis.geo.dot(xBase, yBase), 0) && mathis.geo.almostEquality(mathis.geo.dot(xBase, zBase), 0) && mathis.geo.almostEquality(mathis.geo.dot(yBase, zBase), 0));
                bilanGeo.assertTrue(mathis.geo.almostEquality(1, mathis.geo.norme(xBase)) && mathis.geo.almostEquality(1, mathis.geo.norme(yBase)) && mathis.geo.almostEquality(1, mathis.geo.norme(zBase)));
                var crossXYBase = mathis.XYZ.newZero();
                mathis.geo.cross(xBase, yBase, crossXYBase);
                bilanGeo.assertTrue(crossXYBase.almostEqual(zBase));
            }
        }
        /** test of the computation of angle.
         * Be carefull :  this can be the angle is between 0 and PI*/
        {
            var nb = 10;
            for (var i = 0; i < nb; i++) {
                var angle = 2 * Math.PI / nb * i * 12;
                var randAxis = new mathis.XYZ(0, 0, 1);
                var randRot = mathis.MM.newZero();
                mathis.geo.axisAngleToMatrix(randAxis, angle, randRot);
                mathis.geo.multiplicationMatrixVector(randRot, xAxis, xBase);
                var angleModule = mathis.modulo(angle, 2 * Math.PI);
                if (angleModule > Math.PI)
                    angleModule = 2 * Math.PI - angleModule;
                bilanGeo.assertTrue(mathis.geo.almostEquality(mathis.geo.angleBetweenTwoVectorsBetween0andPi(xBase, xAxis), angleModule));
            }
            var va = mathis.XYZ.newRandom();
            var vb = mathis.XYZ.newRandom();
            var vc = mathis.XYZ.newRandom();
            var bary = mathis.XYZ.newFrom(va);
            bary.add(vb).add(vc).scale(1 / 3);
            var bary2 = mathis.XYZ.newZero();
            mathis.geo.baryCenter([va, vb, vc], [1 / 3, 1 / 3, 1 / 3], bary2);
            bilanGeo.assertTrue(bary.almostEqual(bary2));
        }
        {
            var vect0 = new mathis.XYZ(0, 0, 0);
            var vect2 = new mathis.XYZ(2, 0, 0);
            var tan0 = new mathis.XYZ(0, 1, 0);
            var tan2 = new mathis.XYZ(0, -1, 0);
            var hermite = [];
            mathis.geo.hermiteSpline(vect0, tan0, vect2, tan2, 2, hermite);
            bilanGeo.assertTrue(hermite[1].almostEqual(new mathis.XYZ(1, 0.25, 0)));
        }
        /**close XYZ finder*/
        {
            var list = [new mathis.XYZ(0, 0, 0), new mathis.XYZ(0, 0, 1), new mathis.XYZ(0, 0, 2), new mathis.XYZ(-10, 0, 0), new mathis.XYZ(0, 0, 0), new mathis.XYZ(0, 0, 1), new mathis.XYZ(0, 0, 2), new mathis.XYZ(0, 0, 0)];
            var close_1 = new mathis.geometry.CloseXYZfinder(list, null, 1000);
            var res = close_1.go();
            bilanGeo.assertTrue(JSON.stringify({ 4: 0, 5: 1, 6: 2, 7: 0 }) == JSON.stringify(res));
        }
        {
            var recepterList = [new mathis.XYZ(0, 0, 0), new mathis.XYZ(0, 0, 1), new mathis.XYZ(0, 0, 2), new mathis.XYZ(-20, 0, 0)];
            var sourceList = [new mathis.XYZ(-0.000001, 0, 0), new mathis.XYZ(0, 0, 1.000001), new mathis.XYZ(0, 0, 2), new mathis.XYZ(-10, 0, 0), new mathis.XYZ(0, 0, 2)];
            var close2 = new mathis.geometry.CloseXYZfinder(recepterList, sourceList, 1000);
            close2.nbDistinctPoint = 10000;
            var res2 = close2.go();
            bilanGeo.assertTrue(JSON.stringify({ 0: 0, 1: 1, 2: 2, 4: 2 }) == JSON.stringify(res2));
        }
        {
            var list = [new mathis.XYZ(0, 0, 0), new mathis.XYZ(1, 0, 0), new mathis.XYZ(2, 0, 0), new mathis.XYZ(3, 0, 0), new mathis.XYZ(4, 0, 0),];
            var close_2 = new mathis.geometry.CloseXYZfinder(list, null, 1000);
            close_2.deformationFunction = function (point) { var res = mathis.XYZ.newFrom(point); res.x = mathis.modulo(res.x, 2); return res; };
            var res = close_2.go();
            bilanGeo.assertTrue(JSON.stringify({ 2: 0, 3: 1, 4: 0 }) == JSON.stringify(res));
        }
        {
            var A = new mathis.XYZ(1, 0, 0);
            var B = new mathis.XYZ(0, 0, 1);
            var C = new mathis.XYZ(1, 1, 0).normalize();
            var D = new mathis.XYZ(-1, 1, 0).normalize();
            var mat = new mathis.MM();
            mathis.geo.anOrthogonalMatrixMovingABtoCD(A, B, C, D, mat, true);
            var AA = mathis.XYZ.newZero();
            var BB = mathis.XYZ.newZero();
            mathis.geo.multiplicationMatrixVector(mat, A, AA);
            mathis.geo.multiplicationMatrixVector(mat, B, BB);
            bilanGeo.assertTrue(mathis.geo.xyzAlmostEquality(C, AA) && mathis.geo.xyzAlmostEquality(D, BB));
        }
        {
            var A = mathis.XYZ.newRandom().normalize();
            var B = new mathis.XYZ(-1, 1, 0);
            mathis.geo.getOneOrthonormal(A, B);
            B.normalize();
            var C = mathis.XYZ.newRandom().normalize();
            var D = new mathis.XYZ(0, 0, 0);
            mathis.geo.getOneOrthonormal(C, D);
            D.normalize();
            var mat = new mathis.MM();
            mathis.geo.anOrthogonalMatrixMovingABtoCD(A, B, C, D, mat, true);
            var AA = mathis.XYZ.newZero();
            var BB = mathis.XYZ.newZero();
            mathis.geo.multiplicationMatrixVector(mat, A, AA);
            mathis.geo.multiplicationMatrixVector(mat, B, BB);
            bilanGeo.assertTrue(mathis.geo.xyzAlmostEquality(C, AA) && mathis.geo.xyzAlmostEquality(D, BB));
        }
        {
            var mat = new mathis.MM();
            var A = mathis.XYZ.newRandom().normalize();
            var B = new mathis.XYZ(-1, 1, 0);
            mathis.geo.getOneOrthonormal(A, B);
            B.normalize();
            var C = new mathis.XYZ(0, 0, 0);
            mathis.geo.cross(A, B, C);
            mathis.geo.matrixFromLines(A, B, C, mat);
            var qua = new mathis.XYZW(0, 0, 0, 0);
            mathis.geo.matrixToQuaternion(mat, qua);
            var mat2 = new mathis.MM();
            mathis.geo.quaternionToMatrix(qua, mat2);
            bilanGeo.assertTrue(mat.almostEqual(mat2));
        }
        {
            var qua = new mathis.XYZW(0, 0, 0, 0);
            mathis.geo.axisAngleToQuaternion(new mathis.XYZ(1, 0, 0), 1.5, qua);
            var mat = new mathis.MM();
            mathis.geo.quaternionToMatrix(qua, mat);
            var qua2 = new mathis.XYZW(0, 0, 0, 0);
            mathis.geo.matrixToQuaternion(mat, qua2);
            bilanGeo.assertTrue(mathis.geo.xyzwAlmostEquality(qua, qua2));
        }
        {
            //let A=new XYZ(1,0,0)
            //let B=new XYZ(0,0,1)
            //
            //let C=new XYZ(1,1,0).normalize()
            //let D=new XYZ(-1,1,0).normalize()
            var A = mathis.XYZ.newRandom().normalize();
            var B = new mathis.XYZ(0, 0, 0);
            mathis.geo.getOneOrthonormal(A, B);
            B.normalize();
            var C = mathis.XYZ.newRandom().normalize();
            var D = new mathis.XYZ(0, 0, 0);
            mathis.geo.getOneOrthonormal(C, D);
            D.normalize();
            var qua = new mathis.XYZW(0, 0, 0, 0);
            mathis.geo.aQuaternionMovingABtoCD(A, B, C, D, qua, true);
            var AA = mathis.XYZ.newZero();
            var BB = mathis.XYZ.newZero();
            var mat = new mathis.MM();
            mathis.geo.quaternionToMatrix(qua, mat);
            mathis.geo.multiplicationMatrixVector(mat, A, AA);
            mathis.geo.multiplicationMatrixVector(mat, B, BB);
            bilanGeo.assertTrue(mathis.geo.xyzAlmostEquality(C, AA) && mathis.geo.xyzAlmostEquality(D, BB));
        }
        {
            var fd = new mathis.periodicWorld.CartesianFundamentalDomain(new mathis.XYZ(2, 0, 0), new mathis.XYZ(0, 2, 0), new mathis.XYZ(0, 0, 2));
            var res = new mathis.XYZ(0, 0, 0);
            fd.modulo(new mathis.XYZ(0.5, -1.75, 3.5), res);
            bilanGeo.assertTrue(mathis.geo.xyzAlmostEquality(res, new mathis.XYZ(0.5, 0.25, -0.5)));
        }
        /**orthogonals projections*/
        {
            var direction = new mathis.XYZ(1, 1, 0);
            var proj = new mathis.MM();
            mathis.geo.orthogonalProjectionOnLine(direction, proj);
            var vect = new mathis.XYZ(Math.random(), Math.random(), Math.random());
            var v2 = new mathis.XYZ(0, 0, 0);
            mathis.geo.multiplicationMatrixVector(proj, vect, v2);
            var v3 = new mathis.XYZ(0, 0, 0);
            mathis.geo.multiplicationMatrixVector(proj, v2, v3);
            bilanGeo.assertTrue(v3.almostEqual(v2));
        }
        {
            var direction = new mathis.XYZ(1, 1, 0);
            var direction2 = new mathis.XYZ(-1, 1, 2);
            var proj = new mathis.MM();
            mathis.geo.orthogonalProjectionOnPlane(direction, direction2, proj);
            var vect = new mathis.XYZ(Math.random(), Math.random(), Math.random());
            var v2 = new mathis.XYZ(0, 0, 0);
            mathis.geo.multiplicationMatrixVector(proj, vect, v2);
            var v3 = new mathis.XYZ(0, 0, 0);
            mathis.geo.multiplicationMatrixVector(proj, v2, v3);
            bilanGeo.assertTrue(v3.almostEqual(v2));
        }
        return bilanGeo;
    }
    mathis.geometryTest = geometryTest;
})(mathis || (mathis = {}));
/**
 * Created by vigon on 18/12/2015.
 */
var mathis;
(function (mathis) {
    var VertexData = BABYLON.VertexData;
    var CanEat = (function () {
        function CanEat() {
        }
        CanEat.prototype.eat = function () {
            return 'miam';
        };
        return CanEat;
    }());
    var CanSleep = (function () {
        function CanSleep() {
        }
        CanSleep.prototype.sleep = function () {
            return 'ZZZ';
        };
        return CanSleep;
    }());
    function applyMixins(derivedCtor, baseCtors) {
        baseCtors.forEach(function (baseCtor) {
            Object.getOwnPropertyNames(baseCtor.prototype).forEach(function (name) {
                if (name !== 'constructor') {
                    derivedCtor.prototype[name] = baseCtor.prototype[name];
                }
            });
        });
    }
    var Being = (function () {
        function Being() {
            if (!Being.mixinsWasMade) {
                applyMixins(Being, [CanEat, CanSleep]);
                Being.mixinsWasMade = true;
            }
        }
        Being.mixinsWasMade = false;
        return Being;
    }());
    function informatisTest() {
        var bilan = new mathis.Bilan();
        mathis.logger.c('this a warning which test that warning are fired');
        {
            var v0 = new mathis.Vertex();
            v0.position = new mathis.XYZ(1, 2, 3);
            var v1 = new mathis.Vertex();
            v1.position = new mathis.XYZ(1, 2, 4);
            var v2 = new mathis.Vertex();
            v2.position = new mathis.XYZ(1, 2, 5);
            var v3 = new mathis.Vertex();
            v3.position = new mathis.XYZ(1, 2, 5.5);
            var line0 = new mathis.Line([v0, v1, v2, v3], false);
            var line1 = new mathis.Line([v3, v2, v1, v0], false);
            bilan.assertTrue(line0.hashString == line1.hashString);
            var line0loop = new mathis.Line([v0, v1, v2, v3], true);
            var line1loop = new mathis.Line([v0, v3, v2, v1], false);
            bilan.assertTrue(line0.hashString == line1.hashString);
            var v0a = new mathis.Vertex();
            v0a.position = new mathis.XYZ(1, 2, 3);
            var v1a = new mathis.Vertex();
            v1a.position = new mathis.XYZ(1, 2, 4);
            var v2a = new mathis.Vertex();
            v2a.position = new mathis.XYZ(1, 2, 5);
            var v3a = new mathis.Vertex();
            v3a.position = new mathis.XYZ(1, 2, 5.5);
            var line0a = new mathis.Line([v0a, v1a, v2a, v3a], false);
            bilan.assertTrue(line0a.hashString != line1.hashString);
            bilan.assertTrue(line0a.positionnalHash() == line1.positionnalHash());
        }
        {
            var gene = new mathis.reseau.BasisForRegularReseau();
            gene.nbI = 2;
            gene.nbJ = 2;
            var crea = new mathis.reseau.Regular(gene);
            var mamesh = crea.go();
            mamesh.fillLineCatalogue();
            new mathis.spacialTransformations.Similitude(mamesh.vertices, Math.PI / 4).goChanging();
            mathis.spacialTransformations.adjustInASquare(mamesh, new mathis.XYZ(0, 0, 0), new mathis.XYZ(1, 1, 0));
            var crea2 = new mathis.reseau.Regular(gene);
            var mamesh2 = crea2.go();
            mamesh2.fillLineCatalogue();
            new mathis.spacialTransformations.Similitude(mamesh2.vertices, Math.PI / 2).goChanging();
            mathis.spacialTransformations.adjustInASquare(mamesh2, new mathis.XYZ(0, 0, 0), new mathis.XYZ(1, 1, 0));
            var hashSet2 = new mathis.StringMap();
            for (var _i = 0, _a = mamesh2.lines.concat(mamesh2.lines); _i < _a.length; _i++) {
                var line = _a[_i];
                hashSet2.putValue(line.hashString, true);
            }
            bilan.assertTrue(hashSet2.allValues().length == 4);
            var hashSet = new mathis.StringMap();
            for (var _b = 0, _c = mamesh.lines; _b < _c.length; _b++) {
                var line = _c[_b];
                hashSet.putValue(line.hashStringUpToSymmetries(mathis.symmetries.squareMainSymmetries, true), true);
            }
            bilan.assertTrue(hashSet.allValues().length == 1);
        }
        {
            /**ArrayMinusBlocksElements*/
            var vertex0 = new mathis.Vertex();
            var vertex1 = new mathis.Vertex();
            var vertex2 = new mathis.Vertex();
            var vertex3 = new mathis.Vertex();
            var vertexA = new mathis.Vertex();
            var vertexB = new mathis.Vertex();
            var vertexC = new mathis.Vertex();
            var vertexD = new mathis.Vertex();
            var longList = [vertex0, vertex1, vertex2, vertex3, vertexA, vertexB, vertexC, vertexD];
            var newLongList = new mathis.tab.ArrayMinusBlocksElements(longList, 4, [vertex2, vertex3, vertex0, vertex1]).go();
            bilan.assertTrue(newLongList[0].hashString == vertexA.hashString && newLongList[1].hashString == vertexB.hashString && newLongList[2].hashString == vertexC.hashString && newLongList[3].hashString == vertexD.hashString);
        }
        var being = new Being();
        being.age = 37;
        bilan.assertTrue(being.age == 37);
        bilan.assertTrue(being.sleep() == 'ZZZ');
        bilan.assertTrue(being.eat() == 'miam');
        {
            var dico = new mathis.HashMap();
            var vertex0 = new mathis.Vertex();
            var vertex1 = new mathis.Vertex();
            var vertex2 = new mathis.Vertex();
            dico.putValue(vertex0, 'vertex0');
            dico.putValue(vertex1, 'vertex1');
            dico.putValue(vertex2, 'vertex2');
            dico.putValue(vertex0, 'vertex0bis');
            bilan.assertTrue(dico.getValue(vertex0) == 'vertex0bis');
        }
        /**testing the deep copy of IN_mamesh
         * this test follow the evolution of toString, this is a good idea: so if class {@link Mamesh} change, we have to change the deepCopy
         * */
        {
            var mamCrea = new mathis.reseau.Regular();
            mamCrea.nbI = 3;
            mamCrea.nbJ = 2;
            mamCrea.makeLinks = false;
            var mamesh = mamCrea.go();
            var dicho = new mathis.mameshModification.SquareDichotomer(mamesh);
            dicho.go();
            var linkCrea = new mathis.linkModule.LinkCreaterSorterAndBorderDetecterByPolygons(mamesh).goChanging();
            mamesh.fillLineCatalogue();
            var mameshCopy = new mathis.mameshModification.MameshDeepCopier(mamesh).go();
            bilan.assertTrue(mamesh.toString() == mameshCopy.toString());
        }
        /**test adding dynamicaly a new property to an object*/
        {
            var vertexData = new VertexData();
            /**alors a, a quoi cela sert ???*/
            vertexData._idx = 5;
            var AClass = (function () {
                function AClass() {
                    this.aString = 'toto';
                    this.aNumber = 5;
                }
                return AClass;
            }());
            var anObject = new AClass();
            anObject.aString = 'mqlskdj';
            {
                anObject.newPro = 5;
            }
            bilan.assertTrue(anObject.newPro == 5);
        }
        return bilan;
    }
    mathis.informatisTest = informatisTest;
})(mathis || (mathis = {}));
/**
 * Created by vigon on 25/02/2016.
 */
var mathis;
(function (mathis) {
    var checkTheRegularityOfAGRaph = mathis.debug.checkTheRegularityOfAGraph;
    var creationFlat;
    (function (creationFlat) {
        var SingleSquareWithOneDiag = (function () {
            function SingleSquareWithOneDiag(mamesh) {
                this.makeLinks = true;
                this.markCorners = true;
                this.addALoopLineAround = false;
                this.mamesh = mamesh;
            }
            SingleSquareWithOneDiag.prototype.go = function () {
                var vert0 = this.mamesh.newVertex(new mathis.XYZ(0, 0, 0));
                var vert1 = this.mamesh.newVertex(new mathis.XYZ(1, 0, 0));
                var vert2 = this.mamesh.newVertex(new mathis.XYZ(1, 1, 0));
                var vert3 = this.mamesh.newVertex(new mathis.XYZ(0, 1, 0));
                //let triangulatedRect=new Polygone([vert1,vert2,vert3])
                //this.IN_mamesh.polygones.push(triangulatedRect)
                this.mamesh.addATriangle(vert0, vert1, vert3);
                this.mamesh.addATriangle(vert1, vert2, vert3);
                if (this.markCorners) {
                    vert0.markers.push(mathis.Vertex.Markers.corner);
                    vert1.markers.push(mathis.Vertex.Markers.corner);
                    vert2.markers.push(mathis.Vertex.Markers.corner);
                    vert3.markers.push(mathis.Vertex.Markers.corner);
                }
                if (this.makeLinks) {
                    vert1.setOneLink(vert3);
                    vert3.setOneLink(vert1);
                    if (!this.addALoopLineAround) {
                        vert0.setOneLink(vert1);
                        vert0.setOneLink(vert3);
                        vert1.setOneLink(vert0);
                        vert1.setOneLink(vert2);
                        vert2.setOneLink(vert1);
                        vert2.setOneLink(vert3);
                        vert3.setOneLink(vert0);
                        vert3.setOneLink(vert2);
                    }
                    else {
                        vert0.setTwoOppositeLinks(vert1, vert3);
                        vert1.setTwoOppositeLinks(vert2, vert0);
                        vert2.setTwoOppositeLinks(vert3, vert1);
                        vert3.setTwoOppositeLinks(vert0, vert2);
                    }
                }
                //else this.mamesh.linksOK = false
            };
            return SingleSquareWithOneDiag;
        }());
        creationFlat.SingleSquareWithOneDiag = SingleSquareWithOneDiag;
        var SingleSquareWithTwoDiag = (function () {
            function SingleSquareWithTwoDiag(mamesh) {
                this.makeLinks = true;
                this.markCorners = true;
                this.addALoopLineAround = false;
                this.mamesh = mamesh;
            }
            SingleSquareWithTwoDiag.prototype.go = function () {
                var vert0 = this.mamesh.newVertex(new mathis.XYZ(0, 0, 0));
                var vert1 = this.mamesh.newVertex(new mathis.XYZ(1, 0, 0));
                var vert2 = this.mamesh.newVertex(new mathis.XYZ(1, 1, 0));
                var vert3 = this.mamesh.newVertex(new mathis.XYZ(0, 1, 0));
                var vert4 = this.mamesh.newVertex(new mathis.XYZ(0.5, 0.5, 0));
                //let triangulatedRect=new Polygone([vert1,vert2,vert3])
                //this.IN_mamesh.polygones.push(triangulatedRect)
                this.mamesh.addATriangle(vert0, vert1, vert4);
                this.mamesh.addATriangle(vert1, vert2, vert4);
                this.mamesh.addATriangle(vert2, vert3, vert4);
                this.mamesh.addATriangle(vert4, vert3, vert0);
                if (this.markCorners) {
                    vert0.markers.push(mathis.Vertex.Markers.corner);
                    vert1.markers.push(mathis.Vertex.Markers.corner);
                    vert2.markers.push(mathis.Vertex.Markers.corner);
                    vert3.markers.push(mathis.Vertex.Markers.corner);
                }
                if (this.makeLinks) {
                    vert0.setOneLink(vert4);
                    vert1.setOneLink(vert4);
                    vert2.setOneLink(vert4);
                    vert3.setOneLink(vert4);
                    vert4.setTwoOppositeLinks(vert0, vert2);
                    vert4.setTwoOppositeLinks(vert1, vert3);
                    if (!this.addALoopLineAround) {
                        vert0.setOneLink(vert1);
                        vert0.setOneLink(vert3);
                        vert1.setOneLink(vert0);
                        vert1.setOneLink(vert2);
                        vert2.setOneLink(vert1);
                        vert2.setOneLink(vert3);
                        vert3.setOneLink(vert0);
                        vert3.setOneLink(vert2);
                    }
                    else {
                        vert0.setTwoOppositeLinks(vert1, vert3);
                        vert1.setTwoOppositeLinks(vert2, vert0);
                        vert2.setTwoOppositeLinks(vert3, vert1);
                        vert3.setTwoOppositeLinks(vert0, vert2);
                    }
                }
                //else this.mamesh.linksOK = false
            };
            return SingleSquareWithTwoDiag;
        }());
        creationFlat.SingleSquareWithTwoDiag = SingleSquareWithTwoDiag;
        var SingleSquare = (function () {
            function SingleSquare(mamesh) {
                this.makeLinks = true;
                this.markCorners = true;
                this.addALoopLineAround = false;
                this.mamesh = mamesh;
            }
            SingleSquare.prototype.go = function () {
                var vert0 = this.mamesh.newVertex(new mathis.XYZ(0, 0, 0));
                var vert1 = this.mamesh.newVertex(new mathis.XYZ(1, 0, 0));
                var vert2 = this.mamesh.newVertex(new mathis.XYZ(1, 1, 0));
                var vert3 = this.mamesh.newVertex(new mathis.XYZ(0, 1, 0));
                //let triangulatedRect=new Polygone([vert1,vert2,vert3])
                //this.IN_mamesh.polygones.push(triangulatedRect)
                this.mamesh.addASquare(vert0, vert1, vert2, vert3);
                if (this.markCorners) {
                    vert0.markers.push(mathis.Vertex.Markers.corner);
                    vert1.markers.push(mathis.Vertex.Markers.corner);
                    vert2.markers.push(mathis.Vertex.Markers.corner);
                    vert3.markers.push(mathis.Vertex.Markers.corner);
                }
                if (this.makeLinks) {
                    if (!this.addALoopLineAround) {
                        vert0.setOneLink(vert1);
                        vert1.setOneLink(vert2);
                        vert2.setOneLink(vert3);
                        vert3.setOneLink(vert0);
                        vert0.setOneLink(vert3);
                        vert3.setOneLink(vert2);
                        vert2.setOneLink(vert1);
                        vert1.setOneLink(vert0);
                    }
                    else {
                        vert0.setTwoOppositeLinks(vert1, vert3);
                        vert1.setTwoOppositeLinks(vert2, vert0);
                        vert2.setTwoOppositeLinks(vert3, vert1);
                        vert3.setTwoOppositeLinks(vert0, vert2);
                    }
                }
                //else this.mamesh.linksOK = false
            };
            return SingleSquare;
        }());
        creationFlat.SingleSquare = SingleSquare;
    })(creationFlat = mathis.creationFlat || (mathis.creationFlat = {}));
    function linkerTest() {
        var bilan = new mathis.Bilan();
        {
            var creator = new mathis.reseau.Regular();
            var mamesh = creator.go();
            var linker = new mathis.linkModule.SimpleLinkFromPolygonCreator(mamesh);
            linker.goChanging();
            mamesh.fillLineCatalogue();
            bilan.assertTrue(mamesh.allLinesAsASortedString() == 'straightLines:["[0,1]","[0,3]","[1,2]","[1,4]","[2,5]","[3,4]","[3,6]","[4,5]","[4,7]","[5,8]","[6,7]","[7,8]"]');
        }
        {
            var creator = new mathis.reseau.Regular();
            creator.squareVersusTriangleMaille = false;
            var mamesh = creator.go();
            var linker = new mathis.linkModule.SimpleLinkFromPolygonCreator(mamesh);
            linker.goChanging();
            mamesh.fillLineCatalogue();
            bilan.assertTrue(mamesh.allLinesAsASortedString() == 'straightLines:["[0,1]","[0,3]","[0,4]","[1,2]","[1,4]","[2,4]","[2,5]","[3,4]","[3,6]","[3,7]","[4,5]","[4,7]","[5,7]","[5,8]","[6,7]","[7,8]"]');
        }
        {
            var mamesh = new mathis.Mamesh();
            var single = new creationFlat.SingleSquare(mamesh);
            single.makeLinks = false;
            single.go();
            new mathis.mameshModification.SquareDichotomer(mamesh).go();
            new mathis.linkModule.LinkCreaterSorterAndBorderDetecterByPolygons(mamesh).goChanging();
            mamesh.clearOppositeInLinks();
            new mathis.linkModule.OppositeLinkAssocierByAngles(mamesh.vertices).goChanging();
            checkTheRegularityOfAGRaph(mamesh.vertices);
        }
        {
            var generator = new mathis.reseau.BasisForRegularReseau();
            generator.nbVerticalDecays = 1;
            generator.nbHorizontalDecays = 1;
            generator.nbI = 4;
            generator.nbJ = 4;
            var VV = generator.go();
            var meshMaker = new mathis.reseau.Regular();
            meshMaker.makeLinks = true;
            meshMaker.nbI = 4;
            meshMaker.nbJ = 4;
            meshMaker.Vi = VV.Vi;
            meshMaker.Vj = VV.Vj;
            var mamesh = meshMaker.go();
            mamesh.clearOppositeInLinks();
            var oppositeLinkAssocier = new mathis.linkModule.OppositeLinkAssocierByAngles(mamesh.vertices);
            /**un angle trop grand associe les angles*/
            oppositeLinkAssocier.maxAngleToAssociateLinks = Math.PI / 6;
            oppositeLinkAssocier.goChanging();
            mamesh.fillLineCatalogue();
            bilan.assertTrue(mamesh.allLinesAsASortedString() == 'straightLines:["[0,1,2,3]","[0,4,8,12]","[1,5,9,13]","[12,13,14,15]","[2,6,10,14]","[3,7,11,15]","[4,5,6,7]","[8,9,10,11]"]');
            checkTheRegularityOfAGRaph(mamesh.vertices);
        }
        {
            function torusDecayBySquare(nbX, nbY, nbVerticalDecays, nbHorizontalDecays) {
                var generator = new mathis.reseau.BasisForRegularReseau();
                generator.nbI = nbX;
                generator.nbJ = nbY;
                generator.end = new mathis.XYZ(2 * Math.PI, 2 * Math.PI, 0);
                generator.nbVerticalDecays = nbVerticalDecays;
                generator.nbHorizontalDecays = nbHorizontalDecays;
                var VV = generator.go();
                var r = 0.8;
                var a = 2;
                var meshMaker = new mathis.reseau.Regular();
                meshMaker.makeLinks = false;
                meshMaker.nbI = nbX;
                meshMaker.nbJ = nbY;
                meshMaker.Vi = VV.Vi;
                meshMaker.Vj = VV.Vj;
                var mamesh2 = meshMaker.go();
                mamesh2.vertices.forEach(function (vertex) {
                    var u = vertex.position.x;
                    var v = vertex.position.y;
                    vertex.position.x = (r * Math.cos(u) + a) * Math.cos((v));
                    vertex.position.y = (r * Math.cos(u) + a) * Math.sin((v));
                    vertex.position.z = r * Math.sin(u);
                });
                mamesh2.clearLinksAndLines();
                var merger = new mathis.grateAndGlue.Merger(mamesh2, null, null);
                merger.cleanDoubleLinks = false;
                merger.mergeLink = false;
                merger.goChanging();
                var linkFromPoly = new mathis.linkModule.LinkCreaterSorterAndBorderDetecterByPolygons(mamesh2);
                linkFromPoly.forceOppositeLinksAtCorners = true;
                linkFromPoly.goChanging();
                mamesh2.fillLineCatalogue();
                //cc('mamesh2',mamesh2.toString())
                return mamesh2.allLinesAsASortedString();
            }
            function torusDecayByLinks(nbX, nbY, nbVerticalDecays, nbHorizontalDecays, angleToAssociateOpposite) {
                var generator = new mathis.reseau.BasisForRegularReseau();
                generator.nbI = nbX;
                generator.nbJ = nbY;
                generator.end = new mathis.XYZ(2 * Math.PI, 2 * Math.PI, 0);
                generator.nbVerticalDecays = nbVerticalDecays;
                generator.nbHorizontalDecays = nbHorizontalDecays;
                var VV = generator.go();
                var r = 0.8;
                var a = 2;
                var meshMaker = new mathis.reseau.Regular();
                meshMaker.makeLinks = true;
                meshMaker.nbI = nbX;
                meshMaker.nbJ = nbY;
                meshMaker.Vi = VV.Vi;
                meshMaker.Vj = VV.Vj;
                var mamesh = meshMaker.go();
                mamesh.vertices.forEach(function (vertex) {
                    var u = vertex.position.x;
                    var v = vertex.position.y;
                    vertex.position.x = (r * Math.cos(u) + a) * Math.cos((v));
                    vertex.position.y = (r * Math.cos(u) + a) * Math.sin((v));
                    vertex.position.z = r * Math.sin(u);
                });
                var merger = new mathis.grateAndGlue.Merger(mamesh, null, null);
                merger.cleanDoubleLinks = true;
                merger.mergeLink = true;
                merger.goChanging();
                //new linkModule.LinkCreaterSorterAndBorderDetecterByPolygons(IN_mamesh).goChanging()
                var oppositeAssocier = new mathis.linkModule.OppositeLinkAssocierByAngles(mamesh.vertices);
                oppositeAssocier.maxAngleToAssociateLinks = angleToAssociateOpposite;
                oppositeAssocier.goChanging();
                mamesh.fillLineCatalogue();
                return mamesh.allLinesAsASortedString();
            }
        }
        /**we test that exterior vertex are not taken in count when we use {@link LineComputer.computeAllLinesVersusInnerLines}==false */
        {
            var mamesh = new mathis.Mamesh();
            var v0 = mamesh.newVertex(new mathis.XYZ(1, 0, 0));
            //IN_mamesh.paramToVertex.putValue(v0.param,v0)
            var v1 = mamesh.newVertex(new mathis.XYZ(2, 0, 0));
            //IN_mamesh.paramToVertex.putValue(v1.param,v1)
            v0.setOneLink(v1);
            v1.setOneLink(v0);
            //mamesh.linksOK=true
            var v2 = new mathis.Vertex();
            v2.param = new mathis.XYZ(1, 2, 3);
            v2.setOneLink(v1);
            v1.setOneLink(v2);
            var lineMaker = new mathis.lineModule.LineComputer(mamesh);
            lineMaker.restrictLinesToTheseVertices = mamesh.vertices;
            lineMaker.go();
            bilan.assertTrue(mamesh.getStraightLines().length == 1);
        }
        return bilan;
    }
    mathis.linkerTest = linkerTest;
})(mathis || (mathis = {}));
/**
 * Created by vigon on 22/02/2016.
 */
var mathis;
(function (mathis) {
    function testMameshModification(mathisFrame) {
        var bilan = new mathis.Bilan();
        /**test partial dichotomy, linkModule*/
        {
            var mamesh = new mathis.Mamesh();
            var creator = new mathis.creationFlat.SingleSquare(mamesh);
            creator.makeLinks = false;
            creator.go();
            var dicho = new mathis.mameshModification.SquareDichotomer(mamesh);
            dicho.go();
            var dicho2 = new mathis.mameshModification.SquareDichotomer(mamesh);
            dicho2.squareToCut = [mamesh.vertices[0], mamesh.vertices[4], mamesh.vertices[8], mamesh.vertices[7]];
            dicho2.go();
            var linkerCons = new mathis.linkModule.LinkCreaterSorterAndBorderDetecterByPolygons(mamesh);
            linkerCons.goChanging();
            mamesh.fillLineCatalogue();
            bilan.assertTrue(mamesh.allLinesAsASortedString() == 'straightLines:["[0,12,7,3]","[0,9,4,1]","[1,5,2]","[10,13,12]","[2,6,3]","[4,10,8,6]","[5,8,11,7]","[9,13,11]"]');
        }
        /**idem */
        {
            var mamesh = new mathis.Mamesh();
            new mathis.creationFlat.SingleSquareWithOneDiag(mamesh).go();
            var dicho = new mathis.mameshModification.TriangleDichotomer(mamesh);
            dicho.trianglesToCut = [mamesh.vertices[0], mamesh.vertices[1], mamesh.vertices[3]];
            dicho.makeLinks = true;
            dicho.go();
            var dicho2 = new mathis.mameshModification.TriangleDichotomer(mamesh);
            dicho2.trianglesToCut = [mamesh.vertices[4], mamesh.vertices[5], mamesh.vertices[6]];
            dicho.makeLinks = true;
            dicho2.go();
            new mathis.spacialTransformations.Similitude(mamesh.vertices, 0.1).goChanging();
            mamesh.fillLineCatalogue();
            bilan.assertTrue(mamesh.allLinesAsASortedString() == 'straightLines:["[0,4,1]","[0,6,3]","[1,2]","[1,5,3]","[2,3]","[4,7,5]","[4,9,6]","[5,8,6]","[7,8]","[7,9]","[8,9]"]');
        }
        /**idem*/
        {
            var mamesh = new mathis.Mamesh();
            var creator = new mathis.creationFlat.SingleSquare(mamesh);
            creator.makeLinks = false;
            creator.go();
            var dicho = new mathis.mameshModification.SquareDichotomer(mamesh);
            dicho.go();
            var li = new mathis.linkModule.LinkCreaterSorterAndBorderDetecterByPolygons(mamesh);
            li.goChanging();
            mamesh.fillLineCatalogue();
            bilan.assertTrue(mamesh.allLinesAsASortedString() == 'straightLines:["[0,4,1]","[0,7,3]","[1,5,2]","[2,6,3]","[4,8,6]","[5,8,7]"]');
        }
        /**idem*/
        {
            var mamesh = new mathis.Mamesh();
            new mathis.creationFlat.SingleSquareWithOneDiag(mamesh).go();
            var dicho = new mathis.mameshModification.TriangleDichotomer(mamesh);
            dicho.trianglesToCut = [mamesh.vertices[0], mamesh.vertices[1], mamesh.vertices[3]];
            dicho.makeLinks = true;
            dicho.go();
            mamesh.clearLinksAndLines();
            new mathis.linkModule.LinkCreaterSorterAndBorderDetecterByPolygons(mamesh).goChanging();
            mamesh.fillLineCatalogue();
            bilan.assertTrue(mamesh.allLinesAsASortedString() == 'straightLines:["[0,4,1]","[0,6,3]","[1,2]","[1,5,3]","[2,3]","[4,5]","[4,6]","[5,6]"]');
        }
        /**idem*/
        {
            var mamesh = new mathis.Mamesh();
            var creator = new mathis.creationFlat.SingleSquare(mamesh);
            creator.makeLinks = false;
            creator.go();
            var dicho = new mathis.mameshModification.SquareDichotomer(mamesh);
            dicho.go();
            var dicho2 = new mathis.mameshModification.SquareDichotomer(mamesh);
            dicho2.squareToCut = [mamesh.vertices[0], mamesh.vertices[4], mamesh.vertices[8], mamesh.vertices[7]];
            dicho2.go();
            new mathis.linkModule.LinkCreaterSorterAndBorderDetecterByPolygons(mamesh).goChanging();
            mamesh.fillLineCatalogue();
            bilan.assertTrue(mamesh.allLinesAsASortedString() == 'straightLines:["[0,12,7,3]","[0,9,4,1]","[1,5,2]","[10,13,12]","[2,6,3]","[4,10,8,6]","[5,8,11,7]","[9,13,11]"]');
        }
        //{
        //
        //    let creator=new flat.SingleSquare()
        //    creator.createNewLinks=false
        //    let IN_mamesh:Mamesh=creator.goChanging()
        //    let dicho=new mameshModification.SquareDichotomer(IN_mamesh)
        //    dicho.goChanging()
        //
        //    //let dicho2=new mameshModification.SquareDichotomer(IN_mamesh)
        //    //dicho2.squareToCut=[IN_mamesh.vertices[1],IN_mamesh.vertices[5],IN_mamesh.vertices[8],IN_mamesh.vertices[4],IN_mamesh.vertices[5],IN_mamesh.vertices[2],IN_mamesh.vertices[6],IN_mamesh.vertices[8]]
        //    //dicho2.goChanging()
        //
        //    cc('IN_mamesh',IN_mamesh.toString())
        //
        //
        //    IN_mamesh.vertices.forEach(v=>{
        //        if (v.position.x==1) v.position.x=0
        //    })
        //
        //    new linkModule.LinkCreaterSorterAndBorderDetecterByPolygons(IN_mamesh).goChanging()
        //
        //
        //    new mameshModification.OneMameshAutoMerge(IN_mamesh).goChanging()
        //
        //
        //    cc('mergedMamesh',IN_mamesh.toString())
        //
        //
        //
        //}
        //
        //
        //{
        //
        //
        //    let mamesh0:Mamesh=new flat.SingleSquare().goChanging()
        //    let mamesh1:Mamesh=new flat.SingleSquare().goChanging()
        //
        //    mamesh1.vertices.forEach(v=>{
        //        v.position.x+=1
        //    })
        //
        //
        //
        //    let mergedMamesh=new mameshModification.TwoMameshMerger(mamesh0,mamesh1).goChanging()
        //
        //
        //    //cc('mamesh0',mamesh0.toString(false))
        //    //cc('mamesh1',mamesh1.toString(false))
        //    //
        //    //cc('mergedMamesh',mergedMamesh.toString(false))
        //
        //
        //
        //
        //}
        //{
        //
        //    let IN_mamesh=new Mamesh()
        //    let cart= new flat.Cartesian(IN_mamesh)
        //    cart.nbX=4
        //    cart.nbY=2
        //    cart.maxX=3
        //    cart.createNewLinks=true
        //    cart.goChanging()
        //
        //    //cc(IN_mamesh.toString())
        //
        //    IN_mamesh.vertices.forEach(v=>{
        //        if (v.position.x==3) v.position.x=0
        //    })
        //
        //    new mameshModification.Merger(IN_mamesh).goChanging()
        //
        //    //cc(IN_mamesh)
        //    //cc(IN_mamesh.toString())
        //
        //
        //
        //}
        //
        //
        /**test the cleaning of the links crossing middles of cut segments*/
        {
            var cart = new mathis.reseau.Regular();
            cart.nbI = 2;
            cart.nbJ = 2;
            cart.makeLinks = false;
            var mamesh0 = cart.go();
            new mathis.mameshModification.SquareDichotomer(mamesh0).go();
            new mathis.linkModule.LinkCreaterSorterAndBorderDetecterByPolygons(mamesh0).goChanging();
            var cart1 = new mathis.reseau.Regular();
            cart1.nbI = 2;
            cart1.nbJ = 2;
            var mamesh1 = cart1.go();
            mamesh1.vertices.forEach(function (v) { v.position.x += 1; });
            new mathis.grateAndGlue.Merger(mamesh0, mamesh1, null).goChanging();
        }
        /**two vertices are merged into one. Square are changed into triangles*/
        // {
        //     let IN_mamesh=new MameshForTest()
        //     let cart1= new reseau.Regular(IN_mamesh)
        //     cart1.nbX=3
        //     cart1.maxX=2
        //     cart1.nbY=2
        //     cart1.goChanging()
        //     IN_mamesh.vertices[0].position.x=1
        //     IN_mamesh.vertices[4].position.x=1
        //     new mameshModification.Merger(IN_mamesh).goChanging()
        //     bilan.assertTrue(IN_mamesh.toStringForTest1()=='0|links:(1)(3)(5)1|links:(3)(0)3|links:(5,1)(1,5)(0)5|links:(3)(0)tri:[0,3,1][0,5,3]squa:cutSegments')
        // }
        //{
        //        let IN_mamesh=new Mamesh()
        //        let cartesian= new flat.Cartesian(IN_mamesh)
        //        cartesian.nbX=3
        //    cartesian.maxX=2
        //        cartesian.nbY=2
        //        cartesian.createNewLinks=true
        //        cartesian.goChanging()
        //        cc(IN_mamesh.toString(false))
        //
        //    IN_mamesh.vertices[0].position.x=1
        //    new mameshModification.Merger(IN_mamesh).goChanging()
        //    cc(IN_mamesh.toString())
        //
        //}
        /**comparison of triangles dichotomies : first making links at the end. Secondly making links at each dichotomy. This second procedure is faster*/
        {
            var mamesh = new mathis.Mamesh();
            new mathis.creationFlat.SingleSquareWithOneDiag(mamesh).go();
            var dichotomer = new mathis.mameshModification.TriangleDichotomer(mamesh);
            dichotomer.makeLinks = true;
            dichotomer.go();
            mamesh.fillLineCatalogue();
            var mamesh2 = new mathis.Mamesh();
            new mathis.creationFlat.SingleSquareWithOneDiag(mamesh2).go();
            var dichotomer2 = new mathis.mameshModification.TriangleDichotomer(mamesh2);
            dichotomer2.makeLinks = false;
            dichotomer2.go();
            new mathis.linkModule.LinkCreaterSorterAndBorderDetecterByPolygons(mamesh2).goChanging();
            mamesh2.fillLineCatalogue();
            bilan.assertTrue(mamesh.allLinesAsASortedString() == mamesh2.allLinesAsASortedString());
        }
        /**idem, also time comparison*/
        {
            var deltaTime0 = 0;
            var deltaTime1 = 0;
            var lines0 = "";
            var lines1 = "";
            {
                var time0 = performance.now();
                var mamesh = new mathis.Mamesh();
                var maker = new mathis.reseau.SingleTriangle(mamesh);
                maker.go();
                var dichoter = new mathis.mameshModification.TriangleDichotomer(mamesh);
                dichoter.makeLinks = false;
                dichoter.go();
                dichoter = new mathis.mameshModification.TriangleDichotomer(mamesh);
                dichoter.makeLinks = false;
                dichoter.go();
                dichoter = new mathis.mameshModification.TriangleDichotomer(mamesh);
                dichoter.makeLinks = false;
                dichoter.go();
                dichoter = new mathis.mameshModification.TriangleDichotomer(mamesh);
                dichoter.makeLinks = false;
                dichoter.go();
                dichoter = new mathis.mameshModification.TriangleDichotomer(mamesh);
                dichoter.makeLinks = false;
                dichoter.go();
                new mathis.linkModule.LinkCreaterSorterAndBorderDetecterByPolygons(mamesh).goChanging();
                deltaTime0 = performance.now() - time0;
                mamesh.fillLineCatalogue();
                lines0 = mamesh.allLinesAsASortedString();
            }
            {
                var time0 = performance.now();
                var mamesh = new mathis.Mamesh();
                var maker = new mathis.reseau.SingleTriangle(mamesh);
                maker.go();
                var dichoter = new mathis.mameshModification.TriangleDichotomer(mamesh);
                dichoter.makeLinks = true;
                dichoter.go();
                dichoter = new mathis.mameshModification.TriangleDichotomer(mamesh);
                dichoter.makeLinks = true;
                dichoter.go();
                dichoter = new mathis.mameshModification.TriangleDichotomer(mamesh);
                dichoter.makeLinks = true;
                dichoter.go();
                dichoter = new mathis.mameshModification.TriangleDichotomer(mamesh);
                dichoter.makeLinks = true;
                dichoter.go();
                dichoter = new mathis.mameshModification.TriangleDichotomer(mamesh);
                dichoter.makeLinks = true;
                dichoter.go();
                deltaTime1 = performance.now() - time0;
                mamesh.fillLineCatalogue();
                lines1 = mamesh.allLinesAsASortedString();
            }
            bilan.assertTrue(deltaTime0 > deltaTime1);
            bilan.assertTrue(lines0 == lines1);
        }
        /**idem*/
        // {
        //     let meshSquare2 = new Mamesh()
        //     new creationFlat.SingleSquareWithOneDiag(meshSquare2).goChanging()
        //
        //     new mameshModification.TriangleDichotomer(meshSquare2).goChanging()
        //     meshSquare2.fillLineCatalogue()
        //     bilan.assertTrue(meshSquare2.straightLines.length==9)
        //
        //     let v0=meshSquare2.vertices[0]
        //     let v1=meshSquare2.vertices[1]
        //     let v2=meshSquare2.vertices[2]
        //     let v3=meshSquare2.vertices[3]
        //
        //     /** we add a loop line arround (but not suppress any existing links)*/
        //     v0.setTwoOppositeLinks(v1,v3,false)
        //     v1.setTwoOppositeLinks(v2,v0,false)
        //     v2.setTwoOppositeLinks(v3,v1,false)
        //     v3.setTwoOppositeLinks(v0,v2,false)
        //
        //     meshSquare2.straightLines=null
        //     meshSquare2.loopLines=null
        //     meshSquare2.fillLineCatalogue()
        //
        //     bilan.assertTrue(meshSquare2.loopLines.length==1 && meshSquare2.loopLines[0].length==4)
        // }
        {
            var mamesh = new mathis.reseau.TriangulatedPolygone(13).go();
            mamesh.fillLineCatalogue();
            bilan.assertTrue(mamesh.getStraightLines().length == 26);
        }
        //        {
        //            let meshPoly3 = mmc.createPolygone(3, true)
        //            let mmm = new MameshManipulator(meshPoly3)
        //            mmm.fillLineCatalogue()
        //            bilan.assertTrue(meshPoly3.straightLines.length == 0 && meshPoly3.loopLines.length == 1)
        //
        //        }
        return bilan;
    }
    mathis.testMameshModification = testMameshModification;
})(mathis || (mathis = {}));
/**
 * Created by vigon on 22/02/2016.
 */
var mathis;
(function (mathis) {
    var Similitude = mathis.spacialTransformations.Similitude;
    function testRiemann(mathisFrame) {
        var bilan = new mathis.Bilan();
        {
            var nb = 3;
            var gene0 = new mathis.reseau.BasisForRegularReseau();
            gene0.origin = new mathis.XYZ(-1 / 2, -1 / 2, 0);
            gene0.end = new mathis.XYZ(1 / 2, 1 / 2, 0);
            gene0.nbI = nb;
            gene0.nbJ = nb;
            var mamesh = new mathis.reseau.Regular(gene0).go();
            var verticesToKeep = [];
            for (var i = 0; i < mamesh.vertices.length; i++) {
                if (i != 2)
                    verticesToKeep.push(mamesh.vertices[i]);
            }
            var suber = new mathis.grateAndGlue.SubMameshExtractor(mamesh, verticesToKeep);
            suber.takeCareOfPolygons = false;
            var subMamesh = suber.go();
            subMamesh.isolateMameshVerticesFromExteriorVertices();
            subMamesh.fillLineCatalogue();
            bilan.assertTrue(subMamesh.allLinesAsASortedString() == 'straightLines:["[0,1]","[0,3,6]","[1,4,7]","[3,4,5]","[5,8]","[6,7,8]"]');
        }
        {
            var test = function (neighborhoodCoeficients) {
                var nb = 6;
                var gene0 = new mathis.reseau.BasisForRegularReseau();
                gene0.origin = new mathis.XYZ(-1 / 2, -1 / 2, 0);
                gene0.end = new mathis.XYZ(1 / 2, 1 / 2, 0);
                gene0.nbI = nb;
                gene0.nbJ = nb;
                var mamesh0 = new mathis.reseau.Regular(gene0).go();
                var gene1 = new mathis.reseau.BasisForRegularReseau();
                gene1.origin = new mathis.XYZ(-1 / 2, -1 / 2, 0);
                gene1.end = new mathis.XYZ(1 / 2, 1 / 2, 0);
                gene1.nbI = nb;
                gene1.nbJ = nb;
                var mamesh1 = new mathis.reseau.Regular(gene1).go();
                var gene2 = new mathis.reseau.BasisForRegularReseau();
                gene2.origin = new mathis.XYZ(-1 / 2, -1 / 2, 0);
                gene2.end = new mathis.XYZ(1 / 2, 1 / 2, 0);
                gene2.nbI = nb;
                gene2.nbJ = nb;
                var mamesh2 = new mathis.reseau.Regular(gene2).go();
                new Similitude(mamesh1.vertices, 0, new mathis.XYZ(0.3, 0.2, 0)).goChanging();
                new Similitude(mamesh2.vertices, 0, new mathis.XYZ(0.2, -0.2, 0)).goChanging();
                var grater = new mathis.grateAndGlue.GraphGrater();
                grater.IN_graphFamily = [mamesh0.vertices, mamesh1.vertices, mamesh2.vertices];
                grater.proximityCoefToGrate = neighborhoodCoeficients;
                var graterRes = grater.go();
                mamesh0 = new mathis.grateAndGlue.SubMameshExtractor(mamesh0, graterRes[0]).go();
                mamesh0.isolateMameshVerticesFromExteriorVertices();
                mamesh1 = new mathis.grateAndGlue.SubMameshExtractor(mamesh1, graterRes[1]).go();
                mamesh1.isolateMameshVerticesFromExteriorVertices();
                mamesh2 = new mathis.grateAndGlue.SubMameshExtractor(mamesh2, graterRes[2]).go();
                mamesh2.isolateMameshVerticesFromExteriorVertices();
                // let lineV0 = new visu3d.LinksViewer(mamesh0, mathisFrame.scene)
                // lineV0.color = new BABYLON.Color3(0, 1, 0)
                // lineV0.goChanging()
                //
                // let lineV1 = new visu3d.LinksViewer(mamesh1, mathisFrame.scene)
                // lineV1.color = new BABYLON.Color3(1, 0, 0)
                // lineV1.goChanging()
                //
                // let lineV2 = new visu3d.LinksViewer(mamesh2, mathisFrame.scene)
                // lineV2.color = new BABYLON.Color3(0, 0, 1)
                // lineV2.goChanging()
                //
                //
                // let vertVisu = new visu3d.VerticesViewer(null, mathisFrame.scene)
                // vertVisu.selectedVertices = grater.OUTAllSeeds
                // vertVisu.goChanging()
                //
                // cc(mamesh0.allSquareAndTrianglesAsSortedString()+mamesh1.allSquareAndTrianglesAsSortedString()+mamesh2.allSquareAndTrianglesAsSortedString())
                return mamesh0.allSquareAndTrianglesAsSortedString() + mamesh1.allSquareAndTrianglesAsSortedString() + mamesh2.allSquareAndTrianglesAsSortedString();
            };
            bilan.assertTrue(test([1]) == 'square:["[0,6,7,1]","[1,7,8,2]","[12,18,19,13]","[13,19,20,14]","[14,20,21,15]","[15,21,22,16]","[2,8,9,3]","[3,9,10,4]","[6,12,13,7]","[7,13,14,8]","[8,14,15,9]","[9,15,16,10]"]triangle:[]square:["[0,6,7,1]","[1,7,8,2]","[2,8,9,3]","[6,12,13,7]","[7,13,14,8]","[8,14,15,9]"]triangle:[]square:["[0,6,7,1]","[12,18,19,13]","[18,24,25,19]","[19,25,26,20]","[20,26,27,21]","[24,30,31,25]","[25,31,32,26]","[26,32,33,27]","[6,12,13,7]"]triangle:[]');
            bilan.assertTrue(test([0.7]) == 'square:["[0,6,7,1]","[1,7,8,2]","[10,16,17,11]","[12,18,19,13]","[13,19,20,14]","[14,20,21,15]","[15,21,22,16]","[16,22,23,17]","[2,8,9,3]","[3,9,10,4]","[4,10,11,5]","[6,12,13,7]","[7,13,14,8]","[8,14,15,9]","[9,15,16,10]"]triangle:[]square:["[0,6,7,1]","[1,7,8,2]","[2,8,9,3]","[6,12,13,7]","[7,13,14,8]","[8,14,15,9]"]triangle:[]square:["[0,6,7,1]","[1,7,8,2]","[2,8,9,3]","[6,12,13,7]","[7,13,14,8]","[8,14,15,9]"]triangle:[]');
            bilan.assertTrue(test([0.5]) == 'square:["[0,6,7,1]","[1,7,8,2]","[10,16,17,11]","[12,18,19,13]","[13,19,20,14]","[14,20,21,15]","[15,21,22,16]","[16,22,23,17]","[2,8,9,3]","[21,27,28,22]","[22,28,29,23]","[3,9,10,4]","[4,10,11,5]","[6,12,13,7]","[7,13,14,8]","[8,14,15,9]","[9,15,16,10]"]triangle:[]square:["[0,6,7,1]","[1,7,8,2]","[2,8,9,3]","[6,12,13,7]","[7,13,14,8]","[8,14,15,9]"]triangle:[]square:["[0,6,7,1]","[1,7,8,2]","[2,8,9,3]","[6,12,13,7]","[7,13,14,8]","[8,14,15,9]"]triangle:[]');
        }
        // {
        //
        //
        //     function yep4(takeCareOfPolygons:boolean,nb:number,gratingCoef:number[]=null,stickingCoef:number[]=null,clean=false) {
        //
        //
        //         let gene0 = new reseau.BasisForRegularReseau()
        //         gene0.origin = new XYZ(-1 / 2, -1 / 2, 0)
        //         gene0.end = new XYZ(1 / 2, 1 / 2, 0)
        //         gene0.nbI = nb
        //         gene0.nbJ = nb
        //         let reg=new reseau.Regular( gene0)
        //         reg.strateHaveSquareMailleVersusTriangleMaille=false
        //         let mamesh0 =reg.goChanging()
        //
        //         let gene1 = new reseau.BasisForRegularReseau()
        //         gene1.origin = new XYZ(-1 / 2, -1 / 2, 0)
        //         gene1.end = new XYZ(1 / 2, 1 / 2, 0)
        //         gene1.nbI = nb
        //         gene1.nbJ = nb
        //         let mamesh1 =new reseau.Regular( gene1).goChanging()
        //
        //
        //         let gene2= new reseau.BasisForRegularReseau()
        //         gene2.origin = new XYZ(-1 / 2, -1 / 2, 0)
        //         gene2.end = new XYZ(1 / 2, 1 / 2, 0)
        //         gene2.nbI = nb
        //         gene2.nbJ = nb
        //         let mamesh2 =new reseau.Regular( gene2).goChanging()
        //
        //
        //         new Similitude(mamesh0.vertices, 0.01).goChanging()
        //         new Similitude(mamesh1.vertices, Math.PI / 5, new XYZ(0.32, 0.23, 0)).goChanging()
        //         new Similitude(mamesh2.vertices, -Math.PI / 5, new XYZ(0.32,- 0.4, 0)).goChanging()
        //
        //
        //         let concurenter = new mameshModification.ConcurrentMameshesGraterAndSticker()
        //         concurenter.IN_mameshes=[mamesh0, mamesh1,mamesh2]
        //         concurenter.justGrateDoNotStick = false
        //         concurenter.takeCareOfPolygons = takeCareOfPolygons
        //         concurenter.SUB_grater.proximityCoefToGrate=gratingCoef
        //         concurenter.stickingSizeCoefByFamily=stickingCoef
        //         concurenter.suppressLinksAngularlyTooClose=clean
        //         concurenter.suppressDoubleLinksVersusNot=clean
        //         concurenter.justGrateDoNotStick=true
        //         let stuck = concurenter.goChanging()
        //
        //
        //         stuck.clearOppositeInLinks()
        //         new linkModule.OppositeLinkAssocierByAngles(stuck.vertices).goChanging()
        //         stuck.fillLineCatalogue()
        //
        //
        //
        //         return stuck
        //     }
        //
        //
        //
        //     let stuck
        //
        //     //     stuck=yep4(true,5)//,[0.75,0.75,0.75])
        //     // bilan.assertTrue(stuck.allLinesAsASortedString()=='straightLines:["[0,6,7,13]","[0,60]","[1,6,11,62,67,72]","[11,7,8,4]","[12,13,9]","[18,38,39]","[2,7,12]","[3,8,13,18,41,46]","[4,9,44]","[40,68,67,66,65]","[44,43,42,41,40,73,72,71,70]","[45,40,63,62,61,60]","[45,46,47,48,49]","[47,42,18,12,11,56,55]","[48,43,38]","[49,44,39,9,8,2,1,0,55,60,65,70]","[6,2,3,4]","[71,66,61,56]","[73,68,63]"]')
        //     //
        //     //
        //     //
        //     // /**on grate un peu diffrement*/
        //     // stuck=yep4(true,5,[0.9,0.75,0.9])
        //     // bilan.assertTrue(stuck.allLinesAsASortedString()=='straightLines:["[0,6,7,13,38,43,48]","[1,6,11,62,67,72]","[11,12,37,42,47]","[12,13,39,44,49]","[2,7,12,36,41,46]","[3,8,13]","[39,38,37,36,63,62,61,60]","[44,43,42,41,40,73,72,71,70]","[45,40,68,67,66,65]","[45,46,47,48,49]","[6,2,3]","[73,68,63]","[8,2,1,0,60,65,70]","[8,7,11,61,66,71]"]')
        //     //
        //     //
        //     //
        //     //
        //     // stuck=yep4(true,5,[0.75,0.75,0.75],[2.5,2.5,2.5],false)
        //     //
        //     // bilan.assertTrue(stuck.allLinesAsASortedString()=='straightLines:["[0,6,7,13]","[0,60]","[1,6,11,62,67,72]","[11,7,8,4]","[12,13,9]","[18,41,46]","[18,42,47]","[18,47]","[2,7,12]","[3,8,13,18,46]","[39,38,18,40]","[4,9,44]","[40,68,67,66,65]","[44,43,42,41,40,73,72,71,70]","[45,40,63,62,61,60]","[45,46,47,48,49]","[48,18,12,11,56,55]","[48,43,38]","[49,44,39,9,8,2,1,0,55,60,65,70]","[6,2,3,4]","[71,66,61,56]","[73,68,63]"]')
        //
        //     // /**cleaning*/
        //     // stuck=yep4(true,5,[0.75,0.75,0.75],[2.5,2.5,2.5],true)
        //     // bilan.assertTrue(stuck.allLinesAsASortedString()=='straightLines:["[0,6,7,13]","[1,6,11,62,67,72]","[11,7,8,4]","[12,13,9]","[2,7,12]","[3,8,13,18,42,47]","[39,38,18,12,11,56,55]","[44,43,42,41,40,73,72,71,70]","[45,40,63,62,61,60]","[45,46,47]","[46,41]","[48,43,38]","[48,49]","[49,44,39,9,8,2,1,0,55,60,65,70]","[6,2,3,4]","[65,66,67,68]","[71,66,61,56]","[73,68,63]","[9,4]"]')
        //
        //
        //     // /**2.5 au lieu de 2 rajoute une liaison lointaine*/
        //     // stuck=yep4(true,4,[0.75,0.75,0.75],[2.5,2.5,2.5])
        //     // bilan.assertTrue(stuck.allLinesAsASortedString()=='straightLines:["[0,40]","[0,5,6,26,30]","[1,5,9,24,28]","[2,6,29]","[27,26,25,24,45,44]","[28,29,30,31]","[29,25,9,37,36]","[3,7,27,31]","[31,7,2,1,0,36,40,44]","[40,41]","[45,41,37]","[5,2,3]","[6,30]","[7,6,9,41]"]')
        //
        //
        //
        //     stuck=yep4(true,4,[0.6,0.75,0.75],null,true)
        //     bilan.assertTrue(stuck.allLinesAsASortedString()=='straightLines:["[0,1,2,7,27,31]","[0,4,41,45]","[0,5,6]","[1,5,9]","[2,6,10,25,29]","[24,25,26,27]","[28,24]","[28,29,30,31]","[3,2,5,4,40,44]","[4,9,10,26,30]","[40,41]","[44,45]","[7,3]","[9,6,7]"]')
        //
        //     cc(stuck.allLinesAsASortedString())
        //     new visu3d.LinesViewer(stuck, mathisFrame.scene).goChanging()
        //
        //
        //     // liner.goChanging()
        //     //
        //     // new visu3d.SurfaceViewer(stuck, mathisFrame.scene).goChanging()
        //     // new visu3d.VerticesViewer(stuck, mathisFrame.scene).goChanging()
        //
        //
        //
        // }
        {
            var toTest = function (addBorderPoly) {
                var nb = 4;
                var gene0 = new mathis.reseau.BasisForRegularReseau();
                gene0.origin = new mathis.XYZ(-1 / 2, -1 / 2, 0);
                gene0.end = new mathis.XYZ(1 / 2, 1 / 2, 0);
                gene0.nbI = nb;
                gene0.nbJ = nb;
                var regularMaker = new mathis.reseau.Regular(gene0);
                regularMaker.squareVersusTriangleMaille = false;
                var mamesh0 = regularMaker.go();
                var selected = [mamesh0.vertices[0], mamesh0.vertices[1], mamesh0.vertices[4], mamesh0.vertices[5]];
                var sub = new mathis.grateAndGlue.SubMameshExtractor(mamesh0, selected);
                sub.addBorderPolygonInsteadOfSuppress = addBorderPoly;
                var subma = sub.go();
                return subma;
            };
            var subma = toTest(false);
            bilan.assertTrue(subma.allSquareAndTrianglesAsSortedString() == 'square:[]triangle:["[0,4,5]","[0,5,1]"]');
            subma = toTest(true);
            bilan.assertTrue(subma.allSquareAndTrianglesAsSortedString() == 'square:[]triangle:["[0,4,5]","[0,5,1]","[1,5,2]","[2,5,6]","[4,8,9]","[4,9,5]","[5,9,6]"]');
        }
        {
            var nb = 4;
            var gene0 = new mathis.reseau.BasisForRegularReseau();
            gene0.origin = new mathis.XYZ(-1 / 2, -1 / 2, 0);
            gene0.end = new mathis.XYZ(1 / 2, 1 / 2, 0);
            gene0.nbI = nb;
            gene0.nbJ = nb;
            var mamesh0 = new mathis.reseau.Regular(gene0).go();
            var selected = [mamesh0.vertices[0], mamesh0.vertices[1], mamesh0.vertices[4], mamesh0.vertices[5]];
            var sub = new mathis.grateAndGlue.SubMameshExtractor(mamesh0, selected);
            sub.addBorderPolygonInsteadOfSuppress = true;
            var subma = sub.go();
            bilan.assertTrue(sub.OUT_BorderPolygon.length == 3);
            bilan.assertTrue(sub.OUT_BorderVerticesInside.length == 3);
            bilan.assertTrue(sub.OUTBorderVerticesOutside.length == 5);
            bilan.assertTrue(subma.allSquareAndTrianglesAsSortedString() == 'square:["[0,4,5,1]","[1,5,6,2]","[4,8,9,5]","[5,9,10,6]"]triangle:[]');
        }
        //
        //
        // {
        //
        //
        //     function yep(takeCareOfPolygons:boolean,nb:number) {
        //
        //
        //         let gene0 = new reseau.BasisForRegularReseau()
        //         gene0.origin = new XYZ(-1 / 2, -1 / 2, 0)
        //         gene0.end = new XYZ(1 / 2, 1 / 2, 0)
        //         gene0.nbI = nb
        //         gene0.nbJ = nb
        //         let mamesh0 =new reseau.Regular( gene0).goChanging()
        //
        //         let gene1 = new reseau.BasisForRegularReseau()
        //         gene1.origin = new XYZ(-1 / 2, -1 / 2, 0)
        //         gene1.end = new XYZ(1 / 2, 1 / 2, 0)
        //         gene1.nbI = nb
        //         gene1.nbJ = nb
        //         let mamesh1 =new reseau.Regular( gene1).goChanging()
        //
        //
        //         new creation2D.Similitude(mamesh0.vertices, 0.01).goChanging()
        //         new creation2D.Similitude(mamesh1.vertices, Math.PI / 5, new XYZ(0.32, 0.23, 0)).goChanging()
        //
        //         let concurenter = new mameshModification.ConcurrentMameshesGraterAndSticker([mamesh0, mamesh1])
        //         concurenter.justGrateDoNotStick = false
        //         concurenter.takeCareOfPolygons = takeCareOfPolygons
        //         let stuck = concurenter.goChanging()
        //
        //
        //         stuck.clearOppositeInLinks()
        //         new linkModule.OppositeLinkAssocierByAngles(stuck.vertices).goChanging()
        //         stuck.fillLineCatalogue()
        //
        //
        //
        //
        //
        //         return stuck
        //     }
        //
        //
        //
        //     let stuck=yep(true,4)
        //     bilan.assertTrue(stuck.allLinesAsASortedString()=='straightLines:["[0,1,2]","[0,4,8]","[1,5,9,24,28]","[10,26,30]","[2,6,10,25,29]","[24,25,26,27]","[28,29,30,31]","[31,27]","[4,5,6]","[8,9,10,27]"]')
        //
        //
        //     stuck=yep(false,4)
        //     bilan.assertTrue(stuck.allLinesAsASortedString()=='straightLines:["[0,1,2,3]","[0,4,8]","[1,5,9,20]","[2,6,10,25,29]","[24,25,26,27]","[28,24,20]","[28,29,30,31]","[4,5,6,23,27,31]","[8,9,10,26,30]"]')
        //
        //     stuck=yep(true,5)
        //     bilan.assertTrue(stuck.allLinesAsASortedString()=='straightLines:["[0,1,2,3,4]","[0,5,10,15,20]","[1,6,11,16,21,40,45]","[10,11,12,13,38,43,48]","[15,16,17,37,42,47]","[2,7,12,17,36,41,46]","[20,21]","[3,8,13]","[36,37,38,39]","[4,9,39,44,49]","[40,41,42,43,44]","[45,46,47,48,49]","[5,6,7,8,9]"]')
        //
        //
        //
        //
        //
        //
        // }
        //
        {
            var nb = 4;
            var gene0 = new mathis.reseau.BasisForRegularReseau();
            gene0.origin = new mathis.XYZ(-1 / 2, -1 / 2, 0);
            gene0.end = new mathis.XYZ(1 / 2, 1 / 2, 0);
            gene0.nbI = nb;
            gene0.nbJ = nb;
            var mamesh0 = new mathis.reseau.Regular(gene0).go();
            var selected = [mamesh0.vertices[0], mamesh0.vertices[1], mamesh0.vertices[4], mamesh0.vertices[5]];
            var sub = new mathis.grateAndGlue.SubMameshExtractor(mamesh0, selected);
            sub.addBorderPolygonInsteadOfSuppress = false;
            var subma = sub.go();
            bilan.assertTrue(sub.OUT_BorderPolygon.length == 3);
            bilan.assertTrue(sub.OUT_BorderVerticesInside.length == 3);
            bilan.assertTrue(sub.OUTBorderVerticesOutside.length == 5);
            bilan.assertTrue(subma.allSquareAndTrianglesAsSortedString() == 'square:["[0,4,5,1]"]triangle:[]');
        }
        {
            var nb = 5;
            var gene0 = new mathis.reseau.BasisForRegularReseau();
            gene0.origin = new mathis.XYZ(-1 / 2, -1 / 2, 0);
            gene0.end = new mathis.XYZ(1 / 2, 1 / 2, 0);
            gene0.nbI = nb;
            gene0.nbJ = nb;
            var mamesh0 = new mathis.reseau.Regular(gene0).go();
            mamesh0.fillLineCatalogue();
            var linesBefore = mamesh0.allLinesAsASortedString();
            mamesh0.clearOppositeInLinks();
            new mathis.linkModule.OppositeLinkAssocierByAngles(mamesh0.vertices).goChanging();
            mamesh0.fillLineCatalogue();
            var linesAfter = mamesh0.allLinesAsASortedString();
            bilan.assertTrue(linesBefore == linesAfter);
        }
        {
            var nb = 7;
            var gene0 = new mathis.reseau.BasisForRegularReseau();
            gene0.origin = new mathis.XYZ(-1 / 2, -1 / 2, 0);
            gene0.end = new mathis.XYZ(1 / 2, 1 / 2, 0);
            gene0.nbI = nb;
            gene0.nbJ = nb;
            var mamesh0 = new mathis.reseau.Regular(gene0).go();
            nb = 5;
            var gene = new mathis.reseau.BasisForRegularReseau();
            gene.origin = new mathis.XYZ(-1 / 2, -1 / 2, 0);
            gene.end = new mathis.XYZ(1 / 2, 1 / 2, 0);
            gene.nbI = nb;
            gene.nbJ = nb;
            var mamesh1 = new mathis.reseau.Regular(gene).go();
            new Similitude(mamesh1.vertices, Math.PI / 4, new mathis.XYZ(0, 0, 0), new mathis.XYZ(0.5, 0.5, 0)).goChanging();
            var grater = new mathis.grateAndGlue.GraphGrater();
            grater.IN_graphFamily = [mamesh0.vertices, mamesh1.vertices];
            var graterRes = grater.go();
            mamesh0 = new mathis.grateAndGlue.SubMameshExtractor(mamesh0, graterRes[0]).go();
            mamesh0.isolateMameshVerticesFromExteriorVertices();
            mamesh1 = new mathis.grateAndGlue.SubMameshExtractor(mamesh1, graterRes[1]).go();
            mamesh1.isolateMameshVerticesFromExteriorVertices();
            //bilan.assertTrue(mamesh0.allSquareAndTrianglesAsSortedString()=='square:["[0,7,8,1]","[1,8,9,2]","[12,19,20,13]","[14,21,22,15]","[19,26,27,20]","[2,9,10,3]","[21,28,29,22]","[26,33,34,27]","[28,35,36,29]","[3,10,11,4]","[33,40,41,34]","[35,42,43,36]","[36,43,44,37]","[37,44,45,38]","[38,45,46,39]","[39,46,47,40]","[4,11,12,5]","[40,47,48,41]","[5,12,13,6]","[7,14,15,8]"]triangle:[]')
            //bilan.assertTrue(mamesh1.allSquareAndTrianglesAsSortedString()=='square:["[0,5,6,1]","[1,6,7,2]","[5,10,11,6]","[6,11,12,7]"]triangle:[]')
            bilan.assertTrue(mamesh0.allSquareAndTrianglesAsSortedString() + mamesh1.allSquareAndTrianglesAsSortedString() == 'square:["[0,7,8,1]","[1,8,9,2]","[12,19,20,13]","[28,35,36,29]","[33,40,41,34]","[35,42,43,36]","[36,43,44,37]","[39,46,47,40]","[4,11,12,5]","[40,47,48,41]","[5,12,13,6]","[7,14,15,8]"]triangle:[]square:["[0,5,6,1]","[1,6,7,2]","[10,15,16,11]","[11,16,17,12]","[12,17,18,13]","[13,18,19,14]","[15,20,21,16]","[16,21,22,17]","[17,22,23,18]","[18,23,24,19]","[2,7,8,3]","[3,8,9,4]","[5,10,11,6]","[6,11,12,7]","[7,12,13,8]","[8,13,14,9]"]triangle:[]');
        }
        {
            var nb = 4;
            var gene0 = new mathis.reseau.BasisForRegularReseau();
            gene0.origin = new mathis.XYZ(-1 / 2, -1 / 2, 0);
            gene0.end = new mathis.XYZ(1 / 2, 1 / 2, 0);
            gene0.nbI = nb;
            gene0.nbJ = nb;
            var mamesh0 = new mathis.reseau.Regular(gene0).go();
            mamesh0.name = 'centre00';
            var admisible_1 = new mathis.HashMap();
            mamesh0.vertices.forEach(function (v) {
                if (v.param.x != 1)
                    admisible_1.putValue(v, true);
            });
            var verticesToKeep = mathis.graph.getGroup([mamesh0.vertices[0]], admisible_1);
            verticesToKeep = mathis.graph.getEdge(verticesToKeep);
            var suber = new mathis.grateAndGlue.SubMameshExtractor(mamesh0, verticesToKeep);
            suber.takeCareOfPolygons = false;
            var subMamesh = suber.go();
            subMamesh.isolateMameshVerticesFromExteriorVertices();
            subMamesh.fillLineCatalogue();
            bilan.assertTrue(subMamesh.allLinesAsASortedString() == 'straightLines:["[0,1,2,3]"]');
        }
        {
            var nb = 4;
            var gene0 = new mathis.reseau.BasisForRegularReseau();
            gene0.origin = new mathis.XYZ(-1 / 2, -1 / 2, 0);
            gene0.end = new mathis.XYZ(1 / 2, 1 / 2, 0);
            gene0.nbI = nb;
            gene0.nbJ = nb;
            var mamesh0 = new mathis.reseau.Regular(gene0).go();
            mamesh0.name = 'centre00';
            var admisible_2 = new mathis.HashMap();
            mamesh0.vertices.forEach(function (v) {
                if (v.param.x != 1)
                    admisible_2.putValue(v, true);
            });
            var verticesToKeep = mathis.graph.getGroup([mamesh0.vertices[0]], admisible_2);
            var suber = new mathis.grateAndGlue.SubMameshExtractor(mamesh0, verticesToKeep);
            suber.takeCareOfPolygons = false;
            var subMamesh = suber.go();
            subMamesh.isolateMameshVerticesFromExteriorVertices();
            subMamesh.fillLineCatalogue();
            bilan.assertTrue(subMamesh.allLinesAsASortedString() == 'straightLines:["[0,1,2,3]"]');
        }
        {
            var nb = 4;
            var gene0 = new mathis.reseau.BasisForRegularReseau();
            gene0.origin = new mathis.XYZ(-1 / 2, -1 / 2, 0);
            gene0.end = new mathis.XYZ(1 / 2, 1 / 2, 0);
            gene0.nbI = nb;
            gene0.nbJ = nb;
            var mamesh0 = new mathis.reseau.Regular(gene0).go();
            mamesh0.name = 'centre00';
            var admisible_3 = new mathis.HashMap();
            mamesh0.vertices.forEach(function (v) {
                if (v.param.x != 1 || v.param.y != 1)
                    admisible_3.putValue(v, true);
            });
            var verticesToKeep = mathis.graph.getGroup([mamesh0.vertices[0]], admisible_3);
            var suber = new mathis.grateAndGlue.SubMameshExtractor(mamesh0, verticesToKeep);
            suber.takeCareOfPolygons = false;
            var subMamesh = suber.go();
            subMamesh.isolateMameshVerticesFromExteriorVertices();
            subMamesh.fillLineCatalogue();
            bilan.assertTrue(subMamesh.allLinesAsASortedString() == 'straightLines:["[0,1,2,3]","[0,4,8,12]","[12,13,14,15]","[2,6,10,14]","[3,7,11,15]","[6,7]","[8,9,10,11]","[9,13]"]');
        }
        return bilan;
        // {
        //
        //
        //     let nb=4
        //
        //     let mamesh0 = new Mamesh()
        //     let gene0 = new reseau.BasisForRegularReseau()
        //     gene0.origin = new XYZ(-1/2, -1/2, 0)
        //     gene0.end = new XYZ(1/2, 1/2, 0)
        //     gene0.nbI = nb
        //     gene0.nbJ = nb
        //     new reseau.Regular(mamesh0, gene0).goChanging()
        //     mamesh0.name = 'centre00'
        //
        //
        //     let IN_mamesh = new Mamesh()
        //     let gene = new reseau.BasisForRegularReseau()
        //     gene.origin = new XYZ(-1/2, -1/2, 0)
        //     gene.end = new XYZ(1/2, 1/2, 0)
        //     gene.nbI = nb
        //     gene.nbJ = nb
        //     new reseau.Regular(IN_mamesh, gene).goChanging()
        //     IN_mamesh.name = 'centre11'
        //
        //
        //     new verticesMover.Similitude(IN_mamesh.vertices,Math.PI/4,new XYZ(Math.sqrt(2)/2,0,0)).goChanging()
        //
        //     let concurrent = new mameshModification.ConcurrentMameshesGraterAndSticker([mamesh0, IN_mamesh])
        //     concurrent.justGrateAndNotStick=true
        //     concurrent.overlapOnBorder=false
        //     let stuck=concurrent.goChanging()
        //
        //     //bilan.assertTrue(stuck.allSquareAndTrianglesAsSortedString()=='square:["[0,3,4,1]","[1,4,5,2]","[3,6,7,4]","[4,7,8,5]","[6,15,8,7]"]triangle:["[6,7,8]"]')
        //
        //
        //     let lineV0=new visu3d.LinksViewer(concurrent.OUTGratedMameshes[0],mathisFrame.scene)
        //     lineV0.color=new BABYLON.Color3(0,1,0)
        //     lineV0.goChanging()
        //
        //     let lineV1=new visu3d.LinksViewer(concurrent.OUTGratedMameshes[1],mathisFrame.scene)
        //     lineV1.color=new BABYLON.Color3(0,0,1)
        //     lineV1.goChanging()
        //
        //
        //     //let surfaceVius=new visu3d.SurfaceViewer(stuck,mathisFrame.scene).goChanging()
        //
        //
        //
        // }
        // {
        //
        //
        //     let nb=3
        //
        //     let mamesh0 = new Mamesh()
        //     let gene0 = new reseau.BasisForRegularReseau()
        //     gene0.origin = new XYZ(-1/2, -1/2, 0)
        //     gene0.end = new XYZ(1/2, 1/2, 0)
        //     gene0.nbI = nb
        //     gene0.nbJ = nb
        //     new reseau.Regular(mamesh0, gene0).goChanging()
        //     mamesh0.name = 'centre00'
        //
        //
        //     let IN_mamesh = new Mamesh()
        //     let gene = new reseau.BasisForRegularReseau()
        //     gene.origin = new XYZ(-1/2, -1/2, 0)
        //     gene.end = new XYZ(1/2, 1/2, 0)
        //     gene.nbI = nb
        //     gene.nbJ = nb
        //     new reseau.Regular(IN_mamesh, gene).goChanging()
        //     IN_mamesh.name = 'centre11'
        //
        //
        //     new verticesMover.Similitude(IN_mamesh.vertices,Math.PI/4,new XYZ(Math.sqrt(2)/2,0,0)).goChanging()
        //
        //     let concurrent = new mameshModification.ConcurrentMameshesGraterAndSticker([mamesh0, IN_mamesh])
        //     let stuck=concurrent.goChanging()
        //
        //     bilan.assertTrue(stuck.allSquareAndTrianglesAsSortedString()=='square:["[0,3,4,1]","[1,4,5,2]","[3,6,7,4]","[4,7,8,5]","[6,15,8,7]"]triangle:["[6,7,8]"]')
        //
        //
        //     // let lineV0=new visu3d.LinksViewer(stuck,mathisFrame.scene)
        //     // lineV0.color=new BABYLON.Color3(0,1,0)
        //     // lineV0.goChanging()
        //     // let surfaceVius=new visu3d.SurfaceViewer(stuck,mathisFrame.scene).goChanging()
        //
        //
        //
        // }
        //
        //
        //
        //
        // // {
        // //     let nb=3
        // //     let mamesh0 = new Mamesh()
        // //     let gene0 = new reseau.BasisForRegularReseau()
        // //     gene0.origin = new XYZ(0, 0, 0)
        // //     gene0.end = new XYZ(1, 1, 0)
        // //     gene0.nbI = nb
        // //     gene0.nbJ = nb
        // //     new reseau.Regular(mamesh0, gene0).goChanging()
        // //     mamesh0.name = 'centre00'
        // //
        // //
        // //     let IN_mamesh = new Mamesh()
        // //     let gene = new reseau.BasisForRegularReseau()
        // //     gene.origin = new XYZ(0, 0, 0)
        // //     gene.end = new XYZ(1, 1, 0)
        // //     gene.nbI = nb
        // //     gene.nbJ = nb
        // //     new reseau.Regular(IN_mamesh, gene).goChanging()
        // //     IN_mamesh.name = 'centre11'
        // //
        // //     new verticesMover.Similitude(IN_mamesh.vertices,Math.PI/4,new XYZ(1,0,0)).goChanging()
        // //
        // //     let concurrent = new mameshModification.ConcurrentMameshesGraterAndSticker([mamesh0, IN_mamesh])
        // //     let stuck=concurrent.goChanging()
        // //
        // //     cc(stuck.toString())
        // //
        // //
        // //
        // //     // let lineV0=new visu3d.LinksViewer(stuck,mathisFrame.scene)
        // //     // lineV0.color=new BABYLON.Color3(0,1,0)
        // //     // lineV0.goChanging()
        // //     // let surfaceVius=new visu3d.SurfaceViewer(stuck,mathisFrame.scene).goChanging()
        // //     //
        // //
        // //
        // // }
        //
        //
        //
        //
        // {
        //     let mamesh0 = new Mamesh()
        //     let gene0 = new reseau.BasisForRegularReseau()
        //     gene0.origin = new XYZ(-1, -1, 0)
        //     gene0.end = new XYZ(1, 1, 0)
        //     gene0.nbI = 7
        //     gene0.nbJ = 7
        //     new reseau.Regular(mamesh0, gene0).goChanging()
        //     mamesh0.name = 'centre00'
        //
        //
        //     let IN_mamesh = new Mamesh()
        //     let gene = new reseau.BasisForRegularReseau()
        //     gene.origin = new XYZ(0.1, 0.1, 0)
        //     gene.end = new XYZ(2.1, 2.2, 0)
        //     gene.nbI = 7
        //     gene.nbJ = 7
        //     new reseau.Regular(IN_mamesh, gene).goChanging()
        //     IN_mamesh.name = 'centre11'
        //
        //     let mamesh2 = new Mamesh()
        //     let gene2 = new reseau.BasisForRegularReseau()
        //     gene2.origin = new XYZ(0.1, -2, 0)
        //     gene2.end = new XYZ(2.1, 0, 0)
        //     gene2.nbI = 7
        //     gene2.nbJ = 7
        //     new reseau.Regular(mamesh2, gene2).goChanging()
        //     mamesh2.name = 'centre1_1'
        //
        //     let concurrent = new mameshModification.ConcurrentMameshesGraterAndSticker([mamesh0, IN_mamesh,mamesh2])
        //
        //
        //     let stuck=concurrent.goChanging()
        //
        //     bilan.assertTrue(stuck.allSquareAndTrianglesAsSortedString()=='square:["[0,7,8,1]","[1,8,9,2]","[10,17,18,11]","[105,112,113,106]","[11,18,19,12]","[112,119,120,113]","[113,120,121,114]","[114,121,122,115]","[119,126,127,120]","[12,19,20,13]","[120,127,128,121]","[121,128,129,122]","[126,133,134,127]","[127,134,135,128]","[128,135,136,129]","[129,136,137,130]","[133,140,141,134]","[134,141,142,135]","[135,142,143,136]","[136,143,144,137]","[14,21,22,15]","[15,22,23,16]","[16,23,24,17]","[17,24,25,18]","[18,25,26,19]","[19,26,27,20]","[2,9,10,3]","[21,28,29,22]","[21,99,106,28]","[22,29,30,23]","[23,30,31,24]","[24,31,32,25]","[25,32,33,26]","[26,33,34,27]","[27,34,61,54]","[28,106,113,114]","[28,115,36,29]","[29,36,37,30]","[3,10,11,4]","[30,37,38,31]","[31,38,39,32]","[32,39,40,33]","[33,40,41,34]","[34,67,68,61]","[36,115,122,43]","[36,43,44,37]","[37,44,45,38]","[38,45,46,39]","[39,46,72,40]","[4,11,12,5]","[40,72,73,41]","[41,73,74,67]","[43,122,129,130]","[44,130,137,84]","[45,84,85,46]","[46,85,86,79]","[5,12,13,6]","[54,61,62,55]","[61,68,69,62]","[67,74,75,68]","[68,75,76,69]","[7,14,15,8]","[72,79,80,73]","[73,80,81,74]","[74,81,82,75]","[75,82,83,76]","[79,86,87,80]","[8,15,16,9]","[80,87,88,81]","[81,88,89,82]","[82,89,90,83]","[84,137,144,91]","[84,91,92,85]","[85,92,93,86]","[86,93,94,87]","[87,94,95,88]","[88,95,96,89]","[89,96,97,90]","[9,16,17,10]","[98,105,106,99]"]triangle:["[28,114,115]","[34,41,67]","[43,130,44]","[44,84,45]","[46,79,72]"]')
        //
        //
        //
        //     // let lineV0=new visu3d.LinksViewer(stuck,mathisFrame.scene)
        //     // lineV0.color=new BABYLON.Color3(0,1,0)
        //     // lineV0.goChanging()
        //     // let surfaceVius=new visu3d.SurfaceViewer(stuck,mathisFrame.scene).goChanging()
        //
        //
        //
        // }
        //
        //
        // {
        //     let mamesh0 = new Mamesh()
        //     let gene0 = new reseau.BasisForRegularReseau()
        //     gene0.origin = new XYZ(-1, -1, 0)
        //     gene0.end = new XYZ(1, 1, 0)
        //     gene0.nbI = 7
        //     gene0.nbJ = 7
        //     new reseau.Regular(mamesh0, gene0).goChanging()
        //     mamesh0.name = 'centre00'
        //
        //
        //     let IN_mamesh = new Mamesh()
        //     let gene = new reseau.BasisForRegularReseau()
        //     gene.origin = new XYZ(0.1, 0.1, 0)
        //     gene.end = new XYZ(2.1, 2.2, 0)
        //     gene.nbI = 7
        //     gene.nbJ = 7
        //     new reseau.Regular(IN_mamesh, gene).goChanging()
        //     IN_mamesh.name = 'centre11'
        //
        //     let concurrent = new mameshModification.ConcurrentMameshesGraterAndSticker([mamesh0, IN_mamesh])
        //     let stuck=concurrent.goChanging()
        //
        //     bilan.assertTrue(stuck.allSquareAndTrianglesAsSortedString()=='square:["[0,7,8,1]","[1,8,9,2]","[10,17,18,11]","[11,18,19,12]","[12,19,20,13]","[14,21,22,15]","[15,22,23,16]","[16,23,24,17]","[17,24,25,18]","[18,25,26,19]","[19,26,27,20]","[2,9,10,3]","[21,28,29,22]","[22,29,30,23]","[23,30,31,24]","[24,31,32,25]","[25,32,33,26]","[26,33,34,27]","[27,34,61,54]","[28,35,36,29]","[29,36,37,30]","[3,10,11,4]","[30,37,38,31]","[31,38,39,32]","[32,39,40,33]","[33,40,41,34]","[34,67,68,61]","[35,42,43,36]","[36,43,44,37]","[37,44,45,38]","[38,45,46,39]","[39,46,72,40]","[4,11,12,5]","[40,72,73,41]","[41,73,74,67]","[45,84,85,46]","[46,85,86,79]","[5,12,13,6]","[54,61,62,55]","[61,68,69,62]","[67,74,75,68]","[68,75,76,69]","[7,14,15,8]","[72,79,80,73]","[73,80,81,74]","[74,81,82,75]","[75,82,83,76]","[79,86,87,80]","[8,15,16,9]","[80,87,88,81]","[81,88,89,82]","[82,89,90,83]","[84,91,92,85]","[85,92,93,86]","[86,93,94,87]","[87,94,95,88]","[88,95,96,89]","[89,96,97,90]","[9,16,17,10]"]triangle:["[34,41,67]","[46,79,72]"]')
        //
        // }
        //
        //
        //
        //
        // {
        //     let mamesh0 = new Mamesh()
        //     let gene0 = new reseau.BasisForRegularReseau()
        //     gene0.origin = new XYZ(-1, -1, 0)
        //     gene0.end = new XYZ(1, 1, 0)
        //     gene0.nbI = 5
        //     gene0.nbJ = 5
        //     new reseau.Regular(mamesh0, gene0).goChanging()
        //     mamesh0.name = 'centre00'
        //
        //
        //     let IN_mamesh = new Mamesh()
        //     let gene = new reseau.BasisForRegularReseau()
        //     gene.origin = new XYZ(0.1, 0.1, 0)
        //     gene.end = new XYZ(2, 2, 0)
        //     gene.nbI = 5
        //     gene.nbJ = 5
        //     new reseau.Regular(IN_mamesh, gene).goChanging()
        //     IN_mamesh.name = 'centre11'
        //
        //
        //     let concurrent = new mameshModification.ConcurrentMameshesGraterAndSticker([mamesh0, IN_mamesh])
        //     let stuck=concurrent.goChanging()
        //
        //     stuck.fillLineCatalogue()
        //     bilan.assertTrue(stuck.allLinesAsASortedString()=='straightLines:["[0,1,2,3,4]","[0,5,10,15,20]","[1,6,11,16,21]","[10,11,12,13,14,29]","[15,16,17,18,19,34]","[19,38,43,48]","[2,7,12,17,22,45]","[20,21,22,23,24,38,39]","[23,42,43,44]","[29,34,39,44,49]","[3,8,13,18,23,46]","[4,9,14,19,24,42,47]","[45,46,47,48,49]","[5,6,7,8,9]"]')
        //
        //
        //
        // }
        //
        //
        //
        //
        //
        //
        //
        // {
        //     let mamesh0 = new Mamesh()
        //     let gene0 = new reseau.BasisForRegularReseau()
        //     gene0.origin = new XYZ(-1, -1, 0)
        //     gene0.end = new XYZ(1, 1, 0)
        //     gene0.nbI = 5
        //     gene0.nbJ = 5
        //     new reseau.Regular(mamesh0, gene0).goChanging()
        //     mamesh0.name = 'centre00'
        //
        //
        //     let IN_mamesh = new Mamesh()
        //     let gene = new reseau.BasisForRegularReseau()
        //     gene.origin = new XYZ(0.1, 0.1, 0)
        //     gene.end = new XYZ(2, 2, 0)
        //     gene.nbI = 5
        //     gene.nbJ = 5
        //     new reseau.Regular(IN_mamesh, gene).goChanging()
        //     IN_mamesh.name = 'centre11'
        //
        //
        //     let concurrent = new mameshModification.ConcurrentMameshesGraterAndSticker([mamesh0, IN_mamesh])
        //     concurrent.justGrateAndNotStick=true
        //     concurrent.overlapOnBorder=false
        //
        //     let stuck=concurrent.goChanging()
        //     bilan.assertTrue(stuck==null)
        //
        //     concurrent.OUTGratedMameshes[0].fillLineCatalogue()
        //     concurrent.OUTGratedMameshes[1].fillLineCatalogue()
        //
        //     bilan.assertTrue(concurrent.OUTGratedMameshes[0].allLinesAsASortedString()=='straightLines:["[0,1,2,3,4]","[0,5,10,15,20]","[1,6,11,16,21]","[10,11,12,13,14]","[15,16,17,18]","[2,7,12,17,22]","[20,21,22]","[3,8,13,18]","[4,9,14]","[5,6,7,8,9]"]')
        //     bilan.assertTrue(concurrent.OUTGratedMameshes[1].allLinesAsASortedString()=='straightLines:["[0,1]","[0,5,10,15,20]","[1,6,11,16,21]","[12,13,14,15,16]","[12,17]","[17,18,19,20,21]","[4,5,6]","[4,9,14,19]","[8,13,18]","[8,9,10,11]"]')
        //
        //
        //
        //
        //     //bilan.assertTrue(concurrent.OUTGratedMameshes[0].allLinesAsASortedString()=='straightLines:["[0,1,2,3,4]","[0,5,10,15,20]","[1,6,11,16,21]","[10,11,12,13,14]","[15,16,17,18]","[2,7,12,17,22]","[20,21,22]","[3,8,13,18]","[4,9,14]","[5,6,7,8,9]"]')
        //     //bilan.assertTrue(concurrent.OUTGratedMameshes[1].allLinesAsASortedString()=='straightLines:["[0,5,10,15,20]","[1,0]","[1,6,11,16,21]","[11,10,9,8]","[12,13,14,15,16]","[17,12]","[17,18,19,20,21]","[18,13,8]","[19,14,9,4]","[6,5,4]"]')
        //
        //
        //
        // }
        //
        //
        // {
        //     let mamesh0 = new Mamesh()
        //     let gene0 = new reseau.BasisForRegularReseau()
        //     gene0.origin = new XYZ(-1, -1, 0)
        //     gene0.end = new XYZ(1, 1, 0)
        //     gene0.nbI = 5
        //     gene0.nbJ = 5
        //     new reseau.Regular(mamesh0, gene0).goChanging()
        //     mamesh0.name = 'centre00'
        //
        //
        //     let IN_mamesh = new Mamesh()
        //     let gene = new reseau.BasisForRegularReseau()
        //     gene.origin = new XYZ(0.1, 0.1, 0)
        //     gene.end = new XYZ(2, 2, 0)
        //     gene.nbI = 5
        //     gene.nbJ = 5
        //     new reseau.Regular(IN_mamesh, gene).goChanging()
        //     IN_mamesh.name = 'centre11'
        //
        //
        //     let concurrent = new mameshModification.ConcurrentMameshesGraterAndSticker([mamesh0, IN_mamesh])
        //     concurrent.justGrateAndNotStick=true
        //
        //     let stuck=concurrent.goChanging()
        //     bilan.assertTrue(stuck==null)
        //
        //     concurrent.OUTGratedMameshes[0].fillLineCatalogueCheckingThatLineStayInside()
        //     concurrent.OUTGratedMameshes[1].fillLineCatalogueCheckingThatLineStayInside()
        //
        //     bilan.assertTrue(concurrent.OUTGratedMameshes[0].allLinesAsASortedString()=='straightLines:["[0,1,2,3,4]","[0,5,10,15,20]","[1,6,11,16,21]","[10,11,12,13,14]","[15,16,17,18,19]","[2,7,12,17,22]","[20,21,22,23,24]","[3,8,13,18,23]","[4,9,14,19,24]","[5,6,7,8,9]"]')
        //     bilan.assertTrue(concurrent.OUTGratedMameshes[1].allLinesAsASortedString()=='straightLines:["[13,12,11,10,9]","[14,15,16,17,18]","[19,14,9,4]","[19,20,21,22,23]","[2,7,12,17,22]","[20,15,10,5,0]","[21,16,11,6,1]","[3,2,1,0]","[3,8,13,18,23]","[8,7,6,5,4]"]')
        //
        // }
        //
        //
        //
        // {
        //
        //         let mamesh0 = new Mamesh()
        //         let gene0 = new reseau.BasisForRegularReseau()
        //         gene0.end = new XYZ(1, 1, 0)
        //         gene0.origin = new XYZ(-1, -1, 0)
        //         gene0.nbI = 3
        //         gene0.nbJ = 3
        //         new reseau.Regular(mamesh0, gene0).goChanging()
        //         mamesh0.name = 'centre00'
        //
        //
        //         let IN_mamesh = new Mamesh()
        //         let gene = new reseau.BasisForRegularReseau()
        //         gene.end = new XYZ(2.1, 2.1, 0)
        //         gene.origin = new XYZ(0.1, 0.1, 0)
        //         gene.nbI = 3
        //         gene.nbJ = 3
        //         new reseau.Regular(IN_mamesh, gene).goChanging()
        //         IN_mamesh.name = 'centre11'
        //
        //
        //         let source=[IN_mamesh.vertices[0],IN_mamesh.vertices[3],IN_mamesh.vertices[4],IN_mamesh.vertices[1]]
        //         let map=new mameshModification.FindStickingMapFromSquare(mamesh0.smallestSquares,source).goChanging()
        //
        //
        //
        //
        //     let merger=new mameshModification.Merger(mamesh0,IN_mamesh)
        //     merger.merginMap=map
        //     merger.goChanging()
        //
        //     mamesh0.fillLineCatalogue()
        //     bilan.assertTrue(mamesh0.allLinesAsASortedString()=='straightLines:["[0,1,2]","[0,3,6]","[1,4,7,15]","[11,14,17]","[15,16,17]","[2,5,8,16]","[3,4,5,11]","[6,7,8,14]"]')
        //
        // }
        //
        //
        // {
        //
        //     let mamesh0 = new Mamesh()
        //     let gene0 = new reseau.BasisForRegularReseau()
        //     gene0.origin = new XYZ(-1, -1, 0)
        //     gene0.end = new XYZ(1, 1, 0)
        //     gene0.nbI = 3
        //     gene0.nbJ = 3
        //     new reseau.Regular(mamesh0, gene0).goChanging()
        //     mamesh0.name = 'centre00'
        //
        //
        //     let IN_mamesh = new Mamesh()
        //     let gene = new reseau.BasisForRegularReseau()
        //     gene.origin = new XYZ(0.1, -1.1, 0)
        //     gene.end = new XYZ(2.1, 1.1, 0)
        //     gene.nbI = 3
        //     gene.nbJ = 3
        //     new reseau.Regular(IN_mamesh, gene).goChanging()
        //     IN_mamesh.name = 'centre11'
        //
        //
        //     let source=[IN_mamesh.vertices[0],IN_mamesh.vertices[3],IN_mamesh.vertices[4],IN_mamesh.vertices[1],IN_mamesh.vertices[1],IN_mamesh.vertices[4],IN_mamesh.vertices[5],IN_mamesh.vertices[2]]
        //     let map=new mameshModification.FindStickingMapFromSquare(mamesh0.smallestSquares,source).goChanging()
        //
        //
        //     let merger=new mameshModification.Merger(mamesh0,IN_mamesh)
        //     merger.merginMap=map
        //     merger.goChanging()
        //
        //     mamesh0.fillLineCatalogue()
        //     bilan.assertTrue(mamesh0.allLinesAsASortedString()=='straightLines:["[0,1,2]","[0,3,6,15]","[1,4,7,16]","[15,16,17]","[2,5,8,17]","[3,4,5]","[6,7,8]"]')
        //
        //
        //
        //     // let lineV0=new visu3d.LinesVisuFastMaker(mamesh0,mathisFrame.scene)
        //     // lineV0.color=new BABYLON.Color3(0,1,0)
        //     // lineV0.goChanging()
        //
        //     // let lineV1=new visu3d.LinesVisuFastMaker(IN_mamesh,mathisFrame.scene)
        //     // lineV1.color=new BABYLON.Color3(1,0,0)
        //     // lineV1.goChanging()
        //
        // }
        //
        //
        //
        // {
        //
        //     let IN_mamesh=new Mamesh()
        //
        //
        //
        //     let gene=new reseau.BasisForRegularReseau()
        //     gene.end=new XYZ(1,1,0)
        //     gene.origin=new XYZ(-1,-1,0)
        //     gene.nbI=5
        //     gene.nbJ=5
        //
        //     new reseau.Regular(IN_mamesh,gene).goChanging()
        //
        //     let concurrent=new mameshModification.ConcurrentMameshesGraterAndSticker([IN_mamesh])
        //     concurrent.goChanging()
        //
        //     let vertexAndDist=concurrent.closestVertexFromAMamesh(new XYZ(0,0,0),0)
        //
        //     /**longueur totale:2, divis en 4 (car 5 subdivision), la longueur moyenne est donne exactement 0.5*/
        //     bilan.assertTrue(IN_mamesh.maxLinkLength()==0.5)
        //
        //
        //     bilan.assertTrue(vertexAndDist.vertex.position.x==0&&vertexAndDist.vertex.position.y==0&&vertexAndDist.distToBorder==1)
        //
        //     vertexAndDist=concurrent.closestVertexFromAMamesh(new XYZ(-1,-1,0),0)
        //     bilan.assertTrue(vertexAndDist.vertex.position.x==-1&&vertexAndDist.vertex.position.y==-1&&vertexAndDist.distToBorder==0)
        //
        //     vertexAndDist=concurrent.closestVertexFromAMamesh(new XYZ(-0.9,-0.9,0),0)
        //     bilan.assertTrue(vertexAndDist.vertex.position.x==-1&&vertexAndDist.vertex.position.y==-1&&vertexAndDist.distToBorder==0)
        //
        //     vertexAndDist=concurrent.closestVertexFromAMamesh(new XYZ(-2,-1,0),0)
        //     bilan.assertTrue(vertexAndDist==null)
        //
        //
        //
        //
        //
        // }
        //
        //
        // {
        //
        //     let IN_mamesh = new Mamesh()
        //
        //
        //     let gene = new reseau.BasisForRegularReseau()
        //     gene.end = new XYZ(1, 1, 0)
        //     gene.origin = new XYZ(-1, -1, 0)
        //     gene.nbI = 3
        //     gene.nbJ = 3
        //
        //     new reseau.Regular(IN_mamesh, gene).goChanging()
        //
        //     let mameshToKeep:Vertex[]=[]
        //     IN_mamesh.vertices.forEach(v=>mameshToKeep.push(v))
        //     mameshToKeep.splice(0,1)
        //
        //     let subExtra=new grateAndGlue.SubMameshExtractor(IN_mamesh,mameshToKeep)
        //     let subMam:Mamesh=subExtra.goChanging()
        //
        //     subMam.fillLineCatalogueCheckingThatLineStayInside()
        //
        //     // new verticesMover.rotation(subMam.vertices,0.1).goChanging()
        //     // new visu3d.LinesViewer(subMam,mathisFrame.scene).goChanging()
        //     // new visu3d.SurfaceViewer(subMam,mathisFrame.scene).goChanging()
        //
        //     bilan.assertTrue(subMam.allLinesAsASortedString()=='straightLines:["[0,3,6]","[1,0]","[1,4,7]","[2,3,4]","[5,2]","[5,6,7]"]')
        //
        //
        //
        // }
        //
        // {
        //
        //     let IN_mamesh = new Mamesh()
        //
        //
        //     let gene = new reseau.BasisForRegularReseau()
        //     gene.end = new XYZ(1, 1, 0)
        //     gene.origin = new XYZ(-1, -1, 0)
        //     gene.nbI = 5
        //     gene.nbJ = 5
        //
        //     new reseau.Regular(IN_mamesh, gene).goChanging()
        //
        //     let mameshToKeep:Vertex[]=[]
        //     IN_mamesh.vertices.forEach(v=>{
        //         if (!v.param.equals(new XYZ(2,2,0))){
        //             mameshToKeep.push(v)
        //         }
        //     })
        //
        //     let subExtra=new grateAndGlue.SubMameshExtractor(IN_mamesh,mameshToKeep)
        //     let subMam:Mamesh=subExtra.goChanging()
        //     subMam.fillLineCatalogueCheckingThatLineStayInside()
        //
        //
        //
        //     bilan.assertTrue(subMam.allLinesAsASortedString()=='straightLines:["[0,1,2,3,4]","[0,5,10,15,20]","[1,6,11,16,21]","[10,11]","[13,14]","[15,16,17,18,19]","[17,22]","[2,7]","[20,21,22,23,24]","[3,8,13,18,23]","[4,9,14,19,24]","[5,6,7,8,9]"]')
        //
        //
        // }
        //
        //
        // {
        //
        //     let IN_mamesh = new Mamesh()
        //
        //
        //     let gene = new reseau.BasisForRegularReseau()
        //     gene.end = new XYZ(1, 1, 0)
        //     gene.origin = new XYZ(-1, -1, 0)
        //     gene.nbI = 5
        //     gene.nbJ = 5
        //
        //     new reseau.Regular(IN_mamesh, gene).goChanging()
        //
        //     let mameshToKeep:Vertex[]=[]
        //     IN_mamesh.vertices.forEach(v=>{
        //         if (v.param.x!=2){
        //             mameshToKeep.push(v)
        //         }
        //     })
        //
        //     let subExtra=new grateAndGlue.SubMameshExtractor(IN_mamesh,mameshToKeep)
        //     let subMam:Mamesh=subExtra.goChanging()
        //     subMam.fillLineCatalogueCheckingThatLineStayInside()
        //
        //
        //     bilan.assertTrue(subMam.allLinesAsASortedString()=='straightLines:["[0,1,2,3,4]","[0,5]","[1,6]","[15,16,17,18,19]","[15,20]","[16,21]","[17,22]","[18,23]","[19,24]","[2,7]","[20,21,22,23,24]","[3,8]","[4,9]","[5,6,7,8,9]"]')
        //
        //
        // }
        //
        //
        //
        // {
        //     let IN_mamesh = new Mamesh()
        //     let gene = new reseau.BasisForRegularReseau()
        //     gene.end = new XYZ(1, 1, 0)
        //     gene.origin = new XYZ(-1, -1, 0)
        //     gene.nbI = 3
        //     gene.nbJ = 3
        //
        //     new reseau.Regular(IN_mamesh, gene).goChanging()
        //
        //     IN_mamesh.fillLineCatalogue()
        //
        //     IN_mamesh.paramToVertex.removeKey(new XYZ(0, 0, 0))
        //
        //     new LinesCuter(IN_mamesh).goChanging()
        //
        //     bilan.assertTrue(IN_mamesh.allLinesAsASortedString() == 'straightLines:["[1,2]","[1,4,7]","[2,5,8]","[3,4,5]","[3,6]","[6,7,8]"]')
        // }
        //
        // {
        //     let IN_mamesh = new Mamesh()
        //     let gene = new reseau.BasisForRegularReseau()
        //     gene.end = new XYZ(1, 1, 0)
        //     gene.origin = new XYZ(-1, -1, 0)
        //     gene.nbI = 3
        //     gene.nbJ = 3
        //
        //     new reseau.Regular(IN_mamesh, gene).goChanging()
        //
        //     IN_mamesh.fillLineCatalogue()
        //
        //     IN_mamesh.paramToVertex.removeKey(new XYZ(1, 1, 0))
        //
        //     new LinesCuter(IN_mamesh).goChanging()
        //
        //     bilan.assertTrue(IN_mamesh.allLinesAsASortedString()=='straightLines:["[0,1,2]","[0,3,6]","[2,5,8]","[6,7,8]"]')
        // }
        //
        //
        // {
        //     let IN_mamesh = new Mamesh()
        //
        //     let flat=new creationFlat.SingleSquareWithOneDiag(IN_mamesh)
        //     flat.addALoopLineAround=true
        //     flat.goChanging()
        //
        //     IN_mamesh.fillLineCatalogue()
        //
        //     IN_mamesh.paramToVertex.removeKey(new XYZ(0, 0, 0))
        //
        //     new LinesCuter(IN_mamesh).goChanging()
        //
        //     bilan.assertTrue(IN_mamesh.allLinesAsASortedString()=='straightLines:["[1,2,3]","[1,3]"]')
        //     //bilan.assertTrue(IN_mamesh.allLinesAsASortedString() == 'straightLines:["[1,2]","[1,4,7]","[2,5,8]","[3,4,5]","[3,6]","[6,7,8]"]')
        // }
        //
        //
        //
        //
        //
        // {
        //     let mamesh0=new Mamesh()
        //     let gene0=new reseau.BasisForRegularReseau()
        //     gene0.end=new XYZ(1,1,0)
        //     gene0.origin=new XYZ(-1,-1,0)
        //     gene0.nbI=3
        //     gene0.nbJ=3
        //     new reseau.Regular(mamesh0,gene0).goChanging()
        //     mamesh0.name='centre00'
        //
        //
        //
        //     let IN_mamesh=new Mamesh()
        //     let gene=new reseau.BasisForRegularReseau()
        //     gene.end=new XYZ(2,2,0)
        //     gene.origin=new XYZ(0,0,0)
        //     gene.nbI=3
        //     gene.nbJ=3
        //     new reseau.Regular(IN_mamesh,gene).goChanging()
        //     IN_mamesh.name='centre11'
        //
        //
        //
        //     let concurrent=new mameshModification.ConcurrentMameshesGraterAndSticker([mamesh0,IN_mamesh])
        //     concurrent.goChanging()
        //
        //     let xyz=new XYZ(1,1,0)
        //     let vertexAndMamesh=concurrent.findBestMamesh(xyz)
        //     bilan.assertTrue(vertexAndMamesh.vertex.position.almostEqual(xyz)&&vertexAndMamesh.bestMamesh.name=='centre11')
        //
        //
        //     xyz=new XYZ(0,2,0)
        //     vertexAndMamesh=concurrent.findBestMamesh(xyz)
        //     bilan.assertTrue(vertexAndMamesh.vertex.position.almostEqual(xyz)&&vertexAndMamesh.bestMamesh.name=='centre11')
        //
        //
        //     xyz=new XYZ(2,0,0)
        //     vertexAndMamesh=concurrent.findBestMamesh(xyz)
        //     bilan.assertTrue(vertexAndMamesh.vertex.position.almostEqual(xyz)&&vertexAndMamesh.bestMamesh.name=='centre11')
        //
        //     xyz=new XYZ(1,1,0)
        //     vertexAndMamesh=concurrent.findBestMamesh(xyz)
        //     bilan.assertTrue(vertexAndMamesh.vertex.position.almostEqual(xyz)&&vertexAndMamesh.bestMamesh.name=='centre11')
        //
        //     xyz=new XYZ(2,2,0)
        //     vertexAndMamesh=concurrent.findBestMamesh(xyz)
        //     bilan.assertTrue(vertexAndMamesh.vertex.position.almostEqual(xyz)&&vertexAndMamesh.bestMamesh.name=='centre11')
        //
        //
        //     xyz=new XYZ(0,0,0)
        //     vertexAndMamesh=concurrent.findBestMamesh(xyz)
        //     bilan.assertTrue(vertexAndMamesh.vertex.position.almostEqual(xyz)&&vertexAndMamesh.bestMamesh.name=='centre00')
        //
        //
        //     xyz=new XYZ(-0.9,-0.9,0)
        //     vertexAndMamesh=concurrent.findBestMamesh(xyz)
        //     bilan.assertTrue(vertexAndMamesh.vertex.position.almostEqual(new XYZ(-1,-1,0))&&vertexAndMamesh.bestMamesh.name=='centre00')
        //
        //
        //     xyz=new XYZ(-1,1,0)
        //     vertexAndMamesh=concurrent.findBestMamesh(xyz)
        //     bilan.assertTrue(vertexAndMamesh.vertex.position.almostEqual(xyz)&&vertexAndMamesh.bestMamesh.name=='centre00')
        //
        //
        //     xyz=new XYZ(1,-1,0)
        //     vertexAndMamesh=concurrent.findBestMamesh(xyz)
        //     bilan.assertTrue(vertexAndMamesh.vertex.position.almostEqual(xyz)&&vertexAndMamesh.bestMamesh.name=='centre00')
        //
        //
        //
        // }
        //
        // return bilan
    }
    mathis.testRiemann = testRiemann;
})(mathis || (mathis = {}));
/**
 * Created by vigon on 25/04/2016.
 */
var mathis;
(function (mathis) {
    function symmetriesTest() {
        var bilan = new mathis.Bilan();
        /**test squareMainSymmetries*/
        function testOneSymmetry(sym, mamesh) {
            var vertexAfterTrans = new mathis.HashMap(true);
            mamesh.vertices.forEach(function (v) {
                var paramTrans = sym(v.param);
                vertexAfterTrans.putValue(mamesh.findVertexFromParam(paramTrans), true);
            });
            bilan.assertTrue(vertexAfterTrans.allValues().length == mamesh.vertices.length);
        }
        function testAllSymmetries(mamesh, symmetries) {
            symmetries.allValues().forEach(function (sym) {
                testOneSymmetry(sym, mamesh);
            });
        }
        {
            var crea = new mathis.reseau.Regular();
            crea.nbI = 5;
            crea.nbJ = 6;
            crea.makeLinks = false;
            var mamesh = crea.go();
            new mathis.mameshModification.SquareDichotomer(mamesh).go();
            new mathis.mameshModification.SquareDichotomer(mamesh).go();
            testAllSymmetries(mamesh, mathis.symmetries.cartesian(crea.nbI, crea.nbJ));
        }
        {
            var crea = new mathis.reseau.Regular();
            crea.nbI = 3;
            /**with even number, the IN_mamesh is not j-symmetric !!!!*/
            crea.nbJ = 7;
            crea.oneMoreVertexForOddLine = true;
            crea.squareVersusTriangleMaille = false;
            var mamesh = crea.go();
            testAllSymmetries(mamesh, mathis.symmetries.cartesian(crea.nbI, crea.nbJ, crea.oneMoreVertexForOddLine));
        }
        {
            var crea = new mathis.reseau.Regular();
            crea.nbI = 9;
            /**with even number, the IN_mamesh is not j-symmetric !!!!*/
            crea.nbJ = 5;
            crea.oneMoreVertexForOddLine = false;
            crea.squareVersusTriangleMaille = false;
            var mamesh = crea.go();
            var dicho = new mathis.mameshModification.TriangleDichotomer(mamesh);
            dicho.makeLinks = true;
            dicho.go();
            dicho = new mathis.mameshModification.TriangleDichotomer(mamesh);
            dicho.makeLinks = true;
            dicho.go();
            testAllSymmetries(mamesh, mathis.symmetries.cartesian(crea.nbI, crea.nbJ, crea.oneMoreVertexForOddLine));
        }
        {
            for (var nbSides = 3; nbSides < 12; nbSides++) {
                var crea = new mathis.reseau.TriangulatedPolygone(nbSides);
                var mamesh = crea.go();
                var dicho = new mathis.mameshModification.TriangleDichotomer(mamesh);
                dicho.makeLinks = true;
                dicho.go();
                dicho = new mathis.mameshModification.TriangleDichotomer(mamesh);
                dicho.makeLinks = true;
                dicho.go();
                testAllSymmetries(mamesh, mathis.symmetries.polygonRotations(nbSides));
            }
        }
        {
            var nbSides = 5;
            var crea = new mathis.reseau.TriangulatedPolygone(nbSides);
            var mamesh = crea.go();
            var dicho = new mathis.mameshModification.TriangleDichotomer(mamesh);
            dicho.makeLinks = true;
            dicho.go();
            dicho = new mathis.mameshModification.TriangleDichotomer(mamesh);
            dicho.makeLinks = true;
            dicho.go();
            testAllSymmetries(mamesh, mathis.symmetries.polygonRotations(nbSides));
        }
        {
            bilan.assertTrue(mathis.roundWithGivenPrecision(5.749999999, 3) == 5.75);
            bilan.assertTrue(mathis.roundWithGivenPrecision(-5.789999999, 5) == -5.79);
            bilan.assertTrue(mathis.roundWithGivenPrecision(5.749999936, 9) == 5.749999936);
        }
        return bilan;
    }
    mathis.symmetriesTest = symmetriesTest;
})(mathis || (mathis = {}));
//# sourceMappingURL=MATHIS2.js.map